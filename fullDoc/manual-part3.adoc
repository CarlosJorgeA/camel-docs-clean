= LambdaRouteBuilder

The `LambdaRouteBuilder` is a functional interface which is used for creating a routing rule using the xref:dsl.adoc[DSL],
using Java lambda style.

[source,java]
----
rb -> rb.from("timer:foo").log("Hello Lambda");
----

Instances of `LambdaRouteBuilder` are discovered and transformed into `RouteBuilder` instances
which are added to the CamelContext.

== Usage

To use `LambdaRouteBuilder` you need to create a method that returns `LambdaRouteBuilder` which then
allows to use Java lambda style to define a single route.

In the example below the method `myRoute` is used to create a Camel route that consumes from Kafka and sends the messages to JMS.

To make the route discoverable by Camel during startup, then the method must be annotated.
The method should be annotated with `@BindToRegistry` in standalone mode with `camel-main`, `@Bean` in case of Spring Boot or `@Produce` in case of Quarkus.

[source,java]
----
public class MyConfiguration {
    @BindToRegistry
    public LambdaRouteBuilder myRoute() {
        return rb -> rb.from("kafka:cheese").to("jms:queue:foo");
    }
}
----

== LambdaEndpointRouteBuilder

The xref:Endpoint-dsl.adoc[Endpoint DSL] can also be used as a lambda route builder with the
`org.apache.camel.builder.endpoint.LambdaEndpointRouteBuilder` class from the `camel-endpointdsl` JAR.

[source,java]
----
public class MyConfiguration {
    @BindToRegistry
    public LambdaEndpointRouteBuilder myRoute() {
        return rb -> rb.from(rb.kafka("cheese")).to(rb.jms("queue:foo"));
    }
}
----

The `LambdaEndpointRouteBuilder` has _type safe_ endpoint but requires to prefix with the instance name (`rb`)
when choosing an endpoint name. Notice above how to select the kafka endpoint

[source,java]
----
rb.from(rb.kafka("cheese"))
----

With the regular `LambdaRouteBuilder` it's just a `String` type, so the `rb` prefix is not needed anymore:

[source,java]
----
rb.from("kafka:cheese")
----
= Language DSL

The Language DSL is a builder API that allows using type safe construction of
Camel xref:languages.adoc[Languages].

The Language DSL is exclusively available as part of the Java DSL.

The DSL can be accessed directly from the `RouteBuilder` thanks to the method `expression()`.

== Using Language DSL

In the following example, a `TokenizerExpression` is created using the legacy approach where the expression is instantiated explicitly and configured using setters:

[source,java]
----
public class MyRoutes extends RouteBuilder {
    @Override
    public void configure() {
        TokenizerExpression expression = new TokenizerExpression("(\\W+)\\s*"); // <1>
        expression.setRegex(true); // <2>
        from("file:data")
            .split(expression) // <3>
            .process("processEntry");
    }
}
----
<1> Instantiate the expected expression
<2> Configure the expression according to the needs
<3> Affect the expression with the expected configuration

The previous code could be simplified using the utility methods available directly from the `ExpressionClause` corresponding to the type returned by several existing methods such as `split()`, `setBody()`, `setHeader(String)`, `aggregate()`, etc.:

[source,java]
----
public class MyRoutes extends RouteBuilder {
    @Override
    public void configure() {
        from("file:data")
            .split()
            .tokenize("(\\W+)\\s*", true) // <1>
            .process("processEntry");
    }
}
----
<1> Select the `tokenize` language with a specific regular expression

This approach is suitable for very basic configuration, but as there are only limited utility methods for each supported language, for more complex configuration, we can quickly face situations where the utility method for our expected configuration doesn't exist. In this situation, you can either use the legacy approach or the language DSL like in the next code snippet:

[source,java]
----
public class MyRoutes extends RouteBuilder {
    @Override
    public void configure() {
        from("file:data")
            .split(
                expression() // <1>
                    .tokenize() // <2>
                        .token("(\\W+)\\s*") // <3>
                        .regex(true) // <3>
                    .end() // <4>
            )
            .process("processEntry");
    }
}
----
<1> Give access to all the supported languages
<2> Select the `tokenize` language
<3> Configure the expression according to the needs
<4> Build the expression with the expected configuration
= Languages

To support flexible and powerful
xref:components:eips:enterprise-integration-patterns.adoc[Enterprise Integration
Patterns], Camel supports various Languages to create an
xref:expression.adoc[Expression] or xref:predicate.adoc[Predicate]
within the xref:routes.adoc[Routes] and xref:dsl.adoc[DSL]..

== Supported languages

There are about 20 different xref:components:languages:index.adoc[Languages] such
as scripted programming languages like Groovy, and template based languages like Velocity and Freemarker,
and XML/JSon languages, and many others.

Most of these languages are also supported used as
xref:parameter-binding-annotations.adoc[Annotation Based Expression Language] in Java beans.
= Camel Lifecycle

Camel uses a simple _lifecycle_ interface called
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Service.html[Service]
which has `start()` and `stop()` methods.

Many of Camel's classes implement `Service` such as
`CamelContext` along with all `Component` and `Endpoint` classes.

When you use Camel you typically have to start the
`CamelContext` which will start all the various
components and endpoints and activate the routing rules until the
context is stopped again.

== CamelContext Lifecycle

The `CamelContext` provides methods to control its lifecycle:

* `build`
* `init`
* `start`
* `stop`
* `suspend`
* `resume`

The operations are paired: start/stop and suspend/resume.

Stop is performing a xref:graceful-shutdown.adoc[Graceful Shutdown]
which means all its internal state, cache, etc is cleared; and the
routes is being stopped in a graceful manner to ensure messages are given
time to complete.

IMPORTANT: If you start a `CamelContext` after a stop, then its
performing a _cold_ start, recreating all the state, cache etc. again; which is not guaranteed to startup correctly again.
Instead you can use the suspend/resume operations. They will keep the
`CamelContext` _warm_ and only suspend/stop routes using the same
graceful shutdown feature. This ensures messages are given time to complete.

End users is encouraged to use suspend/resume if you are temporary
stopping a Camel application.

All these operations are available in JMX as well,
so you can control Camel from JMX management.

== Service lifecycle

A service (`org.apache.camel.Service`) in Camel adheres to the following
lifecycle states as illustrated in the diagram below:

image::images/service_lifecycle.png[image]

The `org.apache.camel.support.service.ServiceSupport` is a good base class to
extend for custom services as it offers the basic functionally to keep
track of state. You implement your custom logic in the `doStart`,
`doStop`, `doSuspend`, `doResume` methods.

TIP: A service can optimally support suspend/resume by the
`org.apache.camel.SuspendableService`. This means not all services in
Camel supports suspension. It's encouraged that consumers support
suspension which allows suspending/resuming routes.

== Startup Lifecycle

When Camel startup there are various listeners that can be used to plugin custom code, that
can listen and react during startup such as `LifecycleStrategy`, or `MainListener`.

If you need Camel to check for _something_ before it can start up, then look at xref:startup-condition.adoc[Startup Condition]= Mapped Diagnostic Context (MDC)

The Mapped Diagnostic Context is a technology used in Java to provide a set of customized information into each log trace. The major logging frameworks implements it, and, although it may have certain limitations, this technology is used to enhance the logging and monitoring of a Java application (Camel applications included).

The main limitation of this technology is the fact that it stores values on a context that is available at thread level. Since Camel is an application that manages multiple thread, when it deals with asynchronous calls, the context propagation may not work correctly.

NOTE: the framework should generally handle MDC correctly. However, there could be components (eg, tracing components) and other asynchronous parts of the system that still require the implementation of the context propagation: please report if you notice anything wrong.

== How to configure in Camel application

The first thing you need to do is to enable the `camel.main.useMdcLogging=true`. This flag will automatically include in the MDC context the following Exchange information:

* camel.breadcrumbId
* camel.exchangeId
* camel.messageId
* camel.correlationId
* camel.routeId
* camel.stepId
* camel.contextId
* camel.transactionKey

You can use the above variables for MDC depending on the logging framework you're using. For example, if you're using log4j2, then, the variable will be like `%X{camel.exchangeId}`. Other logging frameworks should have a similar approach, just check its specific documentation.

== User values

If you're using Java DSL you can include any customized information by adding that using low level MDC API:

```java
        org.slf4j.MDC.put("myKey", "myValue");
```

Each MDC should be now able to include that information.

== Context propagation

If you're using some asynchronous component, then, you may need to configure the application to enable the MDC context propagation. For that reason you need to add the `camel.main.mdcLoggingKeysPattern` configuration. This configuration will drive the process of copying the MDC context on the thread that will execute your Exchange asynchronously.
= Apache Camel Migration and Upgrade Guides

We do frequent releases, a release almost every month, and even though we strive to maintain backward compatibility, we may on occasion introduce a breaking change in the interest of the long-term evolution of the project.

Listed here are the notes on how to migrate between major versions, and what to watch out when upgrading from minor versions.

- xref:camel-3-migration-guide.adoc[Camel 2.x to 3.0 migration guide]
- xref:camel-3x-upgrade-guide.adoc[Upgrade guide for 3.x releases]
- xref:camel-4-migration-guide.adoc[Camel 3.x to 4.0 migration guide]
- xref:camel-4x-upgrade-guide.adoc[Upgrade guide for 4.x releases]
= Notify Builder

The `NotifyBuilder` is a builder from the `org.apache.camel.builder` package which allows you to build expressions and then test or wait for that condition to occur.
The expressions are based around notifications about xref:exchange.adoc[Exchange] being routed.
So what does that mean?

It means that you can build an expressions which can tell you when Camel is finished with routing 5 messages etc.
You may want to use this when testing a route which you cannot or will not use xref:components::mock-component.adoc[Mocks].

NOTE: The `NotifyBuilder` is only intended for testing purposes and you can only use this with Java coding.

== Basic example using NotifyBuilder

Suppose we have a very simple route:

[source,java]
----
from("jms:queue:quotes")
    .to("bean:quotes");
----

Imagine the route being more complex, and a production ready route.

Now you want to test this route without using mocks or the likes.
We want to test that it could process a message send to that queue.
By using the `NotifyBuilder` we can build an expression which expresses when that condition occurred.

[source,java]
----
NotifyBuilder notify = new NotifyBuilder().whenDone(1).create();

// now use some API to send a message etc. Maybe you cannot use Camel's ProducerTemplate
// now we want to wait until the message has been routed and completed

boolean done = notify.matches(10, TimeUnit.SECONDS);
assertTrue("Should be done", done);

// now maybe use some API to see that the message did as expected
----

This is a very basic example where we configured the `NotifyBuilder`
to match when any `Exchange` is done.

The builder has many more methods to set more complex expressions, which even can be stacked using and, or, not operations.

== NotifyBuilder API

The `NotifyBuilder` has many methods that allow you to build even more complex expressions.
The table below list the most commonly used methods.

[width="100%",cols="1m,4",options="header",]
|=======================================================================
|Method |Description
| from(endpointUri) | Matches only when Exchanges are incoming from that particular endpoint. The endpointUri can be a pattern, which is the same pattern matching used by Intercept.
| fromRoute(routeId) | Matches only when Exchanges are incoming from that particular route. The routeId can be a pattern, which is the same pattern matching used by Intercept.
| filter(predicate) | Filters out unwanted Exchanges (only messages passing (true) the predicate is used).
| wereSentTo(endpointUri) | Matches only when Exchanges has at any point been sent to the given endpoint. The endpointUri can be a pattern, which is the same pattern matching used by Intercept.
| whenDone(number)| Matches when X number or more messages is done.
| whenComplete(number) | Matches when X number or more messages is complete.
| whenFailed(number) | Matches when X number or more messages is failed.
| whenBodiesDone(bodies) | Matches when the message bodies are done in the same order. This method is non strict which means that it will disregard any additional done messages.
| whenAnyDoneMatches(predicate) | Matches if any one of the done messages matched the Predicate.
| create | Creates the notifier. After you have created it you can use the matches methods.
| matches | Tests whether the notifier currently matches. This operation returns immediately. This method is to be used after you have created the expression.
| matches(timeout) | Waits until the notifier matches or times out. Returns `true` if matches, or `false` if time-out occurs. This operation returns immediately. This method is to be used after you have created the expression.
| matchesWaitTime | Wait until the builder matches or timeout. The timeout value used is based on the highest result wait time configured on any of mock endpoints being used. If no mock endpoint was used, then the default timeout value is 10 seconds. This method is convenient to use in unit tests when you use mocks. Then you don't have to specify the timeout value explicit.
|=======================================================================

`NotifyBuilder` has more than 30 methods. For full list of methods then see the https://www.javadoc.io/doc/org.apache.camel/camel-core-model/current/org/apache/camel/builder/NotifyBuilder.html[javadoc for NotifyBuilder].

TIP: You can create multiple instances of `NotifyBuilder` if you want to be notified
of different conditions. `NotifyBuilder` also supports using binary operations
(and, or, not) to stack together multiple conditions.

=== Difference between done, completed and failed

The `NotifyBuilder` identifies three ways a message can complete:

- _Done_ - The message is done, regardless of whether it completes or fails.
- _Completed_ - The message completes with success (no failure).
- _Failed_ - The message fails (for example an exception is thrown and not handled).

The names of these three ways are also incorporated in the names of the builder methods: `whenDone`, `whenCompleted`, and `whenFailed`.

=== Examples

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .from("direct:foo").whenDone(5)
    .create();
----

Here we want to match when the direct:foo endpoint have done 5 messages.

You may also want to be notified when an message is done by the index, for example the very first message. To do that you can simply do:

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .whenDoneByIndex(0)
    .create();
----

This ensures that the notifier only matches exactly when the first message is done.

If you use `whenDone(1)` instead, then the notifier matches when at least one message is done.
There could be use cases where `whenDone(1)` would match even if the first message hasn't been done yet,
as other message in between could be done ahead of the first message.
That is why `whenDoneByIndex` was added to support this scenario.

Here we want to match when the direct:foo endpoint have done 5 messages which contains the word 'test' in the body.
The filter accepts a xref:predicate.adoc[Predicate].

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .from("direct:foo").filter(body().contains("test")).whenDone(5)
    .create();
----

Here we just say that at least one message should be done received from any JMS endpoint (notice the wildcard matching).

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .from("jms:*").whenDone(1)
    .create();
----

Here, we just say that at least three message should be done received from any of myCoolRoutes (notice the wildcard matching).

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
.fromRoute("myCoolRoutes*").whenDone(3)
.create();
----

Here both 5 foo messages and 7 bar messages must be done. Notice the use of the and operator.

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .from("direct:foo").whenDone(5)
    .and().from("direct:bar").whenDone(7)
    .create();
----

Here we expect to receive two messages whose body is Hello World then Bye World.

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .from("direct:foo").whenBodiesReceived("Hello World", "Bye World")
    .create();
----

Here we expect to receive a message which contains Camel in the body.

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .whenAnyReceivedMatches(body().contains("Camel"))
    .create();
----

=== Using mock endpoint for fine-grained expectations

[source,java]
----
// let's use a mock to set the expressions as it got many great assertions for that
// notice we use mock:assert which does NOT exist in the route, it's just a pseudo name
MockEndpoint mock = getMockEndpoint("mock:assert");
mock.expectedBodiesReceivedInAnyOrder("Hello World", "Bye World", "Hi World");

NotifyBuilder notify = new NotifyBuilder(context)
    .from("direct:foo").whenReceivedSatisfied(mock)
    .create();
----

Here we combine a xref:components::mock-component.adoc[Mock] with the `NotifyBuilder`.
We use the mock to set fine-grained expectations such as we should receive 3 messages in any order. Then using the builder we can tell that those messages should be received from the direct:foo endpoint. You can combine multiple expressions as much as you like.
However, we suggest using the mock for fine-grained expectations that you may already know how to use. You can also specify that the Exchanges must have been sent to a given endpoint.

=== Using wereSentTo

For example in the following we expect the message to be sent to mock:bar

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .wereSentTo("mock:bar")
    .create();
----

You can combine this with any of the other expectations, such as, to only match if 3+ messages are done, and were sent to the mock:bar endpoint:

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .whenDone(3).wereSentTo("mock:bar")
    .create();
----

You can add additional `wereSentTo`, such as the following two:

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .wereSentTo("activemq:queue:foo").wereSentTo("activemq:queue:bar")
.create();
----

As well as you can expect a number of messages to be done, and a message to fail, which has to be sent to another endpoint:

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .whenDone(3).wereSentTo("activemq:queue:goodOrder")
    .and().whenFailed(1).wereSentTo("activemq:queue:badOrder")
    .create();
----
= OnCompletion

Camel has this concept of a _Unit of Work_ that encompass the
Exchange. The unit of work among others supports
synchronization callbacks that are invoked when the
Exchange is complete. The callback API is defined in
`org.apache.camel.spi.Synchronization` and the extended synchronization
`org.apache.camel.spi.SynchronizationRouteAware` that have callbacks for
route events.

== UnitOfWork API

You can get hold of the `org.apache.camel.spi.UnitOfWork` from
`org.apache.camel.Exchange` with the method `getUnitOfWork()`.

== OnCompletion DSL

The OnCompletion EIP supports the following features:

* level: context or route (route level override global level)
* triggered either always, only if completed with success, or only if failed
* `onWhen` predicate to only trigger if matched
* `mode` to define whether to run either before or after
route consumer writes response back to callee (if it is InOut) (default AfterConsumer)
* `parallelProcessing` whether to run async or sync (use a thread pool or not) (default false)

The onCompletion supports running the completion task in either synchronous or asynchronous mode
(using a thread pool) and also whether to run before or after the route
consumer is done. The reason is to give more flexibility. For example to
specify to run synchronous and before the route consumer is done, which
allows to modify the exchange before the consumer writes back any
response to the callee. You can use this to for example add customer
headers, or send to a log to log the response message, etc.

=== onCompletion with route scope

The OnCompletion EIP allows you to add custom routes/processors when
the original Exchange is complete. Camel spins off a
copy of the Exchange and routes it in a separate
thread, similar to a Wire Tap. This allows the
original thread to continue while the onCompletion route is running
concurrently. We chose this model as we did not want the
onCompletion route to interfere with the original route.

=== Multiple onCompletions

You may define multiple onCompletions at both context and route level.

When you define route level onCompletions then any context levels are disabled for that given route.

[source,java]
-----------------------------------------------------------
from("direct:start")
    .onCompletion()
        // this route is only invoked when the original route is complete as a kind
        // of completion callback
        .to("log:sync")
        .to("mock:sync")
    // must use end to denote the end of the onCompletion route
    .end()
    // here the original route contiunes
    .process(new MyProcessor())
    .to("mock:result");
-----------------------------------------------------------

By default the OnCompletion EIP will be triggered when the
Exchange is complete and regardless if the
Exchange completed with success or with a failure
(such as an Exception was thrown). You can limit the trigger to only
occur `onCompleteOnly` or by `onFailureOnly` as shown below:

[source,java]
-----------------------------------------------------------
from("direct:start")
    // here we qualify onCompletion to only invoke when the exchange failed (exception or FAULT body)
    .onCompletion().onFailureOnly()
        .to("log:sync")
        .to("mock:syncFail")
    // must use end to denote the end of the onCompletion route
    .end()    
    .onCompletion().onCompleteOnly()
        .to("log:sync")
        .to("mock:syncOK")
    .end()
    // here the original route continues
    .process(new MyProcessor())
    .to("mock:result");
-----------------------------------------------------------

You can identify if the Exchange is an
OnCompletion Exchange as Camel will add the
property `Exchange.ON_COMPLETION` with a boolean value of `true`.

=== Using onCompletion from XML DSL

The onCompletion is defined like this with XML DSL:

[source,xml]
----
<route>
    <from uri="direct:start"/>
    <!-- this onCompletion block will only be executed when the exchange is done being routed -->
    <!-- this callback is always triggered even if the exchange failed -->
    <onCompletion>
        <!-- so this is a kinda like an after completion callback -->
        <to uri="log:sync"/>
        <to uri="mock:sync"/>
    </onCompletion>
    <process ref="myProcessor"/>
    <to uri="mock:result"/>
</route>
----

And the `onCompleteOnly` and `onFailureOnly` is defined as a boolean
attribute on the `<onCompletion>` tag, so the failure example would be:

[source,xml]
----
<route>
    <from uri="direct:start"/>
    <!-- this onCompletion block will only be executed when the exchange is done being routed -->
    <!-- this callback is only triggered when the exchange failed, as we have onFailureOnly=true -->
    <onCompletion onFailureOnly="true">
        <to uri="log:sync"/>
        <to uri="mock:sync"/>
    </onCompletion>
    <process ref="myProcessor"/>
    <to uri="mock:result"/>
</route>
----

=== onCompletion with global level

This works just like the route level except from the fact that they are
defined globally. An example below:

[source,java]
----
// define a global on completion that is invoked when the exchange is done being routed
onCompletion().to("log:global").to("mock:sync");
 
from("direct:start")
    .process(new MyProcessor())
    .to("mock:result");
----

And in XML:

[source,xml]
----
<!-- this is a global onCompletion route that is invoked when any exchange is done being routed
     as a kind of after callback -->
<onCompletion>
    <to uri="log:global"/>
    <to uri="mock:sync"/>
</onCompletion>
 
<route>
    <from uri="direct:start"/>
    <process ref="myProcessor"/>
    <to uri="mock:result"/>
</route>
----

IMPORTANT: If an `onCompletion` is defined in a route, it overrides *all* global
scoped, and thus it is only the route scoped that is used. The globally
scoped are not in use.

=== Using onCompletion with onWhen predicate

As other DSL in Camel you can attach a predicate to
the `onCompletion`, so it only triggers in certain conditions, when the
predicate matches. For example to only trigger if the message body contains the word
_Hello_ we can do like:

[source,java]
----
from("direct:start")
    .onCompletion().onWhen(body().contains("Hello"))
        // this route is only invoked when the original route is done being routed
        // and the onWhen predicate is true
        .to("log:sync")
        .to("mock:sync")
    // must use end to denote the end of the onCompletion route
    .end()
    // here the original route continues
    .to("log:original")
    .to("mock:result");
----

== Using onCompletion with or without thread pool

To use a thread pool then either set a `executorService` or set
`parallelProcessing` to true.

For example in Java DSL do

[source,java]
----
onCompletion().parallelProcessing()
    .to("mock:before")
    .delay(1000)
    .setBody(simple("OnComplete:${body}"));
----

And in XML DSL:

[source,xml]
----
<onCompletion parallelProcessing="true">
  <to uri="mock:before"/>
  <delay><constant>1000</constant></delay>
  <setBody><simple>OnComplete:${body}</simple></setBody>
</onCompletion>
----

You can also refer to a specific thread pool
to be used, using the `executorServiceRef` option

[source,xml]
----
<onCompletion executorServiceRef="myThreadPool">
  <to uri="mock:before"/>
  <delay><constant>1000</constant></delay>
  <setBody><simple>OnComplete:${body}</simple></setBody>
</onCompletion>
----

=== OnCompletion consumer modes

OnCompletion supports two modes that affect the route consumer:

* AfterConsumer - Default mode which runs after the consumer is done
* BeforeConsumer - Runs before the consumer is done, and before the
consumer writes back response to the callee

The AfterConsumer mode is the default mode which is the same behavior as
in older Camel releases.

The new BeforeConsumer mode is used to run `onCompletion` before the
consumer writes its response back to the callee (if in InOut mode). This
allows the `onCompletion` to modify the Exchange, such as adding special
headers, or to log the Exchange as a response logger etc.

For example to always add a "created by" header you
use `modeBeforeConsumer()` as shown below:

[source,java]
----------------------------------------------------
.onCompletion().modeBeforeConsumer()
    .setHeader("createdBy", constant("Someone"))
.end()
----------------------------------------------------

And in XML DSL you set the mode attribute to BeforeConsumer:

[source,xml]
----
<onCompletion mode="BeforeConsumer">
  <setHeader name="createdBy">
    <constant>Someone</constant>
  </setHeader>
</onCompletion>
----

= Parameter Binding Annotations

The bean parameter binding annotations from Camel are as follows:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Annotation |Meaning |Parameter
|`org.apache.camel.Body`
|To bind to an inbound message body | 

|`org.apache.camel.Header`
|To bind to a message header |String name of the header

|`org.apache.camel.Headers`
|To bind to the Map of the message headers |

|`org.apache.camel.Variable`
|To bind to a named variable |String name of the
variable

|`org.apache.camel.Variables`
|To bind to the variables map |

|`org.apache.camel.ExchangeProperty`
|To bind to a named property on the exchange |String name of the
property

|`org.apache.camel.ExchangeProperties`
|To bind to the exchange property map on the exchange |

|`org.apache.camel.ExchangeException`
|To bind to an Exception set on the exchange |

|=======================================================================

These annotations can be used with the xref:components::bean-component.adoc[Bean]
component or when invoking beans in the xref:dsl.adoc[DSL]

Annotations can be used to define an xref:expression.adoc[Expression] or
to extract various headers, properties or payloads from a
xref:components:eips:message.adoc[Message] when invoking a bean method (see
xref:bean-integration.adoc[Bean Integration] for more detail of how to
invoke bean methods) together with being useful to help disambiguate
which method to invoke.

If no annotations are used then Camel assumes that a single parameter is
the body of the message. Camel will then use the
xref:type-converter.adoc[Type Converter] mechanism to convert from the
expression value to the actual type of the parameter.

== Using bean parameter binding annotations

In this example below we have a `@Consume` consumer (like message driven)
that consumes JMS messages from the activemq queue. We use the `@Header`
and `@Body` parameter binding annotations to bind from the JMSMessage to
the method parameters.

[source,java]
----
public class MyBean {

    @Consume("activemq:my.queue")
    public void doSomething(@Header("JMSCorrelationID") String correlationID, @Body String body) {
        // process the inbound message here
    }

}
----

In the above Camel will extract the value of
`Message.getJMSCorrelationID()`, then using the
xref:type-converter.adoc[Type Converter] to adapt the value to the type
of the parameter if required - it will inject the parameter value for
the *correlationID* parameter. Then the payload of the message will be
converted to a String and injected into the *body* parameter.

TIP: You don't necessarily need to use the `@Consume` annotation if you don't
want to as you could also make use of the Camel xref:dsl.adoc[DSL] to
route to the bean's method as well.

=== Using the DSL to invoke the bean method

Here is another example which does not use xref:pojo-consuming.adoc[POJO
Consuming] annotations but instead uses the xref:dsl.adoc[DSL] to route
messages to the bean method

[source,java]
----
public class MyBean {

    public void doSomething(@Header("JMSCorrelationID") String correlationID, @Body String body) {
        // process the inbound message here
    }

}
----

The routing DSL then looks like this

[source,java]
----
from("activemq:someQueue").
  to("bean:myBean");
----

Here *myBean* would be looked up in the xref:registry.adoc[Registry]
then the body of the message would be used to try figure out what method to call.

If you want to be explicit you can use:

[source,java]
----
from("activemq:someQueue").
  to("bean:myBean?methodName=doSomething");
----

And here we have a nifty example for you to show some great power in
Camel. You can mix and match the annotations with the normal parameters,
so we can have this example with annotations and the Exchange also:

[source,java]
----
public class MyBean {

    public void doSomething(@Header("user") String user, @Body String body, Exchange exchange) {
        exchange.getIn().setBody(body + "MyBean");
    }

}
----

=== Annotation Based Expression Language

You can also use any of the xref:languages.adoc[Languages] supported in
Camel to bind expressions to method parameters when using
xref:bean-integration.adoc[Bean Integration]. For example, you can use
any of these annotations:

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Annotation |Description
|`@Bean`
|Inject a xref:components:languages:bean-language.adoc[Bean] expression

|`@Constant`
|Inject a xref:components:languages:constant-language.adoc[Constant] expression

|`@Groovy`
|Inject a  xref:components:languages:groovy-language.adoc[Groovy] expression

|`@Header`
|Inject a xref:components:languages:header-language.adoc[Header] expression

|`@Simple`
|Inject an xref:components:languages:simple-language.adoc[Simple] expression

|`@XPath`
|Inject an xref:components:languages:xpath-language.adoc[XPath] expression

|=======================================================================

The table above only list some of the commonly used languages. You can find
a list of all supported xref:components:languages:index.adoc[Languages]
which each have their own annotation that can be used.

It is required to include the JAR of the language, for example `camel-groovy`,
or `camel-jsonpath` to use the `@JSonPath` annotation.

Here is an example how to use `@XPath`:

[source,java]
----
public class Foo {

    @Consume("activemq:my.queue")
    public void doSomething(@XPath("/foo/bar/text()") String correlationID, @Body String body) {
        // process the inbound message here
    }

}
----

==== Advanced example using @Bean

And an example of using the the `@Bean` binding annotation,
where you can call a xref:components::bean-component.adoc[POJO] to supply
the parameter value:

[source,java]
----
public class MyBean {
    
    @Consume("activemq:my.queue")
    public void doSomething(@Bean("myCorrelationIdGenerator") String correlationID, @Body String body) {
        // process the inbound message here
    }
}
----

When a message is consumed from the activemq queue, then Camel will invoke the `doSomething`
method. The parameter with `@Bean` is telling Camel to call yet another bean that
computes the correlation id parameter:

[source,java]
----
public class MyIdGenerator {

    private UserManager userManager;

    public String generate(@Header(name = "user") String user, @Body String payload) throws Exception {
       User user = userManager.lookupUser(user);
       String userId = user.getPrimaryId();
       String id = userId + generateHashCodeForPayload(payload);
       return id;
   }
}
----

The xref:components::bean-component.adoc[POJO] MyIdGenerator has one public method that
accepts two parameters. We have also annotated this one with the
`@Header` and `@Body` annotations to help Camel know what to bind here from
the Exchange being processed.

Of course this could be simplified a lot if you for instance just have a
simple id generator. But we wanted to demonstrate that you can use the
xref:bean-binding.adoc[Bean Binding] annotations anywhere.

[source,java]
----
public class MySimpleIdGenerator {

    public static int generate()  {
       // generate a unique id
       return 123;
   }
}
----

And finally we just need to remember to have our bean registered in the xref:registry.adoc[Registry]:

For example in Spring XML:

[source,xml]
----
<bean id="myCorrelationIdGenerator" class="com.mycompany.MySimpleIdGenerator"/>
----

==== Example using Groovy

In this example we have an Exchange that has a User object stored in the
in header. This User object has methods to get some user information. We
want to use xref:components:languages:groovy-language.adoc[Groovy] to inject an expression that
extracts and concats the fullname of the user into the fullName parameter.

[source,java]
----
public class MyBean {

    public void doSomething(@Groovy("$request.header['user'].firstName $request.header['user'].familyName") String fullName, @Body String body) {
        // process the inbound message here
    }

}
----

Groovy supports _GStrings_ that is like a template where we can insert `$`
placeholders that will be evaluated by Groovy.
= Pluggable Class Resolvers

Camel provides pluggable class resolvers allowing third party platforms
and containers to provide their own resolvers in case the default ones
would not fit.

When running Camel on platforms such as Spring Boot, Quarkus, or Apache Karaf,
then Camel uses platform specific resolvers to support classloading in these runtimes.

== Configuration of a custom class resolver

To instruct Camel to use your own custom class resolver, you set the
resolver on the `CamelContext` using the appropriate setters;
or register a custom resolver in the xref:registry.adoc[Registry] then Camel
will automatically detect this during startup.

=== SPI providers

Platform providers should look in the `org.apache.camel.spi` package for
the pluggable resolvers, such as:

* `ClassResolver`
* `FactoryFinderResolver`
* `PackageScanClassResolver`
* `PackageScanResourceResolver`
* `ResourceResolver`
= POJO Consuming

To consume a message you use the `@Consume`
annotation to mark a particular method of a bean as being a consumer
method. The value of the annotation defines the Camel
xref:endpoint.adoc[Endpoint] to consume from.

IMPORTANT: The `@Consume` POJO annotations are not part of any Camel routes, and you cannot use errorHandler or onException with that.

[NOTE]
====
The following steps use the ActiveMQ component which is not yet supported on Camel 4.
====

For example lets invoke the `onCheese()` method with the String body of the
inbound JMS message from ActiveMQ on the cheese
queue; this will use the xref:type-converter.adoc[Type Converter] to
convert the JMS ObjectMessage or BytesMessage to a String - or just use
a TextMessage from JMS

[source,java]
----
public class Foo {

  @Consume("activemq:cheese")
  public void onCheese(String name) {
    // do something here
  }
}
----

The xref:bean-binding.adoc[Bean Binding] is then used to convert the
inbound xref:components:eips:message.adoc[Message] to the parameter list used to invoke
the method .

This basically creates a route that looks kinda like this:

[source,java]
----
from(uri).bean(theBean, "methodName");
----

== Using a property to define the endpoint

The following annotations `@Consume`, `@Produce`, `@EndpointInject`, now
offers a `property` attribute you can use to define the endpoint as a
property on the bean. Then Camel will use the getter method to access
the property.

For example:

[source,java]
----
public class MyService {
  private String serviceEndpoint;
  
  public void setServiceEndpoint(String uri) {
     this.serviceEndpoint = uri;
  }

  public String getServiceEndpoint() {
     return serviceEndpoint;
  }

  @Consume(property = "serviceEndpoint")
  public void onService(String input) {
     // do something
  }
}
----

The bean `MyService` has a property named `serviceEndpoint` which has
getter/setter for the property. Now we want to use the bean for
xref:pojo-consuming.adoc[POJO Consuming], and hence why we use `@Consume`
in the `onService` method. Notice how we use the
`property = "serviceEndpoint` to configure the property that has the
endpoint url.

If you define the bean in Spring XML, then you can configure the property as follows:

[source,xml]
----
<bean id="myService" class="com.foo.MyService">
  <property name="serviceEndpoint" value="activemq:queue:foo"/>
</bean>
----

This allows you to configure the bean without with any dependency injection style.

=== Advanced use with property naming convention

Camel offers a naming convention which allows you to not have to
explicit name the property. Camel uses this algorithm to find the getter method.
The method must be a `getXXX` method.

. Use the property name if explicit given
. If no property name was configured, then use the method name
. Try to get the property with name**Endpoint** (eg with Endpoint as postfix)
. Try to get the property with the name as is (eg no postfix or postfix)
. If the property name starts with **on** then omit that, and try step 3 and 4 again.

So in the example above, we could have defined the `@Consume` annotation as:

[source,java]
----
  @Consume(property = "service")
  public void onService(String input) {
----

Now the property is named "service" which then would match step 3 from
the algorithm, and have Camel invoke the `getServiceEndpoint` method.

We could also have omitted the property attribute, to make it implicit

[source,java]
----
  @Consume
  public void onService(String input) {
----

Now Camel matches step 5, and loses the prefix *on* in the name, and
looks for 'service' as the property. And because there is a
`getServiceEndpoint` method, Camel will use this method.

= POJO producing

There are two different ways to send messages to any Camel
xref:endpoint.adoc[Endpoint] from a POJO:

- Using `@Produce` or `@EndpointInject`
- Or to hide using an interface

[NOTE]
====
The following steps use the ActiveMQ component which is not yet supported on Camel 4.
====

== Using @Produce

To allow sending of messages from POJOs you can use the `@Produce` annotation.
This will inject a `org.apache.camel.ProducerTemplate` so that the bean can send messages.

IMPORTANT: The `@Produce` POJO annotations are not part of any Camel routes, and you cannot use errorHandler or onException with that.

For example to send a message to the foo queue on ActiveMQ:

[source,java]
----
public class Foo {
  @Produce("activemq:foo")
  ProducerTemplate producer;

  public void doSomething() {
    if (whatever) {
      producer.sendBody("<hello>world!</hello>");
    }
  }
}
----

The downside of this is that your code is now dependent on a Camel API,
the `ProducerTemplate`. The next section describes how to remove this
dependency.

TIP: See xref:pojo-consuming.adoc[POJO Consuming] for how to use a property
on the bean as endpoint configuration, e.g., using the `property`
attribute on `@Produce` or `@EndpointInject`.

== Hiding the Camel APIs From Your Code

You can hide Camel APIs from your application code.
You can add the `@Produce` annotation to an injection
point (a field or property setter) using some interface
you use in your business logic. Example:

[source,java]
----
public interface MyListener {
    // this method is request/reply (InOut) because the method has a return value
    // to use one way (InOnly) then the method should be a void method
    String sayHello(String name);
}

public class MyBean {
    @Produce("activemq:foo")
    protected MyListener producer;

    public void doSomething() {
        // lets send a message and get a response back
        String response = producer.sayHello("James");
    }
}
----

Here Camel will automatically inject a smart client side proxy at
the `@Produce` annotation - an instance of the `MyListener`
interface.

When we invoke methods on this interface the method call is
turned into an object and is sent to the
endpoint; in this case the ActiveMQ endpoint to
queue *`foo`*. Because the `sayHello` method has a return type (`String`) then Camel
will use xref:components:eips:requestReply-eip.adoc[Request Reply] (InOut) messaging.

[source,java]
----
public interface MyListener {
    void sayHello(String name);
}
----

If the method is a `void` method, then Camel will use xref:components:eips:event-message.adoc[Event Message] (InOnly) messaging.
= Predicates

xref:expression.adoc[Expressions] and Predicates can then be used to
create the various xref:components:eips:enterprise-integration-patterns.adoc[Enterprise
Integration Patterns] in the xref:dsl.adoc[DSL] like with the xref:components:eips:choice-eip.adoc[Content Based Router] EIP.

To support dynamic rules Camel supports pluggable
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Predicate.html[Predicate]
strategies using a variety of different xref:components:languages:index.adoc[Languages].

== Predicate API

The API for a Camel Predicate is defined in the
`org.apache.camel.Predicate` interface as shown:

[source,java]
-------------------------------------------------------------------------------
public interface Predicate {

    /**
     * Evaluates the predicate on the message exchange and returns true if this
     * exchange matches the predicate
     *
     * @param exchange the message exchange
     * @return true if the predicate matches
     */
    boolean matches(Exchange exchange);

}
-------------------------------------------------------------------------------

A `Predicate` is being evaluated to a boolean value so the result is
either `true` or `false`. This makes predicates so
powerful as it is often used to control the routing of message in which
path they should be routed.

A simple example is to route an xref:exchange.adoc[Exchange] based on a
header value with the xref:components:eips:choice-eip.adoc[Content Based Router] EIP:

[source,java]
----
from("jms:queue:order")
   .choice()
      .when(header("type").isEqualTo("widget")).to("bean:widgetOrder")
      .when(header("type").isEqualTo("wombat")).to("bean:wombatOrder")
   .otherwise()
      .to("bean:miscOrder")
   .end();
----

In the route above the xref:predicate.adoc[Predicate] is the
`header("type").isEqualTo("widget")` as it is constructed as an
xref:expression.adoc[Expression] that is evaluated as a
xref:predicate.adoc[Predicate]. To do this the various _Builder classes_
help us here to create a nice and fluent syntax. `isEqualTo` is a
builder method that returns a xref:predicate.adoc[Predicate] based on
the input.

Sometimes the fluent builders can get long, and a bit complex to read,
then you can just define your predicate outside the route and then just
refer to the predicate in the route:

[source,java]
----
Predicate isWidget = header("type").isEqualTo("widget");
----

And then you can refer to it in the route as:

[source,java]
----
from("jms:queue:order")
   .choice()
      .when(isWidget).to("bean:widgetOrder")
      .when(isWombat).to("bean:wombatOrder")
   .otherwise()
      .to("bean:miscOrder")
   .end();
----

== Negating a Predicate

You can use the *not* method on the `PredicateBuilder` to negate a
predicate.

First, we import the static method `not`, so it makes our route nice and easy to
read:

[source,java]
----
import static org.apache.camel.builder.PredicateBuilder.not;
----

And then we can use it to enclose an existing predicate and negate it as
the example shows:

[source,java]
----
from("direct:start")
    .choice()
        .when(not(header("username").regex("goofy|pluto"))).to("mock:people")
        .otherwise().to("mock:animals")
    .end();
----

== Compound Predicates

You can also create compound predicates using boolean operators such as
`and, or, not` and many others.

Currently, this feature is only available in the Java-based DSLs, and not
in other DSLs such as XML.

Using the
https://www.javadoc.io/doc/org.apache.camel/camel-support/current/org/apache/camel/support/builder/PredicateBuilder.html[`PredicateBuilder`] class,
you can combine predicates *from different Expression Languages* based on logical operators and comparison operators:

* `not`, `and`, `or`
* `isNull`, `isNotNull`
* `isEqualTo`, `isGreaterThan`, `isLessThan`
* `startsWith`, `endsWith`
* `in` ("any of X predicates stands true")

Additionally, with `PredicateBuilder` you can create regular expressions
and use them as predicates, applying them to the result of an
expression, e.g.

[source,java]
----
PredicateBuilder.regex(header("foo"), "\d\{4}");
----
applies the regular expression to the foo header.

Combining different Expression Languages is also possible, e.g.:

[source,java]
----
PredicateBuilder.and(XPathBuilder.xpath("/bookings/flights"), simple("${exchangeProperty.country = 'Spain'}"))
----

The sample below demonstrates further use cases:

[source,java]
----
// We define 3 predicates based on some user roles
// we have static imported and/or from org.apache.camel.builder.PredicateBuilder

// First we have a regular user that is just identified having a username header
Predicate user = header("username").isNotNull();

// The admin user must be a user AND have a admin header as true
Predicate admin = and(user, header("admin").isEqualTo("true"));

// And God must be an admin and (either have type god or a special message containing Camel Rider)
Predicate god = and(admin, or(body().contains("Camel Rider"), header("type").isEqualTo("god")));

// As you can see with the predicates above we can stack them to build compound predicates

// In our route below we can create a nice content based router based on the predicates we
// have defined. Then the route is easy to read and understand.
// We encourage you to define complex predicates outside the fluent router builder as
// it will just get a bit complex for humans to read
from("direct:start").choice()
    .when(god).to("mock:god")
    .when(admin).to("mock:admin")
    .when(user).to("mock:user")
    .otherwise().to("mock:guest")
.end();
----

= Processor

The
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Processor.html[Processor]
interface is used to implement consumers of message exchanges or to
implement a xref:components:eips:message-translator.adoc[Message Translator],
and other use-cases.

== Using a processor in a route

Once you have written a class which implements processor like this:

[source,java]
----
public class MyProcessor implements Processor {

    public void process(Exchange exchange) throws Exception {
        // do something...
    }

}
----

Then you can easily call this processor from a Java such as:

[source,java]
----
from("activemq:myQueue").process(new MyProcessor());
----

Notice that the processor is referred to by the class type `MyProcessor.class` in the route.
Camel will during startup automatic create one new instance of the processor using xref:injector.adoc[Injector]
to be used during routing messages.

In XML DSL however the `<process`> tag requires, referring to an existing processor instance
which can be done:

You can then easily use this inside a route by declaring the bean in
Spring, say via the XML:

[source,xml]
----
<bean id="myProcessor" class="com.acme.MyProcessor"/>
----

And then use the bean id in the Camel route:

[source,xml]
----
<route>
  <from uri="activemq:myQueue"/>
  <process ref="myProcessor"/>
</route>
----

And in Java DSL:

[source,java]
----
from("activemq:myQueue").process("myProcessor");
----

=== Referring to beans using #class syntax

In XML DSL you can also refer to the processor by its class name using `#class:` as prefix as shown:

[source,xml]
----
<route>
  <from uri="activemq:myQueue"/>
  <process ref="#class:com.acme.MyProcessor"/>
</route>
----

This also works in Java DSL:

[source,java]
----
from("activemq:myQueue").process("#class:com.acme.MyProcessor");
----

NOTE: For more details about the `#class:` prefix (and others) then see xref:property-binding.adoc[Property Binding].

However in Java DSL you would often use the type safe way and instantiate the Processor directly as previously shown:

[source,java]
----
from("activemq:myQueue").process(new MyProcessor());
----


== Why use process when you can use to instead?

The process can be used in routes as an anonymous inner class such:

[source,java]
----
    from("activemq:myQueue").process(new Processor() {
        public void process(Exchange exchange) throws Exception {
            String payload = exchange.getIn().getBody(String.class);
            // do something with the payload and/or exchange here
           exchange.getIn().setBody("Changed body");
       }
    }).to("activemq:myOtherQueue");
----

This is usable for quickly whirling up some code. If the code in the
inner class gets a bit more complicated it is of course advised to
refactor it into a separate class. This approach is better if you do not want to use this processor again.
From reusability perspective, it is not recommended to use this approach with anonymous inner classes.

== See Also

** xref:manual::consumertemplate.adoc[Consumer Template]: to learn how to consume data (including within processors)
** xref:manual::producertemplate.adoc[Producer Template]: to learn how to produce data (including within processors)
= ProducerTemplate

The `ProducerTemplate` interface allows you to send message exchanges to
endpoints in a variety of different ways to make it easy to work with
Camel xref:endpoint.adoc[Endpoint] instances from Java code.

It can be configured with a default endpoint if you just want to send
lots of messages to the same endpoint; or you can specify an
xref:endpoint.adoc[Endpoint] or uri as the first parameter.

The `sendBody()` method allows you to send any object to an endpoint
easily as shown:

[source,java]
----
ProducerTemplate template = exchange.getContext().createProducerTemplate();

// send to default endpoint
template.sendBody("<hello>world!</hello>");

// send to a specific queue
template.sendBody("activemq:MyQueue", "<hello>world!</hello>");

// send with a body and header
template.sendBodyAndHeader("activemq:MyQueue",
   "<hello>world!</hello>",
   "CustomerRating", "Gold");
----

You can also supply an `Exchange` or a `Processor` to customize the exchange.

== Send vs Request methods

The `ProducerTemplate` supports xref:exchange-pattern.adoc[Message Exchange Patterns] (MEP)
that are used to control the messaging style to use:

* _send methods_ - xref:components:eips:event-message.adoc[Event Message] (InOnly)
* _request methods_ - xref:components:eips:requestReply-eip.adoc[Request Reply] (InOut)

In other words, all the methods on the `ProducerTemplate` that starts with `sendXXX` are for InOnly messaging,
and all the methods starting with `requestXXX` are for InOut messaging.

Lets see an example where we invoke an endpoint to get the response (InOut):

[source,java]
----
Object response = template.requestBody("<hello/>");

// you can type convert the response to what you want such as String
String ret = template.requestBody("<hello/>", String.class);

// or specify the endpoint uri in the method
String ret = template.requestBody("cxf:bean:HelloWorldService", "<hello/>", String.class);
----

== Fluent interface

The `FluentProducerTemplate` provides a fluent syntax over the regular `ProducerTemplate`.

Here are some examples:

=== Set headers and body

This is the most common style with fluent builders to set headers, and message body as show:

[source,java]
----
Integer result = FluentProducerTemplate.on(context)
    .withHeader("key-1", "value-1")
    .withHeader("key-2", "value-2")
    .withBody("Hello")
    .to("direct:inout")
    .request(Integer.class);
----

=== Using a processor

Here we use xref:processor.adoc[Processor] to prepare the message to be sent.

[source,java]
----
Integer result = FluentProducerTemplate.on(context)
    .withProcessor(exchange -> exchange.getIn().setBody("Hello World"))
    .to("direct:exception")
    .request(Integer.class);
----

=== Advanced with a template customizer

This is rarely in use, but a `TemplateCustomizer` can be used for advanced use-cases
to control various aspects of the `FluentProducerTemplate` such as configuring to use a custom thread pool:

[source,java]
----
Object result = FluentProducerTemplate.on(context)
    .withTemplateCustomizer(
        template -> {
            template.setExecutorService(myExecutor);
            template.setMaximumCacheSize(10);
        }
    )
    .withBody("the body")
    .to("direct:start")
    .request();
----

== See Also

See xref:consumertemplate.adoc[ConsumerTemplate]= Property binding in Camel

Camel supports binding property values (key=value) in many places such as configuration of Camel
components, endpoints, EIPs, routes, and Camel bootstrap configuration.

Together with property placeholders, property placeholder functions, then there is plenty of power, but also
something that takes a little learning to master.

== Property binding features

The core of Camels property binding is implemented in `PropertyBindingSupport.java` which is used internally in Camel,
and as well can be used by Camel component developers.

The `PropertyBindingSupport` class supports binding String valued properties to an instance which uses a set of conventions:

- _property placeholders_ - Keys and values using Camels property placeholder will be resolved.
- _nested_ - Properties can be nested using the dot syntax (OGNL and builder pattern using with as prefix), eg `foo.bar=123`.
- _map_ - Properties can lookup in Map's using map syntax, eg `foo[bar]` where foo is the name of the property that is a Map instance, and bar is the name of the key.
- _list_ - Properties can refer or add to in List's using list syntax, eg `foo[0]` where foo is the name of the property that is a List instance, and 0 is the index. To refer to the last element, then use `last` as key.
- _reference by property placeholder id_ - Values can refer to a property placeholder key with `#property:myKey`
- _reference by bean id_ - Values can refer to other beans in the registry by prefixing with `#` or `#bean:` eg `#myBean` or `#bean:myBean`. It is recommended to favour using `#bean:` syntax to make it obvious it's a bean reference.
- _reference by type_ - Values can refer to singleton beans by their type in the registry by prefixing with `#type:` syntax, eg `#type:com.foo.MyClassType`.
- _autowire by type_ - Values can refer to singleton beans by auto wiring by setting the value to `#autowired`.
- _reference new class_ - Values can refer to creating new beans by their class name by prefixing with `#class`, eg `#class:com.foo.MyClassType`.
       The class is created using a default no-arg constructor, however if you need to create the instance via a factory method
       then you specify the method as shown: `#class:com.foo.MyClassType#myFactoryMethod`.
       And if the factory method requires parameters they can be specified as follows:
       `#class:com.foo.MyClassType#myFactoryMethod('Hello World', 5, true)`.
       Or if you need to create the instance via constructor parameters then you can specify the parameters as shown:
       `#class:com.foo.MyClass('Hello World', 5, true)`.
       If the factory method is on another bean or class, then you must specify this as shown:
       `#class:com.foo.MyClassType#com.foo.MyFactory:myFactoryMethod`. Where `com.foo.MyFactory` either refers to a FQN classname,
       or can refer to an existing bean by id, such as: `#class:com.foo.MyClassType#myFactoryBean:myFactoryMethod`.
- _valueAs(type):value_ - To declare that the value should be converted to the given type, such as `#valueAs(int):123`
       which indicates that the value 123 should be converted to an integer.
- _ignore case_ - Whether to ignore case for property keys (will ignore by default)

== Property binding basics

Do not get overwhelmed by the set of features and what they really do.

At the basics the property binding are used for setting values on Java objects from string values (key=value).

For example to set brokers on the Kafka component you can do:

[source,properties]
----
camel.component.kafka.brokers = mykafka1,mykafka2
----

This will essentially be equivalent to configuring Kafka component in regular Java code via setters:

[source,java]
----
KafkaComponent kafka = ...
kafka.setBrokers("mykafka1,mykafka2");
----

NOTE: For configuring Camel components in Java code, there is also xref:component-dsl.adoc[Component DSL].

The configuration of Camel components, endpoints, routes etc can often require more flexibility and therefore
the property binding has many features to bind by looking up existing objects by id, or anonymously by their type,
and as well to walk down an object graph to bind nested parameters.

== Using PropertyBindingSupport in Java

Although `PropertyBindingSupport` is not primary intended for end users to use, but nevertheless its possible to use,
and also you may get a better understanding of this feature by seeing how this class is used with pure Java.

Suppose we have the following two POJOs `Foo.java` and `Bar.java`:

[source,java]
----
public class Foo {
    private String name;
    private Bar bar = new Bar();

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Bar getBar() {
        return bar;
    }

    public void setBar(Bar bar) {
        this.bar = bar;
    }
}

public class Bar {
    private int age;
    private boolean rider;

    public int getAge() {
        return age;
    }

    public boolean isRider() {
        return rider;
    }

    // this has no setter but only builders and mix the builders with both styles

    public Bar withAge(int age) {
        this.age = age;
        return this;
    }

    public Bar withRider(boolean rider) {
        this.rider = rider;
        return this;
    }
}
----

Then we can use `PropertyBindingSupport` to bind properties to these POJOs:

[source,java]
----
Foo foo = new Foo();

Map<String, Object> prop = new HashMap<>();
prop.put("name", "James");
prop.put("bar.age", "33");
prop.put("bar.rider", "true");

PropertyBindingSupport.bindProperties(context, foo, prop);
----

This will then set the POJOs to have the following values:

----
Foo.name = James
Foo.Bar.age = 33
Foo.Bar.rider = true
----

Instead of providing a map with all the parameters then a single parameter can also be set using builder style as shown:

[source,java]
----
Foo foo = new Foo();

PropertyBindingSupport.build().bind(context, foo, "name", "James");
PropertyBindingSupport.build().bind(context, foo, "bar.age", "33");
PropertyBindingSupport.build().bind(context, foo, "bar.rider", "true");
----

Which is more common to do as follows:

[source,java]
----
Foo foo = new Foo();

PropertyBindingSupport.build().withCamelContext(context).withTarget(foo)
    .withProperty("name", "James");
    .withProperty("bar.age", "33");
    .withProperty("bar.rider", "true")
    .bind();
----

In the example above then we are setting nested values on foo via `bar.age` and `bar.rider`. This is possible because
Foo class has a `getBar` method that returns the `Bar` instance to use:

[source,java]
----
    private Bar bar = new Bar();

    public Bar getBar() {
        return bar;
    }
----

It's a common practice for POJO classes to not create nested instances, but instead on demand. So suppose
`private Bar bar = new Bar();` was not present in the Foo class. In this situation then Camel will automatic
create a new instance of `Bar` using its default no-arg constructor. For more advanced use-cases then you
can specify how the Bar instance should be created, such as via a factory method, or pass in constructor parameters.

For example suppose Bar has a constructor parameter that accepts a boolean, we can pass that information via `#class:` as shown:

[source,java]
----
PropertyBindingSupport.build().withCamelContext(context).withTarget(foo)
    .withProperty("name", "James");
    .withProperty("bar", "#class:com.mycompany.Bar(true)")
    .withProperty("bar.age", "33");
    .withProperty("bar.rider", "true")
    .bind();
----

=== Using fluent builder class

When you are in need to configure a bean via _fluent builder class_, such as the following example:

[source,java]
----
public class MyDriverBuilder {

 private String url;
 private String username;
 private String password;

 public MyDriverBuilder url(String url) {
     this.url = url;
     return this;
 }

 public MyDriverBuilder username(String username) {
     this.username = username;
     return this;
 }

 public MyDriverBuilder password(String password) {
     this.password = password;
     return this;
 }

 public MyDriver build() {
     return new MyDriver(url, username, password);
 }
}
----

And you want to create an instance of `MyDriver` via the `MyDriverBuilder` class, then this can be done as follows:

[source,java]
----
MyDriver driver = PropertyBindingSupport.build()
  .withCamelContext(context)
  .withTarget(new MyDriverBuilder())
  .withFluentBuilder(true)
  .withProperty("url", "localhost:1234")
  .withProperty("username", "scott")
  .withProperty("password", "tiger")
  .build(MyDriver.class);
----

Notice how we use the `build(MyDriver.class)` to build the bean via the target class `.withTarget(new MyDriverBuilder())`.
The build method will by default invoke `build` as the builder method, but you can specify the name, such as `.build(MyDriver.class, "myBuilderMethod");`


== More details

Property binding is notably used when running Camel in standalone mode with Camel Main, or using Camel Spring Boot, Camel K,
Camel Kafka Connector, or Camel Quarkus. All these runtimes have a similar way of configuring via property bindings such
as from `application.properties` files.

See more at xref:components:others:main.adoc[Camel Main]
= Registry

The `org.apache.camel.spi.Registry` API is a common API to lookup beans in any kind of runtime platform,
whether you run Camel on Spring Boot, Quarkus, Standalone, Kafka or something else.

Camel uses the `DefaultRegistry` that based on which runtime used (Spring Boot, Quarkus, etc.) will
first look up beans from the runtime platform, and fallback to Camel's own `SimpleRegistry`.

== Registry API

The registry has two sets of APIs:

- binding
- lookup

The binding API is used to add new beans into the registry.
The lookup is used for looking up existing beans from the registry.

=== Binding API

The binding API is as follows:

[source,java]
----
public interface Registry extends BeanRepository {

    /**
     * Binds the bean to the repository (if possible).
     * If the bean is CamelContextAware then the registry will automatic inject the context if possible.
     *
     * @param  id    the id of the bean
     * @param  bean  the bean
     */
    void bind(String id, Object bean);

    /**
     * Binds the bean to the repository (if possible).
     * Binding by id and type allows to bind multiple entries with the same id but with different type.
     * If the bean is CamelContextAware then the registry will automatic inject the context if possible.
     *
     * @param  id    the id of the bean
     * @param  type  the type of the bean to associate the binding
     * @param  bean  the bean
     */
    void bind(String id, Class<?> type, Object bean);

}
----

If you, for example, need to add a bean to the `Registry` then you can easily do this from Java as follows:

[source,java]
----
Object myFoo = ...
camelContext.getRegistry().bind("foo", myFoo);
----

Then you can access the bean by the id, such as from a Camel route:

[source,java]
----
from("jms:cheese").bean("foo");
----

==== Binding in Spring XML

If you use the Spring XML file, then any `<bean>` is automatic handled by Spring itself, and
registered into Spring bean container; which means there is no need to bind the bean from Camel also.

[source,xml]
----
<bean id="foo" class="com.foo.MyFoo"/>
----

==== Binding in Spring Boot

When using Spring Boot, then you can also use annotations to declare beans
such as with the `@Bean` annotation on the method that creates the bean:

[source,java]
----
@Bean
public MyFoo foo() {
    return new MyFoo();
}
----

This is a common functionality of Spring Boot, and you can find information about this in
the Spring Boot project documentation.

==== Binding in Quarkus

Quarkus has similar functionality like Spring Boot to declare beans, which can be done
with the `javax.inject.enterprise.Produces` and `javax.inject.Named` annotations:

[source,java]
----
@Produces @Named("foo")
public MyFoo foo() {
    return new MyFoo();
}
----

== Lookup API

Registry is mostly used for looking up beans by their IDs, or by type. This is heavily used
during startup of Camel where Camel is wiring up all components, endpoints, routes, processors, beans and so forth.

The lookup API is the following methods:

[source,java]
----
public interface BeanRepository {

    /**
     * Looks up a bean in the registry based purely on name, returning the bean or null if it could not be found.
     *
     * Important: Multiple beans of different types may be bound with the same name, and its encouraged to use the
     * lookupByNameAndType(String, Class) to lookup the bean with a specific type, or to use any of the
     * find methods.
     *
     * @param  name the name of the bean
     * @return      the bean from the registry or null if it could not be found
     */
    Object lookupByName(String name);

    /**
     * Looks up a bean in the registry, returning the bean or null if it could not be found.
     *
     * @param  name the name of the bean
     * @param  type the type of the required bean
     * @return      the bean from the registry or null if it could not be found
     */
    <T> T lookupByNameAndType(String name, Class<T> type);

    /**
     * Finds beans in the registry by their type.
     *
     * @param  type the type of the beans
     * @return      the types found, with their bean ids as the key. Returns an empty Map if none found.
     */
    <T> Map<String, T> findByTypeWithName(Class<T> type);

    /**
     * Finds beans in the registry by their type.
     *
     * @param  type the type of the beans
     * @return      the types found. Returns an empty Set if none found.
     */
    <T> Set<T> findByType(Class<T> type);

}
----

You can lookup beans from Java code as shown:

[source,java]
----
// lookup by id only
Object foo = camelContext.getRegistry().lookupByName("foo");

// lookup by type so there is no need for type casting
MyFoo foo2 = camelContext.getRegistry().lookupByNameAndType("foo", MyFoo.class);
----

=== Looking up beans

You can also use dependency injection that will look up the bean via the Camel registry.
If you use a runtime platform such as Spring Boot or Quarkus, then they come with their own
functionality for this. Camel also has its own bean injection annotation `@BeanInject` which can
be used when running Camel standalone.

NOTE: You can also use `@BeanInject` from Camel in Spring Boot or Quarkus;
but this requires the class with the bean injection is _managed_ by Camel (such as a `RouteBuilder` class);
which may not always be the case. Therefore, it is best to only use the Spring Boot or Quarkus annotations.

==== Lookup in Spring Boot

When using Spring Boot, you can use Spring annotations such as `@Autowired` or `@Inject`
for dependency injection.

==== Lookup in Quarkus

When using Quarkus, you can use CDI annotations such as `@Inject` and `@Named`
for dependency injection.

== More Information

See xref:bean-injection.adoc[Bean Injection] and xref:bean-integration.adoc[Bean Integration]
for more details on working with Beans in Camel.

= Updating the website after a release

Most steps are the same for all releases, although some details may vary.
There are several cases:

* A single repository release, such as `camel-kafka-connector`.
* A set of separately versioned repositories, such as `camel-k`, `camel-k-runtime`, and `camel-kamelets`.
* The set of main `camel` and `camel-spring-boot` which are versioned together.

Changes in the content repositories may be done as part of release preparation, or later. Changes in the `camel-website` `antora-playbook.yml` can be supplied in a PR at any time but should be merged only after the release is voted on and approved.

We'll use the notation `<repo short name>:<path>` to indicate the file to be changed.
For instance, `camel:docs/components/antora.yml` for the `docs/components/antora.yml` component descriptor in the main camel repository, in whatever branch is under discussion.

//== Notes on versions
//
//Within an Antora component, xrefs to content in the same component, whether they are in the same source tree or repository, should never include the `version` or `component` segment of the page id.
//Including the version will make the page non-relocatable to another version: for instance specifying `next` in the main branch will break the link when main is branched for a release.
//Including the `component` segment will redirect to the (Antora) latest version, which will typically be the last released version.
//
//Antora calculates the latest version as the last non-prerelease version.
//Since we are marking the main branch as prerelease, this will never be the main branch.

== After the new release, branches are created in all affected content repositories

These will always be branches from `main`.
Changes to all the new branches, e.g. `camel-3.13.x`, will be necessary.
The changes are almost the same whether the new branch is LTS or not.

=== Changes to the new branches (e.g. `camel-3.13.x`) in affected content repositories

. Examine the `content:sources` key of the `camel-website:antora-playbook.yml` and locate the URLs of the repositories.
. For each URL, locate the `start_path` or `start_paths` key.
. For each start path entry, locate the `antora.yml` component descriptor at that path in the new branch in the repository.
For each Antora component, exactly one of the associated component descriptors will have additional information beyond the name and version.
The version will need to be updated in all associated component descriptors, and the additional information only in the one containing it.
The primary component descriptor, having been duplicated from `main`, will specify version `next` and related properties, and will look something like this:
+
[source,yaml]
----
name: camel-kafka-connector
title: Camel Kafka Connector
version: next
prerelease: true
display-version: Next (Pre-release)

nav:
- modules/ROOT/nav.adoc

asciidoc:
  attributes:
    camel-version: 3.12.x
    camel-k-runtime-version: 1.8.0
    camel-kamelets-version: 0.3.0
    prerelease: true
----
. Set the version to the documentation version for the new release, e.g. `0.11.0`.
. Remove the top level `prerelease` key.
. If the new release is LTS, set the `display-version` appropriately, e.g. `0.11.0 (LTS)`: otherwise remove the `display-version` key.
. Consider the versions listed in `asciidoc/attributes`.
These represent the other camel subprojects this one depends on.
** For subprojects outside the current release set, these will not change on release.
** For subprojects in the same release set, such as `camel` and `camel-spring-boot`, these versions will need to be updated to refer to the new version of the other subproject.
. Remove `prerelease` from `asciidoc/attributes`.
. If the release is LTS, add an `lts` attribute specifying the date out of service.
. Find the `source-map.yml` file next to the `antora.yml` component descriptor.
It will look something like this:
+
--
[source,yml]
----
    - require: '@djencks/antora-source-map'
#      log_level: trace
      source-map:
        - url: 'https://github.com/apache/camel-kamelets.git'
          mapped-url: './../camel-kamelets'
          branches:
            - branch: main
              mapped-branch: HEAD
----
--
Change the `- branch: main` to specify the branch being released, e.g. `- branch: 0.6.x`.
. Build each project (e.g. `mvn clean install -Pfastinstall`) and check for generated changes that need to be committed (or undone if there are tooling problems).
. There will also be `local-build.sh`, `source-map.yml`, and `source-watch.yml` files in the docs directory of the subproject.
These files support xref:improving-the-documentation.adoc#_local_build_instructions[local partial builds of the subproject].
In `source-map.yml`, change the `branch` value from `main` to the new git branch name for the release.

Since the branches with these changes have not yet been added to the Antora playbook, they may be kept on a PR fork/branch or merged into the release branch locally or in the repository.

=== Playbook changes

These changes must go through a PR before being merged, and it is highly advisable to build the website locally to check for problems.

. As in the previous section, examine the `content:sources` key of the `camel-website:antora-playbook.yml` and locate the URLs of the repositories.
. Under `branches` add the new branch directly under `main`, so the branches appear in reverse chronological order, newest first.
Note that this is the git branch name, which is related to but usually not identical to the Antora component version.
. Consult these xref:improving-the-documentation.adoc#_local_build_instructions[local build instructions].
. Consult these xref:improving-the-documentation.adoc#_creating_a_documentation_pull_request[instructions for creating a documentation PR].
Note that your `camel-website` PR will definitely need to be merged after removing the `source-map` extension configuration used to preview the website changes.

=== Notes for specific projects

==== camel-quarkus

Many of the versions in the `antora.yml` component descriptor are set by the maven build from `pom.xml` properties.
Check that these have appropriate values after running the build.
If the build sets inappropriate values, consider fixing or disabling the groovy script.

== Removing obsolete component versions

After each release, it may be possible to remove old versions of the documentation from subprojects.
This depends on whether any current versions of other subprojects depend on the old subproject versions.

The experimental approach is to remove the old branches from the playbook and build the site.
If there are errors from broken xrefs pointing to the removed version, put them back.

You can also examine the component descriptors of older versions of subprojects that depend on the current subproject,
but it is not obvious how to determine which these are without looking at all of them.
= Release Guide

This guide covers how to create and announce a Camel release.
Instructions on updating the website to include the new documentation version are xref:release-guide-website.adoc[here].

[[ReleaseGuide-Prequisites]]
== Prequisites

To prepare or perform a release, you *must be* at least an Apache Camel committer.

* The artifacts for each and every release must be *signed*.
* Your public key must be added to the KEYS file.
* Your public key should also be cross-signed by other Apache committers (this can be done at key signing parties at
ApacheCon, for instance).
* Make sure you have the correct maven configuration in `~/.m2/settings.xml`.
* https://github.com/takari/maven-wrapper[Maven Wrapper] is used and bundled with Camel 2.21 onwards and should be used
for building the release.
* You may want to get familiar with the release settings in the parent Apache POM.
* Make sure you are using Java 11 for Apache Camel 3 and Java 21 for Apache Camel 4.

[[ReleaseGuide-MavenSetup]]
== Maven Setup
Before you deploy anything to the https://repository.apache.org[Apache Nexus repository] using Maven, you should
configure your `~/.m2/settings.xml` file so that the file permissions of the deployed artifacts are group-writable.
If you do not do this, other developers will not be able to overwrite your SNAPSHOT releases with newer versions.

The settings follow the guidelines used by the Maven project. Please pay particular attention to the
http://maven.apache.org/guides/mini/guide-encryption.html[password encryption recommendations].

[source,xml]
----
<settings>
  ...
  <servers>
    <!-- Per http://maven.apache.org/developers/committer-settings.html -->

    <!-- To publish a snapshot of some part of Maven -->
    <server>
      <id>apache.snapshots.https</id>
      <username> <!-- YOUR APACHE LDAP USERNAME --> </username>
      <password> <!-- YOUR APACHE LDAP PASSWORD --> </password>
    </server>
    <!-- To publish a website of some part of Maven -->
    <server>
      <id>apache.website</id>
      <username> <!-- YOUR APACHE LDAP USERNAME --> </username>
      <filePermissions>664</filePermissions>
      <directoryPermissions>775</directoryPermissions>
    </server>
    <!-- To stage a release of some part of Maven -->
    <server>
      <id>apache.releases.https</id>
      <username> <!-- YOUR APACHE LDAP USERNAME --> </username>
      <password> <!-- YOUR APACHE LDAP PASSWORD --> </password>
    </server>
    <!-- To stage a website of some part of Maven -->
    <server>
      <id>stagingSite</id> <!-- must match hard-coded repository identifier in site:stage-deploy -->
      <username> <!-- YOUR APACHE LDAP USERNAME --> </username>
      <filePermissions>664</filePermissions>
      <directoryPermissions>775</directoryPermissions>
    </server>

  </servers>
  ...
  <profiles>
    <profile>
      <id>release</id>
      <properties>
        <gpg.useagent>false</gpg.useagent>
        <gpg.passphrase><!-- YOUR GPG PASSPHRASE --></gpg.passphrase>
        <test>false</test>
      </properties>
    </profile>

  </profiles>
...
</settings>
----

[[ReleaseGuide-CreatingTheRelease-Camel]]
== Creating the Release

Complete the following steps to create a new Camel release:

. Grab the latest source from Git, checkout the target branch (`BRANCH_NAME`) to build from, and create a release branch off of that branch:

  
  $ git clone https://git-wip-us.apache.org/repos/asf/camel.git
  $ cd camel
  $ git checkout BRANCH_NAME
  $ git checkout -b release/NEW-VERSION

. Perform a license check with http://creadur.apache.org/rat/apache-rat-plugin[Apache Rat]:

  
  ./mvnw -e org.apache.rat:apache-rat-plugin:check
  grep -e ' !?????' target/rat.txt
  

*  The latter command will provide a list of all files without valid license headers.
  Ideally this list is empty, otherwise fix the issues by adding valid license headers and rerun the above commands before
  proceeding with the next step.

. Do a release dry run to check for problems:

  
  ./mvnw release:prepare -DdryRun -Prelease
  

* The release plugin will prompt for a release version, an SCM tag and the next release version.

*  Use a three digit release version of the form: `MAJOR.MINOR.PATCH`, e.g. `3.0.0`.

*  For the tag use a string of the form: `camel-MAJOR.MINOR.PATCH`, e.g. `camel-3.0.0`.

*  For the next version increase the patch version and append `-SNAPSHOT`, e.g. `3.0.1-SNAPSHOT`.

* Make sure to check the generated signature files:

  
  $ gpg camel-core/target/camel-core-3.0.0-SNAPSHOT.jar.asc
  gpg: assuming signed data in `camel-core/target/camel-core-3.0.0.jar'
  gpg: Signature made Sat 06 Apr 2019 03:58:01 AM PDT using RSA key ID 5942C049
  gpg: Good signature from "Gregor Zurowski <gzurowski@apache.org>"
 

. Prepare the release:

* First clean up the dry run results:


  $ ./mvnw release:clean -Prelease


* Next prepare the release:


  $ ./mvnw release:prepare -Prelease


*  This command will create the tag and update all pom files with the given version number.

. Perform the release and publish to the Apache staging repository:


  $ ./mvnw release:perform -Prelease


. Close the Apache staging repository:

* Login to https://repository.apache.org using your Apache LDAP credentials.
Click on "Staging Repositories". Then select "org.apache.camel-xxx" in the list of repositories, where xxx represents
your username and ip.
Click "Close" on the toolbar above.
This will close the repository from future deployments and make it available for others to view.
If you are staging multiple releases together, skip this step until you have staged everything.
Enter the name and version of the artifact being released in the "Description" field and then click "Close".
This will make it easier to identify it later.

. Verify staged artifacts:

* If you click on your repository, a tree view will appear below.
You can then browse the contents to ensure the artifacts are as you expect them.
Pay particular attention to the existence of *.asc (signature) files.
If you don't like the content of the repository, right-click your repository and choose "Drop".
You can then roll back your release and repeat the process.
Note the repository URL, you will need this in your vote email.

[[ReleaseGuide-CreatingTheRelease-Camel-spring-boot]]
== Creating the Release for camel-spring-boot

Complete the following steps to create a new Camel-spring-boot release:

. Grab the latest source from Git and checkout the target branch (`BRANCH_NAME`) to build from:

  $ git clone https://git-wip-us.apache.org/repos/asf/camel-spring-boot.git
  $ cd camel
  $ git checkout BRANCH_NAME

. From Camel 3.3.0 ahead, the camel-spring-boot project uses camel-dependencies as parent.
You'll need to set the version here https://github.com/apache/camel-spring-boot/blob/master/pom.xml#L26
To the version released from the main Camel repository as the first step.
  
. Perform a license check with http://creadur.apache.org/rat/apache-rat-plugin[Apache Rat]:

  ./mvnw -e org.apache.rat:apache-rat-plugin:check
  grep -e ' !?????' target/rat.txt
  
*  The latter command will provide a list of all files without valid license headers.
  Ideally this list is empty, otherwise fix the issues by adding valid license headers and rerun the above commands before
  proceeding with the next step.

. You already have built the main camel repo for releasing, so you already have a final version in your local repository.
Change the camel-version property in https://github.com/apache/camel-spring-boot/blob/master/pom.xml accordingly and commit.

. Do a release dry run to check for problems:

  ./mvnw release:prepare -DdryRun -Prelease
  
 * The release plugin will prompt for a release version, an SCM tag and the next release version.

*  Use a three digit release version of the form: `MAJOR.MINOR.PATCH`, e.g. `3.0.0`.

*  For the tag use a string of the form: `camel-MAJOR.MINOR.PATCH`, e.g. `camel-3.0.0`.

*  For the next version increase the patch version and append `-SNAPSHOT`, e.g. `3.0.1-SNAPSHOT`.

* Make sure to check the generated signature files:

  $ gpg core/camel-spring-boot/target/camel-spring-boot-3.0.0-SNAPSHOT.jar.asc
  gpg: assuming signed data in `core/camel-spring-boot/target/camel-spring-boot-3.0.0-SNAPSHOT.jar'
  gpg: Signature made Sat 06 Apr 2019 03:58:01 AM PDT using RSA key ID 5942C049
  gpg: Good signature from "Gregor Zurowski <gzurowski@apache.org>"
 
. Prepare the release:

* First clean up the dry run results:

  $ ./mvnw release:clean -Prelease

* Next prepare the release:

  $ ./mvnw release:prepare -Prelease

*  This command will create the tag and update all pom files with the given version number.

. Perform the release and publish to the Apache staging repository:

  $ ./mvnw release:perform -Prelease

. Close the Apache staging repository:

* Login to https://repository.apache.org using your Apache LDAP credentials.
Click on "Staging Repositories". Then select "org.apache.camel-xxx" in the list of repositories, where xxx represents
your username and ip.
Click "Close" on the tool bar above.
This will close the repository from future deployments and make it available for others to view.
If you are staging multiple releases together, skip this step until you have staged everything.
Enter the name and version of the artifact being released in the "Description" field and then click "Close".
This will make it easier to identify it later.

. Verify staged artifacts:

* If you click on your repository, a tree view will appear below.
You can then browse the contents to ensure the artifacts are as you expect them.
Pay particular attention to the existence of *.asc (signature) files.
If you don't like the content of the repository, right-click your repository and choose "Drop".
You can then roll back your release and repeat the process.
Note the repository URL, you will need this in your vote email.

. Once the release has been voted

* Login to https://repository.apache.org using your Apache LDAP credentials.
Click on "Staging Repositories". Then select "org.apache.camel-xxx" in the list of repositories, where xxx represents
your username and ip.
Click "Release" on the tool bar above.
This will release the artifacts.

[[ReleaseGuide-PublishingTheRelease-Camel]]
== Publishing the Release

. Once the release has been voted:

* Login to https://repository.apache.org using your Apache LDAP credentials.
Click on "Staging Repositories". Then select "org.apache.camel-xxx" in the list of repositories, where xxx represents
your username and IP.
Click "Release" on the tool bar above.
This will release the artifacts.

. Perform a release in JIRA:

* Release the version in JIRA: https://issues.apache.org/jira/plugins/servlet/project-config/CAMEL/versions

. Copy distribution to Apache website:

  cd ${CAMEL_ROOT_DIR}/etc/scripts
  ./release-distro.sh <Camel version>
  
. Copy SBOMs to Apache website:

  cd ${CAMEL_ROOT_DIR}/etc/scripts
  ./release-sbom.sh <Camel version>

. Remove the old distribution version from the Apache website:

  svn rm https://dist.apache.org/repos/dist/release/camel/apache-camel/OLD_CAMEL_VERSION -m "Removed the old release"

. Upload the new schema files (and the manual):

  cd ${CAMEL_ROOT_DIR}/etc/scripts
  ./release-website.sh <Camel version>

. Merge the release branch back into the corresponding base branch (e.g., merge `release/3.2.0` into `camel-3.2.x`)

  git checkout BASE_BRANCH
  git pull
  git merge --no-ff release/VERSION
  git push

. Delete the local and remote release branch:

  git branch -D release/VERSION
  git push origin --delete release/VERSION

[[Publish-xsd-schemas]]
== Publish xsd schemas

* On https://github.com/apache/camel-website/tree/main/static/schema the xsd related to cxf,spring-security and spring
must be pushed to make them available to end users.

[[Tagging-examples]]
== Tagging examples

These steps are optional, and they could be done later too.

Once the release train (camel and camel-spring-boot) has been voted and published, there are some additional steps needed for the camel examples.

. Camel-examples

* On https://github.com/apache/camel-examples in the examples/pom.xml file, the following steps are necessary:

* Update the camel-dependencies version to the version coming from the release-train

* Update the `camel.version` properties to the version coming from the release-train

* To be sure everything is fine, run:

  $ ./mvnw clean install

* Commit

  $ git commit -a
  $ git push origin master (or the branch related to the release, eg. camel-3.4.x)
  $ git tag -a camel-examples-$version -m "$version"
  $ git push origin camel-examples-$version

* Now we pushed the tag, and we need to advance the version of the examples

* Update the camel-dependencies version to the next version

* Update the `camel.version` properties to the next version

* Run the following command to advance the version in the examples
  
  $ find . -type f -exec sed -i 's/$oldVersion/$newVersion/g' {} +

* To be sure everything is fine, run:

  $ ./mvnw clean install

. Camel-spring-boot-examples

* On https://github.com/apache/camel-spring-boot-examples in the examples/pom.xml file the following steps are necessary:

* Update the camel-dependencies version to the version coming from the release-train
    
* Update the `camel.version` properties to the version coming from the release-train
    
* To be sure everything is fine, run:
      
  $ ./mvnw clean install
    
* Commit
  
  $ git commit -a
  $ git push origin master (or the branch related to the release, eg. camel-3.4.x)
  $ git tag -a camel-spring-boot-examples-$version -m "$version"
  $ git push origin camel-spring-boot-examples-$version

* Now we pushed the tag, and we need to advance the version of the examples

* Update the camel-dependencies version to the next version

* Update the `camel.version` properties to the next version

* Run the following command to advance the version in the examples

  $ find . -type f -exec sed -i 's/$oldVersion/$newVersion/g' {} +
   
* To be sure everything is fine, run:

  $ ./mvnw clean install= REST DSL with contract-first OpenAPI

From *Camel 4.6* onwards, the xref:rest-dsl.adoc[Rest DSL] has been improved with a _contract-first_
approach using vanilla OpenAPI specification.

== How it works

The Rest DSL OpenAPI is a facade that builds xref:components::rest-openapi-component.adoc[Rest OpenAPI] endpoint as
consumer for Camel routes. The actual HTTP transport is leveraged by using the xref:components::platform-http-component.adoc[Platform HTTP],
which makes it plugin to Camel Spring Boot, Camel Quarkus or can run standalone with Camel Main.

=== Limitations

Camel does not support websockets from the OpenAPI 3.1 specification.
Neither is (at this time of writing) any security aspects from the OpenAPI specification in use.

== Contract first

The _contract-first_ approach requires you to have an existing OpenAPI v3 specification file.
This contract is a standard OpenAPI contract, and you can use any existing API design tool to build such contracts.

TIP: Camel support OpenAPI v3.0 and v3.1.

In Camel, you then use the Rest DSL in _contract-first_ mode.
For example, having a contract in a file named `my-contract.json`,
you can then copy this file to `src/main/resources` so it's loaded from classpath.

In Camel Rest DSL you can then very easily define _contract-first_ as shown below:


[tabs]
====
Java::
+
[source,java]
----
@Override
public void configure() throws Exception {
    rest().openApi("petstore-v3.json");
}
----
XML::
+
[source,xml]
----
<rest>
  <openApi specification="petstore-v3.json"/>
</rest>
----
YAML::
+
[source,yaml]
----
- rest:
    openApi:
      specification: petstore-v3.json
----
====

When Camel startup the OpenAPI specification file is loaded and parsed. For every API
Camel builds HTTP REST endpoint, which are routed 1:1 to Camel routes using the `direct:operationId` naming convention.

The _pestore_ has 18 APIs here we look at the 5 user APIs:

[source,text]
----
 http://0.0.0.0:8080/api/v3/user                       (POST)   (accept:application/json,application/x-www-form-urlencoded,application/xml produce:application/json,application/xml)
 http://0.0.0.0:8080/api/v3/user/createWithList        (POST)   (accept:application/json produce:application/json,application/xml)
 http://0.0.0.0:8080/api/v3/user/login                 (GET)    (produce:application/json,application/xml)
 http://0.0.0.0:8080/api/v3/user/logout                (GET)
 http://0.0.0.0:8080/api/v3/user/{username}            (DELETE,GET,PUT)
----

These APIs are outputted using the URI that clients can use to call the service.
Each of these APIs has a unique _operation id_ which is what Camel uses for calling the route. This gives:

[source,text]
----
 http://0.0.0.0:8080/api/v3/user                       direct:createUser
 http://0.0.0.0:8080/api/v3/user/createWithList        direct:createUsersWithListInput
 http://0.0.0.0:8080/api/v3/user/login                 direct:loginUser
 http://0.0.0.0:8080/api/v3/user/logout                direct:logoutUser
 http://0.0.0.0:8080/api/v3/user/{username}            direct:getUserByName
----

You should then implement a route for each API that starts from those direct endpoints listed above, such as:

[tabs]
====
Java::
+
[source,java]
----
@Override
public void configure() throws Exception {
    rest().openApi("petstore-v3.json");

    from("direct:getUserByName")
       ... // do something here
}
----
XML::
+
[source,xml]
----
<rest>
  <openApi specification="petstore-v3.json"/>
</rest>
<route>
  <from uri="direct:getUserByName"/>
  // do something here
</route>
----
YAML::
+
[source,yaml]
----
- rest:
    openApi:
      specification: petstore-v3.json
- route:
    from:
      uri: direct:getUserByName
      steps:
        - log:
            message: "do something here"
----
====

=== Ignoring missing API operations

When using OpenAPI with _contract-first_, then Camel will on startup check if there is a corresponding `direct:operationId` route
for every API service. If some operations are missing, then Camel will fail on startup with an error.

During development, you can use `missingOperation` to ignore this as shown:

[source,java]
----
    rest().openApi("petstore-v3.json").missingOperation("ignore");
----

This allows you to implement the APIs one by one over time.

=== Mocking API operations

This is similar to ignoring missing API operations, as you can tell Camel to mock instead, as shown:

[source,java]
----
    rest().openApi("petstore-v3.json").missingOperation("mock");
----

When using _mock_, then Camel will (for missing operations) simulate a successful response:

1. attempting to load canned responses from the file system.
2. for GET verbs then attempt to use example inlined in the OpenAPI `response` section.
3. for other verbs (DELETE, PUT, POST, PATCH) then return the input body as response.
4. if none of the above, then return empty body.

This allows you to have a set of files that you can use for development and testing purposes.

The files should be stored in `camel-mock` when using Camel JBang, and `src/main/resources/camel-mock` for Maven/Gradle based projects.

For example, the following https://github.com/apache/camel-kamelets-examples/tree/main/jbang/open-api-contract-first[Camel JBang example] is structured as:

[source,text]
----
README.md
camel-mock/pet/123.json
petstore-v3.json
petstore.camel.yaml
----

And the Camel route:

[source,yaml]
----
- restConfiguration:
    clientRequestValidation: true
- rest:
    openApi:
      missingOperation: mock
      specification: petstore-v3.json
----

When running this example, you can call the APIs and have an empty successful response. However, for the url `pet/123` the
file `camel-mock/pet/123.json` will be loaded as the response as shown below:

[source,bash]
----
$ curl http://0.0.0.0:8080/api/v3/pet/123
{
  "pet": "donald the dock"
}
----

If no file is found, then Camel will attempt to find an example from the _response_ section in the OpenAPI specification.

In the response section below, then for success GET response (200) then for the `application/json` content-type, we have
an inlined example. Note if there are multiple examples for the same content-type, then Camel will pick the first example,
so make sure it's the best example you want to let Camel use as mocked response body.

[source,json]
----
"responses": {
    "200": {
        "description": "successful operation",
        "content": {
            "application/xml": {
                "schema": {
                    "$ref": "#/components/schemas/Pet"
                }
            },
            "application/json": {
                "schema": {
                    "$ref": "#/components/schemas/Pet"
                },
                "examples": {
                    "success": {
                        "summary": "A cat",
                        "value": "{\"pet\": \"Jack the cat\"}"
                    }
                }
            }
        }
    },
    "400": {
        "description": "Invalid ID supplied"
    },
    "404": {
        "description": "Pet not found"
    }
----

=== Binding to POJO classes

_contract-first_ Rest DSL with OpenAPI also supports binding mode to JSON and XML.
This works the same as _code first_ xref:rest-dsl.adoc[Rest DSL].

However, we have added the `bindingPackageScan` configuration to make it possible for Camel to automatically discover POJO classes from classpath.

When using Spring Boot or Quarkus, then you must configure the package names (base) such as follows:

[source,java]
----
// turn on json binding and scan for POJO classes in the model package
restConfiguration().bindingMode(RestBindingMode.json)
        .bindingPackageScan("sample.petstore.model");
----

You can also configure this in `application.properties`:

[source,properties]
----
camel.rest.bindingMode = json
camel.rest.bindingPackageScan = sample.petstore.model
----

Then Camel will automatically for every OpenAPI operation detect the specified schemas for incoming and outgoing responses,
and map that to Java POJO classes by class name.

For example, the `getPetById` operation in the OpenAPI contract:

[source,json]
----
"responses": {
    "200": {
        "description": "successful operation",
        "content": {
            "application/xml": {
                "schema": {
                    "$ref": "#/components/schemas/Pet"
                }
            },
            "application/json": {
                "schema": {
                    "$ref": "#/components/schemas/Pet"
                }
            }
        }
    },
----

Here Camel will detect the `schema` part:

[source,json]
----
"schema": {
    "$ref": "#/components/schemas/Pet"
}
----

And compute the class name as `Pet` and attempt to discover this class from classpath scanning specified via the `bindingPackageScan` option.

You can also use `title` attribute of the Schema to provide the name of the POJO class. This is helpful when you need to use one name for the Schema in the OpenAPI contract and use another name for the actual POJO class in the implementation.

[source,json]
----
"components": {
        "schemas": {
            "Pet": {
                "type": "object",
                "title": "PetResponseDto",
                "properties": {
                    ...
                }
            }
        }
    },
----

Here Camel will detect the class name as `PetResponseDto` and try to discover it from the classpath. This can be used for both Responses and RequestBodies.

You can source code generate Java POJO classes from an OpenAPI specification via tooling such as the `swagger-codegen-maven-plugin` Maven plugin.
For more details, see this https://github.com/apache/camel-spring-boot-examples/tree/main/openapi-contract-first[Spring Boot example].

=== Expose API specification

The OpenAPI specification is by default not exposed on the HTTP endpoint. You can make this happen by setting the rest-configuration as follows:

[source,yaml]
----
- restConfiguration:
    apiContextPath: /api-doc
----

Then the specification is accessible on `/api-doc` on the embedded HTTP server, so typically that would be `http://localhost:8080/api-doc`.

In the returned API specification the `server` section has been modified to return the IP of the current server. This can be controlled via:


[source,yaml]
----
- restConfiguration:
    apiContextPath: /api-doc
    hostNameResolver: localIp
----

And you can turn this off by setting the value to `none` so the server part is taken verbatim from the specification file.

[source,yaml]
----
- restConfiguration:
    apiContextPath: /api-doc
    hostNameResolver: none
----

== Examples

You can find a few examples such as:

- https://github.com/apache/camel-kamelets-examples/tree/main/jbang/open-api-contract-first
- https://github.com/apache/camel-spring-boot-examples/tree/main/openapi-contract-first
= REST DSL

Apache Camel offers a REST styled DSL.

The intention is to allow end users to define REST services (hosted by Camel) using a
REST style with verbs such as get, post, delete, etc.

NOTE: From *Camel 4.6* onwards, the Rest DSL has been improved with a _contract-first_ approach using vanilla OpenAPI specification
files. This is documented in the xref:rest-dsl-openapi.adoc[Rest DSL with OpenAPI contract first] page. This current page documents the
_code-first_ Rest DSL that Camel provides for a long time.

== How it works

The Rest DSL is a facade that builds xref:components::rest-component.adoc[Rest] endpoints as
consumers for Camel routes. The actual REST transport is leveraged by
using Camel REST components such
as xref:components::netty-http-component.adoc[Netty HTTP], xref:components::servlet-component.adoc[Servlet], and
others that have native REST integration.

== Components supporting Rest DSL

The following Camel components support the Rest DSL:

* xref:components::rest-component.adoc[camel-rest] *required* contains the base rest component needed by Rest DSL
* xref:components::netty-http-component.adoc[camel-netty-http]
* xref:components::jetty-component.adoc[camel-jetty]
* xref:components::platform-http-component.adoc[camel-platform-http]
* xref:components::servlet-component.adoc[camel-servlet]
* xref:components::undertow-component.adoc[camel-undertow]

== Rest DSL with Java DSL

To use the Rest DSL in Java DSL, then just do as with regular Camel routes by
extending the `RouteBuilder` and define the routes in the `configure`
method.

A simple REST service can be defined as follows, where we use `rest()` to
define the services as shown below:

[source,java]
----
@Override
public void configure() throws Exception {
    rest("/say")
        .get("/hello").to("direct:hello")
        .get("/bye").consumes("application/json").to("direct:bye")
        .post("/bye").to("mock:update");

    from("direct:hello")
        .transform().constant("Hello World");

    from("direct:bye")
        .transform().constant("Bye World");
}
----

This defines a REST service with the following url mappings:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Base Path |Uri template |Verb |Consumes
|`_/say_` |`_/hello_` |`get` |_all_
|`_/say_` |`_/bye_` |`get` |`application/json`
|`_/say_` |`_/bye_` |`post` |_all_
|===

Notice that in the REST service we route directly to a Camel endpoint
using `to()`. This is because the Rest DSL has a shorthand for
routing directly to an endpoint using `to()`.

== Rest DSL with XML DSL

The example above can be defined in XML as shown below:

[source,xml]
----
<camelContext xmlns="http://camel.apache.org/schema/spring">
  <rest path="/say">
    <get path="/hello">
      <to uri="direct:hello"/>
    </get>
    <get path="/bye" consumes="application/json">
      <to uri="direct:bye"/>
    </get>
    <post path="/bye">
      <to uri="mock:update"/>
    </post>
  </rest>
  <route>
    <from uri="direct:hello"/>
    <transform>
      <constant>Hello World</constant>
    </transform>
  </route>
  <route>
    <from uri="direct:bye"/>
    <transform>
      <constant>Bye World</constant>
    </transform>
  </route>
</camelContext>
----

== Using a base path

The REST DSL allows defining a base path to help applying the _"don't repeat yourself"_ (DRY) practice.
For example, to define a customer path, we can set the base path in
`rest("/customer")` and then provide the uri templates in the verbs, as
shown below:

[source,java]
----
rest("/customers/")
    .get("/{id}").to("direct:customerDetail")
    .get("/{id}/orders").to("direct:customerOrders")
    .post("/neworder").to("direct:customerNewOrder");
----

And using XML DSL, it becomes:

[source,xml]
----
<rest path="/customers/">
  <get path="/{id}">
    <to uri="direct:customerDetail"/>
  </get>
  <get path="/{id}/orders">
    <to uri="direct:customerOrders"/>
  </get>
  <post path="/neworder">
    <to uri="direct:customerNewOrder"/>
  </post>
</rest>
----

TIP: The REST DSL will take care of duplicate path separators when using base
path and uri templates. In the example above the rest base path ends
with a slash `/` and the verb starts with a slash `/`.
Camel will take care of this and remove the duplicated slash.

It is not required to use both base path and uri templates. You can omit
the base path and define the base path and uri template in the verbs
only. The example above can be defined as:

[source,xml]
----
<rest>
  <get path="/customers/{id}">
    <to uri="direct:customerDetail"/>
  </get>
  <get path="/customers/{id}/orders">
    <to uri="direct:customerOrders"/>
  </get>
  <post path="/customers/neworder">
    <to uri="direct:customerNewOrder"/>
  </post>
</rest>
----

You can combine path parameters to build complex expressions.
For example:

[source,java]
----
 rest("items/")
     .get("{id}/{filename}.{content-type}")
     .to("direct:item")
----


== Managing Rest services

Each of the rest services becomes a Camel route, so in the first example,
we have 2 x get and 1 x post REST service, which each becomes a Camel
route.
This makes it _the same_ from Apache Camel to manage and run these
services, as they are just Camel routes.
This means any tooling and API
today that deals with Camel routes, also work with the REST services.

NOTE: To use JMX with Camel then `camel-management` JAR must be included in the classpath.

This means you can use JMX to stop/start routes, and also get the JMX
metrics about the routes, such as the number of messages processed, and their
performance statistics.

There is also a Rest Registry JMX MBean that contains a registry of all
REST services that has been defined.

== Inline Rest DSL as a single route

IMPORTANT: Camel 4.4 or older has inline-routes disabled by default. Camel 4.5 or newer has inline-routes enabled by default.

Each of the rest services becomes a Camel route, and this means, that if the rest
service is calling another Camel route via `direct`, which is a widespread practice.
This means that each rest service then becomes two routes. This can become harder to manage
if you have many rest services.

When you use `direct` endpoints then you can enable Rest DSL to automatically _inline_ the direct
route in the rest route, meaning that there is only one route per rest service.

To do this you *MUST* use `direct` endpoints, and each endpoint must be unique name per service.
And the option `inlineRoutes` must be enabled.

For example, in the Java DSL below we have enabled inline routes and each rest service
uses `direct` endpoints with unique names.

[source,java]
----
restConfiguration().inlineRoutes(true);

rest("/customers/")
    .get("/{id}").to("direct:customerDetail")
    .get("/{id}/orders").to("direct:customerOrders")
    .post("/neworder").to("direct:customerNewOrder");
----

And in XML:

[source,xml]
----
<restConfiguration inlineRoutes="true"/>

<rest>
  <get path="/customers/{id}">
    <to uri="direct:customerDetail"/>
  </get>
  <get path="/customers/{id}/orders">
    <to uri="direct:customerOrders"/>
  </get>
  <post path="/customers/neworder">
    <to uri="direct:customerNewOrder"/>
  </post>
</rest>
----

If you use Camel Main, Camel Spring Boot, Camel Quarkus or Camel JBang, you can also enable this in `application.properties` such as:

[source,properties]
----
camel.rest.inline-routes = true
----

== Disabling REST services

While developing REST services using Rest DSL, you may want to temporary disabled some REST endpoints,
which you can do using `disabled` as shown in the following.

[source,java]
----
rest("/customers/")
    .get("/{id}").to("direct:customerDetail")
    .get("/{id}/orders").to("direct:customerOrders").disabled("{{ordersEnabled}}")
    .post("/neworder").to("direct:customerNewOrder").disabled();
----

And in XML:

[source,xml]
----
<rest>
  <get path="/customers/{id}">
    <to uri="direct:customerDetail"/>
  </get>
  <get path="/customers/{id}/orders" disabled="{{ordersEnabled}}">
    <to uri="direct:customerOrders"/>
  </get>
  <post path="/customers/neworder" disabled="true">
    <to uri="direct:customerNewOrder"/>
  </post>
</rest>
----

In this example the last two REST endpoints are configured with `disabled`.
You can use xref:manual:ROOT:using-propertyplaceholder.adoc[Property Placeholder] to
let an external configuration determine if the REST endpoint is disabled or not.
In this example the `/customers/\{id}/orders` endpoint is disabled via a placeholder.
The last REST endpoint is hardcoded to be disabled.

== Binding to POJOs using

The Rest DSL supports automatic binding json/xml contents to/from POJOs
using data formats.
By default, the binding
mode is off, meaning there is no automatic binding happening for
incoming and outgoing messages.

You may want to use binding if you develop POJOs that maps to your REST
services request and response types. This allows you as a developer to
work with the POJOs in Java code.

The binding modes are:

[width="100%",cols="10%,90%",options="header",]
|===
|Binding Mode |Description

|`off` |Binding is turned off. This is the default option.

|`auto` |Binding is enabled, and Camel is relaxed and supports JSON, XML or both if
the necessary data formats are included in the classpath. Notice that if
for example `camel-jaxb` is not on the classpath, then XML binding is
not enabled.

|`json` |Binding to/from JSON is enabled, and requires a JSON capable data
format on the classpath. By default, Camel will use `jackson` as the
data format.

|`xm` |Binding to/from XML is enabled, and requires `camel-jaxb` on the
classpath.

|`json_xml` |Binding to/from JSON and XML is enabled and requires both data formats to
be on the classpath.
|===

When using camel-jaxb for XML bindings, then
you can use the option `mustBeJAXBElement` to relax the output message
body must be a class with JAXB annotations. You can use this in
situations where the message body is already in XML format, and you want
to use the message body as-is as the output type. If that is the case,
then set the dataFormatProperty option `mustBeJAXBElement` to `false`
value.

The binding from POJO to JSon/JAXB will only happen if the `content-type`
header includes the word `json` or `xml` representatively. This allows you
to specify a custom content-type if the message body should not attempt to be
marshalled using the binding. For example, if the message body is a
custom binary payload, etc.

When automatic binding from POJO to JSON/JAXB takes place the existing `content-type` header will by default be replaced with either `application/json` or `application/xml`.
To disable the default behavior and be able to produce JSON/JAXB responses with custom `content-type` headers (e.g. `application/user.v2+json`) you configure this in Java DSL as shown below:

[source,java]
----
restConfiguration().dataFormatProperty("contentTypeHeader", "false");
----

To use binding you must include the necessary data formats on the
classpath, such as `camel-jaxb` and/or `camel-jackson`. And then enable
the binding mode. You can configure the binding mode globally on the
rest configuration, and then override per rest service as well.

To enable binding, you configure this in Java DSL as shown below:

[source,java]
----
restConfiguration().component("netty-http").host("localhost").port(portNum).bindingMode(RestBindingMode.auto);
----

And in XML DSL:

[source,xml]
----
<restConfiguration bindingMode="auto" component="netty-http" port="8080"/>
----

When binding is enabled, Camel will bind the incoming and outgoing
messages automatic, accordingly to the content type of the message. If
the message is JSON, then JSON binding happens; and so if the message is
 XML, then XML binding happens. The binding happens for incoming and reply
messages. The table below summaries what binding occurs for incoming and
reply messages. 

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Message Body |Direction |Binding Mode |Message Body

|XML |Incoming |auto,xml,json_xml |POJO

|POJO |Outgoing |auto,xml, json_xml |XML

|JSON |Incoming |auto,json,json_xml |POJO

|POJO |Outgoing |auto,json,json_xml |JSON
|===
 
When using binding, you must also configure what POJO type to map to.
This is mandatory for incoming messages, and optional for outgoing.

NOTE: When using binding mode `json`, `xml` or `json_xml` then Camel will automatically set `consumers` and `produces`
on the rest endpoint (according to the mode), if not already explicit configured. For example, with binding mode `json`
and setting the outType as `UserPojo` then Camel will define this rest endpoint as producing `application/json`.

For example, to map from xml/json to a pojo class `UserPojo` you do this
in Java DSL as shown below:

[source,java]
----
// configure to use netty-http on localhost with the given port
// and enable auto binding mode
restConfiguration().component("netty-http").host("localhost").port(portNum).bindingMode(RestBindingMode.auto);

// use the rest DSL to define the rest services
rest("/users/")
    .post().type(UserPojo.class)
        .to("direct:newUser");
----

Notice we use `type` to define the incoming type. We can optionally
define an outgoing type (which can be a good idea, to make it known from
the DSL and also for tooling and JMX APIs to know both the incoming and
outgoing types of the REST services). To define the outgoing type, we
use `outType` as shown below:

[source,java]
----
// configure to use netty-http on localhost with the given port
// and enable auto binding mode
restConfiguration().component("netty-http").host("localhost").port(portNum).bindingMode(RestBindingMode.auto);

// use the rest DSL to define the rest services
rest("/users/")
    .post().type(UserPojo.class).outType(CountryPojo.class)
        .to("direct:newUser");
----

And in XML DSL:

[source,xml]
----
<rest path="/users/">
  <post type="UserPojo" outType="CountryPojo">
    <to uri="direct:newUser"/>
  </post>
</rest>
----

To specify input and/or output using an array, append `[]` to the end
of the canonical class name as shown in the following Java DSL:

[source,java]
----
// configure to use netty-http on localhost with the given port
// and enable auto binding mode
restConfiguration().component("netty-http").host("localhost").port(portNum).bindingMode(RestBindingMode.auto);

// use the rest DSL to define the rest services
rest("/users/")
    .post().type(UserPojo[].class).outType(CountryPojo[].class)
        .to("direct:newUser");
----

The `UserPojo` is just a plain pojo with getter/setter as shown:

[source,java]
----
public class UserPojo {
    private int id;
    private String name;
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
----

The `UserPojo` only supports JSON, as XML requires using JAXB
annotations, so we can add those annotations if we want to support XML
also

[source,java]
----
@XmlRootElement(name = "user")
@XmlAccessorType(XmlAccessType.FIELD)
public class UserPojo {
    @XmlAttribute
    private int id;
    @XmlAttribute
    private String name;
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
----

By having the JAXB annotations, the POJO supports both JSON and XML
bindings.

=== Camel Rest-DSL configurations

The Rest DSL supports the following options:

[width="100%",cols="2,5,^1,2",options="header"]
|===
| Name | Description | Default | Type
| *apiComponent* | Sets the name of the Camel component to use as the REST API (such as swagger or openapi) |  | String
| *apiContextPath* | Sets a leading API context-path the REST API services will be using. This can be used when using components such as camel-servlet where the deployed web application is deployed using a context-path. |  | String
| *apiHost* | To use a specific hostname for the API documentation (such as swagger or openapi) This can be used to override the generated host with this configured hostname |  | String
| *apiProperties* | Sets additional options on api level |  | Map
| *apiVendorExtension* | Whether a vendor extension is enabled in the Rest APIs. If enabled, then Camel will include additional information as a vendor extension (e.g., keys starting with `_x-_`) such as route ids, class names etc. Not all third party API gateways and tools support vendor-extensions when importing your API docs. | false | boolean
| *bindingMode* | Sets the binding mode to be used by the REST consumer | RestBindingMode.off | RestBindingMode
| *clientRequestValidation* | Whether to enable validation of the client request to check: 1) Content-Type header matches what the Rest DSL consumes; returns HTTP Status 415 if validation error. 2) Accept header matches what the Rest DSL produces; returns HTTP Status 406 if validation error. 3) Missing required data (query parameters, HTTP headers, body); returns HTTP Status 400 if validation error. 4) Parsing error of the message body (JSON, XML or Auto binding mode must be enabled); returns HTTP Status 400 if validation error. | false | boolean
| *component* | Sets the name of the Camel component to use as the REST consumer |  | String
| *componentProperties* | Sets additional options on component level |  | Map
| *consumerProperties* | Sets additional options on consumer level |  | Map
| *contextPath* | Sets a leading context-path the REST services will be using. This can be used when using components such as camel-servlet where the deployed web application is deployed using a context-path. Or for components such as camel-jetty or camel-netty-http that includes a HTTP server. |  | String
| *corsHeaders* | Sets the CORS headers to use if CORS has been enabled. |  | Map
| *dataFormatProperties* | Sets additional options on data format level |  | Map
| *enableCORS* | To specify whether to enable CORS, which means Camel will automatically include CORS in the HTTP headers in the response. This option is default false | false | boolean
| *enableNoContentResponse* | To specify whether to return HTTP 204 with an empty body when a response contains an empty JSON object or XML root object. | false | boolean
| *endpointProperties* | Sets additional options on endpoint level |  | Map
| *host* | Sets the hostname to use by the REST consumer |  | String
| *hostNameResolver* | Sets the resolver to use for resolving hostname | RestHostNameResolver.allLocalIp | RestHostNameResolver
| *inlineRoutes* | Inline routes in rest-dsl which are linked using direct endpoints. By default, each service in Rest DSL is an individual route, meaning that you would have at least two routes per service (rest-dsl, and the route linked from rest-dsl). Enabling this allows Camel to optimize and inline this as a single route. However, this requires using direct endpoints, which must be unique per service. This option is default false. | false | boolean
| *jsonDataFormat* | Sets a custom JSON data format to be used Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance. |  | String
| *port* | Sets the port to use by the REST consumer |  | int
| *producerApiDoc* | Sets the location of the api document (swagger api) the REST producer will use to validate the REST uri and query parameters are valid accordingly to the api document. This requires adding camel-openapi-java to the classpath, and any miss configuration will let Camel fail on startup and report the error(s). The location of the api document is loaded from classpath by default, but you can use file: or http: to refer to resources to load from file or http url. |  | String
| *producerComponent* | Sets the name of the Camel component to use as the REST producer |  | String
| *scheme* | Sets the scheme to use by the REST consumer |  | String
| *skipBindingOnErrorCode* | Whether to skip binding output if there is a custom HTTP error code, and instead use the response body as-is. This option is default true. | true | boolean
| *useXForwardHeaders* | Whether to use X-Forward headers to set host etc. for Swagger. This option is default true. | true | boolean
| *xmlDataFormat* | Sets a custom XML data format to be used. Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance. |  | String
|===


For example, to configure to use the jetty component on port 9091, then we can do as follows:
[source,java]
----
restConfiguration().component("jetty").port(9091).componentProperty("foo", "123");
----

And with XML DSL:

[source,xml]
----
<restConfiguration component="jetty" port="9091">
  <componentProperty key="foo" value="123"/>
</restConfiguration>
----

If no component has been explicitly configured,
then Camel will look up if there is a Camel component that integrates with the Rest DSL,
or if a `org.apache.camel.spi.RestConsumerFactory` is registered in the registry.
If either one is found, then that is being used.

You can configure properties on these levels.

* component - Is used to set any options on the Component class. You can
also configure these directly on the component.
* endpoint - Is used set any option on the endpoint level. Many of the
Camel components has many options you can set on endpoint level.
* consumer - Is used to set any option on the consumer level.
* data format - Is used to set any option on the data formats. For
example, to enable pretty print in the JSON data format.
* cors headers - If cors is enabled, then custom CORS headers can be
set. See below for the default values which are in used. If a custom
header is set then that value takes precedence over the default value.

You can set multiple options of the same level, so you can, for
example, configure two component options, and three endpoint options, etc.


== Enabling or disabling Jackson JSON features

When using JSON binding, you may want to turn specific Jackson features
on or off.
For example, to disable failing on unknown properties (e.g., JSON
input has a property which cannot be mapped to a POJO) then configure
this using the `dataFormatProperty` as shown below:

[source,java]
----
restConfiguration().component("jetty").host("localhost").port(getPort()).bindingMode(RestBindingMode.json)
   .dataFormatProperty("json.in.disableFeatures", "FAIL_ON_UNKNOWN_PROPERTIES");
----

You can disable more features by separating the values using comma, such
as:

[source,java]
----
.dataFormatProperty("json.in.disableFeatures", "FAIL_ON_UNKNOWN_PROPERTIES,ADJUST_DATES_TO_CONTEXT_TIME_ZONE");
----

Likewise, you can enable features using the enableFeatures such as:

[source,java]
----
restConfiguration().component("jetty").host("localhost").port(getPort()).bindingMode(RestBindingMode.json)
   .dataFormatProperty("json.in.disableFeatures", "FAIL_ON_UNKNOWN_PROPERTIES,ADJUST_DATES_TO_CONTEXT_TIME_ZONE")
   .dataFormatProperty("json.in.enableFeatures", "FAIL_ON_NUMBERS_FOR_ENUMS,USE_BIG_DECIMAL_FOR_FLOATS");
----

The values that can be used for enabling and disabling features on
Jackson are the names of the enums from the following three Jackson
classes

* `com.fasterxml.jackson.databind.SerializationFeature`
* `com.fasterxml.jackson.databind.DeserializationFeature`
* `com.fasterxml.jackson.databind.MapperFeature`

The rest configuration is, of course, also possible using XML DSL:

[source,xml]
----
<restConfiguration component="jetty" host="localhost" port="9090" bindingMode="json">
  <dataFormatProperty key="json.in.disableFeatures" value="FAIL_ON_UNKNOWN_PROPERTIES,ADJUST_DATES_TO_CONTEXT_TIME_ZONE"/>
  <dataFormatProperty key="json.in.enableFeatures" value="FAIL_ON_NUMBERS_FOR_ENUMS,USE_BIG_DECIMAL_FOR_FLOATS"/>
</restConfiguration>
----

== Default CORS headers

If CORS is enabled, then the _"follow headers"_ is in use by default.
You can configure custom CORS headers that take precedence over the default
value.

[width="100%",cols="50%,50%",options="header",]
|===
|Key |Value
|`Access-Control-Allow-Origin` |*
|`Access-Control-Allow-Methods` |GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, CONNECT, PATCH
|`Access-Control-Allow-Headers` |Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers
|`Access-Control-Max-Age` |3600
|===
 
== Defining a custom error message as-is

If you want to define custom error messages to be sent back to the
client with a HTTP error code (e.g., such as 400, 404 etc.)
then you set a header with the key `Exchange.HTTP_RESPONSE_CODE`
to the error code (must be 300+) such as 404.
And then the message body with any reply message, and optionally
set the content-type header as well. There is a little example shown
below:

[source,java]
----
restConfiguration().component("netty-http").host("localhost").port(portNum).bindingMode(RestBindingMode.json);
// use the rest DSL to define the rest services
rest("/users/")
    .post("lives").type(UserPojo.class).outType(CountryPojo.class)
    .to("direct:users-lives");

from("direct:users-lives")
    .choice()
        .when().simple("${body.id} < 100")
            .bean(new UserErrorService(), "idToLowError")
        .otherwise()
            .bean(new UserService(), "livesWhere");
----

In this example, if the input id is a number that is below 100, we want
to send back a custom error message, using the UserErrorService bean,
which is implemented as shown:

[source,java]
----
public class UserErrorService {
    public void idToLowError(Exchange exchange) {
        exchange.getIn().setBody("id value is too low");
        exchange.getIn().setHeader(Exchange.CONTENT_TYPE, "text/plain");
        exchange.getIn().setHeader(Exchange.HTTP_RESPONSE_CODE, 400);
    }
}
----

In the `_UserErrorService_` bean, we build our custom error message, and set
the HTTP error code to 400. This is important, as that tells rest-dsl
that this is a custom error message, and the message should not use the
output pojo binding (e.g., would otherwise bind to `_CountryPojo_`).

=== Catching JsonParserException and returning a custom error message

You can return a custom message as-is (see previous section).
So we can leverage this with Camel error handler to
catch `JsonParserException`, handle that exception and build our custom
response message.
For example, to return a HTTP error code 400 with a
hardcoded message, we can do as shown below:

[source,java]
----
onException(JsonParseException.class)
    .handled(true)
    .setHeader(Exchange.HTTP_RESPONSE_CODE, constant(400))
    .setHeader(Exchange.CONTENT_TYPE, constant("text/plain"))
    .setBody().constant("Invalid json data");
----

== Query/Header Parameter default Values

You can specify default values for parameters in the rest-dsl, such as
the verbose parameter below:

[source,java]
----
  rest("/customers/")
      .get("/{id}").to("direct:customerDetail")
      .get("/{id}/orders")
        .param().name("verbose").type(RestParamType.query).defaultValue("false").description("Verbose order details").endParam()
          .to("direct:customerOrders")
      .post("/neworder").to("direct:customerNewOrder");
----

The default value is automatic set as
header on the incoming Camel `Message`. So if the call
to `/customers/id/orders` do not include a query parameter with
key `verbose` then Camel will now include a header with key `verbose`
and the value `false` because it was declared as the default value. This
functionality is only applicable for query parameters.
Request headers may also be defaulted in the same way.

[source,java]
----
  rest("/customers/")
      .get("/{id}").to("direct:customerDetail")
      .get("/{id}/orders")
        .param().name("indicator").type(RestParamType.header).defaultValue("disabled").description("Feature Enabled Indicator").endParam()
          .to("direct:customerOrders")
      .post("/neworder").to("direct:customerNewOrder");
----

== Client Request Validation

It is possible to enable validation of the incoming client request.
The validation checks for the following:

- Content-Type header matches what the Rest DSL consumes. (Returns HTTP Status 415)
- Accept header matches what the Rest DSL produces. (Returns HTTP Status 406)
- Missing required data (query parameters, HTTP headers, body). (Returns HTTP Status 400)
- Checking if query parameters or HTTP headers has not-allowed values. (Returns HTTP Status 400)
- Parsing error of the message body (JSON, XML or Auto binding mode must be enabled). (Returns HTTP Status 400)

If the validation fails, then Rest DSL will return a response
with an HTTP error code.

The validation is by default turned off (to be backwards compatible).
It can be turned on via `clientRequestValidation` as shown below:

[source,java]
----
restConfiguration().component("jetty").host("localhost")
    .clientRequestValidation(true);
----

== OpenAPI / Swagger API

The Rest DSL supports OpenAPI and Swagger by
the `camel-openapi-java` modules.

You can define each parameter fine-grained
with details such as name, description, data type, parameter type and so
on, using the `param`.
For example, to define the id path parameter, you
can do as shown below:

[source,xml]
----
<!-- this is a rest GET to view an user by the given id -->
<get path="/{id}" outType="org.apache.camel.example.rest.User">
  <description>Find user by id</description>
  <param name="id" type="path" description="The id of the user to get" dataType="int"/>
  <to uri="bean:userService?method=getUser(${header.id})"/>
</get>
----

And in Java DSL

[source,java]
----
.get("/{id}").description("Find user by id").outType(User.class)
    .param().name("id").type(path).description("The id of the user to get").dataType("int").endParam()
    .to("bean:userService?method=getUser(${header.id})")
----

The body parameter type requires to use body as well for the name. For
example, a REST PUT operation to create/update an user could be done as:

[source,xml]
----
<!-- this is a rest PUT to create/update an user -->
<put type="org.apache.camel.example.rest.User">
  <description>Updates or create a user</description>
  <param name="body" type="body" description="The user to update or create"/>
  <to uri="bean:userService?method=updateUser"/>
</put>
----

And in Java DSL:

[source,java]
----
.put().description("Updates or create a user").type(User.class)
    .param().name("body").type(body).description("The user to update or create").endParam()
    .to("bean:userService?method=updateUser")
----

=== Vendor Extensions

The generated API documentation can be configured to include vendor extensions (https://swagger.io/specification/#specificationExtensions)
which document the operations and definitions with additional information, such as class name of model classes, camel context id and route id's.
This information can be very helpful for developers, especially during troubleshooting. However, at production usage you may wish to not have this turned
on to avoid leaking implementation details into your API docs.

The vendor extension information is stored in the API documentation with keys starting with `x-`.

NOTE: Not all third party API gateways and tools support vendor-extensions when importing your API docs.

The vendor extensions can be turned on `RestConfiguration` via the `apiVendorExtension` option:

[source,java]
----
restConfiguration()
    .component("servlet")
    .bindingMode(RestBindingMode.json)
    .dataFormatProperty("prettyPrint", "true")
    .apiContextPath("api-doc")
    .apiVendorExtension(true)
        .apiProperty("api.title", "User API").apiProperty("api.version", "1.0.0")
        .apiProperty("cors", "true");
----

And in XML DSL:

[source,xml]
----
 <restConfiguration component="servlet" bindingMode="json"
                       apiContextPath="api-docs"
                       apiVendorExtension="true">

      <!-- we want json output in pretty mode -->
      <dataFormatProperty key="prettyPrint" value="true"/>

      <!-- setup swagger api descriptions -->
      <apiProperty key="api.version" value="1.0.0"/>
      <apiProperty key="api.title" value="User API"/>

</restConfiguration>
----

=== Supported API properties

The following table lists supported API properties and explains their effect. To set them use `apiProperty(String, String)` in the Java DSL
or `<apiProperty>` when defining the REST API via XML configuration. Properties in **bold** are required by the OpenAPI 2.0 specification. 
Most of the properties affect the OpenAPI https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#infoObject[Info object], https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#licenseObject[License object] or https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#contact-object[Contact object].

|===
|Property | Description
| **api.version** | Version of the API 
| **api.title** | Title of the API
| api.description | Description of the API
| api.termsOfService | API Terms of Service of the API
| api.license.name | License information of the API
| api.license.url | URL for the License of the API
| api.contact.name | The identifying name of the contact person/organization
| api.contact.url | The URL pointing to the contact information
| api.contact.email | The email address of the contact person/organization
| api.specification.contentType.json | The Content-Type of the served OpenAPI JSON specification, `application/json` by default
| api.specification.contentType.yaml | The Content-Type of the served OpenAPI YAML specification, `text/yaml` by default
| externalDocs.url |  The URI for the target documentation. This must be in the form of a URI
| externalDocs.description | A description of the target documentation
|===
= RouteBuilder

The `RouteBuilder` is a base class which is derived from to create routing rules using the DSL.
Instances of `RouteBuilder` are then added to the `CamelContext`.

== RouteBuilder example

The following shows an example of a `RouteBuilder`:

[source,java]
-------------------------------------------------------------------------
import org.apache.camel.builder.RouteBuilder;

/**
 * A Camel Java DSL Router
 */
public class MyRouteBuilder extends RouteBuilder {

    /**
     * Let's configure the Camel routing rules using Java code...
     */
    public void configure() {

        // here is a sample which processes the input files
        // (leaving them in place - see the 'noop' flag)
        // then performs content based routing on the message using XPath
        from("file:src/data?noop=true")
            .choice()
                .when(xpath("/person/city = 'London'"))
                    .to("file:target/messages/uk")
                .otherwise()
                    .to("file:target/messages/others");
    }

}
-------------------------------------------------------------------------

In the `configure` method we can define Camel xref:routes.adoc[Routes].

== More Information

See more in xref:dsl.adoc[DSL], xref:java-dsl.adoc[Java DSL] and xref:routes.adoc[Routes].
= Route Configuration

Camel 3.12 introduces route configuration which is used for separating configurations
from the routes. This can be used in situations such as configuring different error handling across a set of routes.
In previous versions of Camel, this was more cumbersome to do, as you would either have
to copy the same configuration to a set of routes or rely on global error handling configuration.

Now you can configure a number of route configurations, and then specify on each route
which configuration to use (you can use match by ids, wildcards, and regular expression).

The route configuration is supported by all DSLs, so usable by: Java, XML, Groovy and so forth.

In the route configuration, you can set up common strategies for:

- xref:error-handler.adoc[Error Handler]
- xref:exception-clause.adoc[OnException]
- xref:oncompletion.adoc[OnCompletion]
- xref:components:eips:intercept.adoc[Intercept]


== Route Configuration Builder in Java DSL

With Java DSL you can use `RouteConfigurationBuilder` to specify the configuration as shown below.
The builder is similar to `RouteBuilder` so its use is familiar.

[source,java]
----
public class MyJavaErrorHandler extends RouteConfigurationBuilder {

    @Override
    public void configuration() throws Exception {
        routeConfiguration("javaError")
            .onException(Exception.class).handled(true)
            .log("Java WARN: ${exception.message}");
    }
}
----

NOTE: The `RouteConfigurationBuilder` uses `configuration` as the method where the configuration is coded.
This is on purpose, so as not to use the `configure` method which the regular Java DSL `RouteBuilder`
uses for coding Camel routes.

In the example above, then there is only one route configuration that has been assigned the ID `_javaError_`.
This ID allows us to refer to this configuration later when you want to assign which routes are using the configuration.

This configuration is a basic configuration that just catches and handles all exceptions and logs a WARN message.

=== Assigning route configurations to routes

To use this configuration in your routes, then you can assign it with `routeConfigurationId` as shown:

[source,java]
----
public class MyJavaRouteBuilder extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        from("timer:java?period=2s")
            // refer to the route configuration by the id to use for this route
            .routeConfigurationId("javaError")
            .setBody(method(MyJavaRouteBuilder.class, "randomNumber"))
            .log("Random number ${body}")
            .filter(simple("${body} < 30"))
                .throwException(new IllegalArgumentException("The number is too low"));
    }

    public static int randomNumber() {
        return new Random().nextInt(100);
    }
}
----

In the `routeConfigurationId` the configuration to use is specified by the ID, eg `_javaError_`.

Multiple configurations can be assigned (separated by comma), such as:

[source,java]
----
.routeConfigurationId("javaError,myAudit")
----

The route configuration supports matching by:

- exact ID name. This is the sample we have seen above.
- wildcard
- regular expression.

Wildcards are text ending with a `*`.
They are matched when the configuration ID starts with the specified text followed by any characters.
For instance, you can do:

[source,java]
----
.routeConfigurationId("java*,myAudit")
----

Here we use wildcard in `_java*_` which means any configuration whose ID starts with java is a match.

Match by regular expression is just like match by wildcard but using regex instead.

[source,java]
----
.routeConfigurationId(".*error.*")
----

Here we want to match any configuration whose ID contains `_error_`.

=== Adding route configurations to CamelContext

Because a `RouteConfigurationBuilder` is also a `RouteBuilder` then you add route configurations
the same way for `RouteBuilder` such as using the API on `CamelContext`

[source,java]
----
CamelContext context = ...
// add the route configuration
context.addRoutes(new MyJavaErrorHandler());
// add the regular route
context.addRoutes(new MyJavaRouteBuilder());
----

If you use Spring Boot, then your Camel routes and route configurations can be auto-discovered
by the spring boot component scanning. This requires adding the `@Component` annotation to the class.

See the example https://github.com/apache/camel-spring-boot-examples/tree/main/routes-configuration[camel-spring-boot-examples/routes-configuration].


=== Route configuration with Endpoint DSL

The xref:Endpoint-dsl.adoc[Endpoint DSL] can also be used for route configurations.
This requires adding `camel-endpointdsl` to the classpath, and then using
`org.apache.camel.builder.endpoint.EndpointRouteConfigurationBuilder`,
which offers the _type safe_ DSL for Camel endpoints.


== Default route configurations

Route configurations are either given an explicit unique ID, or the configuration is _nameless_.
A _nameless_ configuration is used as default/fallback configuration, for routes which have *NOT*
been explicitly assigned route configurations.

Suppose you have one _nameless_ configuration and another named `_retryError_`:

[source,java]
----
public class MyJavaErrorHandler extends RouteConfigurationBuilder {

    @Override
    public void configuration() throws Exception {
        routeConfiguration()
            .onException(Exception.class).handled(true)
            .log("WARN: ${exception.message}");

        routeConfiguration("retryError")
            .onException(Exception.class).maximumRedeliveries(5);
    }
}
----

And the following two routes:

[source,java]
----
   from("file:cheese").routeId("cheese")
        .to("kafka:cheese");

   from("file:beer").routeId("beer")
        .routeConfigurationId("retryError")
        .to("jms:beer");
----

In the example above, the `_cheese_` route has no route configurations assigned, so the route
will use the default configuration, which in case of an exception will log a warning.

The `_beer_` route on the other hand has the route configuration `_retryError_` assigned, and this
configuration will in case of an exception retry up to five times and then if still an error
then fail and rollback.

If you add more routes, then those routes can also be assigned the `_retryError_` configuration
if they should also retry in case of error.

=== Route Configuration with Error Handler

Each route configuration can also have a specific error handler configured, as shown below:

[source,java]
----
public class MyJavaErrorHandler extends RouteConfigurationBuilder {

    @Override
    public void configuration() throws Exception {
        routeConfiguration()
            .errorHandler(deadLetterChannel("mock:dead"));

        routeConfiguration("retryError")
            .onException(Exception.class).maximumRedeliveries(5);
    }
}
----

In the example above, the `_nameless_` configuration has an error handler with a dead letter queue.
And the route configuration with id `_retryError_` does not, and instead it will attempt
to retry the failing message up till five times before giving up (exhausted).
Because this route configuration does not have any error handler assigned, then Camel will use the default error handler.

IMPORTANT: Routes that have a local error handler defined, will always use this error handler,
instead of the error handler from route configurations. A route can only have one error handler.

== Route Configuration in XML

When using XML DSL, then you can code your route configurations in XML files as shown below:

[source,xml]
----
<routeConfiguration id="xmlError">
    <onException>
        <exception>java.lang.Exception</exception>
        <handled><constant>true</constant></handled>
        <log message="XML WARN: ${exception.message}"/>
    </onException>
</routeConfiguration>
----

And in the XML routes you can assign which configurations to use:

[source,xml]
----
<route routeConfigurationId="xmlError">
    <from uri="timer:xml?period=5s"/>
    <log message="I am XML"/>
    <throwException exceptionType="java.lang.Exception" message="Some kind of XML error"/>
</route>
----

In this example, the route is assigned the `_xmlError_` route configuration by the exact ID.


== Route Configuration in YAML

When using YAML DSL, then you can code your route configurations in YAML files as shown below:

[source,yaml]
----
- route-configuration:
    id: "yamlError"
    on-exception:
    - on-exception:
        handled:
          constant: "true"
        exception:
          - "java.lang.Exception"
        steps:
          - log:
              message: "YAML WARN ${exception.message}"
----

And in the YAML routes you can assign which configurations to use:

[source,yaml]
----
- route:
    # refer to the route configuration by the id to use for this route
    route-configuration-id: "yamlError"
    from:
      uri: "timer:yaml?period=3s"
      steps:
        - set-body:
            simple: "Timer fired ${header.CamelTimerCounter} times"
        - to:
            uri: "log:yaml"
            parameters:
              show-body-type: false
              show-exchange-pattern: false
        - throw-exception:
            exception-type: "java.lang.IllegalArgumentException"
            message: "Error from yaml"
----

In this example, the route is assigned the `_yamlError_` route configuration by the exact ID.

== Mixing DSLs

Routes and route configuration are not required to use the same language. For example, you can code
route configurations in Java, and then use XML DSL for the routes, and they would work together.

== Route Configuration in classic Spring XML

When using XML DSL with `camel-spring-xml` then you can code your route configurations in `<routeConfigurationContext>` snippets
in separate XML files as shown below:

[source,xml]
----
<routeConfigurationContext id="myConf" xmlns="http://camel.apache.org/schema/spring">
    <routeConfiguration id="xmlError">
        <onException>
            <exception>java.lang.Exception</exception>
            <handled><constant>true</constant></handled>
            <log message="XML WARN: ${exception.message}"/>
        </onException>
    </routeConfiguration>
</routeConfigurationContext>
----

Then from `<camelContext>` you can refer to these XML snippets by their ids:

[source,xml]
----
<camelContext id="myCamel" xmlns="http://camel.apache.org/schema/spring">

    <!-- refer to the ID on the context that has the route configurations (see above) -->
    <routeConfigurationContextRef ref="myConf"/>

    <!-- routes can then assign which configuration to use -->
    <route routeConfigurationId="xmlError">
        <from uri="timer:xml?period=5s"/>
        <log message="I am XML"/>
        <throwException exceptionType="java.lang.Exception" message="Some kind of XML error"/>
    </route>
</camelContext>
----

In this example, the route is assigned the `_xmlError_` route configuration by the exact ID.

== Packaging route configurations in reusable JARs

You can package common route configurations into JARs which you can then use together with
your Camel applications, by adding the JARs as dependencies to the classpath (such as in Maven pom.xml file).

This allows, for example, to use a _common practice_ among your Camel applications.

== Logging Summary

If you set `startup-summary-level=verbose` then Camel will log for each route which route configurations they have been assigned.

This option can be configured via Java API and also in `application.properties` for Camel on Spring Boot, Quarkus, and Camel standalone via `camel-main`

[source,java]
----
camelContext.setStartupSummaryLevel(StartupSummaryLevel.Verbose);
----

And with Spring Boot:

[source,properties]
----
camel.spring-boot.startup-summary-level = verbose
----

And in Camel Main / Quarkus:

[source,properties]
----
camel.main.startup-summary-level = verbose
----

== Route Precondition

The route configurations can be included or not according to the result of a test expressed in simple language that is evaluated only once during the initialization phase.

In the next example, the route configuration is only included if the parameter `activate` has been set to `true`.

[source,java]
----
routeConfiguration().precondition("{{activate}}")
    .onException(IllegalArgumentException.class)
    .handled(true)
    .log("WARN: ${exception.message}");
----

And the same example using XML DSL:

[source,xml]
----
<routeConfiguration precondition="{{activate}}">
    <onException>
        <exception>java.lang.IllegalArgumentException</exception>
        <handled>
            <constant>true</constant>
        </handled>
        <log message="XML WARN: ${exception.message}"/>
    </onException>
</routeConfiguration>
----

And in YAML DSL:

[source,yaml]
----
- route-configuration:
    precondition: "{{activate}}"
    on-exception:
    - on-exception:
        exception:
          - "java.lang.IllegalArgumentException"
        handled:
          constant: "true"
        steps:
          - log:
              message: "YAML WARN ${exception.message}"
----

== More Information

See these examples:

- https://github.com/apache/camel-examples/tree/main/routes-configuration[camel-examples/examples/routes-configuration]
- https://github.com/apache/camel-spring-boot-examples/tree/main/routes-configuration[camel-spring-boot-examples/routes-configuration/]

= Route Controller

Camel uses a `RouteController` for managing the lifecycle of all the routes.
The controller is mainly in use during starting up the routes when Camel startup.

The controller is handling which routes, and in which order they should be started.

Camel offers two kinds of controllers. The classic default controller, and a supervising
controller that can attempt to restart routes that failed during startup.

== DefaultRouteController

This is the default controller and strategy that has always been in use by Camel.
The controller works with the _fail fast_ principle, that if any routes fail to
start, then it gives up and Camel itself fails to start up.

The controller also starts the routes sequentially and uses a single thread.
This means there is no concurrent startup, meaning the routes are started
more reliably without concurrency issues.

If a route fails on startup then it is often its `Consumer` that triggers an error
in its startup. Some components offer a way to handle this internally and
attempt to recover from this. However, most components do not offer such a feature
and therefore in most situations, the route would fail to startup and therefore
also Camel itself. The JMS component is an example of a component that can
recover from startup issues in the `Consumer` such as failing to connect to the JMS broker.

The `SupervisingRouteController` is capable of handling this, and manages routes
that have failed to startup, by taking over and attempting to restart these routes.

Given the routes below:

[source,java]
----
from("file:foo/cake")
  to("log:cake");

from("salesforce:cheese")
  to("log:cheese");
----

Then the two routes may fail on startup. However, the first route with the file component
would very likely always start up as it is just using the file system that is reliable.

The second route, however, is using Salesforce, which can fail to start up if there is no network
connecting to Salesforce.

== SupervisingRouteController

A supervising capable `RouteController` that delays the startup of the routes
after the camel context startup and takes control of starting the routes in a safe manner.
This controller is able to retry starting failing routes, and has various options to configure
settings for backoff between restarting routes.

If we take the same example again:

[source,java]
----
from("file:foo/cake")
  to("log:cake");

from("salesforce:cheese")
  to("log:cheese");
----

Then we can tell Camel to use the supervising route controller to let Camel attempt to
recover starting the salesforce route.

=== Configuring Supervising Route Controller

Enabling and configuring supervising route controller from Java:

[source,java]
-----
CamelContext camel = ...
SupervisingRouteController src = camel.getRouteController().supervise();
src.setBackOffDelay(5000);
src.setBackOffMaxAttempts(3);
src.setInitialDelay(1000);
src.setThreadPoolSize(2);
-----

If you use Camel with Spring Boot or Camel Main, you can also enable supervising
from `application.properties`:

[source,properties]
----
camel.routecontroller.enabled = true

# and you can configure more options
camel.routecontroller.backoffDelay = 5000
camel.routecontroller.backoffMaxAttempts = 3
camel.routecontroller.initialDelay = 1000
camel.routecontroller.threadPoolSize = 2
----

And for users with Spring <beans> you can do as follows:

[source,xml]
----
<camelContext>
    <routeController id="myController"
                     supervising="true" initialDelay="1000" threadPoolSize="2"
                     backOffDelay="5000" backOffMaxAttempts="3"/>
    <route>
      <from uri="file:foo/cake"/>
      <to uri="log:cake"/>
    </route>
    <route>
      <from uri="salesforce:cheese"/>
      <to uri="log:cheese"/>
    </route>
</camelContext>
----

=== Supervising Route Controller Options

You can configure the `SupervisingRouteController` using the following options:

[width="100%",cols="10%,20%,70%",options="header",]
|=======================================================================
| Option | Default | Description
| Enabled | `false` | To enable using supervising route controller which allows Camel to start up, and then, the controller takes care of starting the routes in a safe manner. This can be used when you want to startup Camel despite a route may otherwise fail fast during startup and cause Camel to fail to startup as well. By delegating the route startup to the supervising route controller then its manages the startup using a background thread. The controller allows to be configured with various settings to attempt to restart failing routes.
| InitialDelay | | Initial delay in milliseconds before the route controller starts, after CamelContext has been started.
| BackOffDelay | `2000` | Backoff delay in milliseconds when restarting a route that failed to startup.
| BackOffMaxAttempts | | Backoff maximum number of attempts to restart a route that failed to startup. When this threshold has been exceeded then the controller will give up attempting to restart the route, and the route will remain as stopped. Will by default attempt forever.
| BackOffMaxDelay | | Backoff maximum delay in milliseconds when restarting a route that failed to startup.
| BackOffMaxElapsedTime | | Backoff maximum elapsed time in milliseconds, after which the backoff should be considered exhausted and no more attempts should be made.
| BackOffMultiplier | 1.0 | Backoff multiplier to use for exponential backoff. This is used to extend the delay between restart attempts.
| IncludeRoutes | | Pattern for filtering routes to be included as supervised. The pattern is matched on route id, and endpoint uri for the route. Multiple patterns can be separated by comma. For example, to include all kafka routes, you can say `kafka:`. And to include routes with specific route ids `_myRoute,myOtherRoute_`. The pattern supports wildcards and uses the matcher from `org.apache.camel.support.PatternHelper#matchPattern`.
| ExcludeRoutes | | Pattern for filtering routes to be excluded as supervised. The pattern is matched on route id, and endpoint uri for the route. Multiple patterns can be separated by comma. For example, to exclude all JMS routes, you can say `jms:`. And to exclude routes with specific route ids `_mySpecialRoute,myOtherSpecialRoute_`. The pattern supports wildcards and uses the matcher from `org.apache.camel.support.PatternHelper#matchPattern`.
| ThreadPoolSize | `1` | The number of threads used by the route controller scheduled thread pool that are used for restarting routes. The pool uses 1 thread by default, but you can increase this to allow the controller to concurrently attempt to restart multiple routes in case more than one route has problems starting.
| UnhealthyOnExhausted | `true` | Whether to mark the route as unhealthy (down) when all restarting attempts (backoff) have failed and the route is not successfully started and the route manager is giving up. If setting this to `false` will make health checks ignore this problem and allow to report the Camel application as UP.
| UnhealthyOnRestarting | `true` | Whether to mark the route as unhealthy (down) when the route failed to initially start, and is being controlled for restarting (backoff). If setting this to false will make health checks ignore this problem and allow reporting the Camel application as UP.
|=======================================================================

IMPORTANT: The `UnhealthyOnExhausted` and `UnhealthyOnRestarting` options are default `false` in Camel 4.6 or older.

=== Filtering routes to fail fast

When using supervising route controller, then all routes would by default be supervised
and allow Camel to start up successfully; even if one or more routes failed to start up.
This is because the supervising will handle those failed routes and attempt to restart
them in the background (with backoff).

You may have a critical route which must always start up, and if not, cause Camel itself to fail starting.
This can be done by filtering the route from the supervising with the include/exclude options.

Given the routes below:

[source,java]
----
from("file:foo/cake")
  to("log:cake");

from("salesforce:cheese")
  to("log:cheese");

from("aws-s3:foo")
  .to("log:foo")

----

Then suppose we should fail fast if any AWS route fails to startup. This can be done
by excluding by pattern `aws*` (uri or route id)

[source,java]
-----
camel.routecontroller.excludeRoutes = aws*
-----

== JMX management

The route controllers are manageable in JMX, where you can find their MBean under the `services` node.

NOTE: To use JMX with Camel then `camel-management` JAR must be included in the classpath.

== More Information

When Apache Camel is shutting down, then its xref:graceful-shutdown.adoc[Graceful Shutdown]
that handles this to ensure all the routes are shutdown graceful and safely.
= RoutePolicy

A route policy `org.apache.camel.spi.RoutePolicy` is used to control
route(s) at runtime. For example, you can use it to determine whether a
route should be running or not. However, the policies can support any
kind of use cases.

== How it works

You associate a route with a given `RoutePolicy` and then during
runtime Camel will invoke callbacks on this policy where you can
implement your custom logic. Camel provides a support class that is a
good base class to extend `org.apache.camel.support.RoutePolicySupport`.

There are these callbacks invoked:

* `onInit`
* `onRemove`
* `onStart`
* `onStop`
* `onSuspend`
* `onResume`
* `onExchangeBegin`
* `onExchangeDone`

See the Javadoc of the `org.apache.camel.spi.RoutePolicy` for more
details; and also the implementation of the
`org.apache.camel.throttling.ThrottlingInflightRoutePolicy` for a concrete
example.

Camel provides the following policies out of the box:

* `org.apache.camel.throttling.ThrottlingInflightRoutePolicy` - a throttling
based policy that automatically suspends/resumes route(s) based on metrics
from the current in flight exchanges. You can use this to dynamically
 throttle, e.g. a xref:components::jms-component.adoc[JMS] consumer, to avoid it consuming too
fast.

* `org.apache.camel.throttling.ThrottlingExceptionRoutePolicy` - a throttling
based policy modeled after the circuit breaker. This policy will stop consuming
from an endpoint based on the type of exceptions that are thrown and the threshold setting.

Camel also provides an ability to schedule routes to
be activated, deactivated, suspended and/or resumed at certain times
during the day using a
xref:scheduledroutepolicy.adoc[ScheduledRoutePolicy] (offered via the
xref:components::quartz-component.adoc[Quartz] component).

== SuspendableService

If you want to dynamic suspend/resume routes, then it is advised to
use `SuspendableService` as it allows for fine-grained
suspend and resume operations.

== `ThrottlingInflightRoutePolicy`

The *`ThrottlingInflightRoutePolicy`* is triggered when an
xref:exchange.adoc[Exchange] is complete, which means that it requires
at least one xref:exchange.adoc[Exchange] to be complete before it
_works_.

The throttling in flight route policy has the following options:

[width="100%",cols="10%,10%,80%",options="header",]
|===

|Option |Default |Description

|`scope` |`Route` |A scope for either `Route` or `Context` which defines if the current
number of in flight exchanges is context based or for that particular
route.

|`maxInflightExchanges` |`1000` |The maximum threshold when the throttling will start to suspend the
route if the current number of in flight exchanges is higher than this
value.

|`resumePercentOfMax` |`70` |A percentage `0..100` which defines when the throttling should resume
again in case it has been suspended.

|`loggingLevel` |`INFO` |The logging level used for logging the throttling activity.

|`logger` |`ThrottlingInflightRoutePolicy` |The logger category.
|===

=== ThrottlingInflightRoutePolicy compared to the Throttler EIP

The `ThrottlingInflightRoutePolicy` compared to
xref:components:eips:throttle-eip.adoc[Throttler] EIP is that it does *not* block during
throttling. Its throttling is approximate-based, meaning that
its coarser grained and not explicitly precise as the
xref:components:eips:throttle-eip.adoc[Throttler] EIP.

The xref:components:eips:throttle-eip.adoc[Throttler] EIP can
be much more accurate and only allow a specific number of messages being
passed per a given time unit. Also, the `ThrottlingInflightRoutePolicy`
is based its metrics on number of in flight exchanges whereas
xref:components:eips:throttle-eip.adoc[Throttler] EIP is based on number o
messages per time unit.

== ScheduledRoutePolicy

See xref:scheduledroutepolicy.adoc[Scheduled Route Policy] for scheduling based route policy.

== Using route policies in Camel routes

You configure the route policy as follows from Java DSL, using the
`routePolicy` method:

[source,java]
-----------------------------------------------------------
RoutePolicy myPolicy = new MyRoutePolicy();

from("seda:foo").routePolicy(myPolicy).to("mock:result");
-----------------------------------------------------------

In Spring XML you configure using the `routePolictRef` attribute on `<route>` as shown:

[source,xml]
---------------------------------------------------------
<bean id="myPolicy" class="com.mycompany.MyRoutePolicy"/>
   
<route routePolicyRef="myPolicy">
    <from uri="seda:foo"/>
    <to uri="mock:result"/>
</route>
---------------------------------------------------------

You can configure one or more route policies (separated by comma), such as:

[source,java]
----
from("seda:foo").routePolicy(myPolicy, myOtherPolicy).to("mock:result");
----

And in XML:

[source,xml]
---------------------------------------------------------
<route routePolicyRef="myPolicy,myOtherPolicy">
    <from uri="seda:foo"/>
    <to uri="mock:result"/>
</route>
---------------------------------------------------------

== Using RoutePolicyFactory

If you want to use a route policy for every route, you can use
a `org.apache.camel.spi.RoutePolicyFactory` as a factory for creating
a `RoutePolicy` instance for each route. This can be used when you
want to use the same kind of route policy for all or some routes.

With the factory, you only need to configure this once, and every route created will
have the policy assigned.

There is API on `CamelContext` to add a factory, as shown below

[source,java]
----------------------------------------------------------
context.addRoutePolicyFactory(new MyRoutePolicyFactory());
----------------------------------------------------------

And from XML DSL you just define a `<bean>` with the factory, and Camel will automatically detect this factory:

[source,xml]
----------------------------------------------------------------------
<bean id="myRoutePolicyFactory" class="com.foo.MyRoutePolicyFactory"/>
----------------------------------------------------------------------

You can have as many route policy factories as you want, so if you have two factories,
you can add them both as shown:

[source,java]
----------------------------------------------------------
context.addRoutePolicyFactory(new MyRoutePolicyFactory());
context.addRoutePolicyFactory(new MyOtherRoutePolicyFactory());
----------------------------------------------------------

And in XML:

[source,xml]
----------------------------------------------------------------------
<bean id="myRoutePolicyFactory" class="com.foo.MyRoutePolicyFactory"/>
<bean id="myOtherRoutePolicyFactory" class="com.foo.MyOtherRoutePolicyFactory"/>
----------------------------------------------------------------------
= Route Reload

The route reload functionality in Camel is capable of watching a directory folder
for file changes, and then automatic trigger reload of the running routes in the Camel application.

This functionality is intended for development purposes and not for production use.

NOTE: This feature is not supported when using Camel Quarkus, as you should be using
the hot-reloading functionality that comes with Quarkus instead. This functionality
can also reload Java source code changes and much more.

== Using route reloading

You cannot watch for file changes in the Java classpath. It is only possible to watch
for file changes in the file system (i.e., using `file` and not `classpath`).

The route reloading can be configured in Java or with Spring Boot, Quarkus in the following way:

[source,java]
----
CamelContext context = ...

RouteWatcherReloadStrategy reload = new RouteWatcherReloadStrategy();
reload.setFolder("myfolder/routes");
reload.setPattern("*.xml");

context.addService(reload);
----

And with Camel Quarkus / Camel Main you can configure this in `application.properties:`

[source,properties]
----
# turn on route reloading on file changes
camel.main.routes-reload-enabled = true
# the base directory to watch
camel.main.routes-reload-directory = myfolder/routes
# pattern(s) for files to watch
camel.main.routes-reload-pattern = *.xml
----

And in Spring Boot:

[source,properties]
----
# turn on route reloading on file changes
camel.springboot.routes-reload-enabled = true
# the base directory to watch
camel.springboot.routes-reload-directory = myfolder/routes
# pattern(s) for files to watch
camel.springboot.routes-reload-pattern = *.xml
----

=== Route Reload Options

You can configure the `RouteWatcherReloadStrategy` using the following options:

[width="100%",cols="2,5,^1,2",options="header"]
|=======================================================================
| Name | Description | Default | Type
| `routesReloadDirectory` | Directory to scan for route changes. Camel cannot scan the classpath, so this must be configured to a file directory. Development with Maven as build tool, you can configure the directory to be `src/main/resources` to scan for Camel routes in XML or YAML files. | `src/main/resources/camel` | String
| `routesReloadDirectoryRecursive` | Whether the directory to scan should include subdirectories. Depending on the number of sub-directories, then this can cause the JVM to start up slower as Camel uses the JDK file-watch service to scan for file changes. | `false` | boolean
| `routesReloadEnabled` | Used for enabling automatic routes reloading. If enabled, then Camel will watch for file changes in the given reload directory, and trigger reloading routes if files are changed. | `false` | boolean
| `routesReloadPattern` | Used for inclusive filtering of routes from directories. Typical used for specifying to accept routes in XML or YAML files. The default pattern is \*.yaml,*.xml Multiple patterns can be specified separated by comma. | `\*.yaml,*.xml`  | String
| `routesReloadRemoveAllRoutes` | When reloading routes should all existing routes be stopped and removed. By default, Camel will stop and remove all existing routes before reloading routes. This ensures that only the reloaded routes will be active. If disabled, then only routes with the same route id are updated, and any existing routes are continued to run. | `true` | boolean
|=======================================================================


=== Must use route id's

When using route reload, then it is recommended to assign id's to your routes, so Camel
knows exactly which routes have been updated.
This is necessary because Apache Camel must stop the existing routes from running before they can be updated.

And adding new routes is therefore possible as they would have a new unique route id specified.

== See Also

See related xref:context-reload.adoc[].

See the following examples that come with live reloading enabled:

- https://github.com/apache/camel-examples/tree/main/main-xml[camel-examples/examples/main-xml]
- https://github.com/apache/camel-examples/tree/main/main-yaml[camel-examples/examples/main-yaml]
= Route Template

A Route template is as its name implies a template for a route, which is used
to create routes from a set of input parameters. In other words,
route templates are parameterized routes.

_Route template_ + _input parameters_ => _route_

From a route template, you can create one or more routes.

== Defining route templates in the DSL

Route templates are to be defined in the DSL (just like routes) as shown in the following:

[source,java]
----
public class MyRouteTemplates extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        // create a route template with the given name
        routeTemplate("myTemplate")
            // here we define the required input parameters (can have default values)
            .templateParameter("name")
            .templateParameter("greeting")
            .templateParameter("myPeriod", "3s")
            // here comes the route in the template
            // notice how we use {{name}} to refer to the template parameters
            // we can also use {{propertyName}} to refer to property placeholders
            .from("timer:{{name}}?period={{myPeriod}}")
                .setBody(simple("{{greeting}} ${body}"))
                .log("${body}");
    }
}
----

And in Spring XML DSL

[source,xml]
----
<camelContext>
  <routeTemplate id="myTemplate">
    <templateParameter name="name"/>
    <templateParameter name="greeting"/>
    <templateParameter name="myPeriod" defaultValue="3s"/>
    <route>
      <from uri="timer:{{name}}?period={{myPeriod}}"/>
      <setBody><simple>{{greeting}} ${body}</simple></setBody>
      <log message="${body}"/>
    </route>
  </routeTemplate>
</camelContext>
----

And in XML DSL

[source,xml]
----
<routeTemplates xmlns="http://camel.apache.org/schema/spring">
    <routeTemplate id="myTemplate">
        <templateParameter name="name"/>
        <templateParameter name="greeting"/>
        <templateParameter name="myPeriod" defaultValue="3s"/>
        <route>
            <from uri="timer:{{name}}?period={{myPeriod}}"/>
            <setBody><simple>{{greeting}} ${body}</simple></setBody>
            <log message="${body}"/>
        </route>
    </routeTemplate>
</routeTemplates>
----

In the examples above, there was one route template, but you can define as many as you want.
Each template must have a unique id. The template parameters are used for defining the parameters
the template accepts. As you can see, there are three parameters: `_name_`, `_greeting_`, and `_myPeriod_`. The first two
parameters are mandatory, whereas `_myPeriod_` is optional as it has a default value of 3s.

The template parameters are then used in the route as regular property placeholders with the `{{ }}` syntax.
Notice how we use `{\{name}}` and `{\{greeting}}` in the timer endpoint and the simple language.

The route can, of course, use regular property placeholders as well.
Now imagine there was a property placeholder with the name greeting:

[source,properties]
----
greeting = Davs
----

Then Camel would normally have used this value `Davs` when creating the route. However, as the route template
has defined a template parameter with the same name `greeting` then a value must be provided when
creating routes from the template.

Template parameters take precedence over regular property placeholders.

== Creating a route from a route template

To create routes from route templates, then you should use `org.apache.camel.builder.TemplatedRouteBuilder`.

In the following code snippet, you can see how this is done with the builder:

[source,java]
----
// create two routes from the template
TemplatedRouteBuilder.builder(context, "myTemplate")
    .parameter("name", "one")
    .parameter("greeting", "Hello")
    .add();

TemplatedRouteBuilder.builder(context, "myTemplate")
    .parameter("name", "two")
    .parameter("greeting", "Bonjour")
    .parameter("myPeriod", "5s")
    .add();
----

And in Java DSL:

[source,java]
----
templatedRoute("myTemplate")
        .parameter("name", "one")
        .parameter("greeting", "Hello");
templatedRoute("myTemplate")
        .parameter("name", "two")
        .parameter("greeting", "Bonjour")
        .parameter("myPeriod", "5s");
----

And in Spring XML DSL:

[source,xml]
----
<camelContext>
  <templatedRoute routeTemplateRef="myTemplate">
    <parameter name="name" value="one"/>
    <parameter name="greeting" value="Hello"/>
  </templatedRoute>
  <templatedRoute routeTemplateRef="myTemplate">
    <parameter name="name" value="two"/>
    <parameter name="greeting" value="Bonjour"/>
    <parameter name="myPeriod" value="5s"/>
  </templatedRoute>
</camelContext>
----

And in XML DSL:

[source,xml]
----
<templatedRoutes xmlns="http://camel.apache.org/schema/spring">
  <templatedRoute routeTemplateRef="myTemplate">
    <parameter name="name" value="one"/>
    <parameter name="greeting" value="Hello"/>
  </templatedRoute>
  <templatedRoute routeTemplateRef="myTemplate">
    <parameter name="name" value="two"/>
    <parameter name="greeting" value="Bonjour"/>
    <parameter name="myPeriod" value="5s"/>
  </templatedRoute>
</templatedRoutes>
----

And in YAML DSL:

[source,yaml]
----
- templated-route:
    route-template-ref: "myTemplate"
    parameters:
      - name: "name"
        value: "one"
      - name: "greeting"
        value: "Hello"
- templated-route:
    route-template-ref: "myTemplate"
    parameters:
      - name: "name"
        value: "two"
      - name: "greeting"
        value: "Bonjour"
      - name: "myPeriod"
        value: "5s"
----

The returned value from `add` is the route id of the new route that was added.
However `null` is returned if the route is not yet created and added, which can happen if `CamelContext` is
not started yet.

If no route id is provided, then Camel will auto assign a route id. In the example above then Camel would
assign route ids such as `route1`, `route2` to these routes.

If you want to specify a route id, then use `routeId` as follows, where the id is set to myCoolRoute:

[source,java]
----
TemplatedRouteBuilder.builder(context, "myTemplate")
    .routeId("myCoolRoute")
    .parameter("name", "one")
    .parameter("greeting", "hello")
    .parameter("myPeriod", "5s")
    .add();
----

And in Java DSL:

[source,java]
----
templatedRoute("myTemplate")
        .routeId("myCoolRoute")
        .parameter("name", "one")
        .parameter("greeting", "hello")
        .parameter("myPeriod", "5s");
----

And in Spring XML DSL:

[source,xml]
----
<camelContext>
  <templatedRoute routeTemplateRef="myTemplate" routeId="myCoolRoute">
    <parameter name="name" value="one"/>
    <parameter name="greeting" value="hello"/>
    <parameter name="myPeriod" value="5s"/>
  </templatedRoute>
</camelContext>
----

And in XML DSL:

[source,xml]
----
<templatedRoutes xmlns="http://camel.apache.org/schema/spring">
  <templatedRoute routeTemplateRef="myTemplate" routeId="myCoolRoute">
    <parameter name="name" value="one"/>
    <parameter name="greeting" value="hello"/>
    <parameter name="myPeriod" value="5s"/>
  </templatedRoute>
</templatedRoutes>
----

And in YAML DSL:

[source,yaml]
----
- templated-route:
    route-template-ref: "myTemplate"
    route-id: "myCoolRoute"
    parameters:
      - name: "name"
        value: "one"
      - name: "greeting"
        value: "hello"
      - name: "myPeriod"
        value: "5s"
----

=== Using template parameters with Java DSL simple builder

When using Java DSL and simple language, then beware that you should
not use the _simple fluent builder_ when defining the simple expressions/predicates.

For example, given the following route template in Java DSL:

[source,java]
----
public class MyRouteTemplates extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        routeTemplate("myTemplate")
            .templateParameter("name")
            .templateParameter("color")
            .from("direct:{{name}}")
                .choice()
                    .when(simple("{{color}}").isEqualTo("red"))
                        .to("direct:red")
                    .otherwise()
                        .to("color:other")
                .end();
    }
}
----

Then notice how the simple predicate is using _simple fluent builder_ `simple("{\{color}}").isEqualTo("red")`.
This is **not supported** with route templates and would not work when creating multiple routes from the template.

Instead, the simple expression should be a literal String value _only_ as follows:
----
    .when(simple("'{{color}}' == 'red'")
----

=== Using hardcoded node IDs in route templates

If route templates contain hardcoded node IDs, then routes created from templates will use the same IDs.
Therefore, if two or more routes are created from the same template, you will have _duplicate id detected_ error.

Given the route template below, then it has hardcoded ID (`_new-order_`) in node calling the http services.

[source,java]
----
public class MyRouteTemplates extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        routeTemplate("orderTemplate")
            .templateParameter("queue")
            .from("jms:{{queue}}")
                .to("http:orderserver.acme.com/neworder").id("new-order")
                .log("Processing order");
    }
}
----

When creating routes from templates, you can then provide a _prefix_ which is used for all node IDs.
This allows to create 2 or more routes without _duplicate id_ errors.

For example in the following, we create a new route `_myCoolRoute_` from the `_myTemplate_` template, and
use a prefix of `_web_`.

And in Java DSL

[source,java]
----
templatedRoute("orderTemplate")
        .routeId("webOrder")
        .prefixId("web")
        .parameter("queue", "order.web");
----

Then we can create a 2nd route:

[source,java]
----
templatedRoute("orderTemplate")
        .routeId("ftpOrder")
        .prefixId("ftp")
        .parameter("queue", "order.ftp");
----

And in Spring XML DSL:

[source,xml]
----
<camelContext>
  <templatedRoute routeTemplateRef="orderTemplate" routeId="webOrder" prefixId="web">
    <parameter name="queue" value="web"/>
  </templatedRoute>
</camelContext>
----

And in XML DSL:

[source,xml]
----
<templatedRoutes xmlns="http://camel.apache.org/schema/spring">
  <templatedRoute routeTemplateRef="orderTemplate" routeId="webOrder" prefixId="web">
    <parameter name="queue" value="web"/>
  </templatedRoute>
</templatedRoutes>
----

And in YAML DSL:

[source,yaml]
----
- templated-route:
    route-template-ref: "orderTemplate"
    route-id: "webOrder"
    prefix-id: "web"
    parameters:
      - name: "queue"
        value: "web"
----

== Binding beans to route template

The route template allows binding beans that are locally scoped and only used as part of creating routes from the template.
This allows using the same template to create multiple routes, where beans are local (private) for each created route.

For example, given the following route template where we use `templateBean` to set up the local bean as shown:

[source,java]
----
routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .templateBean("myClient", S3Client.class, rtc ->
            S3Client.builder().region(rtc.getProperty("region", Region.class)).build();
    )
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")
----

The template has two parameters to specify the AWS region and the S3 bucket. To connect to S3
then a `software.amazon.awssdk.services.s3.S3Client` bean is necessary.

To create this bean, we specify this with the `templateBean` DSL where we specify the bean id as `myClient`.
The type of the bean can be specified (`S3Client.class`), however, it is optional
(can be used if you need to let beans be discovered by type and not by name).

This ensures that the code creating the bean is executed later (when Camel is creating a route from the template),
then the code must be specified as a _supplier_. Because we want during creation of the bean access to template parameters,
we use a Camel `BeanSupplier` which gives access to `RouteTemplateContext` that is the `_rtc_` variable in the code above.

IMPORTANT: The local bean with id `myClient` *must* be referred to using Camel's property placeholder syntax, eg `{\{myClient}}`
in the route template, as shown above with the _to_ endpoint. This is because the local
bean must be made unique and Camel will internally re-assign the bean id to use a unique id instead of `myClient`. And this is done with the help
of the property placeholder functionality.

If multiple routes are created from this template, then each of the created routes have their own
`S3Client` bean created.

=== Binding beans to route templates from template builder

The `TemplatedRouteBuilder` also allows to bind local beans (which allows specifying those beans) when
creating routes from existing templates.

Suppose the route template below is defined in XML:
[source,xml]
----
<camelContext>
  <routeTemplate id="s3template">
    <templateParameter name="region"/>
    <templateParameter name="bucket"/>
    <route>
      <from uri="direct:s3-store"/>
      <to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/>
    </route>
  </routeTemplate>
</camelContext>
----

The template has no bean bindings for `#{\{myClient}}` which would be required for creating the template.

When creating routes form the template via `TemplatedRouteBuilder` then you can provide the bean binding
if you desire the bean to be locally scoped (not shared with others):

[source,java]
----
TemplatedRouteBuilder.builder(context, "s3template")
    .parameter("region", "US-EAST-1")
    .parameter("bucket", "myBucket")
    .bean("myClient", S3Client.class,
                S3Client.builder()
                    .region(rtc.getProperty("region", Region.class))
                    .build())
    .routeId("mys3route")
    .add();
----

As you can see the binding is similar to when using `templateBean` directly in the route template.

And in Java DSL:

[source,java]
----
templatedRoute("s3template")
        .parameter("region", "US-EAST-1")
        .parameter("bucket", "myBucket")
        .bean("myClient", S3Client.class,
                rtc -> S3Client.builder() // <1>
                    .region(rtc.getProperty("region", Region.class))
                    .build())
        .routeId("mys3route");
----
<1> Note that the third parameter of the `bean` method is not directly the bean but rather a factory method that will be used to create the bean, here we use a lambda expression as factory method.

And in XML DSL:

[source,xml]
----
  <templatedRoute routeTemplateRef="s3template" routeId="mys3route">
    <parameter name="region" value="US-EAST-1"/>
    <parameter name="bucket" value="myBucket"/>
    <bean name="myClient" type="software.amazon.awssdk.services.s3.S3Client"
          scriptLanguage="groovy"> <!--1-->
        <script>
            import software.amazon.awssdk.services.s3.S3Client
            S3Client.builder()
                .region(rtc.getProperty("region", Region.class))
                .build()
        </script>
    </bean>
  </templatedRoute>
----
<1> For non-Java DSL, in case of a complex bean factory, you can still rely on a language like `groovy` to define your bean factory inside a `script` element.

And in YAML DSL:

[source,yaml]
----
- templated-route:
    route-template-ref: "s3template"
    route-id: "mys3route"
    parameters:
      - name: "region"
        value: "US-EAST-1"
      - name: "bucket"
        value: "myBucket"
    beans:
      - name: "myClient"
        type: "software.amazon.awssdk.services.s3.S3Client"
        scriptLanguage: "groovy"
        script: | # <1>
            import software.amazon.awssdk.services.s3.S3Client
            S3Client.builder()
                .region(rtc.getProperty("region", Region.class))
                .build()
----
<1> For non-Java DSL, in case of a complex bean factory, you can still rely on a language like `groovy` to define your bean factory as value of the `script` key.

Instead of binding the beans from the template builder, you could also create the bean outside the template,
and bind it by reference.

[source,java]
----

final S3Client myClient = S3Client.builder().region(Region.US_EAST_1).build();

TemplatedRouteBuilder.builder(context, "s3template")
    .parameter("region", Region.US_EAST_1)
    .parameter("bucket", "myBucket")
    .bean("myClient", myClient)
    .routeId("mys3route")
    .add();
----

And in Java DSL:

[source,java]
----
templatedRoute("s3template")
        .parameter("region", "US-EAST-1")
        .parameter("bucket", "myBucket")
        .bean("myClient", S3Client.class, rtc -> myClient)
        .routeId("mys3route");
----

You should prefer to create the local beans directly from within the template (if possible) because this
ensures the route template has this out of the box. Otherwise, the bean must be created or provided every time
a new route is created from the route template. However, the latter gives freedom to create the bean in any other custom way.

=== Binding beans to route templates using bean types

You can create a local bean by referring to a fully qualified class name which Camel will use to create
a new local bean instance. When using this, the created bean is created via default constructor of the class.

The bean instance can be configured with properties via getter/setter style.
The previous example with creating the AWS S3Client would not support this kind as this uses _fluent builder_ pattern (not getter/setter).

TIP: In *Camel 4.6* onwards, you can also use constructor arguments for beans

So suppose we have a class as follows:

[source,java]
----
public class MyBar {
    private String name;
    private String address;

    // getter/setter omitted

    public String location() {
        return "The bar " + name + " is located at " + address;
    }
}
----

Then we can use the `MyBar` class as a local bean in a route template as follows:

[source,java]
----
routeTemplate("barTemplate")
    .templateParameter("bar")
    .templateParameter("street")
    .templateBean("myBar")
        .typeClass("com.foo.MyBar")
        .property("name", "{{bar}}")
        .property("address", "{{street}}")
    .end()
    .from("direct:going-out")
    .to("bean:{{myBar}}")
----

With Java DSL, you can also refer to the bean class using type safe way:

[source,java]
----
.templateBean("myBar")
    .typeClass(MyBar.class)
    .property("name", "{{bar}}")
    .property("address", "{{street}}")
.end()
----

In XML DSL you would do:

[source,xml]
----
<camelContext xmlns="http://camel.apache.org/schema/spring">
    <routeTemplate id="myBar">
        <templateParameter name="bar"/>
        <templateParameter name="street"/>
        <templateBean name="myBean" type="#class:com.foo.MyBar">
            <properties>
                <property key="name" value="{{bar}}"/>
                <property key="address" value="{{street}}"/>
            </properties>
        </templateBean>
        <route>
            <from uri="direct:going-out"/>
            <to uri="bean:{{myBar}}"/>
        </route>
    </routeTemplate>
</camelContext>
----

=== Binding beans to route templates using scripting languages

You can use scripting languages like groovy, java, mvel to create the bean.
This allows defining route templates with the scripting language built-in (such as groovy).

For example, creating the AWS S3 client can be done as shown in Java (with inlined groovy code):

[source,java]
----
routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .templateBean("myClient", "groovy",
            "software.amazon.awssdk.services.s3.S3Client.S3Client.builder()
            .region(rtc.getProperty("region", Region.class))
            .build()"
    )
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")
----

The groovy code can be externalized into a file on the classpath or file system, by using `resource:` as prefix, such as:

[source,java]
----
routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .templateBean("myClient", "groovy", "resource:classpath:s3bean.groovy")
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")
----

Then create the file `s3bean.groovy` in the classpath root:

[source,groovy]
----
import software.amazon.awssdk.services.s3.S3Client
S3Client.builder()
    .region(rtc.getProperty("region", Region.class))
    .build()
----

The route template in XML DSL can then also use groovy language to create the bean as follows:

[source,xml]
----
<camelContext>
  <routeTemplate id="s3template">
    <templateParameter name="region"/>
    <templateParameter name="bucket"/>
    <templateBean name="myClient" type="groovy">
        <script>
            import software.amazon.awssdk.services.s3.S3Client
            S3Client.builder()
                .region(rtc.getProperty("region", Region.class))
                .build()
        </script>
    </templateBean>
    <route>
      <from uri="direct:s3-store"/>
      <to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/>
    </route>
  </routeTemplate>
</camelContext>
----

Notice how the groovy code can be inlined directly in the route template in XML also. Of course, you can also externalize
the bean creation code to an external file, by using `resource:` as prefix:

[source,xml]
----
<camelContext>
  <routeTemplate id="s3template">
    <templateParameter name="region"/>
    <templateParameter name="bucket"/>
    <templateBean name="myClient" type="groovy">
        <script>resource:classpath:s3bean.groovy</script>
    </templateBean>
    <route>
      <from uri="direct:s3-store"/>
      <to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/>
    </route>
  </routeTemplate>
</camelContext>
----

The languages supported are:

[width="100%",cols="2s,8",options="header"]
|===
| Type | Description
| bean | Calling a method on a Java class to create the bean.
| groovy | Using a groovy script to create the bean.
| java | Java code which is runtime compiled (using jOOR library) to create the bean.
| mvel | To use a Mvel template script to create the bean.
| ognl | To use OGNL template script to create the bean.
| _name_ | To use a third-party language by the given `_name_` to create the bean.
|===

Camel will bind `RouteTemplateContext` as the root object with name `rtc` when evaluating the script.
This means you can get access to all the information from `RouteTemplateContext` and `CamelContext` via `rtc`.

This is what we have done in the scripts in the previous examples where we get hold of a template parameter with:

[source,groovy]
----
    rtc.getProperty('region', String.class)
----

To get access to `CamelContext` you can do:

[source,groovy]
----
    var cn = rtc.getCamelContext().getName()
----

The most powerful languages to use are groovy and java. The other languages are limited in flexibility
as they are not complete programming languages, but are more suited for templating needs.

It is recommended to either use groovy or java, if creating the local bean requires coding,
and the route templates are not defined using Java code.

The bean language can be used when creating the local bean from an existing Java method (static or not-static method),
and the route templates are not defined using Java code.

For example suppose there is a class named `com.foo.MyAwsHelper` that has a method called `createS3Client`
then you can call this method from the route template in XML DSL:

[source,xml]
----
<camelContext>
  <routeTemplate id="s3template">
    <templateParameter name="region"/>
    <templateParameter name="bucket"/>
    <templateBean name="myClient" type="bean">
        <script>com.foo.MyAwsHelper?method=createS3Client</script>
    </templateBean>
    <route>
      <from uri="direct:s3-store"/>
      <to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/>
    </route>
  </routeTemplate>
</camelContext>
----

The method signature of createS3Client must then have one parameter for the `RouteTemplateContext` as shown:

[source,java]
----
public static S3Client createS3Client(RouteTemplateContext rtc) {
    return S3Client.builder()
        .region(rtc.getProperty("region", Region.class))
        .build();
}
----

If you are using pure Java code (both template and creating local bean),
then you can create the local bean using Java lambda style as previously documented.

==== Configuring the type of the created bean

The `type` must be set to define what FQN class the created bean.

[source,xml]
----
<camelContext>
  <routeTemplate id="s3template">
    <templateParameter name="region"/>
    <templateParameter name="bucket"/>
    <templateBean name="myClient" scriptLanguage="bean" type="software.amazon.awssdk.services.s3.S3Client">
        <script>com.foo.MyAwsHelper?method=createS3Client</script>
    </templateBean>
    <route>
      <from uri="direct:s3-store"/>
      <to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/>
    </route>
  </routeTemplate>
</camelContext>
----

And in Java DSL you can do:

[source,java]
----
routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .templateBean("myClient", S3Client.class, "bean", "com.foo.MyAwsHelper?method=createS3Client")
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")
----

== Configuring route templates when creating route

There may be some special situations where you want to be able to do some custom configuration/code when
a route is about to be created from a route template. To support this you can use the `configure` in the route template DSL
where you can specify the code to execute as show:

[source,java]
----
routeTemplate("myTemplate")
    .templateParameter("myTopic")
    .configure((RouteTemplateContext rtc) ->
        // do some custom code here
    )
    .from("direct:to-topic")
    .to("kafka:{{myTopic}}");
----

== JMX management

The route templates can be dumped as XML from the `ManagedCamelContextMBean` MBean via the `dumpRouteTemplatesAsXml` operation.

== Creating routes from a properties file

When using `camel-main` you can specify the parameters for route templates in `application.properties` file.

For example, given the route template below (from a `RouteBuilder` class):

[source,java]
----
routeTemplate("mytemplate")
    .templateParameter("input")
    .templateParameter("result")
    .from("direct:{{input}}")
        .to("mock:{{result}}");
----

Then we can create two routes from this template by configuring the values in the `application.properties` file:

[source,properties]
----
camel.route-template[0].template-id=mytemplate
camel.route-template[0].input=foo
camel.route-template[0].result=cheese

camel.route-template[1].template-id=mytemplate
camel.route-template[1].input=bar
camel.route-template[1].result=cheese
----

== Creating routes from custom sources of template parameters

The SPI interface `org.apache.camel.spi.RouteTemplateParameterSource` can be used to implement custom sources that
are used during startup of Camel to create routes via the templates with parameters from the custom source(s).

For example, a custom source can be implemented to read parameters from a shared database that Camel uses during startup
to create routes.
This allows externalizing these parameters and as well to easily add more routes with varying parameters.

To let Camel discover custom sources, then register the source into the Camel registry.

== See Also

See the example https://github.com/apache/camel-examples/tree/main/routetemplate[camel-examples/examples/routetemplate/].
= Routes

In Apache Camel, a _route_ is a set of processing steps that are applied to a message as it travels from a source to a destination. A route typically consists of a series of processing steps that are connected in a linear sequence.

A Camel _route_ is where the integration flow is defined. For example, you can write a Camel route to specify how two systems can be integrated. You can also specify how the data can be manipulated, routed, or mediated between the systems.

The routes are typically defined using a simple, declarative syntax that is easy to read and understand.

For instance, you could write a _route_ to consume files from an FTP server and send them to an http://activemq.apache.org[ActiveMQ] messaging system. A _route_ to do so, using xref:java-dsl.adoc[Java DSL], would look like this:

[source,java]
----
from("ftp:myserver/folder")
  .to("activemq:queue:cheese");
----

Camel _routes_ can be defined using a variety of xref:dsl.adoc[domain-specific languages (DSLs)], such as Java, Spring XML, or YAML. For example, you could write the _route_ described above using XML:

[source,xml]
----
<route>
  <from uri="ftp:myserver/folder"/>
  <to uri="activemq:queue:cheese"/>
</route>
----


== Writing Routes in Java using the Java DSL

You can create a route using the Java language by extending the xref:manual::route-builder.adoc[`RouteBuilder` class], and implementing the `configure` method.

Here's an example:

[source,java]
------------------------------------------------------
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
        from("direct:a").to("direct:b");
    }
};
------------------------------------------------------

As you can see from the code snippet above, Camel uses xref:manual::uris.adoc[URIs] to wire endpoints together.

We refer to this way of writing route as using the xref:manual::java-dsl.adoc[Java DSL].

== Route Precondition

The routes can be included or not according to the result of a test. You can express the condition for the tests using the simple language. Camel evaluates this condition only once during the initialization phase.

Here's an example that includes the route only if the parameter `format` has been set to `xml`:

[source,java]
----
from("direct:in").precondition("'{{format}}' == 'xml'")
   .unmarshal().jaxb()
   .to("direct:out");
----

You can write the same route described above using the xref:components:others:java-xml-io-dsl.adoc[XML DSL]:

[source,xml]
----
<route precondition="'{{format}}' == 'xml'">
  <from uri="direct:in"/>
  <unmarshal><jaxb/></unmarshal>
  <to uri="direct:out"/>
</route>
----

You can also write the same route described above using the xref:components:others:yaml-dsl.adoc[YAML DSL]:

[source,yaml]
----
- route:
    precondition: "'{{format}}' == 'xml'"
    from:
      uri: "direct:in"
      steps:
        - unmarshal:
            jaxb: {}
        - to: "direct:out"
----

== More Information

Check the xref:dsl.adoc[list of supported languages] that you can use for writing Camel routes.
= ScheduledRoutePolicy

A scheduled xref:route-policy.adoc[Route Policy]
`org.apache.camel.routepolicy.quartz.ScheduledRoutePolicy` is an
extensible abstract policy that is used to provide Camel routes
scheduling capabilities at runtime.

Scheduling of routes typically involves the following capabilities:

* _Route activation_ - Starting a route a given start time if the route is
in a stopped state awaiting activation.
* _Route de-activation_ - Shutting down an otherwise active and started
route at a given time.
* _Route suspension_ - Simply de-activating the route consumer endpoint
URI declared on the `from(...)` section of the route from listening on a
given port. The route is still considered as started, however, clients
will not be able to send requests along the route.
* _Route resumption_ - Resuming the listener on a formerly suspended route
consumer endpoint URI. This route is ready to accept requests following
route resumption and client requests will be accepted by the route
consumer to be forwarded along the route.

Camel offers two such concrete policies that offer scheduled route policy
support:

* xref:simplescheduledroutepolicy.adoc[SimpleScheduledRoutePolicy] - An
ability to offer route scheduling services using a Simple xref:components::quartz-component.adoc[Quartz] trigger.
* xref:cronscheduledroutepolicy.adoc[CronScheduledRoutePolicy] - An
ability to offer route scheduling services using a Cron based xref:components::quartz-component.adoc[Quartz]
trigger.

== More Information

See xref:route-policy.adoc[Route Policy]= Security

Camel offers several forms and levels of security capabilities that can be
used on Camel routes. These various forms of security may be used in
conjunction with each other or separately.

The broad categories offered are:

* _Route Security_ - Authentication and Authorization services to proceed
on a route or route segment
* _Payload Security_ - Data Formats that offer encryption/decryption
services at the payload level
* _Endpoint Security_ - Security offered by components that can be
utilized by endpointUri associated with the component
* _Configuration Security_ - Security offered by encrypting sensitive
information from configuration files or external Secured Vault systems.

Camel offers the xref:camel-configuration-utilities.adoc[JSSE Utility]
for configuring SSL/TLS related aspects of a number of Camel components.

== Route Security

Authentication and Authorization Services

Camel offers xref:route-policy.adoc[Route Policy] driven security capabilities that may be wired into
routes or route segments. A route policy in Camel utilizes a strategy pattern
for applying interceptors on Camel Processors. It's offering the ability
to apply cross-cutting concerns (for example. security, transactions etc) of a Camel route.

The components offering authentication and authorization services
utilizing xref:route-policy.adoc[Route Policy] are:

* xref:components:others:shiro.adoc[Shiro Security]
* xref:components:others:spring-security.adoc[Spring Security]

== Payload Security

Camel offers encryption/decryption services to secure payloads or
selectively apply encryption/decryption capabilities on
portions/sections of a payload.

The dataformats offering encryption/decryption of payloads
utilizing xref:components:eips:marshal-eip.adoc[Marshal] are:

* xref:components:dataformats:crypto-dataformat.adoc[Crypto]
* xref:components:dataformats:pgp-dataformat.adoc[PGP]
* xref:components:dataformats:xmlSecurity-dataformat.adoc[XML security]

== Endpoint Security

Some components in Camel offer an ability to secure their endpoints
(using interceptors etc) and therefore ensure that they offer the
ability to secure payloads as well as provide
authentication/authorization capabilities at endpoints created using the
components.

== Configuration Security

Camel offers the xref:components::properties-component.adoc[Properties] component to
externalize configuration values to properties files. Those values could
contain sensitive information such as usernames and passwords.

Those values can be encrypted and automatically decrypted by Camel using:

* xref:components:others:jasypt.adoc[Jasypt]

Camel also supports accessing the secured configuration from an external vault systems.

=== Configuration Security using Vaults

The following _Vaults_ are supported by Camel:

* xref:components::aws-secrets-manager-component.adoc[AWS Secrets Manager]
* xref:components::google-secret-manager-component.adoc[Google Secret Manager]
* xref:components::azure-key-vault-component.adoc[Azure Key Vault]
* xref:components::hashicorp-vault-component.adoc[Hashicorp Vault]

==== Using AWS Vault

To use AWS Secrets Manager, you need to provide _accessKey_, _secretKey_ and the _region_.
This can be done using environmental variables before starting the application:

[source,bash]
----
export $CAMEL_VAULT_AWS_ACCESS_KEY=accessKey
export $CAMEL_VAULT_AWS_SECRET_KEY=secretKey
export $CAMEL_VAULT_AWS_REGION=region
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.aws.accessKey = accessKey
camel.vault.aws.secretKey = secretKey
camel.vault.aws.region = region
----

If you want instead to use the https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/credentials.html[AWS default credentials provider], you'll need to provide the following env variables:

[source,bash]
----
export $CAMEL_VAULT_AWS_USE_DEFAULT_CREDENTIALS_PROVIDER=true
export $CAMEL_VAULT_AWS_REGION=region
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.aws.defaultCredentialsProvider = true
camel.vault.aws.region = region
----

It is also possible to specify a particular profile name for accessing AWS Secrets Manager

[source,bash]
----
export $CAMEL_VAULT_AWS_USE_PROFILE_CREDENTIALS_PROVIDER=true
export $CAMEL_VAULT_AWS_PROFILE_NAME=test-account
export $CAMEL_VAULT_AWS_REGION=region
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.aws.profileCredentialsProvider = true
camel.vault.aws.profileName = test-account
camel.vault.aws.region = region
----

At this point you'll be able to reference a property in the following way by using `aws:` as prefix in the `{{ }}` syntax:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{aws:route}}"/>
    </route>
</camelContext>
----

Where `route` will be the name of the secret stored in the AWS Secrets Manager Service.

You could specify a default value in case the secret is not present on AWS Secret Manager:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{aws:route:default}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist, the property will fallback to "default" as value.

Also, you are able to get a particular field of the secret, if you have, for example, a secret named database of this form:

[source,json]
----
{
  "username": "admin",
  "password": "password123",
  "engine": "postgres",
  "host": "127.0.0.1",
  "port": "3128",
  "dbname": "db"
}
----

You're able to do get single secret value in your route, like for example:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{aws:database#username}}"/>
    </route>
</camelContext>
----

Or re-use the property as part of an endpoint.

You could specify a default value in case the particular field of secret is not present on AWS Secret Manager:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{aws:database#username:admin}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist or the secret exists, but the username field is not part of the secret, the property will fall back to "admin" as value.

NOTE: For the moment we are not considering the rotation function if any are applied, but it is in the work to be done.

The only requirement is adding `camel-aws-secrets-manager` JAR to your Camel application.

==== Using GCP Vault

To use GCP Secret Manager, you need to provide _serviceAccountKey_ file and GCP _projectId_.
This can be done using environmental variables before starting the application:

[source,bash]
----
export $CAMEL_VAULT_GCP_SERVICE_ACCOUNT_KEY=file:////path/to/service.accountkey
export $CAMEL_VAULT_GCP_PROJECT_ID=projectId
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.gcp.serviceAccountKey = accessKey
camel.vault.gcp.projectId = secretKey
----

If you want instead to use the https://cloud.google.com/docs/authentication/production[GCP default client instance], you'll need to provide the following env variables:

[source,bash]
----
export $CAMEL_VAULT_GCP_USE_DEFAULT_INSTANCE=true
export $CAMEL_VAULT_GCP_PROJECT_ID=projectId
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.gcp.useDefaultInstance = true
camel.vault.aws.projectId = region
----

At this point you'll be able to reference a property in the following way by using `gcp:` as prefix in the `{{ }}` syntax:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{gcp:route}}"/>
    </route>
</camelContext>
----

Where `route` will be the name of the secret stored in the GCP Secret Manager Service.

You could specify a default value in case the secret is not present on GCP Secret Manager:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{gcp:route:default}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist, the property will fallback to "default" as value.

Also, you are able to get a particular field of the secret, if you have, for example, a secret named database of this form:

[source,json]
----
{
  "username": "admin",
  "password": "password123",
  "engine": "postgres",
  "host": "127.0.0.1",
  "port": "3128",
  "dbname": "db"
}
----

You're able to do get single secret value in your route, like for example:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{gcp:database#username}}"/>
    </route>
</camelContext>
----

Or re-use the property as part of an endpoint.

You could specify a default value in case the particular field of secret is not present on GCP Secret Manager:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{gcp:database#username:admin}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist or the secret exists, but the username field is not part of the secret, the property will fallback to "admin" as value.

NOTE: For the moment we are not considering the rotation function if any are applied, but it is in the work to be done.

There are only two requirements: 
- Adding `camel-google-secret-manager` JAR to your Camel application.
- Give the service account used permissions to do operation at secret management level (for example accessing the secret payload, or being admin of secret manager service)

==== Using Azure Key Vault

To use this function, you'll need to provide credentials to Azure Key Vault Service as environment variables:

[source,bash]
----
export $CAMEL_VAULT_AZURE_TENANT_ID=tenantId
export $CAMEL_VAULT_AZURE_CLIENT_ID=clientId
export $CAMEL_VAULT_AZURE_CLIENT_SECRET=clientSecret
export $CAMEL_VAULT_AZURE_VAULT_NAME=vaultName
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.azure.tenantId = accessKey
camel.vault.azure.clientId = clientId
camel.vault.azure.clientSecret = clientSecret
camel.vault.azure.vaultName = vaultName
----

Or you can enable the usage of Azure Identity in the following way:

[source,bash]
----
export $CAMEL_VAULT_AZURE_IDENTITY_ENABLED=true
export $CAMEL_VAULT_AZURE_VAULT_NAME=vaultName
----

You can also enable the usage of Azure Identity in the `application.properties` file such as:

[source,properties]
----
camel.vault.azure.azureIdentityEnabled = true
camel.vault.azure.vaultName = vaultName
----

At this point, you'll be able to reference a property in the following way:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{azure:route}}"/>
    </route>
</camelContext>
----

Where route will be the name of the secret stored in the Azure Key Vault Service.

You could specify a default value in case the secret is not present on Azure Key Vault Service:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{azure:route:default}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist, the property will fallback to "default" as value.

Also you are able to get a particular field of the secret if you have, for example, a secret named database of this form:

[source,bash]
----
{
  "username": "admin",
  "password": "password123",
  "engine": "postgres",
  "host": "127.0.0.1",
  "port": "3128",
  "dbname": "db"
}
----

You're able to do get single secret value in your route, like for example:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{azure:database#username}}"/>
    </route>
</camelContext>
----

Or re-use the property as part of an endpoint.

You could specify a default value in case the particular field of secret is not present on Azure Key Vault:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{azure:database#username:admin}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist or the secret exists, but the username field is not part of the secret, the property will fallback to "admin" as value.

For the moment we are not considering the rotation function if any are applied, but it is in the work to be done.

The only requirement is adding the camel-azure-key-vault jar to your Camel application.

==== Using Hashicorp Vault

To use this function, you'll need to provide credentials for Hashicorp vault as environment variables:

[source,bash]
----
export $CAMEL_VAULT_HASHICORP_TOKEN=token
export $CAMEL_VAULT_HASHICORP_HOST=host
export $CAMEL_VAULT_HASHICORP_PORT=port
export $CAMEL_VAULT_HASHICORP_SCHEME=http/https
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.hashicorp.token = token
camel.vault.hashicorp.host = host
camel.vault.hashicorp.port = port
camel.vault.hashicorp.scheme = scheme
----

In case the running Hashicorp Vault instance you're pointing is running on Hashicorp Cloud, the configuration will require two additional parameters:

[source,bash]
----
export CAMEL_VAULT_HASHICORP_TOKEN=token
export CAMEL_VAULT_HASHICORP_HOST=host
export CAMEL_VAULT_HASHICORP_PORT=port
export CAMEL_VAULT_HASHICORP_SCHEME=http/https
export CAMEL_HASHICORP_VAULT_CLOUD=true
export CAMEL_HASHICORP_VAULT_NAMESPACE=namespace
----

You can also set the same in the `application.properties` file such as:

[source,properties]
----
camel.vault.hashicorp.token = token
camel.vault.hashicorp.host = host
camel.vault.hashicorp.port = port
camel.vault.hashicorp.scheme = scheme
camel.vault.hashicorp.cloud = true
camel.vault.hashicorp.namespace = namespace
----

At this point, you'll be able to reference a property in the following way:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{hashicorp:secret:route}}"/>
    </route>
</camelContext>
----

Where route will be the name of the secret stored in the Hashicorp Vault instance, in the 'secret' engine.

You could specify a default value in case the secret is not present on Hashicorp Vault instance:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{hashicorp:secret:route:default}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist in the 'secret' engine, the property will fall back to "default" as value.

Also, you are able to get a particular field of the secret, if you have, for example, a secret named database of this form:

[source,bash]
----
{
  "username": "admin",
  "password": "password123",
  "engine": "postgres",
  "host": "127.0.0.1",
  "port": "3128",
  "dbname": "db"
}
----

You're able to do get single secret value in your route, in the 'secret' engine, like, for example:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{hashicorp:secret:database#username}}"/>
    </route>
</camelContext>
----

Or re-use the property as part of an endpoint.

You could specify a default value in case the particular field of secret is not present on Hashicorp Vault instance, in the 'secret' engine:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{hashicorp:secret:database#username:admin}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist or the secret exists (in the 'secret' engine) but the username field is not part of the secret, the property will fall back to "admin" as value.

There is also the syntax to get a particular version of the secret for both the approach, with field/default value specified or only with secret:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{hashicorp:secret:route@2}}"/>
    </route>
</camelContext>
----

This approach will return the RAW route secret with version '2', in the 'secret' engine.

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{hashicorp:route:default@2}}"/>
    </route>
</camelContext>
----

This approach will return the route secret value with version '2' or default value in case the secret doesn't exist or the version doesn't exist (in the 'secret' engine).

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{hashicorp:secret:database#username:admin@2}}"/>
    </route>
</camelContext>
----

This approach will return the username field of the database secret with version '2' or admin in case the secret doesn't exist or the version doesn't exist (in the 'secret' engine).

==== Using IBM Secrets Manager Vault

To use this function, you'll need to provide credentials for IBM Secrets Manager vault as environment variables:

[source,bash]
----
export CAMEL_VAULT_IBM_TOKEN=token
export CAMEL_VAULT_IBM_SERVICE_URL=serviceUrl
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.ibm.token = token
camel.vault.ibm.serviceUrl = serviceUrl
----

NOTE: if you're running the application on a Kubernetes based cloud platform, you can initialize the environment variables from a Secret or Configmap to enhance security. You can also enhance security by xref:manual::using-propertyplaceholder.adoc#_resolving_property_placeholders_on_cloud[setting a Secret property placeholder] which will be initialized at application runtime only.

NOTE: `camel.vault.ibm` configuration only applies to the IBM Secrets Manager Vault properties function (E.g when resolving properties).
When using the `operation` option to create, get, list secrets etc., you should provide the `token` and `serviceUrl` options.

At this point, you'll be able to reference a property in the following way:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{ibm:default:route}}"/>
    </route>
</camelContext>
----

Where route will be the name of the secret stored in the IBM Secrets Manager Vault instance, in the 'default' secret group.

You could specify a default value in case the secret is not present on IBM Secrets Manager Vault instance:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{ibm:default:route:default}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist in the 'default' secret group, the property will fall back to "default" as value.

Also, you are able to get a particular field of the secret, if you have, for example, a secret named database of this form:

[source,bash]
----
{
  "username": "admin",
  "password": "password123",
  "engine": "postgres",
  "host": "127.0.0.1",
  "port": "3128",
  "dbname": "db"
}
----

You're able to do get single secret value in your route, in the 'default' secret group, like for example:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{ibm:default:database#username}}"/>
    </route>
</camelContext>
----

Or re-use the property as part of an endpoint.

You could specify a default value in case the particular field of secret is not present on IBM Secrets Manager Vault instance, in the 'secret' engine:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{ibm:default:database#username:admin}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist or the secret exists (in the 'default' secret group) but the username field is not part of the secret, the property will fall back to "admin" as value.

There is also the syntax to get a particular version of the secret for both the approaches, with field/default value specified or only with secret:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{ibm:default:route@2}}"/>
    </route>
</camelContext>
----

This approach will return the RAW route secret with version '2', in the 'default' secret group.

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{ibm:default:route:default@2}}"/>
    </route>
</camelContext>
----

This approach will return the route secret value with version '2' or default value in case the secret doesn't exist or the version doesn't exist (in the 'default' secret group).

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{ibm:default:database#username:admin@2}}"/>
    </route>
</camelContext>
----

This approach will return the username field of the database secret with version '2' or admin in case the secret doesn't exist or the version doesn't exist (in the 'default' secret group).

The only requirement is adding the camel-ibm-secrets-manager jar to your Camel application.

==== Automatic Camel context reloading on Secret Refresh while using AWS Secrets Manager

Being able to reload Camel context on a Secret Refresh, could be done by specifying the usual credentials (the same used for AWS Secret Manager Property Function).

With Environment variables:

[source,bash]
----
export $CAMEL_VAULT_AWS_USE_DEFAULT_CREDENTIALS_PROVIDER=accessKey
export $CAMEL_VAULT_AWS_REGION=region
----

or as plain Camel main properties:

[source,properties]
----
camel.vault.aws.useDefaultCredentialProvider = true
camel.vault.aws.region = region
----

Or by specifying accessKey/SecretKey and region, instead of using the default credentials provider chain.

To enable the automatic refresh, you'll need additional properties to set:

[source,properties]
----
camel.vault.aws.refreshEnabled=true
camel.vault.aws.refreshPeriod=60000
camel.vault.aws.secrets=Secret
camel.main.context-reload-enabled = true
----

where `camel.vault.aws.refreshEnabled` will enable the automatic context reload, `camel.vault.aws.refreshPeriod` is the interval of time between two different checks for update events and `camel.vault.aws.secrets` is a regex representing the secrets we want to track for updates.

Note that `camel.vault.aws.secrets` is not mandatory: if not specified the task responsible for checking updates events will take into accounts or the properties with an `aws:` prefix.

The only requirement is adding the camel-aws-secrets-manager jar to your Camel application.

==== Automatic Camel context reloading on Secret Refresh while using AWS Secrets Manager with Eventbridge and AWS SQS Services

Another option is to use AWS EventBridge in conjunction with the AWS SQS service.

On the AWS side, the following resources need to be created:

- an AWS CloudTrail trail
- an AWS SQS Queue
- an EventBridge rule of the following kind

[source,json]
----
{
  "source": ["aws.secretsmanager"],
  "detail-type": ["AWS API Call via CloudTrail"],
  "detail": {
    "eventSource": ["secretsmanager.amazonaws.com"]
  }
}
----

This rule will make the event related to AWS Secrets Manager filtered

- You need to set the a Rule target to the AWS SQS Queue for Eventbridge rule

- You need to give permission to the Eventbrige rule, to write on the above SQS Queue. For doing this you'll need to define a json file like this:

[source,json]
----
{
    "Policy": "{\"Version\":\"2012-10-17\",\"Id\":\"<queue_arn>/SQSDefaultPolicy\",\"Statement\":[{\"Sid\": \"EventsToMyQueue\", \"Effect\": \"Allow\", \"Principal\": {\"Service\": \"events.amazonaws.com\"}, \"Action\": \"sqs:SendMessage\", \"Resource\": \"<queue_arn>\", \"Condition\": {\"ArnEquals\": {\"aws:SourceArn\": \"<eventbridge_rule_arn>\"}}}]}"
}
----

Change the values for queue_arn and eventbridge_rule_arn, save the file with policy.json name and run the following command with AWS CLI

[source,bash]
----
aws sqs set-queue-attributes --queue-url <queue_url> --attributes file://policy.json
----

where queue_url is the AWS SQS Queue URL of the just created Queue.

Now you should be able to set up the configuration on the Camel side. To enable the SQS notification, add the following properties:

[source,properties]
----
camel.vault.aws.refreshEnabled=true
camel.vault.aws.refreshPeriod=60000
camel.vault.aws.secrets=Secret
camel.main.context-reload-enabled = true
camel.vault.aws.useSqsNotification=true
camel.vault.aws.sqsQueueUrl=<queue_url>
----

where queue_url is the AWS SQS Queue URL of the just created Queue.

Whenever an event of PutSecretValue for the Secret named 'Secret' will happen, a message will be enqueued in the AWS SQS Queue and consumed on the Camel side and a context reload will be triggered.

==== Automatic Camel context reloading on Secret Refresh while using Google Secret Manager

Being able to reload Camel context on a Secret Refresh, could be done by specifying the usual credentials (the same used for Google Secret Manager Property Function).

With Environment variables:

[source,bash]
----
export $CAMEL_VAULT_GCP_USE_DEFAULT_INSTANCE=true
export $CAMEL_VAULT_GCP_PROJECT_ID=projectId
----

or as plain Camel main properties:

[source,properties]
----
camel.vault.gcp.useDefaultInstance = true
camel.vault.aws.projectId = projectId
----

Or by specifying a path to a service account key file, instead of using the default instance.

To enable the automatic refresh you'll need additional properties to set:

[source,properties]
----
camel.vault.gcp.projectId= projectId
camel.vault.gcp.refreshEnabled=true
camel.vault.gcp.refreshPeriod=60000
camel.vault.gcp.secrets=hello*
camel.vault.gcp.subscriptionName=subscriptionName
camel.main.context-reload-enabled = true
----

where `camel.vault.gcp.refreshEnabled` will enable the automatic context reload, `camel.vault.gcp.refreshPeriod` is the interval of time between two different checks for update events and `camel.vault.gcp.secrets` is a regex representing the secrets we want to track for updates.

Note that `camel.vault.gcp.secrets` is not mandatory: if not specified the task responsible for checking updates events will take into accounts or the properties with an `gcp:` prefix.

The `camel.vault.gcp.subscriptionName` is the subscription name created in relation to the Google PubSub topic associated with the tracked secrets.

This mechanism makes use of the notification system related to Google Secret Manager: through this feature, every secret could be associated with one up to ten Google Pubsub Topics. These topics will receive
events related to the life cycle of the secret.

There are only two requirements: 
- Adding `camel-google-secret-manager` JAR to your Camel application.
- Give the service account used permissions to do operation at secret management level (for example, accessing the secret payload, or being admin of secret manager service and also have permission over the Pubsub service)

==== Automatic Camel context reloading on Secret Refresh while using Azure Key Vault

Being able to reload Camel context on a Secret Refresh, could be done by specifying the usual credentials (the same used for Azure Key Vault Property Function).

With Environment variables:

[source,bash]
----
export $CAMEL_VAULT_AZURE_TENANT_ID=tenantId
export $CAMEL_VAULT_AZURE_CLIENT_ID=clientId
export $CAMEL_VAULT_AZURE_CLIENT_SECRET=clientSecret
export $CAMEL_VAULT_AZURE_VAULT_NAME=vaultName
----

or as plain Camel main properties:

[source,properties]
----
camel.vault.azure.tenantId = accessKey
camel.vault.azure.clientId = clientId
camel.vault.azure.clientSecret = clientSecret
camel.vault.azure.vaultName = vaultName
----

If you want to use Azure Identity with environment variables, you can do in the following way:

[source,bash]
----
export $CAMEL_VAULT_AZURE_IDENTITY_ENABLED=true
export $CAMEL_VAULT_AZURE_VAULT_NAME=vaultName
----

You can also enable the usage of Azure Identity in the `application.properties` file such as:

[source,properties]
----
camel.vault.azure.azureIdentityEnabled = true
camel.vault.azure.vaultName = vaultName
----

To enable the automatic refresh, you'll need additional properties to set:

[source,properties]
----
camel.vault.azure.refreshEnabled=true
camel.vault.azure.refreshPeriod=60000
camel.vault.azure.secrets=Secret
camel.vault.azure.eventhubConnectionString=eventhub_conn_string
camel.vault.azure.blobAccountName=blob_account_name
camel.vault.azure.blobContainerName=blob_container_name
camel.vault.azure.blobAccessKey=blob_access_key
camel.main.context-reload-enabled = true
----

where `camel.vault.azure.refreshEnabled` will enable the automatic context reload, `camel.vault.azure.refreshPeriod` is the interval of time between two different checks for update events and `camel.vault.azure.secrets` is a regex representing the secrets we want to track for updates.

where `camel.vault.azure.eventhubConnectionString` is the eventhub connection string to get notification from, `camel.vault.azure.blobAccountName`, `camel.vault.azure.blobContainerName` and `camel.vault.azure.blobAccessKey` are the Azure Storage Blob parameters for the checkpoint store needed by Azure Eventhub.

Note that `camel.vault.azure.secrets` is not mandatory: if not specified the task responsible for checking updates events will take into accounts or the properties with an `azure:` prefix.

The only requirement is adding the camel-azure-key-vault jar to your Camel application.

==== Automatic Camel context reloading on Secret Refresh while using IBM Secrets Manager

Being able to reload Camel context on a Secret Refresh could be done by specifying the IBM Event Streams credentials combined with the IBM Secrets Manager one (the same used for IBM Secrets Manager Property Function).

With Environment variables:

[source,bash]
----
export CAMEL_VAULT_IBM_TOKEN=token
export CAMEL_VAULT_IBM_SERVICE_URL=serviceUrl
export CAMEL_VAULT_IBM_EVENTSTREAM_BOOTSTRAP_SERVERS=bootstrapServers
export CAMEL_VAULT_IBM_EVENTSTREAM_TOPIC=topic
export CAMEL_VAULT_IBM_EVENTSTREAM_USERNAME=token
export CAMEL_VAULT_IBM_EVENTSTREAM_PASSWORD=password
export CAMEL_VAULT_IBM_EVENTSTREAM_CONSUMER_GROUP_ID=groupId
export CAMEL_VAULT_IBM_EVENTSTREAM_CONSUMER_POLL_TIMEOUT=3000
----

or as plain Camel main properties:

[source,properties]
----
camel.vault.ibm.token = token
camel.vault.ibm.serviceUrl = serviceUrl
camel.vault.ibm.eventStreamBootstrapServers = bootstrapServers
camel.vault.ibm.eventStreamTopic = topic
camel.vault.ibm.eventStreamUsername = token
camel.vault.ibm.eventStreamPassword = password
camel.vault.ibm.eventStreamGroupId = groupId
camel.vault.ibm.eventStreamConsumerPollTimeout=3000
----

To enable the automatic refresh, you'll need additional properties to set:

[source,properties]
----
camel.vault.ibm.refreshEnabled=true
camel.vault.ibm.secrets=Secret
camel.main.context-reload-enabled = true
----

where `camel.vault.ibm.refreshEnabled` will enable the automatic context reload and `camel.vault.ibm.secrets` is a regex representing the secrets we want to track for updates.

where `camel.vault.ibm.eventStreamBootstrapServers` is the comma-separated list of Bootstrap Servers for IBM Event Stream, `camel.vault.ibm.eventStreamTopic`, `camel.vault.ibm.eventStreamUsername`, `camel.vault.ibm.eventStreamPassword`, `camel.vault.ibm.eventStreamGroupId` and `camel.vault.ibm.eventStreamConsumerPollTimeout` are the IBM Event Stream parameters for connecting and consuming events related to Secrets.

Note that `camel.vault.ibm.secrets` is not mandatory: if not specified the task responsible for checking updates events will take into accounts or the properties with an `ibm:` prefix.

The only requirement is adding the camel-ibm-secrets-manager jar to your Camel application.
= Service Registry

Service registration is a key part of service discovery which Camel leverages through
the _Service Call EIP_ and support to ease the process to expose routes in a
cloud environment and consume them with minimal configuration.

== Service Registry Set-Up

A `ServiceRegistry` is just like any other camel service so set it up you only need
to register your implementations to the `CamelContext`:

[source,java]
----
ServiceRegistry service = new MyServiceRegistry();

context.addService(service);
----

The configuration of the _Service Registry_ depends on the implementation you have chosen.
Out of the box camel provides the following implementations:

[cols="1,1,2", options="header"]
|====
|Type         |Module             | Class
|consul       |camel-consul       | org.apache.camel.component.consul.cloud.ConsulServiceRegistry
|spring-cloud |camel-spring-cloud | org.apache.camel.component.spring.cloud.CamelSpringCloudServiceRegistry
|zookeeper    |camel-zookeeper    | org.apache.camel.component.zookeeper.cloud.ZooKeeperServiceRegistry
|====

== Service Registry Usage

The _Service Registry SPI_ is leveraged by the following new implementations:

=== ServiceRegistryRoutePolicy

This is an implementation of a xref:route-policy.adoc[Route Policy] that register/deregister routes
to a given `ServiceRegistry` according to route's life-cycle:

[source,java]
----
RoutePolicy policy = new ServiceRegistrationRoutePolicy()

// bind the policy to one or more routes
from("undertow:http://0.0.0.0:8080")
    .routePolicy(policy)
    .log("Route ${routeId} has been invoked");
----

To apply the same policy to all the routes a dedicated `RoutePolicyFactory` can be used:

[source,java]
----
// add the service registry route policy factory to context
context.addRoutePolicyFactory(new ServiceRegistrationRoutePolicyFactory()));
----

To configure how the service is exposed you can add route specific properties like:

[source,java]
----
// bind the policy to one or more routes
from("undertow:http://0.0.0.0:8080")
    .routePolicy(policy)
    .routeProperty(ServiceDefinition.SERVICE_META_NAME, "my-service")
    .routeProperty(ServiceDefinition.SERVICE_META_ID, "my-id")
    .routeProperty(ServiceDefinition.SERVICE_META_PORT, "8080")
    .log("Route ${routeId} has been invoked");
----

Service name and service id can also be provided by _routeId_ and _routeGroup_:

[source,java]
----
// bind the policy to one or more routes
from("undertow:http://0.0.0.0:8080")
    .routePolicy(policy)
    .routeGroup("my-service")
    .routeId("my-id")
    .routeProperty(ServiceDefinition.SERVICE_META_PORT, "8080")
    .log("Route ${routeId} has been invoked");
----

Any property prefixed with _service._ is automatically added to the service's metadata.

TIP: Some component such has camel-undertow and those based on camel-http-common implement _DiscoverableService_ and they can automatically provide the metadata needed for service registration.

=== Service Component

The xref:components::service-component.adoc[Service] component is similar to a `ServiceRegistrationRoutePolicyFactory`
but is capable of tagging routes that need to be registered to the `ServiceRegistry`
by prefixing the related endpoints with `service:name` according to the following syntax:

[source,text]
----
service:serviceName:delegateUri[?options]
----

Let's explain this with an example:

[source,java]
----
from("service:my-service:undertow:http://0.0.0.0:8080")
    .log("Route ${routeId} has been invoked");
----

To configure how the service is exposed you can add service specific endpoint options such as:

[source,java]
----
from("service:my-service:undertow:http://0.0.0.0:8080?service.id=my-service-id")
    .log("Route ${routeId} has been invoked");
----

Any option prefixed with _service._ is automatically added to the service's metadata.

= SimpleScheduledRoutePolicy

`SimpleScheduledRoutePolicy` is a xref:scheduledroutepolicy.adoc[ScheduledRoutePolicy]
that facilitates route activation, de-activation, suspension and resumption of routes
based on the xref:components::quartz-component.adoc[Quartz] simple trigger.


== How it works

In order to use a `SimpleScheduledRoutePolicy` it is necessary to
instantiate an object of the type
`org.apache.camel.routepolicy.quartz.SimpleScheduledRoutePolicy`.

NOTE: All Scheduled route policies share the scheduler created by the Quartz
component. In this way, scheduler, jobs and triggers can be managed in a
common and consistent way.

=== Configuration options

In order to perform a route operation at a given time the following
information must be provided.

* Starting a route

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter Name |Type |Default |Description
|routeStartDate |java.util.Date |  |the initial scheduled Date and time
for route start

|routeStartRepeatCount |int |  |no of times to repeat the job

|routeStartRepeatInterval |long |  |the time interval in milliseconds to
trigger the next attempt to start the route
|=======================================================================

* Stopping a route

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter Name |Type |Default |Description
|routeStopDate |java.util.Date |  |the initial scheduled Date and time
for route stop

|routeStopRepeatCount |int |  |no of times to repeat the job

|routeStopRepeatInterval |long |  |the time interval in milliseconds to
trigger the next attempt to stop the route

|routeStopGracePeriod |int |10 seconds |the time period to wait before
initiating graceful route stop

|routeStopTimeUnit |long |TimeUnit.MILLISECONDS |the time unit for the
grace period expressed as java.util.concurrent.TimeUnit
|=======================================================================

* Suspending a route

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter Name |Type |Default |Description
|routeSuspendDate |java.util.Date |  |the initial scheduled Date and
time for route suspension

|routeSuspendRepeatCount |int |  |no of times to repeat the job

|routeSuspendRepeatInterval |long |  |the time interval in milliseconds
to trigger the next attempt to suspend the route
|=======================================================================

* Resuming a route

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter Name |Type |Default |Description
|routeResumeDate |java.util.Date |  |the initial scheduled Date and time
for route start

|routeResumeRepeatCount |int |  |no of times to repeat the job

|routeResumeRepeatInterval |long |  |the time interval in milliseconds
to trigger the next attempt to resume the route
|=======================================================================

Once the
`org.apache.camel.routepolicy.quartz.SimpleScheduledRoutePolicy` is
created it can be wired into the camel route as follows.

== Using the SimpleScheduledRoutePolicy

The `SimpleScheduledRoutePolicy` can be used in Java DSL as show:

[source,java]
----
SimpleScheduledRoutePolicy policy = new SimpleScheduledRoutePolicy();
long startTime = System.currentTimeMillis() + 3000L;
policy.setRouteStartDate(new Date(startTime));
policy.setRouteStartRepeatCount(1);
policy.setRouteStartRepeatInterval(3000);
                
from("direct:start")
   .routeId("test")
   .routePolicy(policy)
   .to("mock:success");
----

And in Spring XML:

[source,xml]
----
<bean id="date" class="org.apache.camel.routepolicy.quartz.SimpleDate"/>

<bean id="startPolicy" class="org.apache.camel.routepolicy.quartz.SimpleScheduledRoutePolicy">
    <property name="routeStartDate" ref="date"/>
    <property name="routeStartRepeatCount" value="1"/>
    <property name="routeStartRepeatInterval" value="3000"/>      
</bean> 
    
<camelContext xmlns="http://camel.apache.org/schema/spring">
    <route id="myroute" routePolicyRef="startPolicy">
        <from uri="direct:start"/>
        <to uri="mock:success"/>
    </route>
</camelContext>
----

== Dependency

Maven users will need to add a `camel-quartz` dependency to their
`pom.xml` to avail this capability.

[source,xml]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-quartz</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----
= Spring XML

Using Camel with Spring XML files, is a classic way, of using XML DSL with Camel.
Camel has historically been using Spring XML for a long time.
The Spring framework started with XML files as a popular and common configuration for building Spring applications.

The following is an example of what it looks like:

[source,xml]
----
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
    ">

    <camelContext xmlns="http://camel.apache.org/schema/spring">
        <route>
            <from uri="direct:a"/>
            <choice>
                <when>
                    <xpath>$foo = 'bar'</xpath>
                    <to uri="direct:b"/>
                </when>
                <when>
                    <xpath>$foo = 'cheese'</xpath>
                    <to uri="direct:c"/>
                </when>
                <otherwise>
                    <to uri="direct:d"/>
                </otherwise>
            </choice>
        </route>
    </camelContext>

</beans>
----

== Using Spring XML

The following dependency needs to be added to your pom.xml so that Spring XML files can be scanned by Camel:

[source,xml]
--------------------------------------------------------------------------------------------------------------
 <dependency>
     <groupId>org.apache.camel.springboot</groupId>
     <artifactId>camel-spring-boot-xml-starter</artifactId>
 </dependency>
--------------------------------------------------------------------------------------------------------------

You can use Spring XML files to specify Camel routes using XML DSL as shown:

[source,xml]
--------------------------------------------------------------------------------------------------------------
<camelContext id="camel-A" xmlns="http://camel.apache.org/schema/spring">
  <route>
    <from uri="seda:start"/>
    <to uri="mock:result"/>
  </route>
</camelContext>
--------------------------------------------------------------------------------------------------------------

=== Configuring Components and Endpoints

You can configure your Component or xref:endpoint.adoc[Endpoint] instances in your Spring XML as follows in this example.

[source,xml]
--------------------------------------------------------------------------------------------------------------
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
</camelContext>

<bean id="activemq" class="org.apache.camel.component.activemq.ActiveMQComponent">
  <property name="connectionFactory">
    <bean class="org.apache.activemq.ActiveMQConnectionFactory">
      <property name="brokerURL" value="tcp:someserver:61616"/>
    </bean>
  </property>
</bean>
--------------------------------------------------------------------------------------------------------------

Which allows you to configure a component using any name, but its common to use the same name
eg (`activemq`). Then you can refer to the component using `activemq:destinationName`.

This works by the Camel lazily fetching components from the Spring context for the scheme name you use for Endpoint xref:uris.adoc[URI]s.

== Using Java DSL with Spring XML files

You can use Java Code to define your xref:route-builder.adoc[RouteBuilder] implementations. These can be defined as beans in spring and then referenced in your camel context e.g.

[source,xml]
--------------------------------------------------------------------------------------------------------------
<camelContext xmlns="http://camel.apache.org/schema/spring">
  <routeBuilder ref="myBuilder"/>
</camelContext>

<bean id="myBuilder" class="org.apache.camel.spring.example.test1.MyRouteBuilder"/>
--------------------------------------------------------------------------------------------------------------

=== Using package scanning

Camel also provides a powerful feature that allows for the automatic discovery and initialization of routes in given packages. This is configured by adding tags to the camel context in your spring context definition, specifying the packages to be recursively searched for RouteBuilder implementations. To use this feature in 1.X, requires a <package></package> tag specifying a comma separated list of packages that should be searched e.g.

[source,xml]
--------------------------------------------------------------------------------------------------------------
<camelContext>
  <packageScan>
    <package>com.foo</package>
    <excludes>**.*Excluded*</excludes>
    <includes>**.*</includes>
  </packageScan>
</camelContext>
--------------------------------------------------------------------------------------------------------------

This will scan for `RouteBuilder` classes in the _com.foo_ and sub-packages.

You can also filter the classes with includes or excludes such as:

[source,xml]
--------------------------------------------------------------------------------------------------------------
<camelContext>
  <packageScan>
    <package>com.foo</package>
    <excludes>**.*Special*</excludes>
  </packageScan>
</camelContext>
--------------------------------------------------------------------------------------------------------------

Which will skip classes that has _Special_ in the name.

Exclude patterns are applied before the include patterns. If no include or exclude patterns are defined then all the Route classes discovered in the packages will be returned.

`?` matches one character `\*` matches zero or more characters `**` matches zero or more segments of a fully qualified name

=== Using context scanning

You can allow Camel to scan the container context, e.g. the Spring ApplicationContext for route builder instances. This allow you to use the Spring *<component-scan>* feature and have Camel pickup any *`RouteBuilder`* instances which was created by Spring in its scan process.

[source,xml]
--------------------------------------------------------------------------------------------------------------
<!-- enable Spring @Component scan -->
<context:component-scan base-package="org.apache.camel.spring.issues.contextscan"/>

<camelContext xmlns="http://camel.apache.org/schema/spring">
    <!-- and then let Camel use those @Component scanned route builders -->
    <contextScan/>
</camelContext>
--------------------------------------------------------------------------------------------------------------

This allows you to just annotate your routes using the Spring *`@Component`*  and have those routes included by Camel:

[source,java]
--------------------------------------------------------------------------------------------------------------
@Component
public class MyRoute extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        from("direct:start")
            .to("mock:result");
    }
}
--------------------------------------------------------------------------------------------------------------

You can also use the ANT style for inclusion and exclusion, as mentioned above in the package scan section.

== Additional configuration of Spring XML

See more details at xref:advanced-configuration-of-camelcontext-using-spring.adoc[Camel Spring XML Auto Configuration].
= Spring

Apache Camel is designed to work first class with Spring in a number of ways, such as:

* Camel runs on Spring Boot with the Camel Spring Boot project
* Camel works with Spring XML files (classic Spring XML)
* Camel works with Spring dependency injection
* Camel works with Spring configuration and property placeholders
* Camel works with Spring transactions
* Camel works with Spring testing

== Using Camel on Spring Boot

See the Camel Spring Boot documentation.

== Using Camel with Spring XML files

Using Camel with Spring XML files, is a classic way, of using XML DSL with Camel.
Camel has historically been using Spring XML for a long time. The Spring framework
started with XML files as a popular and common configuration for building Spring applications.

To use Camel with Spring XML files see the xref:spring-xml-extensions.adoc[Spring XML] documentation.

== Using Spring dependency injection

Spring dependency injection is integrated first-class when using Spring and Spring together.

For example when using Camel on Spring Boot, then you can use any kind of Spring dependency and
be able to inject Camel resources such as 'CamelContext', xref:endpoint.adoc[Endpoint] and many more.

== Using Camel with Spring configuration and property placeholders

See xref:using-propertyplaceholder.adoc[Using Property Placeholder] documentation.

== Using Camel with Spring transactions

See xref:components:eips:transactional-client.adoc[Transactional Client] EIP.

== Using Camel with Spring testing

See xref:components:others:test-spring-junit5.adoc[camel-test-spring-junit5] documentation.

= Startup Condition

*Available as of Camel 4.9*

You can use `StartupCondition` to let Camel perform some checks on startup,
before continuing. For example to check if a specific ENV exists, or wait
for a specific file to be created etc.

Camel provides a few out of the box

- `EnvStartupCondition` - To check for a specific OS environment exists
- `FileStartupCondition` - To check for a specific file exists

You can implement custom conditions by implementing `org.apache.camel.spi.StartupCondition`,
and add these to the `StartupConditionStrategy` or `Registry` such as:

[source,java]
----
StartupConditionStrategy scs = context.getCamelContextExtension().getContextPlugin(StartupConditionStrategy.class);
scs.addStartupCondition(new MyCondition());
----

If you use Camel Main, Spring Boot, or Quarkus, you can configure startup conditions with configuration in `application.properties`.

For example to check for a specific OS environment variable exists:

[source,properties]
----
camel.startupcondition.enabled = true
camel.startupcondition.environmentVariableExists = FOO_BAR
----

Or to use a custom condition by its class name:

[source,properties]
----
camel.startupcondition.enabled = true
camel.startupcondition.customClassNames = com.foo.MyStartupCondition
----

= Stream caching

While stream types (like `StreamSource`, `InputStream` and `Reader`) are commonly used in messaging for performance reasons, they also have an important drawback: they can only be read once. In order to be able to work with message content multiple times, the stream needs to be cached.

Streams are cached in memory. However, for large stream messages, you can set `spoolEnabled=true`
and then large message (over 128 KB) will be cached in a temporary file instead.
Camel itself will handle deleting the temporary file once the cached stream is no longer necessary.

[IMPORTANT]
====
*StreamCache - Affecting the message payload*

The `StreamCache` will affect your payload object as it will replace the `Stream` payload with a `org.apache.camel.StreamCache` object.
This `StreamCache` is capable of being re-readable and thus possible to better be routed within Camel using redelivery
or xref:components:eips:choice-eip.adoc[Content Based Router] or the likes.
====

In order to determine if a message payload requires caching, then Camel uses
the xref:type-converter.adoc[Type Converter] functionality, to determine if
the message payload type can be converted into an `org.apache.camel.StreamCache` instance.

[IMPORTANT]
====
All the classes from the Camel release that implements `org.apache.camel.StreamCache` is NOT intended for end users
to create as instances, but they are part of Camels stream-caching functionality.
====

== Configuring Stream Caching

Stream caching is configured using `org.apache.camel.spi.StreamCachingStrategy`.

The strategy has the following options:

[width="100%",cols="20%,20%,60%",options="header"]
|=======================================================================
| Option | Default | Description

| enabled | true
| Whether stream caching is enabled

| allowClasses | | To filter stream caching of a given set of allowed/denied classes. By default, all classes that are `java.io.InputStream` is allowed. Multiple class names can be separated by comma.

| denyClasses | | To filter stream caching of a given set of allowed/denied classes. By default, all classes that are `java.io.InputStream` is allowed. Multiple class names can be separated by comma.

| spoolEnabled | false
| Whether spool to disk is enabled

| spoolDirectory | ${java.io.tmpdir}/camel/camel-tmp-\#uuid#
| Base directory where temporary files for spooled streams should be stored. This option supports naming patterns as documented below.

| spoolCipher | null
| If set, the temporary files are encrypted using the specified cipher transformation (i.e., a valid stream or 8-bit cipher name such as "RC4", "AES/CTR/NoPadding". An empty name "" is treated as null).

| spoolThreshold | 128 KB
| Size in bytes when the stream should be spooled to disk instead of keeping in memory. Use a value of 0 or negative to disable it all together so streams is always kept in memory regardless of their size.

| spoolUsedHeapMemoryThreshold | 0
| A percentage (1 to 99) of current used heap memory to use as threshold for spooling streams to disk. The upper bounds is based on heap committed (guaranteed memory the JVM can claim). This can be used to spool to disk when running low on memory.

| spoolUsedHeapMemoryLimit | Max
| If `spoolUsedHeapMemoryThreshold` is in use, then whether the used heap memory upper limit is either Max or Committed.

| anySpoolRules | false
| Whether any or all ``SpoolRule``s must return `true` to determine if the stream should be spooled or not. This can be used as applying AND/OR binary logic to all the rules. By default it's AND based.

| bufferSize | 4096
| Sets the buffer size to use when allocating in-memory buffers used for in-memory stream caches.

| removeSpoolDirectoryWhenStopping | true
| Whether to remove the spool directory when stopping xref:camelcontext.adoc[CamelContext].

| statisticsEnabled | false
| Whether utilization statistics is enabled. By enabling this you can see these statics for example with JMX.
|=======================================================================

=== SpoolDirectory naming pattern

The following patterns is supported:

* `\#uuid#` = a random UUID
* `\#camelId#` = the CamelContext id (e.g. the name)
* `\#name#` = same as `\#camelId#`
* `\#counter#` = an incrementing counter
* `\#bundleId#` = the OSGi bundle id (only for OSGi environments)
* `\#symbolicName#` = the OSGi symbolic name (only for OSGi environments)
* `\#version#` = the OSGi bundle version (only for OSGi environments)
* `${env:key}` = the environment variable with the key
* `$\{key}` = the JVM system property with the key

A couple of examples:

To store in the java temp directory with a sub directory using the `CamelContext` name:

[source,java]
----
context.getStreamCachingStrategy().setSpoolDirectory"${java.io.tmpdir}#name#/");
----

To store in `KARAF_HOME/tmp/bundleId` directory:

[source,java]
----
context.getStreamCachingStrategy().setSpoolDirectory"${env:KARAF_HOME}/tmp/bundle#bundleId#");
----

== Configuring StreamCachingStrategy in Java

You can configure the `StreamCachingStrategy` in Java as shown below:

[source,java]
----
context.getStreamCachingStrategy().setSpoolEnabled(true);
context.getStreamCachingStrategy().setSpoolDirectory("/tmp/cachedir");
context.getStreamCachingStrategy().setSpoolThreshold(64 * 1024);
context.getStreamCachingStrategy().setBufferSize(16 * 1024);
// to enable encryption using RC4
// context.getStreamCachingStrategy().setSpoolCipher("RC4");
----

And remember to enable Stream caching on the `CamelContext`:

[source,java]
----
context.setStreamCaching(true);
----

or on routes:

[source,java]
----
from("file:inbox")
  .streamCaching()
  .to("bean:foo");
----

== Configuring StreamCachingStrategy in XML

In XML you can enable stream caching on the `<camelContext>` and then do the configuration in the `streamCaching` element:

[source,xml]
----
<camelContext streamCache="true">

  <streamCaching id="myCacheConfig" bufferSize="16384" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolThreshold="65536"/>

  <route>
    <from uri="direct:c"/>
    <to uri="mock:c"/>
  </route>

</camelContext>
----

=== Using spoolUsedHeapMemoryThreshold

By default, stream caching will spool only big payloads (128 KB or bigger) to disk. However you can also set the `spoolUsedHeapMemoryThreshold` option which is a percentage of used heap memory. This can be used to also spool to disk when running low on memory.

For example with:

[source,xml]
----
<streamCaching id="myCacheConfig" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolUsedHeapMemoryThreshold="70"/>
----

Then notice that as `spoolThreshold` is default enabled with 128 KB, then we have both thresholds in use (`spoolThreshold` and `spoolUsedHeapMemoryThreshold`). And in this example then we only spool to disk if payload is > 128 KB and that used heap memory is > 70%. The reason is that we have the option `anySpoolRules` as default `false`. That means both rules must be `true` (e.g. AND).

If we want to spool to disk if either of the rules (e.g. OR), then we can do:

[source,xml]
----
<streamCaching id="myCacheConfig" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolUsedHeapMemoryThreshold="70" anySpoolRules="true"/>
----

If we only want to spool to disk if we run low on memory then we can set:

[source,xml]
----
<streamCaching id="myCacheConfig" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolThreshold="-1" spoolUsedHeapMemoryThreshold="70"/>
----

then we do not use the `spoolThreshold` rule, and only the heap memory based is in use.

By default, the upper limit of the used heap memory is based on the maximum heap size. Though you can also configure to use the committed heap size as the upper limit, this is done using the `spoolUsedHeapMemoryLimit` option as shown below:

[source,xml]
----
<streamCaching id="myCacheConfig" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolUsedHeapMemoryThreshold="70" spoolUsedHeapMemoryLimit="Committed"/>
----

== Using custom SpoolRule implementations

You can implement your custom rules to determine if the stream should be spooled to disk. This can be done by implementing the interface `org.apache.camel.spi.StreamCachingStrategy.SpoolRule` which has a single method:

[source,java]
----
boolean shouldSpoolCache(long length);
----

The `length` is the length of the stream.
To use the rule then add it to the `StreamCachingStrategy` as shown below:

[source,java]
----
SpoolRule mySpoolRule = ...
context.getStreamCachingStrategy().addSpoolRule(mySpoolRule);
----

And from XML you need to define a `<bean>` with your custom rule:

[source,xml]
----
<bean id="mySpoolRule" class="com.foo.MySpoolRule"/>

<streamCaching id="myCacheConfig" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolRules="mySpoolRule"/>
----

Using the spoolRules attribute on `<streamCaching>`. if you have more rules, then separate them by comma.

[source,xml]
----
<streamCaching id="myCacheConfig" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolRules="mySpoolRule,myOtherSpoolRule"/>
----

== Using StreamCachingProcessor

Since Camel 4.11 this processor can be used to convert the current message body to a `StreamCache`. This allows the body to be re-read multiple times and can be placed at any point in a Camel route.

[source, java]
----
from("direct:start")
    .process(new StreamCachingProcessor())
    .to("log:cached");
----
= Test Infrastructure

The components in the Camel Test Infra provide utilities to simplify testing with Camel and other systems may interact with it.

The test infra is divided in two parts:

* One that offers container provisioning features for all scopes
* Another that provides container provisioning features for tests.

== Simulating the Test Infrastructure

One of the first steps when implementing a new test is to identify how to simulate infrastructure required for it to
run. The test-infra module provides a reusable library of infrastructure that can be used for that purpose. 

In general, the integration test leverages the features provided by the project https://www.testcontainers.org/[TestContainers]
and uses container images to simulate the environments. Additionally, it may also support running the tests against remote 
environments as well as, when available, embeddable components. This varies by each component, and it is recommended to 
check the code for additional details.

=== Writing A New Test Infrastructure Module


[NOTE]
====
This section is aimed at Camel maintainers that need to write new test infra components. End users can skip this section.
====

The test code abstracts the provisioning of test environments behind service classes (i.e.: JMSService, JDBCService,
etc). The purpose of the service class is to abstract both the type service (i.e.: Kafka, Strimzi, etc.) and
the location of the service (i.e.: remote, local, embedded, etc). This provides flexibility to test the code under 
different circumstances (i.e.: using a remote JMS broker or using a local JMS broker running in a container managed by
TestContainers). It makes it easier to hit edge cases as well as try different operating scenarios (i.e.: higher
latency, slow backends, etc).

When a container image is not available via TestContainers, tests can provide their own implementation using officially
available images. The license must be compatible with Apache 2.0. If an official image is not available, a Dockerfile
to build the service can be provided. The Dockerfile should try to minimize the container size and resource usage
whenever possible.

The container information must reside in a file named `container.properties` which should contain the container fully qualified
name:

[source,properties]
----
opensearch.container=mirror.gcr.io/opensearchproject/opensearch:2.18.0
opensearch.container.ppc64le=icr.io/ppc64le-oss/opensearch-ppc64le:2.12.0
----

The keys must follow the pattern `<name>.properties`. Specific architectures can be added to the key to denote which container
to be used for each architecture. Currently accepted values are:

* `aarch64`: for Arm
* `s390x`: for s390x (Linux On Mainframe)
* `ppc64le`: for 64-bit little ending power

It is also possible to use embeddable components when required, although this usually leads to more code and higher
maintenance.

NOTE: support for embeddable components may be removed in future versions.

==== Recommended Structure for Test Infrastructure Modules

The actual Service interface and implementation should be added under `src/main`, while the actual integration with JUnit 
can be added to `src/test`, in this way the classes needed to run the service (most of them, with testcontainers) are decoupled
by JUnit and can be run separately.

===== Main Sources

The service should provide an interface, named after the infrastructure being implemented, and this interface should extend the 
https://github.com/apache/camel/blob/main/test-infra/camel-test-infra-common/src/main/java/org/apache/camel/test/infra/common/services/InfrastructureService.java[`InfrastructureService`]
interface.

Ideally, there should be two concrete implementations of the services: one of the remote service (if applicable) and
another for the container service: 

```
              MyService
                 / \
                /   \
               /     \
 MyRemoteService    MyContainerService
```
                     

In most cases, a specialized service factory class is responsible for creating the service according to runtime
parameters and/or other test scenarios constraints. When a service allows different service types or locations to be
selected, this should be done via command line properties (`-D<property.name>=<value>`). For example, when allowing a
service to choose between running as a local container or as remote instance, a property in the format
`<name>.instance.type` should be handled. Additional runtime parameters used in different scenarios, should be handled
as `<name>.<parameter>`. More complex services may use the builder available through the factory classes to compose 
the service accordingly.

===== Test Sources

Once the main sources are implemented, https://github.com/apache/camel/blob/main/test-infra/camel-test-infra-common/src/test/java/org/apache/camel/test/infra/common/services/TestService.java[TestService]
interface can be used to integrate the actual Service implementation with JUnit and its lifecycle.
The services should try to minimize the test execution time and resource usage when running. As such,
the https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/BeforeAllCallback.html[BeforeAllCallback]
and https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/AfterAllCallback.html[AfterAllCallback]
should be the preferred extensions whenever possible because they allow the instance of the infrastructure to be static
throughout the test execution.

[NOTE]
====
Bear in mind that, according to the https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/RegisterExtension.html[JUnit 5 extension]
model, the time of service initialization may differ depending on whether the service instance is declared as
static or not in the test class. As such, the code should make no assumptions as to its time of initialization.
====

==== Registering Properties

All services should register the properties, via `System.setProperty` that allow access to the services. This is required
 to resolve those properties when running tests using the Spring framework. This registration allows the properties
to be resolved in Spring's XML files. 

This registration is done in the `registerProperties` methods during the service initialization. 

==== Registering Properties Example:

Registering the properties in the concrete service implementation:

[source,java]
----
    public void registerProperties() {
        // MyServiceProperties.MY_SERVICE_HOST is a string with value "my.service.host"
        System.setProperty(MyServiceProperties.MY_SERVICE_HOST, container.getHost());
        
        // MyServiceProperties.MY_SERVICE_PORT is a string with value "my.service.port"
        System.setProperty(MyServiceProperties.MY_SERVICE_PORT, String.valueOf(container.getServicePort()));
        
        // MyServiceProperties.MY_SERVICE_ADDRESS is a string with value "my.service.address"
        System.setProperty(MyServiceProperties.MY_SERVICE_ADDRESS, getServiceAddress());
    }
    
    public void initialize() {
        LOG.info("Trying to start the MyService container");
        container.start();

        registerProperties();
        LOG.info("MyService instance running at {}", getServiceAddress());
    }
----

Then, when referring these properties in Camel routes or Spring XML properties, you may use `{{my.service.host}}`,
`{{my.service.port}}` and `{{my.service.address}}`.


==== Packaging Recommendations

This is infrastructure code for testing, therefore, it should be package as test type artifacts. The
https://github.com/apache/camel/blob/main/test-infra/camel-test-infra-parent[parent pom] should provide all the necessary bits for packaging the test infrastructure.

=== Using The Test Infrastructure in Tests

Using the test infra in a new component test is rather straightforward, similar to using any other reusable component.
You start by declaring the test infra dependencies in your pom file. 

This should be similar to:

[source,xml]
----
<!-- test infra -->
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-test-infra-myservice</artifactId>
    <version>${project.version}</version>
    <type>test-jar</type>
    <scope>test</scope>
</dependency>
----

[NOTE]
====
On the dependencies above, the dependency version is set to `${project.version}`. This should be adjusted to the
Camel version when used outside the Camel Core project.
====

On the test class, add a member variable for the service and annotate it with the https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/RegisterExtension.html[@RegisterExtension],
 to let JUnit 5 manage its lifecycle.

[source,java]
----
@RegisterExtension
static MyService service = MyServiceServiceFactory.createService();
----

More complex test services can be created using something similar to:

[source,java]
----
@RegisterExtension
static MyService service = MyServiceServiceFactory
    .builder()
        .addRemoveMapping(MyTestClass::myCustomRemoteService) // this is rarely necessary
        .addLocalMapping(MyTestClass::staticMethodReturningAService) // sets the handler for -Dmy-service.instance.type=local-myservice-local-container
        .addMapping("local-alternative-service", MyTestClass::anotherMethodReturningAService) // sets the handler for -Dmy-service.instance.type=local-alternative-service
    .createService();
----

You can use the methods as well as the registered properties to access the test infrastructure services available. 
When using these properties in Spring XML files, you may use those properties.

[source,xml]
----
<someSpringXmlElement httpHost="{{my.service.host}}" port="{{my.service.port}}" />
----

It's also possible to use these properties in the test code itself. For example, when setting up the test url for the
Camel component:

[source,java]
----
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() {
                from("direct:put")
                    .to("mycomponent:someoption?host={{my.service.host}}&port={{my.service.port}}");
            }
        };
    }
----

==== Execution Ordering

When combining the different modules of the test infra, you may need to ensure that they execute in the proper order. You can do so by using JUnit's `@Order` annotation.

For instance:

[source,java]
----
    @Order(1)
    @RegisterExtension
    protected static KafkaService service = KafkaServiceFactory.createSingletonService();

    @Order(2)
    @RegisterExtension
    protected static CamelContextExtension contextExtension = new DefaultCamelContextExtension();
----

== Container Runtime Support

Most of the test infrastructure in this module is based on containers.
Therefore, they will require a container runtime to run.
The tests have been written and tested using:

* Docker
* https://podman.io/[Podman]

=== Podman Support

Assuming Podman is properly installed and configured to behave like docker (i.e.: short name resolution, resolving docker.io registry, etc.), the only requirement for using Podman is to export the `DOCKER_HOST` variable before running the tests.

==== Linux

On most systems that should be similar to the following command: 

```
export DOCKER_HOST=unix:///run/user/$UID/podman/podman.sock
```

==== OS X and Windows

Running the test-infra with Podman on OS X and Windows should work on many cases. However, it requires additional steps and has a few issues. Therefore, it is not recommended at this time.

== Known Issues and/or Tips

=== Multi-architecture support

Some containers don't have images available for all architectures. In this case, it is recommended to:

1. use an alternative image from a reputable source if they provide an image for that architecture.
2. create a `Dockerfile` and build your own if the system is available on that arch.
3. disable the tests on that architecture.= Testing

Testing is a crucial activity in any piece of software development or
integration. Typically, Camel users would use various different
technologies wired together in a variety of EIPs with different
endpoints, languages, bean integration, and
dependency injection, so it's easy for things to go wrong!
Testing is the crucial weapon to ensure that things work as you would expect.

Camel is a Java library, so you can easily wire up tests in JUnit.
However, the Camel project has tried to make the testing of Camel as easy
and powerful as possible, so we have introduced the following features.

== Testing modules

The following modules are supported:

[width="100%",cols="1m,4",options="header",]
|=======================================================================
|Component |Description

|xref:components:others:test-junit5.adoc[camel-test-junit5] |*JUnit 5*: Is an older standalone Java
library letting you easily create Camel test cases using a single Java
class for all your configuration and routing without.
|xref:components:others:test-main-junit5.adoc[camel-test-main-junit5] | *JUnit 5*: Used for testing Camel in Camel Main mode

|xref:components:others:test-spring-junit5.adoc[camel-test-spring-junit5] | *JUnit 5*: Used for testing Camel with Spring / Spring Boot

|xref:test-infra.adoc[camel-test-infra] | *Camel Test Infra*: Camel Test Infra is a set of modules that leverage modern JUnit 5 features to abstract the provisioning and execution of test infrastructure. Among other things, it provides abstraction of the infrastructure (based on Test Containers - being the de-facto successor of the camel-testcontainers components) as well as JUnit 5 extensions for the Camel Context itself.

|=======================================================================

NOTE: If you are using Camel Quarkus, then you can find information in
its documentation how to do testing with Quarkus and Camel.

In all approaches, the test classes look pretty much the same in that
they all reuse the xref:bean-integration.adoc[Camel binding and
injection annotations].

TIP: For more details on the different testing modules, then see their respective documentation
from the links in the table above.

== Testing functionality

Camel provides a set of features that are common to use when writing unit or integration tests with Camel.

=== Testing endpoints

Camel provides a number of xref:endpoint.adoc[endpoints] which can make testing easier.

[width="100%",cols="1,3",options="header",]
|=======================================================================
|Name |Description
|xref:components::mock-component.adoc[Mock] |For testing routes and mediation rules using
mocks and allowing assertions to be added to an endpoint.

|xref:components::dataset-component.adoc[DataSet] |For load & soak testing, this endpoint
provides a way to create huge numbers of messages for sending to
components and asserting that they are consumed correctly.

|xref:components::dataset-test-component.adoc[DataSet Test] |Used to automatically load
a set of expected messages from another endpoint which is then compared to the messages
that arrive at this endpoint.

|=======================================================================

The main endpoint is the xref:components::mock-component.adoc[Mock] endpoint, which allows
expectations to be added to different endpoints; you can then run your
tests and assert that your expectations are met at the end.

=== Stubbing out physical transport technologies

If you wish to test out a route but want to avoid actually using real physical transport, then the following
endpoints can be useful:

NOTE: For example, to unit test a transformation route rather than performing a full integration test

[width="100%",cols="1,3",options="header",]
|=======================================================================
|Name |Description
|xref:components::direct-component.adoc[Direct] |Direct invocation of the consumer from the
producer so that single threaded (non-SEDA) in VM invocation is
performed which can be useful to mock out physical transports

|xref:components::seda-component.adoc[SEDA] |Deliver messages asynchronously to consumers via
a `BlockingQueue` which is good for testing asynchronous transports

|xref:components::stub-component.adoc[Stub] |Works like xref:components::stub-component.adoc[SEDA] but does not
validate the endpoint URI, which makes stubbing straightforward.
|=======================================================================

=== Testing existing routes

Camel provides some features to aid during testing of existing routes
where you cannot or will not use xref:components::mock-component.adoc[Mock] etc.
For example, you may have a production ready route which you want to test with some
third party API that sends messages into this route.

[width="100%",cols="1,3",options="header",]
|=======================================================================
|Name |Description
|xref:notify-builder.adoc[NotifyBuilder] |Allows you to be notified when
a certain condition has occurred. For example, when the route has
completed five messages. You can build complex expressions to match your
criteria when to be notified.

|xref:advice-with.adoc[AdviceWith] |Allows you to _advice_ (enhance)
an existing route using a xref:route-builder.adoc[RouteBuilder] style.
For example, you can send (or send and skip) a message to a xref:components::mock-component.adoc[Mock]
endpoint for validating the message send by Camel is as expected.
|=======================================================================

=== Third Party Testing libraries

There are a number of third party testing libraries that Camel users have found useful.

[width="100%",cols="1,3",options="header",]
|=======================================================================
|Name |Description
| https://citrusframework.org/[Citrus Integration Framework] | Framework for automated integration tests supporting a wide range of message protocols and data formats
| https://citrusframework.org/yaks/[Citrus Yaks] | YAKS is a framework to enable Cloud Native BDD testing on Kubernetes
|=======================================================================
= Threading Model

The threading model in Camel is based on a pluggable reactive routing engine,
and thread pools from the JDK concurrency API.

This page focuses on thread pools.
Camel leverages thread pools in several places such as:

* Several xref:components:eips:enterprise-integration-patterns.adoc[EIP] patterns support using thread pools for
concurrency
* xref:components::seda-component.adoc[SEDA] component for asynchronous connectivity
* xref:components:eips:threads-eip.adoc[Threads] EIP in Camel routes
* Some components use thread pools out of the box, such as
xref:components::jms-component.adoc[JMS] or xref:components::jetty-component.adoc[Jetty]

== Thread pool profiles

By default, when a thread pool is to be created by Camel, then the pool configuration
is based upon a profile, the _default thread pool profile_

The default profile is pre-configured out of the box with the following settings:

[width="100%",cols="25%,25%,50%",options="header",]
|===
| Option | Default | Description
| *poolSize* | `10` | Sets the default core pool size (threads to keep minimum in pool)
| *keepAliveTime* | `60` | Sets the default keep alive time (in seconds) for inactive threads
| *maxPoolSize* | `20` | Sets the default maximum pool size
| *maxQueueSize* | `1000` | Sets the default maximum number of tasks in the work queue. Use -1 for an unbounded queue.
| *allowCoreThreadTimeOut* | `true` | Sets default whether to allow core threads to timeout
| *rejectedPolicy* | `CallerRuns` | Sets the default handler for tasks which cannot be executed by the thread pool. Has four options:
`Abort, CallerRuns, Discard, DiscardOldest` which corresponds to the same four options provided out of the box in the JDK.
|===

What that means is that for example when you use
xref:components:eips:multicast-eip.adoc[Multicast] with `parallelProcessing=true` enabled,
then it would create a thread pool based on the profile above.

You can define as many thread pool profiles as you like. But there must
be only *one* default profile. A custom thread pool profile will inherit
from the default profile. Which means that any option you do not
explicit define will fallback and use the option from the default
profile.

=== Configuring default thread pool profile

In Spring XML you can configure thread pool profile with `threadPoolProfile` as shown:

[source,xml]
----
<threadPoolProfile id="defaultThreadPoolProfile"
    defaultProfile="true"
    poolSize="5"
    maxPoolSize="10"/>
----

And in Java DSL

[source,java]
----
ThreadPoolProfile profile = camelContext.getExecutorServiceManager().getDefaultThreadPoolProfile();
profile.setPoolSize(5);
profile.setMaxPoolSize(10);
----

And with camel-main, Spring Boot or Quarkus you can configure this in the `application.properties|yaml` file:

[source,properties]
----
## configure default thread pool profile
camel.threadpool.pool-size = 5
camel.threadpool.max-pool-size = 5
----


=== Using thread pool profiles

Suppose you want to use a custom thread pool profile for a Multicast EIP
pattern in a Camel route you can do it using the `executorServiceRef`
attribute as shown in Spring XML:

[source,xml]
---------------------------------------------------------------------------
<camelContext>

    <threadPoolProfile id="fooProfile"
                       poolSize="20" maxPoolSize="50" maxQueueSize="-1"/>

    <route>
       <multicast aggregationStrategy="myStrategy" executorServiceRef="fooProfile">
          ...
       </multicast>
    </route>
</camelContext>
---------------------------------------------------------------------------

What Camel will do at runtime is to lookup in the
xref:registry.adoc[Registry] for a `ExecutorService` with the id `fooProfile`.
If none found it will fallback and see if there is a
`ThreadPoolProfile` defined with that id. In this example there is a profile,
so the profile is used as base settings for creating a new `ExecutorService` which is
handed back to the xref:components:eips:multicast-eip.adoc[Multicast] EIP to use in the
Camel route.

In Java DSL you can use `ThreadPoolProfileBuilder` to create a profile and then register the profile:

[source,java]
----
ThreadPoolProfileBuilder builder = new ThreadPoolProfileBuilder("fooProfile");
builder.poolSize(20).maxPoolSize(50).maxQueueSize(-1);

camelContext.getExecutorServiceManager().registerThreadPoolProfile(builder.build());
----

== Creating custom thread pools

You can also use the `<threadPool>` tag in Spring XML to create a
specific thread pool (`ExecutorService`). Notice that any options you
do not explicit define, will have Camel to use the default thread pool
profile as fallback. For example if you omit setting the `maxQueueSize`
then Camel will fallback and use the value from the default thread pool
profiles, which by default is `1000`.

== Customizing thread names

On the `ExecutorServiceManager` you can
configure the thread name pattern using the `setThreadNamePattern`
method, which defines the thread names used when a thread pool creates a
thread.

The default pattern is:

[source,text]
----
Camel (#camelId#) thread ##counter# - #name#
----

In the pattern you can use the following placeholders

* `\#camelId#` - The xref:camelcontext.adoc[CamelContext] name
* `\#counter#` An unique incrementing counter
* `\#name#` - The thread name
* `\#longName#` - The long thread name which can include endpoint parameters etc.

In Spring XML the pattern can be set with `threadNamePattern` attribute as shown:

[source,xml]
----
<camelContext threadNamePattern="Riding the thread #counter#">
  <route>
    <from uri="seda:start"/>
    <to uri="log:result"/>
    <to uri="mock:result"/>
  </route>
</camelContext>
----

In Java DSL you can set the pattern as follows:

[source,java]
----
CamelContext camel = ...
camel.getExecutorServiceManager().setThreadNamePattern("Riding the thread #counter#")
----

And with camel-main, Spring Boot or Quarkus you can configure this in the `application.properties|yaml` file:

[source,properties]
----
## camel-main or quarkus
camel.main.thread-name-pattern = Riding the thread #counter#

## spring boot
camel.springboot.thread-name-pattern = Riding the thread #counter#
----

== Shutting down thread pools

All thread pools created by Camel will be properly shutdown when
`CamelContext` shutdowns which ensures no leaks in the pools in case you
run in a server environment with hot deployments and the likes.

The `ExecutorServiceManager` has APIs for shutting down thread pools
gracefully and aggressively. It is encouraged to use this API for creating
and shutting down thread pools.

The method `shutdownGraceful(executorService)` from `ExecutorServiceManager`
will shutdown graceful at first, until a timeout value is hit. After
that it shuts down aggressively, again using the timeout value to wait for
the operation to complete. This means you can wait at most 2 x timeout
for shutting down the thread pool.

The timeout value is by default `10000` millis. You can configure a
custom value on the `ExecutorServiceManager` if needed. During shutdown
Camel will log every 2 seconds at INFO level progress of shutting down
the thread pool. For example in case a shutdown takes a while, then
there is activity in the logs.

The APIs on `ExecutorServiceManager` that is related to shutting down a
thread pool is as follows:

[width="100%",cols="25%,75%",options="header"]
|===
|Method |Description
|shutdown |Marks the thread pool as shutdown
(like calling the `ExecutorService.shutdown()` method).
|shutdownNow |Forces the thread pool to shut down now
(like calling the `ExecutorService.shutdownNow()` method).
|shutdownGraceful |Marks the thread pool as shutdown, and graceful shutdown
the pool, by waiting for tasks to complete. A default timeout value of
10 sec is used, before shutdown becomes aggressive using `shutdownNow`,
forcing threads to shut down quicker.
|shutdownGraceful(timeout) |As shutdownGraceful but with custom timeout value
|awaitTermination |To wait graceful for the termination of a thread pool (eg
to wait for its tasks to complete). Will wait until all tasks are completed or timed out.
|===

== JMX Management

All the thread pools that Camel creates are managed and thus you can see
them in JMX under the `threadpools` tree.

NOTE: This requires to enabled JMX by including `camel-management` JAR in the classpath.

== Component developers

If you develop your own Camel component and are in need of a thread
pool, then it is advised to use the
`ExecutorServiceStrategy`/`ExecutorServiceManager` to create the thread
pool you need.

=== ExecutorServiceStrategy

Camel provides a pluggable strategy to hook in your own thread pool
provider, for example from a WorkManager in a J2EE server etc. +
See the `org.apache.camel.spi.ExecutorServiceStrategy` interface which
you should implement and hook into the WorkManager.

=== ExecutorServiceManager

To hook in custom thread pool providers (e.g. for J2EE servers) a
`ThreadPoolFactory` interface can be implemented. The implementation can
be set in the `ExecutorServiceManager`.

== Virtual Threads

Starting from Java 21, the default `ThreadPoolFactory` can build `ExecutorService` and `ScheduledExecutorService` that
use https://openjdk.org/jeps/425[virtual threads] instead of platform threads.
But as it is an experimental feature, it is not enabled by default, you need to set the System property `camel.threads.virtual.enabled`
to `true` and run Camel using Java 21 or above to enable it.

Be aware that even if it is enabled, there are some use cases where platform threads are still used, for example, if the
thread factory is configured to create non-daemon threads since virtual threads can only be daemons, or when the
`ExecutorService` or `ScheduledExecutorService` to build cannot have more than one thread or finally when `corePoolSize`
is set to zero and `maxQueueSize` is set to a value less or equal to `0`.
= Tracer

Camel's tracer is used for logging message details during routing, where
you can see the route path of each message as they happen. Details of the message is also logged such as the message body, and headers.

TIP: There is an alternative tracer that captures the messages in a xref:backlog-tracer.adoc[Backlog Tracer].

== Enabling Tracing

In Java you set tracing on `CamelContext`:

[source,java]
----
context.setTracing(true);
----

And in XML DSL:

[source,xml]
----
<camelContext trace="true" xmlns="http://activemq.apache.org/camel/schema/spring">
...
</camelContext>
----

And in Spring Boot

[source,text]
----
camel.springboot.tracing = true
----

=== Setting Tracing in Standby mode

By default Camel optimizes and opt-out tracing. Therefore, you would either have to enable tracing from the startup,
or turn on standby mode, to allow tracing to be enabled later during runtime.

To set tracing in standby mode you can do:

[source,java]
----
context.setTracingStandby(true);
----

And in XML DSL:

[source,xml]
----
<camelContext trace="standby" xmlns="http://activemq.apache.org/camel/schema/spring">
...
</camelContext>
----

And in Spring Boot

[source,text]
----
camel.springboot.tracing-standby = true
----

If tracer is in standby mode, then tracing is made available, and can be enabled during runtime.
This requires to either use JMX or enable via Java code:

[source,java]
----
Tracer tracer = context.getTracer();
tracer.setEnabled(true);
----

=== Trace Logging Formatting

The tracer formats the execution of exchanges to log lines. They are
logged at `INFO` level in the log category: `org.apache.camel.Tracing`.

The message information from the Exchange is formatted using `ExchangeFormatter` and the default implementation
has many options you can configure accordingly to the https://www.javadoc.io/doc/org.apache.camel/camel-support/latest/org/apache/camel/support/processor/DefaultExchangeFormatter.html[javadoc].

The tracer outputs the logging with a prefix with the following information:

- arrow - (direction whether input or output)
- routeId - the current route
- label - the current EIP node

This output is assembled using the following default format:

- %-4.4s [%-12.12s] [%-33.33s]

The default format can be customized using, for exameple to use wider columns:

[source,java]
----
context.setTracingLoggingFormat("%-4.4s [%-30.30s] [%-50.50s]");
----

And in XML DSL:

[source,xml]
----
<camelContext trace="true" traceLoggingFormat="%-4.4s [%-30.30s] [%-50.50s]">
...
</camelContext>
----

And in Spring Boot

[source,properties]
----
camel.springboot.tracing-logging-format = %-4.4s [%-30.30s] [%-50.50s]
----

And in Camel Main / Quarkus

[source,properties]
----
camel.main.tracing-logging-format = %-4.4s [%-30.30s] [%-50.50s]
----
= Transformer

Transformer (`org.apache.camel.spi.Transformer`) performs declarative transformation of the message according
to the declared _Input Type_ and/or _Output Type_ on a route definition which declares
the expected message type. The default Camel Message implements `DataTypeAware`, which allows to hold the message type
represented by `DataType`.

If the input type and/or output type is declared by _Input Type_ and/or _Output Type_ in the route
definition, and in case it is different from actual message type at runtime, Camel internal processor
looks for a `Transformer` which transforms from the current message type to the expected message
type and apply. Once transform succeed or message is already in expected type, then the message
data type is updated.

== Data type format

[source,text]
----
scheme:name
----

where *scheme* is the type of data model like `java`, `xml` or `json`, and *name* is the individual data type name.
The scheme could also represent a Camel component scheme such as `http` or `aws2-s3` in order to reference component specific data types.
When using the `java` scheme the data type name may be the qualified class name (e.g. `java:org.apache.camel.Foo`)
If you only specify *scheme* then it hits all the data types which has that scheme like a wildcard.

== Supported Transformers

[width="100%",cols="25%,75%",options="header",]
|===
| Transformer | Description
| Data Format Transformer | Transform with using Data Format
| Endpoint Transformer | Transform with using Endpoint
| Custom Transformer | Transform with using custom transformer class. Transformer must be a subclass of `org.apache.camel.spi.Transformer`
| Loading Transformer | Loads multiple transformer implementations (e.g. via annotation classpath scan). Also preloads known default Camel transformer implementations.
|===

=== Common Options

All transformers have following common options to specify which data type is supported by the transformer. `name` or both of `fromType` and `toType` must be specified.

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| scheme | The supported data type scheme. It is possible to just reference a scheme like `xml` or `json`. For example if `xml` is specified, the transformer is applied for all java -&gt; xml and xml -&gt; java transformation.
| name | The name of the transformer. If name is specified users may use a combination of a scheme and name (e.g. `xml:Order`) to reference the transformer in a route.
| fromType | xref:transformer.adoc[Data type] to transform from.
| toType | xref:transformer.adoc[Data type] to transform to.
|===

Transformer implementations may use `scheme:name` or the combination of `fromType/toType` as an identifier.

When using the `scheme:name` identifier users may reference the transformer by its full name in a route.

[tabs]
====
Java::
+
[source,java]
----
from("direct:abc")
    .inputType("myScheme:myTransformer")
    .to("...");
----

XML::
+
[source,xml]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
    <route>
        <from uri="direct:abc"/>
        <inputType urn="myScheme:myTransformer"/>
        <to uri="..."/>
    </route>
</camelContext>
----
====

As mentioned earlier the transformer may also skip the name and just use a `scheme` (e.g. `xml`) in order to apply to
all data type transformations of a given scheme (e.g. `xml:Order`, `xml:OrderResponse`, `xml:anything`)

When using the combination of `fromType/toType` as an identifier the transformer gets matched automatically by the given
data types used on the Camel route (e.g. inputType) and the given Exchange data type (specified by the Exchange message using `DataTypeAware` interface).

In general, the transformer resolving mechanism tries to find the best match when searching for a proper transformation
from a given data type to a given data type. The mechanism tries to find exact matches for `fromType` and `toType` first,
then wildcard matches (using transformers for the given data type scheme only), then named transformers using `scheme:name` identifiers,
then named transformers matching `scheme` only.

If not already preloaded by the configuration the Transformer resolving mechanism also performs lazy loading of transformer implementations using the factory finder resource path lookup.

=== DataFormat Transformer Options

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| type | Data Format type
| ref | reference to the Data Format ID
|===

Here is an example to specify xref:components:dataformats:bindy-dataformat.adoc[Bindy] DataFormat type:

[tabs]
====
Java::
+
[source,java]
----
BindyDataFormat bindy = new BindyDataFormat();
bindy.setType(BindyType.Csv);
bindy.setClassType(com.example.Order.class);
transformer()
    .fromType(com.example.Order.class)
    .toType("csv:CSVOrder")
    .withDataFormat(bindy);
----

XML::
+
[source,xml]
----
<dataFormatTransformer fromType="java:com.example.Order" toType="csv:CSVOrder">
    <bindy id="csvdf" type="Csv" classType="com.example.Order"/>
</dataFormatTransformer>
----
====

== Endpoint Transformer Options

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| ref | Reference to the Endpoint ID
| uri | Endpoint URI
|===

Here is an example to specify endpoint URI in Java DSL:

[source,java]
----
transformer()
    .fromType("xml")
    .toType("json")
    .withUri("component:componentPathOptions?mappingFile=myMapping.xml...");
----

And here is an example to specify endpoint ref in XML DSL:

[source,xml]
----
<endpointTransformer ref="myEndpoint" fromType="xml" toType="json"/>
----

== Custom Transformer Options

Note that Transformer must be a subclass of `org.apache.camel.spi.Transformer`

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| ref | Reference to the custom Transformer bean ID
| className | Fully qualified class name of the custom Transformer class
|===

Here is an example to specify custom Transformer class:

[tabs]
====
Java::
+
[source,java]
----
transformer()
    .fromType("xml")
    .toType("json")
    .withJava(com.example.MyCustomTransformer.class);
----

XML::
+
[source,xml]
----
<customTransformer className="com.example.MyCustomTransformer" fromType="xml" toType="json"/>
----
====

== Load Transformer Options

Users are able to preload known default transformers. Also users may load transformers via classpath scan.

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| defaults | Loads known default transformer implementations (e.g. plain-text, application-octet-stream)
| location | Classpath location to scan for transformer implementations. Transformer implementations must use the `org.apache.camel.spi.DataTypeTransformer` annotation to get recognized by the scanner.
|===

Here is an example to load default Transformer classes:

[tabs]
====
Java::
+
[source,java]
----
transformer()
    .withDefaults()
----

XML::
+
[source,xml]
----
<loadTransformer defaults="true"/>
----
====

Here is an example to load Transformer classes via classpath scan:

[tabs]
====
Java::
+
[source,java]
----
transformer()
    .scan("org.apache.camel.transformer.standard")
----

XML::
+
[source,xml]
----
<loadTransformer packageScan="org.apache.camel.transformer.standard"/>
----
====

The classpath scan looks for classes that use the `org.apache.camel.spi.DataTypeTransformer` annotation.
The annotation defines the transformer name and/or the supported from/to data types.

[source,java]
----
@DataTypeTransformer(name = "uppercase")
public class UppercaseDataTypeTransformer extends Transformer {

    @Override
    public void transform(Message message, DataType fromType, DataType toType) {
        message.setBody(message.getBody(String.class).toUpperCase());
    }
}
----

== Example

For example to declare the Endpoint Transformer which uses
xslt component to transform from `xml:ABCOrder` to `xml:XYZOrder`, we can do as follows:

[tabs]
====
Java::
+
[source,java]
----
transformer()
    .fromType("xml:ABCOrder")
    .toType("xml:XYZOrder")
    .withUri("xslt:transform.xsl");
----

XML::
+
[source,xml]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
    <transformers>
        <endpointTransformer uri="xslt:transform.xsl" fromType="xml:ABCOrder" toType="xml:XYZOrder"/>
    </transformers>
    ....
</camelContext>
----
====

If you have following route definition, above transformer will be applied when `direct:abc` endpoint sends the message to `direct:xyz`:

[tabs]
====
Java::
+
[source,java]
----
from("direct:abc")
    .inputType("xml:ABCOrder")
    .to("direct:xyz");

from("direct:xyz")
    .inputType("xml:XYZOrder")
    .to("somewhere:else");
----

XML::
+
[source,xml]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
    <route>
        <from uri="direct:abc"/>
        <inputType urn="xml:ABCOrder"/>
        <to uri="direct:xyz"/>
    </route>
    <route>
        <from uri="direct:xyz"/>
        <inputType urn="xml:XYZOrder"/>
        <to uri="somewhere:else"/>
    </route>
</camelContext>
----
====

== See Also

The xref:validator.adoc[Validator] is a related functionality.
= Try, Catch and Finally

Camel supports the Java equivalent of try ... catch ... finally directly in the DSL.
It aims to work like its Java sisters but with more power.

In Camel, we prefix the keywords with `do` to avoid having same keyword as Java.
So we have:

- `doTry`
- `doCatch`
- `doFinally`
- `end` to end the block in Java DSL

When using `doTry ... doCatch ... doFinally` then the regular Camel
xref:error-handler.adoc[Error Handler] is not in use; meaning any
`onException` or the likes does not trigger.
The reason is that
`doTry ... doCatch ... doFinally` is in fact its own error handler and mimics how try/catch/finally works in Java.

== Using doTry ... doCatch ... doFinally

In the route below we have all of them in action:

[source,java]
----
from("direct:start")
    .doTry()
        .process(new ProcessorFail())
        .to("mock:result")
    .doCatch(IOException.class, IllegalStateException.class)
        .to("mock:catch")
    .doFinally()
        .to("mock:finally")
    .end();
----

And in XML DSL

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <doTry>
    <process ref="processorFail"/>
    <to uri="mock:result"/>
    <doCatch>
      <exception>java.io.IOException</exception>
      <exception>java.lang.IllegalStateException</exception>
      <to uri="mock:catch"/>
    </doCatch>
    <doFinally>
       <to uri="mock:finally"/>
    </doFinally>
  </doTry>
</route>
----

=== Using onWhen with doCatch

You can use xref:predicate.adoc[Predicate]s with `doCatch` to make it runtime determine if the block should be triggered or not.
In our case, we only want to trigger if the caused exception message contains the *damn* word.

[source,java]
----
from("direct:start")
    .doTry()
        .process(new ProcessorFail())
        .to("mock:result")
    .doCatch(IOException.class, IllegalStateException.class).onWhen(exceptionMessage().contains("Damn"))
        .to("mock:catch")
    .doCatch(CamelExchangeException.class)
        .to("mock:catchCamel")
    .doFinally()
        .to("mock:finally")
    .end();
----

And in XML DSL

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <doTry>
    <process ref="processorFail"/>
    <to uri="mock:result"/>
    <doCatch>
      <exception>java.io.IOException</exception>
      <exception>java.lang.IllegalStateException</exception>
      <onWhen>
        <simple>${exception.message} contains 'Damn'</simple>
      </onWhen>
      <to uri="mock:catch"/>
    </doCatch>
    <doCatch>
      <exception>org.apache.camel.CamelExchangeException</exception>
      <to uri="mock:catchCamel"/>
    </doCatch>
    <doFinally>
       <to uri="mock:finally"/>
    </doFinally>
  </doTry>
</route>
----

=== Use end() to end the block

Notice when using Java DSL we must use `end()` to indicate where the try ... catch ... finally block ends.
As the example above has a finally, then the `end()` should be at the end of the finally block.
If we are not using a finally, then the `end()` should be at the end of the `doCatch`
to indicate the end there.

TIP: Instead of `end()` you can use `endDoTry()` to end and _return back_ to the try ... catch scope.

=== Using nested doTry ... doCatch EIPs

When nesting `doTry ... doCatch` from an outer `doTry ... doCatch` EIP,
then pay extra attention when using Java DSL as the Java programming language is not _indent aware_
so you may write Java code
that is indented in a way where you think that a catch block is associated with the other doTry, but it is not.

Given the following Java DSL:

[source,java]
----
from("direct:test").routeId("myroute")
    .doTry().
        doTry().
            throwException(new IllegalArgumentException("Forced by me"))
        .doCatch(Exception.class)
            .log("docatch 1")
            .throwException(new IllegalArgumentException("Second forced by me"))
    .doCatch(Exception.class)
        .log("docatch 2")
    .end();
----

Then you may think that `_docatch2_` is associated on the outer doTry because of how the code is formatted.
But it is **not**, both `_docatch1_` and `_docatch2_` are in the inner `doTry`, and the outer `doTry` has no catch blocks.

So in this example, the route will throw the first exception which is then handled in `_docatch1_`
which then throws a second exception, that is not caught.

So what you must do is to end the doCatch block correct (notice how we use `endDoTry()` two times) as shown below:

[source,java]
----
from("direct:test").routeId("myroute")
    .doTry().
        doTry().
            throwException(new IllegalArgumentException("Forced by me"))
        .doCatch(Exception.class)
            .log("docatch 1")
            .throwException(new IllegalArgumentException("Second forced by me"))
         .endDoTry() // end this doCatch block
     .endDoTry() // end the inner doTry
    .doCatch(Exception.class)
        .log("docatch 2")
    .end();
----

And by using the `endDoTry()` we can end the block correctly, and an XML representation of the route would be as follows:

[source,xml]
----
<route>
    <from uri="direct:test"/>
    <doTry>
        <doTry>
            <throwException id="throwException1"/>
            <doCatch id="doCatch1">
                <log id="log1" message="docatch 1"/>
                <throwException id="throwException2"/>
            </doCatch>
        </doTry>
        <doCatch id="doCatch2">
            <log id="log2" message="docatch 2"/>
        </doCatch>
    </doTry>
</route>
----
= Type Converter

Converting body payloads from one type to another is common when routing messages between endpoints.
Conversions regularly occur between the following types:

* `File`
* `String`
* `byte[]` and `ByteBuffer`
* `InputStream` and `OutputStream`
* `Reader` and `Writer`
* XML payloads such as `Document` and `Source`

For example to convert the message body to XML `Document` type
then this can be done as follows in Java:

[source,java]
----
Message message = exchange.getMessage();
Document document = message.getBody(Document.class);
----

Notice that the code only tells Camel what you *want* as the result type (`Document`)
and not what the input type is, or how Camel should do this.

== How Type Conversion works

The type conversion strategy is defined by the
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/TypeConverter.html[TypeConverter]
interface. The interface has several methods, however the most important and common API is:

[source,java]
----
<T> T convertTo(Class<T> type, Exchange exchange, Object value) throws TypeConversionException;
----

This API is used by Camel when it converts an object from one type to another. However if
you pay attention then this API only has the result type in the contract. The input type
is inferred from the _value_ parameter.

There are many type converters in Camel, some comes out of the box from camel-core, and others
are additional converters that are shipped in various Camel components.

=== Type converter registry

To keep track of all those converters, then Camel has a registry for type converters
(`org.apache.camel.spi.TypeConverterRegistry`).

This registry keeps track of all possible type converter combinations, such as which converters
that can convert to an `InputStream` and so forth.

So the example from before, what Camel would do is to lookup in the `TypeConverterRegistry`
to find a suitable converter that can convert the given input value to the `Document` type.

The `TypeConverterRegistry` can be accessed via Java:

[source,java]
----
TypeConverterRegistry tcr = camelContext.getTypeConverterRegistry();
TypeConverter tc = tcr.lookup(Document.class, InputStream.class);
----

However often you would not work directly with the `TypeConverterRegistry` or `TypeConverter` APIs in Camel;
as type conversion are often implicit in use where you would just declare the result type; and Camel takes care of this.

[NOTE]
====
In Camel, all the official Camel components, come with source code generated `TypeConverter`
(via `camel-component-maven-plugin`) that allows Camel to load these converters very quickly,
and invoke these type converters at runtime via quick Java method invocations (no reflection overhead).
====

=== Type converter registry utilization statistics

NOTE: as of Camel 4.7.0, the statistics collector in the registry has been made immutable.
As such, enabling collection of statistics has to be done prior to creating the type converter
registry.

Camel can gather utilization statistics of the runtime usage of type
converters. These statistics are available in xref:jmx.adoc[JMX] as well as
from https://www.javadoc.io/doc/org.apache.camel/camel-api/latest/org/apache/camel/spi/TypeConverterRegistry.html#getStatistics--[`TypeConverterRegistry#getStatistics()`].

These statistics are turned off by
default as there is some performance overhead under very high concurrent load.

Enabling statistics in Java:

[source,java]
----
CamelContext context = ...;
context.setTypeConverterStatisticsEnabled(true);
----

Enabling statistics in XML DSL:

[source,xml]
----
<camelContext typeConverterStatisticsEnabled="true">
    ...
</camelContext>
----

== TypeConverter using @Converter annotation

All the type converters that come out of the box are coded as Java methods on _converter_ classes.

This means a class has been annotated with `@Converter` and the methods in the class
annotated with `@Converter` become a type converter _pair_ like in the following example:

[source,java]
----
@Converter(generateLoader = true)
public class IOConverter {
    @Converter
    public static InputStream toInputStream(File file) throws FileNotFoundException {
        return new BufferedInputStream(new FileInputStream(file));
    }
}
----

This is from camel-core where the `IOConverter` class has a number of converters (only 1 shown).
The method `toInputStream` is annotated with `@Converter` which then becomes a type converter
that can convert from `File` to `InputStream`.

All these _converter_ classes are discovered and loaded by Camel.

== Discovering Type Converters

Camel automatically discovers and loads the type converters from all JARs on the classpath at startup.

Camel searches the classpath for a file called
`META-INF/services/org/apache/camel/TypeConverterLoader` which lists
all type converter loader classes. These are automatically generated by the Camel Component Package Plugin.
These _loader_ classes will load the type converters into the Camel type converter registry
and invoke them in a _fast way_ using standard Java method calls.

=== Discovering Type Converters (fast way)

To enable the fast type converter way, you should enable `generateLoader = true`
on the class level annotation as shown:

[source,java]
----
@Converter(generateLoader = true)
public class IOConverter {
    @Converter
    public static InputStream toInputStream(File file) throws FileNotFoundException {
        return new BufferedInputStream(new FileInputStream(file));
    }
}
----

And then you should have the xref:camel-component-maven-plugin.adoc[Camel Component Package Plugin] in as build plugin when compiling the project.

=== Discovering Type Converters in the fastest way

In Camel 3.7 we optimized the type converter system for optimal performance when using the built-in converters.
This was done by bulking together all the converters in the same Maven module into a single class. The class has a single
`convert` method where all the supported converters are available and discovered in a fast way using Java primitives.

To enable this then set `generateBulkLoader=true` in the class `@Converter` annotation. You should do this for all the converter
classes within the same Maven artifact. Then they will be bulked together into a single class.

[source,java]
----
@Converter(generateBulkLoader = true)
public class IOConverter {
    @Converter
    public static InputStream toInputStream(File file) throws FileNotFoundException {
        return new BufferedInputStream(new FileInputStream(file));
    }
}
----

There are few limitations:

- fallback converters are not supported
- the order of the `@Converter` methods matters. If you have multiple `@Converter` methods that accept as _from_ type
types which are from the same class hierarchy then put the methods first that are the most concrete.

For example in `camel-xml-jaxp` we have in the `XmlConverter` multiple `@Converter` methods which can convert to `DomSource`.
We had to put the method that takes `org.w3c.dom.Document` before the method that takes `org.w3c.dom.Node` as `Document` extends `Node`.

The following code shows snippet of the source code generated bulk class. As you can see we have the `Document` method before the `Node` method below:

[source,java]
----
        } else if (to == javax.xml.transform.dom.DOMSource.class) {
            if (value instanceof org.w3c.dom.Document) {
                return getXmlConverter().toDOMSource((org.w3c.dom.Document) value);
            }
            if (value instanceof org.w3c.dom.Node) {
                return getXmlConverter().toDOMSource((org.w3c.dom.Node) value);
            }
----

=== Returning null values

By default, when using a method in a POJO annotation with `@Converter`
returning `null` is not a valid response. If null is returned, then Camel
will regard that type converter as a _miss_, and prevent from using it
in the future. If `null` should be allowed as a valid response, then
you must specify this in the annotation (via `allowNull`) as shown:

[source,java]
----
@Converter(allowNull = true)
public static InputStream toInputStream(File file) throws IOException {
    if (file.exist()) {
        return new BufferedInputStream(new FileInputStream(file));
    } else {
        return null;
    }
}
----

== Fallback Type Converters

The
https://www.javadoc.io/doc/org.apache.camel/camel-base/current/org/apache/camel/impl/converter/AnnotationTypeConverterLoader.html[AnnotationTypeConverterLoader]
has been enhanced to also look for methods defined with a
`@FallbackConverter` annotation, and register it as a fallback type
converter.

Fallback type converters are used as a last resort for converting a
given value to another type. It is used when the regular type converters
give up.
The fallback converters are also meant for a broader scope, so its method
signature is a bit different:

[source,java]
----
@FallbackConverter
public static <T> T convertTo(Class<T> type, Exchange exchange, Object value, TypeConverterRegistry registry)
----

Or you can use the non-generic signature.

[source,java]
----
@FallbackConverter
public static Object convertTo(Class type, Exchange exchange, Object value, TypeConverterRegistry registry)
----

And the method name can be anything (`convertTo` is not required as a
name), so it can be named `convertMySpecialTypes` if you like. +
The `Exchange` parameter is optional, just like the regular
`@Converter` methods.

The purpose with this broad scope method signature is allowing you to
control if you can convert the given type or not. The `type` parameter
holds the type we want the `value` converted to. It is used internally in
Camel for wrapper objects, so we can delegate the type conversion to the
body that is wrapped.

For instance in the method below we will handle all type conversions
that are based on the wrapper class `GenericFile` and we let Camel do the
type conversions on its body instead.

[source,java]
----
@FallbackConverter
public static <T> T convertTo(Class<T> type, Exchange exchange, Object value, TypeConverterRegistry registry) {
    // use a fallback type converter so we can convert the embedded body
    // if the value is GenericFile
    if (GenericFile.class.isAssignableFrom(value.getClass())) {
        GenericFile file = (GenericFile) value;
        Class from = file.getBody().getClass();
        TypeConverter tc = registry.lookup(type, from);
        if (tc != null) {
            Object body = file.getBody();
            return tc.convertTo(type, exchange, body);
        }
    }
    return null;
}
----

== Writing your own Type Converters

You are welcome to write your own converters. Remember to use the
`@Converter` annotations on the classes and methods you wish to use.
And on the top-level class add `Converter(generateLoader = true)` to support the _fast way_
of using type converters.

* static methods are encouraged to reduce caching, but instance methods
are fine, particularly if you want to allow optional dependency
injection to customize the converter
* converter methods should be thread safe and reentrant

=== Exchange parameter

The type converter accepts the `Exchange` as an optional 2nd parameter.
This is usable if the type converter for instance needs information from
the current exchange. For instance combined with the encoding support
it is possible for type converters to convert with the configured
encoding. An example from camel-core for the `byte[]` -> `String`
converter:

[source,java]
----
@Converter
public static String toString(byte[] data, Exchange exchange) {
    String charsetName = exchange.getProperty(Exchange.CHARSET_NAME, String.class);
    if (charsetName != null) {
        try {
            return new String(data, charsetName);
        } catch (UnsupportedEncodingException e) {
            // ignore
        }
    }
    return new String(data);
}
----
= URIs

Camel makes extensive use of URIs to allow you to refer to xref:endpoint.adoc[Endpoints].

For example, consider the following URI:

[source,text]
----
kafka:cheese?brokers=mykafka:1234&clientId=foo
----

This endpoint is created by the xref:components::kafka-component.adoc[Kafka] component.
The URI contains endpoint configurations as context-path and query parameters.
In this example, the context-path is `cheese` which is the kafka topic to use.

The query parameters have two parameters:

1. `brokers=mykafka:1234`: the remote Kafka broker to connect to.
2. `clientId=foo`: the client id, which is a configuration of the Kafka component

== More Information

You can read the guide xref:faq:how-do-i-configure-endpoints.adoc[How do I configure endpoints] to learn more about configuring _endpoints_. Among other things, this guide explains how to refer to beans in the xref:registry.adoc[registry], how to use raw values for password options, how to use xref:using-propertyplaceholder.adoc[property placeholders], or how to use the type safe xref:Endpoint-dsl.adoc[Endpoint DSL] and xref:dataformat-dsl.adoc[DataFormat DSL].
= Using Exchange Pattern Annotations

Invoking InOut methods for ref:components:eips:requestReply-eip.adoc[request/reply] when working with xref:pojo-producing.adoc[POJO Producing] is typically synchronous. As such, the caller will block until the server returns a result.

[NOTE]
====
InOut means that there is an In message for  the input and an Out for the output/result.
====

[NOTE]
====
Other books, posts and reference guides may use the terms In/Out and In/Only for the patterns. In this guide we use InOut and InOnly respectively, as these are the names used within Camel.
====

You can also implement support for xref:components:eips:event-message.adoc[Event Messages] with Apache Camel, using the InOnly xref:exchange-pattern.adoc[pattern]. These are often called "fire and forget" (i.e., like sending a JMS message but not waiting for any response).

Since version 1.5 Camel supports annotations for specifying the message
exchange pattern on Java methods, classes or interfaces.

[[UsingExchangePatternAnnotations-SpecifyingInOnlymethods]]
== Specifying InOnly methods

Typically the InOut pattern is what most users want, but you can
customize to use InOnly using an annotation. For instance:

[source,syntaxhighlighter-pre]
----
public interface Foo {
  Object someInOutMethod(String input);
  String anotherInOutMethod(Cheese input);
  
  @InOnly
  void someInOnlyMethod(Document input);
}
----

The above code shows three methods on an interface:
* the first two use the default InOut mechanism
* the third one, `someInOnlyMethod` uses the InOnly annotation to specify it as being a one-way method call.

[[UsingExchangePatternAnnotations-Classlevelannotations]]
== Class level annotations

You can also use class level annotations to default all methods in an
interface to a pattern:

[source,syntaxhighlighter-pre]
----
@InOnly
public interface Foo {
  void someInOnlyMethod(Document input);
  void anotherInOnlyMethod(String input);
}
----

Apache Camel will detect annotations on base classes or interfaces. For instance, suppose you created a client side proxy for the following code:

[source,syntaxhighlighter-pre]
----
public class MyFoo implements Foo {
  ...
}
----

In this case, the methods inherited from Foo would be InOnly.

[[UsingExchangePatternAnnotations-Overloadingaclasslevelannotation]]
== Overloading a class level annotation


You can overload a class level annotation on specific methods. Suppose you have a class or interface with many InOnly methods, but you want to annote just one or two methods as InOut. You can do it like this:

[source,syntaxhighlighter-pre]
----
@InOnly
public interface Foo {
  void someInOnlyMethod(Document input);
  void anotherInOnlyMethod(String input);
  
  @InOut
  String someInOutMethod(String input); 
}
----

In the above `Foo` interface the only the `someInOutMethod` will be InOut.

[[UsingExchangePatternAnnotations-Usingyourownannotations]]
== Using your own annotations

You might want to create your own annotations to represent a group of
different bits of metadata; such as combining synchrony, concurrency and
transaction behaviour.

In this case you can annotate your annotation with the `@Pattern` annotation to the default exchange pattern you wish to use.

For example, lets say we want to create our own annotation called
`@MyAsyncService`:

[source,syntaxhighlighter-pre]
----
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})

// lets add the message exchange pattern to it
@Pattern(ExchangePattern.InOnly)

// lets add some other annotations - maybe transaction behaviour?

public @interface MyAsyncService {
}
----

Now we can use this annotation, and Camel will figure out the correct
exchange pattern.

[source,syntaxhighlighter-pre]
----
public interface Foo {
  void someInOnlyMethod(Document input);
  void anotherInOnlyMethod(String input);
  
  @MyAsyncService
  String someInOutMethod(String input); 
}
----
= Property placeholders

Camel has extensive support for property placeholders, which
can be used _almost anywhere_ in your Camel xref:routes.adoc[routes],
xref:endpoint.adoc[endpoints], xref:dsl.adoc[DSL], and xref:route-configuration.adoc[route configuration],
xref:bean-integration.adoc[bean integration] and elsewhere.

Property placeholders are used to define a _placeholder_ instead of the actual value.
This is important as you would want to be able to make your applications external
configurable, such as values for network addresses, port numbers, authentication credentials,
login tokens, and configuration in general.

== Properties component

Camel provides the xref:components::properties-component.adoc[Properties] out of the box
from the core, which is responsible for handling and resolving the property placeholders.

See the xref:components::properties-component.adoc[Properties] documentation for how
to configure Camel to known from which location(a) to load properties.


== Property placeholder syntax

The value of a Camel property can be obtained by specifying its key name
within a property placeholder, using the following syntax: `{\{key}}`

For example:

[source,text]
----
{{file.uri}}
----

where `file.uri` is the property key.

Property placeholders can be used to specify parts, or all, of an
endpoint's URI by embedding one or more placeholders in the URI's string
definition.

=== Using property placeholder with default value

You can specify a default value to use if a
property with the key does not exist, where the default value is the text after the colon:

[source,text]
----
{{file.url:/some/path}}
----

In this case the default value is `/some/path`.

=== Using optional property placeholders

Camel's elaborate property placeholder feature supports optional placeholders,
which is defined with the `?` (question mark) as prefix in the key name, as shown:

[source,text]
----
{{?myBufferSize}}
----

If a value for the key exists then the value is used, however if the key does not exist,
then Camel understands this, such as when used in xref:endpoint.adoc[Endpoints]:

[source,text]
----
file:foo?bufferSize={{?myBufferSize}}
----

Then the `bufferSize` option will only be configured in the endpoint, if a placeholder exists.
Otherwise the option will not be set on the endpoint, meaning the endpoint would be _restructued_ as:

[source,text]
----
file:foo
----

Then the option `bufferSize` is not in specified at all, and this would allow Camel to
use the standard default value for `bufferSize` if any exists.

=== Reverse a boolean value

If a property placeholder is a boolean value, then it is possible to negate (reverse) the value by using `!` as prefix in the key.

[source,properties]
----
integration.ftpEnabled=true
----

[source,java]
----
from("ftp:....").autoStartup("{{integration.ftpEnabled}}")
    .to("kafka:cheese")

from("jms:....").autoStartup("{{!integration.ftpEnabled}}")
    .to("kafka:cheese")
----

In the example above then the FTP route or the JMS route should only be started. So if the FTP is enabled then JMS should be disable, and vise-versa.
We can do this be negating the `autoStartup` in the JMS route, by using `!integration.ftpEnabled` as the key.


== Using property placeholders

When using property placeholders in the endpoint xref:uris.adoc[URIs] you should use this with the syntax `{\{key}}` as shown in this example:

[source,properties]
----
cool.end = mock:result
where = cheese
----

And in Java DSL:

[source,java]
----
from("direct:start")
    .to("{{cool.end}}");
----

And in XML DSL:

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <to uri="{{cool.end}}"/>
</route>
----

A property placeholder may also just be a one part in the endpoint URI.
A common use-case is to use a placeholder for an endpoint option such
as the size of the write buffer in the file endpoint:

[source,properties]
----
buf = 8192
----

[source,java]
----
from("direct:start")
    .to("file:outbox?bufferSize={{buf}}");
----

And in XML DSL:

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <to uri="file:outbox?bufferSize={{buf}}"/>
</route>
----

However the placeholder can be anywhere, so it could also be the name of a mock endpoint

[source,java]
----
from("direct:start")
    .to("mock:{{where}}");
----

In the example above the mock endpoint, is already hardcoded to start with `mock:`,
and the `where` placeholder has the value `cheese` so the resolved uri becomes `mock:cheese`.

=== Property placeholders referring to other properties (nested placeholders)

You can also have properties with refer to each other such as:

[source,properties]
----
cool.foo=result
cool.concat=mock:{{cool.foo}}
----

Notice how `cool.concat` refer to another property.

And the route in XML:

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <to uri="{{cool.concat}}"/>
</route>
----

==== Turning off nested placeholders

If the placeholder value contains data that interfere with the property placeholder syntax `{{` and `}}` (such as JSon data),
you can be then explicit turn off nested placeholder by `?nested=false` in the key name, such as shown:

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <to uri="elasticsearch:foo?query={{myQuery?nested=false}}"/>
</route>
----

In the example above the placeholder _myQuery_ placeholder value is as follows

[source,json]
----
{"query":{"match_all":{}}}
----

Notice how the json query ends with `}}` which interfere with the Camel property placeholder syntax.

Nested placeholders can also be turned off globally on the xref:components::properties-component.adoc[Properties] component, such as:

[source,java]
----
CamelContext context = ...
context.getPropertiesComponent().setNestedPlaceholder(false);
----

=== Escape a property placeholder

The property placeholder can be problematic if the double curly brackets are used by a third party library like for example a query in ElasticSearch of type `{"query":{"match_all":{}}}`.

To work around that it is possible to escape the double curly brackets with a backslash character like for example `\{{ property-name \}}`. This way, it won't be interpreted as a property placeholder to resolve and will be resolved as `{{ property-name }}`.

If for some reason, the backslash character before the double curly brackets must not be interpreted as an escape character, it is possible to add another backslash in front of it to escape it, it will then be seen as a backslash.

=== Using property placeholders multiple times

You can of course also use placeholders several times:

[source,properties]
----
cool.start=direct:start
cool.showid=true
cool.result=result
----

And in this route we use `cool.start` two times:

[source,java]
----
from("{{cool.start}}")
    .to("log:{{cool.start}}?showBodyType=false&showExchangeId={{cool.showid}}")
    .to("mock:{{cool.result}}");
----

=== Using property placeholders with producer template

You can also your property placeholders when using
xref:producertemplate.adoc[ProducerTemplate] for example:

[source,java]
----
template.sendBody("{{cool.start}}", "Hello World");
----

=== Using property placeholders with consumer template

This can also be done when using xref:consumertemplate.adoc[ConsumerTemplate], such as:

[source,java]
----
Object body = template.receiveBody("{{cool.start}}");
----

== Resolving property placeholders on cloud

When you are running your Camel application on the cloud you may want to automatically scan any Configmap or Secret as it was an application properties. Given the following Secret:

----
apiVersion: v1
data:
  my-property: Q2FtZWwgNC44
kind: Secret
metadata:
  name: my-secret
type: Opaque
----

You can mount it in your Pod container, for instance, under `/etc/camel/conf.d/_secrets/my-secret`. Now, just make your Camel application be aware where to scan your configuration via `camel.main.cloud-properties-location = /etc/camel/conf.d/_secrets/my-secret` application properties. It's a comma separated value, so, you can add as many Secrets/Configmaps you need.

At runtime, you will be able to read the configuration transparently as ```{{ my-property }}``` as you're doing with the rest of properties.

NOTE: the same configuration works with Configmap.

== Resolving property placeholders from Java code

If you need to resolve property placeholder(s) from some Java code, then Camel has two APIs for this:

- You can use the method `resolveProperty` on the `PropertiesComponent` to resolve a single property from Java code.
- Use the method `resolvePropertyPlaceholders` on the `CamelContext` to resolve (one or more) property placeholder(s) in a String.

For example to resolve a placeholder with key foo, you can do:

[source,java]
----
Optional<String> prop = camelContext.getPropertiesComponent().resolveProperty("foo");
if (prop.isPresent()) {
    String value = prop.get();
    ....
}
----

This API is to lookup a single property and returns a `java.util.Optional` type.

The `CamelContext` have another API which is capable of resolving multiple placeholders, and interpolate placeholders from an input String.
Lets try with an example to explain this:

[source,java]
----
String msg = camelContext.resolvePropertyPlaceholders("{{greeting}} Camel user, Camel is {{cool}} dont you think?");
----

The input string is a text statement which have two placeholders that will be resolved, for example:

[source,properties]
----
greeting = Hi
cool = awesome
----

Will be resolved to:

[source,text]
----
Hi Camel user, Camel is awesome dont you think?
----

== Using property placeholders for any kind of attribute in Spring XML files

Previously it was only the `xs:string` type attributes in the XML DSL
that support placeholders. For example often a timeout attribute would
be a `xs:int` type and thus you cannot set a string value as the
placeholder key. This is now possible using a special
placeholder namespace.

In the example below we use the `prop` prefix for the namespace
`\http://camel.apache.org/schema/placeholder`. Now we can use `prop:` as prefix
to configure any kind of XML attributes in Spring XML files.

In the example below we want to use a placeholder for the `stopOnException` option in
the xref:components:eips:multicast-eip.adoc[Multicast] EIP. The `stopOnException` is a `xs:boolean` type,
so we cannot configure this as:

[source,xml]
----
<multicast stopOnException="{{stop}}">
   ...
</multicast>
----

Instead, we must use the `prop:` namespace, so we must add this namespace
in the top of the XML file in the `<beans>` tag.

To configure the option we must then use the `prop:optionName` as shown below:

[source,xml]
----
<multicast prop:stopOnException="stop">
  ...
</multicast>
----

The complete example is below:

[source,xml]
----
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:prop="http://camel.apache.org/schema/placeholder"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
           http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd">

    <bean id="damn" class="java.lang.IllegalArgumentException">
        <constructor-arg index="0" value="Damn"/>
    </bean>

    <camelContext xmlns="http://camel.apache.org/schema/spring">
        <propertyPlaceholder id="properties" location="classpath:myprop.properties"/>
        <route>
            <from uri="direct:start"/>
            <!-- use prop namespace, to define a property placeholder, which maps to option stopOnException={{stop}} -->
            <multicast prop:stopOnException="stop">
                <to uri="mock:a"/>
                <throwException ref="damn"/>
                <to uri="mock:b"/>
            </multicast>
        </route>
    </camelContext>
</beans>
----

In our properties file we have the value defined as:

[source,properties]
----
stop = true
----


== Bridging Camel property placeholders with Spring XML files

NOTE: If you are using Spring Boot then this does not apply.
This is only for legacy Camel and Spring applications which are using Spring XML files.

The Spring Framework does not allow third-party frameworks such as
Apache Camel to seamless hook into the Spring property placeholder
mechanism. However, you can bridge Spring and Camel by declaring a
Spring bean with the type
`org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer`,
which is a Spring
`org.springframework.beans.factory.config.PropertyPlaceholderConfigurer`
type.

To bridge Spring and Camel you must define a single bean as shown below:

[source,xml]
----
<!-- bridge spring property placeholder with Camel -->
<!-- you must NOT use the <context:property-placeholder at the same time, only this bridge bean -->
<bean id="bridgePropertyPlaceholder" class="org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer">
  <property name="location" value="classpath:org/apache/camel/component/properties/cheese.properties"/>
</bean>
----

You *must not* use the spring `<context:property-placeholder>` namespace
at the same time; this is not possible.

After declaring this bean, you can define property placeholders using
both the Spring style, and the Camel style within the `<camelContext>`
tag as shown below:

[source,xml]
----
<!-- a bean that uses Spring property placeholder -->
<!-- the ${hi} is a spring property placeholder -->
<bean id="hello" class="org.apache.camel.component.properties.HelloBean">
  <property name="greeting" value="${hi}"/>
</bean>

<camelContext xmlns="http://camel.apache.org/schema/spring">
  <!-- in this route we use Camels property placeholder {{ }} style -->
  <route>
    <from uri="direct:{{cool.bar}}"/>
    <bean ref="hello"/>
    <to uri="{{cool.end}}"/>
  </route>
</camelContext>
----

Notice how the hello bean is using pure Spring property placeholders using
the `${}` notation. And in the Camel routes we use the Camel
placeholder notation with `{\{key}}`.

== Using property placeholder functions

The xref:components::properties-component.adoc[Properties] component includes the following functions out of the box:

* `env` - A function to lookup the property from OS environment variables
* `sys` - A function to lookup the property from Java JVM system properties
* `bean` - A function to lookup the property from the return value of bean's method (requires `camel-bean` JAR)
* `service` - A function to lookup the property from OS environment variables using the service naming idiom
* `service.name` - A function to lookup the property from OS environment variables using the service naming idiom returning the hostname part only
* `service.port` - A function to lookup the property from OS environment variables using the service naming idiom returning the port part only

These functions are intended to make it easy to lookup values from the environment, as shown in the example below:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{env:SOMENAME}}"/>
        <to uri="{{sys:MyJvmPropertyName}}"/>
    </route>
</camelContext>
----

You can use default values as well, so if the property does not exist, you can define a default value as shown below, where the default value is a `log:foo` and `log:bar` value.

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{env:SOMENAME:log:foo}}"/>
        <to uri="{{sys:MyJvmPropertyName:log:bar}}"/>
    </route>
</camelContext>
----

The service function is for looking up a service which is defined using OS environment variables using the service naming idiom, to refer to a service location using `hostname : port`

* __NAME__**_SERVICE_HOST**
* __NAME__**_SERVICE_PORT**

in other words the service uses `_SERVICE_HOST` and `_SERVICE_PORT` as prefix.
So if the service is named FOO, then the OS environment variables should be set as

[source,bash]
----
export $FOO_SERVICE_HOST=myserver
export $FOO_SERVICE_PORT=8888
----

For example if the FOO service a remote HTTP service, then we can refer to the service in the Camel endpoint uri, and use the HTTP component to make the HTTP call:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="http://{{service:FOO}}/myapp"/>
    </route>
</camelContext>
----

And we can use default values if the service has not been defined, for example to call a service on localhost, maybe for unit testing.

[source,xml]
----
<camelContext>
<route>
    <from uri="direct:start"/>
    <to uri="http://{{service:FOO:localhost:8080}}/myapp"/>
</route>
</camelContext>
----

The bean function (you need to have `camel-bean` JAR on classpath) is for looking up the property from the return value of bean's method.

Assuming we have registered a bean named 'foo' that has a method called 'bar' that returns a directory name, then we can refer to the bean's method in the camel endpoint url, and use the file component to poll a directory:

[source,xml]
----
<camelContext>
<route>
    <from uri="file:{{bean:foo.bar}}"/>
    <to uri="direct:result"/>
</route>
</camelContext>
----

IMPORTANT: The method must be a public no-arg method (i.e. no parameters) and return a value such as a String, boolean, int.

=== Using Kubernetes property placeholder functions

The `camel-kubernetes` component include the following functions:

* `configmap` - A function to lookup the string property from Kubernetes ConfigMaps.
* `configmap-binary` - A function to lookup the binary property from Kubernetes ConfigMaps.
* `secret` - A function to lookup the string property from Kubernetes Secrets.
* `secret-binary` - A function to lookup the binary property from Kubernetes Secrets.

The syntax for both functions are:

[source]
----
configmap:name/key[:defaultValue]
----

Where the default value is optional, for example the following will lookup `myKey`,
and fail if there is no such configmap.

[source]
----
configmap:mymap/mykey
----

In this example then it would not fail as a default value is provided:

[source]
----
configmap:mymap/mykey:123
----

If the value stored in the configmap is in binary format, so it is stored as `Binary Data`, it will be downloaded in a file, and it returns the absolute path of the file

[source]
----
configmap-binary:mymap/mybinkey
----

it returns a path like `/tmp/camel11787545916150467474/mybinkey`

Before the Kubernetes property placeholder functions can be used they need to be configured with either (or both)

- path - A _mount path_ that must be mounted to the running pod, to load the configmaps or secrets from local disk.
- kubernetes client - *Autowired* An `io.fabric8.kubernetes.client.KubernetesClient` instance to use for connecting to the Kubernetes API server.

Camel will first use _mount paths_ (if configured) to lookup, and then fallback to use the `KubernetesClient`.

==== Configuring mount paths for ConfigMaps and Secrets

The configuration of the _mount path_ are used by the given order:

1. Reading configuration property with keys `camel.kubernetes-config.mount-path-configmaps`
and `camel.kubernetes-config.mount-path-secrets`.
2. Use JVM system property with key `camel.k.mount-path.configmaps` and `camel.k.mount-path.secrets` (Camel K compatible).
3. Use OS ENV variable with key `CAMEL_K_MOUNT_PATH_CONFIGMAPS` and `CAMEL_K_MOUNT_PATH_SECRETS` (Camel K compatible).

For example to use `/etc/camel/resources/` as mount path, you can configure this in the `application.properties`:

[source,properties]
----
camel.kubernetes-config.mount-path-configmaps = /etc/camel/myconfig/
camel.kubernetes-config.mount-path-secrets = /etc/camel/mysecrets/
----

==== Configuring Kubernetes Client

Camel will autowire the `KubernetesClient` if a single instance of the client exists in the running application (lookup via the xref:registry.adoc[Registry]).
Otherwise, a new `KubernetesClient` is created. The client can be configured from either

- Using `camel.kubernetes-config.client.` properties (see below for example)
- Attempt to auto-configure itself by a combination of OS Environment variables, reading from `~./kube/config` configuration,
and service account token file. For more details see the https://github.com/fabric8io/kubernetes-client documentation.

You most likely only need to explicit configure the `KubernetesClient` when you want to connect
from a local computer to a remote Kubernetes cluster, where you can specify various options,
such as the masterUrl and oauthToken as shown:

[source,properties]
----
camel.kubernetes-config.client.masterUrl = https://127.0.0.1:50179/
camel.kubernetes-config.client.oauthToken = eyJhbGciOiJSUzI1NiIsImtpZCI...
----

The `KubernetesClient` has many options, see the https://github.com/fabric8io/kubernetes-client documentation.

If you only use _mount paths_, then it is good practice to disable `KubernetesClient` which can be done by setting enabled to false as show:

[source,properties]
----
camel.kubernetes-config.client-enabled = false
----

When running your Camel applications inside an existing Kubernetes cluster, then you often
would not need to explicit configure the `KubernetesClient` and can rely on default settings.

TIP: If you use Camel Quarkus, then it is recommended to use their https://quarkus.io/guides/kubernetes-config
which automatic pre-configure the `KubernetesClient` which Camel then will reuse.

==== Using configmap with Kubernetes

Given a configmap named `myconfig` in Kubernetes that has two entries:

[source,properties]
----
drink = beer
first = Carlsberg
----

Then these values can be used in your Camel routes such as:

[source,xml]
----
<camelContext>
  <route>
    <from uri="direct:start"/>
    <log message="What {{configmap:myconfig/drink}} do you want?"/>
    <log message="I want {{configmap:myconfig/first}}"/>
  </route>
</camelContext>
----

You can also provide a default value in case a key does not exist:

[source,xml]
----
    <log message="I want {{configmap:myconfig/second:Heineken}}"/>
----

==== Using secrets with Kubernetes

Camel reads ConfigMaps from the Kubernetes API Server. And when RBAC is enabled on the cluster,
the ServiceAccount that is used to run the application needs to have the proper permissions for such access.

A secret named `mydb` could contain username and passwords to connect to a database such as:

[source,properties]
----
myhost = killroy
myport = 5555
myuser = scott
mypass = tiger
----

This can be used in Camel with for example the Postrgres Sink Kamelet:

[source,xml]
----
<camelContext>
  <route>
    <from uri="direct:rome"/>
    <setBody>
      <constant>{ "username":"oscerd", "city":"Rome"}</constant>
    </setBody>
    <to uri="kamelet:postgresql-sink?serverName={{secret:mydb/myhost}}
             &amp;serverPort={{secret:mydb/myport}}
             &amp;username={{secret:mydb/myuser}}
             &amp;password={{secret:mydb/mypass}}
             &amp;databaseName=cities
             &amp;query=INSERT INTO accounts (username,city) VALUES (:#username,:#city)"/>
  </route>
</camelContext>
----

The postgres-sink Kamelet can also be configured in `application.properties` which reduces the configuration
in the route above:

[source,properties]
----
camel.component.kamelet.postgresql-sink.databaseName={{secret:mydb/myhost}}
camel.component.kamelet.postgresql-sink.serverPort={{secret:mydb/myport}}
camel.component.kamelet.postgresql-sink.username={{secret:mydb/myuser}}
camel.component.kamelet.postgresql-sink.password={{secret:mydb/mypass}}
----

Which reduces the route to:

[source,xml]
----
<camelContext>
  <route>
    <from uri="direct:rome"/>
    <setBody>
      <constant>{ "username":"oscerd", "city":"Rome"}</constant>
    </setBody>
    <to uri="kamelet:postgresql-sink?databaseName=cities
             &amp;query=INSERT INTO accounts (username,city) VALUES (:#username,:#city)"/>
  </route>
</camelContext>
----

==== Using configmap or secrets in local-mode

During development you may want to run in _local mode_ where you do not need acces to a Kubernetes cluster, to lookup the configmap.
In the local mode, then Camel will lookup the configmap _keys_ from local properties, eg:

For example the example above with the postgresql kamelet, that was configured using a secret:

[source,properties]
----
camel.component.kamelet.postgresql-sink.databaseName={{secret:mydb/myhost}}
camel.component.kamelet.postgresql-sink.serverPort={{secret:mydb/myport}}
camel.component.kamelet.postgresql-sink.username={{secret:mydb/myuser}}
camel.component.kamelet.postgresql-sink.password={{secret:mydb/mypass}}
----

Now suppose we have a local Postrgres database we want to use, then we can turn on _local mode_
and specify the credentials in the same properties file:

[source,properties]
----
camel.kubernetes-config.local-mode = true
mydb/myhost=localhost
mydb/myport=1234
mydb/myuser=scott
mydb/mypass=tiger
----

NOTE: Notice how the key is prefixed with the name of the secret and a slash, eg `name/key`. This makes it easy to copy/paste
from the actual use of the configmap/secret and into the `application.properties` file.

=== Using custom property placeholder functions

The xref:components::properties-component.adoc[Properties] component allow to plugin 3rd party functions which can be used during parsing of the property placeholders.
These functions are then able to do custom logic to resolve the placeholders, such as looking up in databases, do custom computations, or whatnot.
The name of the function becomes the prefix used in the placeholder.

This is best illustrated in the example route below, where we use `beer` as the prefix:

[source,xml]
----
<route>
    <from uri="direct:start"/>
    <to uri="{{beer:FOO}}"/>
    <to uri="{{beer:BAR}}"/>
</route>
----

The implementation of the function is only two methods as shown below:

[source,java]
----
@org.apache.camel.spi.annotations.PropertiesFunction("beer")
public class MyBeerFunction implements PropertiesFunction {

    @Override
    public String getName() {
        return "beer";
    }

    @Override
    public String apply(String remainder) {
        return "mock:" + remainder.toLowerCase();
    }
}
----

The function must implement the `org.apache.camel.spi.PropertiesFunction` interface.
The method `getName` is the name of the function (beer).
And the `apply` method is where we implement the custom logic to do.
As the sample code is from a unit test, it just returns a value to refer to a mock endpoint.

You also need to have `camel-component-maven-plugin` as part of building the component will
then ensure that this custom properties function has necessary source code generated that makes Camel
able to automatically discover the function.

NOTE: If the custom properties function need logic to startup and shutdown, then the function can extend `ServiceSupport`
and have this logic in `doStart` and `doStop` methods.

TIP: For an example see the `camel-base64` component.

== Using third party property sources

The properties component allows to plugin 3rd party sources to load and lookup properties via the `PropertySource`
API from camel-api.

The regular `PropertySource` will lookup the property on-demand,
for example to lookup values from a backend source such as a database or HashiCorp Vault etc.

A `PropertySource` can define that it supports loading all its properties
(by implementing `LoadablePropertiesSource`) from the source at once, for example from file system.
This allows Camel properties component to load these properties at once during startup.

For example the `camel-microprofile-config` component is implemented using this.
The 3rd-party `PropertySource` can automatically be discovered from classpath when Camel is starting up.
This is done by including the file `META-INF/services/org/apache/camel/property-source-factory` which refers to the fully qualified class name of the `PropertySource` implementation.

See xref:components:others:microprofile-config.adoc[MicroProfile Config] component as an example.

You can also register 3rd-party property sources via Java API:

[source,java]
----
PropertiesComponent pc = context.getPropertiesComponent();
pc.addPropertiesSource(myPropertySource);
----

= UUID Generator

Camel supports third-party UUID generator(s).

A useful scenario is to use a simple counter for testing purpose. With this, it is
easier to correlate the exchanges in the log/debugger.

Camel uses UUIDs in the exchange and message ids, and other unique ids
it uses.

You only have to implement `org.apache.camel.spi.UuidGenerator` and tell
Camel, that it should use your custom implementation:

== Configuring UuidGenerator

[source,java]
----
getContext().setUuidGenerator(new MyCustomUuidGenerator());
----

Camel will configure this UUID generator by doing a lookup in the Spring
bean registry to find the bean of the type `org.apache.camel.spi.UuidGenerator`.

[source,xml]
----
<bean id="simpleUuid" class="org.apache.camel.support.SimpleUuidGenerator" />

<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
  <route>
    <from uri="direct:start" />
    <to uri="mock:result" />
  </route>
</camelContext>
----

== Standard UUID Generators

Camel comes with the following implementations out of the box:

* `org.apache.camel.support.ClassicUuidGenerator`: this is the classic Camel 2.x generator
* `org.apache.camel.support.DefaultUuidGenerator`: default generator (32 chars) optimized for Camel usage
* `org.apache.camel.support.ShortUuidGenerator`: Is 50% the size of the default (16 chars) optimized for Camel usage
* `org.apache.camel.support.SimpleUuidGenerator`: This implementation uses
internally a `java.util.concurrent.atomic.AtomicLong` and increases the
ID for every call by one. Starting with 1 as the first id.
= Validator

Validator performs declarative validation of the message according to the declared
_Input Type_ and/or _Output Type_ on a route definition which declares the expected
message type.


== Data type format

[source,text]
----
scheme:name
----

where *scheme* is the type of data model like `java`, `xml` or `json`, and *name* is the individual
data type name.

== Supported Validators

[width="100%",cols="25%,75%",options="header",]
|===
| Validator | Description
| Predicate Validator | Validate with using Expression or Predicate
| Endpoint Validator | Validate by forwarding to the Endpoint to be used with validation component such as Validation Component or Bean Validation Component.
| Custom Validator | Validate with using custom validator class. Validator must be a subclass of `org.apache.camel.spi.Validator`
|===


== Common Options
All validators have following common options to specify which data type is supported by the validator.
`type` must be specified.

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| type | Data type to validate
|===


== Predicate Validator Options

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| expression | Expression or Predicate to be used for validation
|===

Here is an example to specify a validation predicate:

Java DSL:

[source,java]
----
validator()
    .type("csv:CSVOrder")
    .withExpression(bodyAs(String.class).contains("{name:XOrder}"));
----

XML DSL:

[source,xml]
----
<predicateValidator Type="csv:CSVOrder">
    <simple>${body} contains '{name:XOrder}'</simple>
</predicateValidator>
----

== Endpoint Validator Options

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| ref | Reference to the Endpoint ID
| uri | Endpoint URI
|===

Here is an example to specify endpoint URI in Java DSL:

[source,java]
----
validator()
    .type("xml")
    .withUri("validator:xsd/schema.xsd");
----

And here is an example to specify endpoint ref in XML DSL:

[source,xml]
----
<endpointValidator uri="validator:xsd/schema.xsd" type="xml"/>
----

Note that the Endpoint Validator just forwards the message to the specified endpoint. In above example,
camel forwards the message to the `validator:` endpoint, which actually is a
xref:components::validator-component.adoc[Validation Component]. You can also use any other validation component like
Bean Validation Component.

== Custom Validator Options

The validator must be an implementation of `org.apache.camel.spi.Validator`

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| ref | Reference to the custom Validator bean ID
| className | Fully qualified class name of the custom Validator class
|===

Here is an example to specify custom Validator class:

Java DSL:

[source,java]
----
validator()
    .type("json")
    .withJava(com.example.MyCustomValidator.class);
----

XML DSL:

[source,xml]
----
<customTransformer className="com.example.MyCustomValidator" type="json"/>
----

== Examples

For example to declare the Endpoint Validator which uses
validator component to validate `xml:ABCOrder`, we can do as follows:

Java DSL:

[source,java]
----
validator()
    .type("xml:ABCOrder")
    .withUri("validator:xsd/schema.xsd");
----

And in XML DSL:

[source,xml]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
    <validators>
        <endpointValidator uri="validator:xsd/schema.xsd" type="xml:ABCOrder"/>
    </validators>
</camelContext>
----

If you have following route definition, above validator will be applied when `direct:abc` endpoint
receives the message. Note that `inputTypeWithValidate` is used instead of `inputType` in Java DSL,
and the `validate` attribute on the inputType declaration is set to `true` in XML DSL:

Java DSL:

[source,java]
----
from("direct:abc")
    .inputTypeWithValidate("xml:ABCOrder")
    .log("${body}");
----

XML DSL:

[source,xml]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
    <route>
        <from uri="direct:abc"/>
        <inputType urn="xml:ABCOrder" validate="true"/>
        <log message="${body}"/>
    </route>
</camelContext>
----

== See Also

The xref:transformer.adoc[Transformer] is a related functionality.= Variables

*Available from Camel 4.4*

In Camel 4.4, we have introduced the concept of _variables_.

A variable is a key/value that can hold a value that can either be private per `Exchange`,
or shared per route, or per `CamelContext`.

NOTE: You can also use _exchange properties_ as variables, but the exchange properties are also used internally by Camel,
and some EIPs and components. With the newly introduced _variables_ then these are exclusively for end users.

== Variable Repository

The variables are stored in one or more `org.apache.camel.spi.VariableRepository`. By default, there are the following repositories

- `ExchangeVariableRepository` - A private repository per `Exchange` that holds variables that are private for the lifecycle of each `Exchange`.
- `RouteVariableRepository` - Uses `route` as id. A single repository, that holds variables per `Route`.
- `GlobalVariableRepository` - Uses `global` as id. A single global repository for the entire `CamelContext`.

The `ExchangeVariableRepository` is special as its private per exchange and is the default repository when used during routing.
The `RouteVariableRepository` is a single repository that holds variables that are route scoped.

TIP: There is also `org.apache.camel.spi.BrowsableVariableRepository` which is an extension to `VariableRepository` that
has APIs to browse the current variables. Camel uses this with Camel JBang, and JMX to be able to see the current variables
from management tooling, CLI, and the developer console.

=== Custom variable repositories

You can implement custom `org.apache.camel.spi.VariableRepository` and plugin to be used out of the box with Apache Camel.
For example, you can build a custom repository that stores the variables in a database, so they are persisted.

Each repository must have its own unique id. However, it's also possible to replace the default `global`, or `route` repositories with another.

IMPORTANT: The id `exchange` and `header` is reserved by Camel internally and should not be used as id for custom repositories.

== Getting and setting variables from Java API

To get a local variable from the current exchange, you can do this via Java API:

[source,java]
----
String myValue = "...";
exchange.setVariable("myKey", myValue);

// and later to get the variable
Object val = exchange.getVariable("myKey");

// you can get the value as a specific type
String str = exchange.getVariable("myKey", String.class);
----

The API on `Exchange` will by default get the variables from its local private repository.
However, you can also get variables from other repositories, such as the `global` as show:

[source,java]
----
Object val = exchange.getVariable("global:myGlobalKey");
----

And you can also assign a global variable by prefixing with `global:` as follows:

[source,java]
----
exchange.setVariable("global:myGlobalKey", someObjectHere);
----

There is also API on `CamelContext` to get variables. However, this API will by default get from the `global` repository,
as it's not possible to get variables from any inflight `Exchange` currently being routed.

[source,java]
----
Object val = context.getVariable("myGlobalKey");

// you can get the value as a specific type
String str = context.getVariable("myGlobalKey", String.class);
----

You can also assign a variable to a specific route with `route:` as follows:

[source,java]
----
exchange.setVariable("route:myRouteId:myRouteKey", someObjectHere);
----

And you can get route variables as well:

[source,java]
----
Object val = context.getVariable("route:myRouteId:myRouteKey");

// you can get the value as a specific type
String str = context.getVariable("route:myRouteId:myRouteKey", String.class);
----

== Setting and getting variables from DSL

It is also possible to use variables in Camel xref:routes.adoc[routes] using the
setVariable, removeVariable, and convertVariableTo EIPs.

These EIPs make it possible to set and remove variables from routes. And you can also access variables from the xref:components:languages:simple-language.adoc[Simple] language.

In the following route, we set a variable on the exchange which we use later to build a human-readable event message:

[tabs]
====
Java::
+
[source,java]
----
from("kafka:order.in")
  .setVariable("customerId", jq(".customer.custId"))
  .setVariable("country", jq(".customer.address.co"))
  .transform().simple("Order received from customer ${variable.customerId} in ${variable.country}")
  .to("kafka:order.event");
----

XML::
+
[source,xml]
----
<route>
    <from uri="kafka:order.in"/>
    <setVariable name="customerId">
        <jq>.customer.custId</jq>
    </setVariable>
    <setVariable name="country">
        <jq>.customer.address.co</jq>
    </setVariable>
    <transform>
        <simple>Order received from customer ${variable.customerId} in ${variable.country}</simple>
    </transform>
    <to uri="kafka:order.event"/>
</route>
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: kafka:order.in
      steps:
        - setVariable:
            name: customerId
            jq:
              expression: .customer.custId
        - setVariable:
            name: country
            jq:
              expression: .customer.address.co
        - transform:
            simple:
              expression: "Order received from customer ${variable.customerId} in ${variable.country}"
        - to:
            uri: kafka:order.event
----
====

When `route` variables in Camel routes, then the `routeId` is implied as the current route, if not explicit declared.
For example, the following example the first route will set a variable (`route:second:foo`) in the second route.
Then the second route can get hold of the variable without having to specify its route id `route:foo`:

[tabs]
====
Java::
+
[source,java]
----
from("direct:start").routeId("first")
    // sets variable in another route
    .setVariable("route:second:foo").constant("Hello World")
    .to("mock:end");

from("direct:second").routeId("second")
    // use variable from this route
    .setBody().variable("route:foo");
----
====


== Configuring initial variables on startup

When Camel is starting then it's possible to configure initial variables for `global` and `route` repositories only.

This can be done in `application.properties` as shown below:

[source,properties]
----
camel.variable.greeting = Random number
camel.variable.random = 999
----

The variables are default set on the `global` repository, but you can set route scoped variables,
using `route.` as prefix. As we cannot use colon (`:`) in property keys, then dot is used to separate
the route id from the variable name, eg `myRoute.gold`.

[source,properties]
----
camel.variable.route.myRoute.gold = true
camel.variable.greeting = Random number
camel.variable.random = 999
----

Here the gold variable is set on the `route` repository, and the other variables are set on the `global` repository.

The value of a variable can also be loaded from the file system, such as a JSon file. To do this, you should
prefix the value with `resource:file:` or `resource:classpath:` to load from the file system or classpath,
as shown below:

[source,properties]
----
camel.variable.user-template = resource:file:/etc/user.json
----

Camel (*Camel 4.8*) will automatically convert the value to appropriate type:

- all digits are converted to an int or long
- true/false are converted to a boolean
- otherwise string value

There is also support for referring to other existing beans, using the `#bean:` syntax:

[source,properties]
----
camel.variable.cheese = #bean:myCheeseBean
----

Or create a new bean via the `#class:` or `#type:` syntax:

[source,properties]
----
camel.variable.cheese = #class:com.foo.MyClassName
----

Or if the value must be of a special type, you can specify this via `#valueAs` as follows:

[source,properties]
----
camel.variable.amount = #valueAs(float):1.23
----

== Using Variables with EIPs

The following commonly used EIPs for sending and receiving, and transforming messages, have
special support for choosing to use variables over the current `Exchange`:

- from
- to
- toD
- enrich
- poll
- pollEnrich
- wireTap
- unmarshal
- marshal

The intention is to make it more convenient and easy to _gather data_ from other systems without any ceremony to keep
existing data by using techniques such as storing the data temporary using headers, exchange properties,
or with the xref:components:eips:claimCheck-eip.adoc[Claim Check] EIP.

=== Important concept when using variables and EIPs

It is **important** to understand that the variables focus the use of the message **body** only.
This is on purpose to keep it simpler and primary work with the message body as the user data.

The following table summarizes what the EIP supports with variables:

|===
|*EIP* | *VariableSend* | *VariableReceive*
| From | | yes
| To | yes | yes
| ToD | yes | yes
| Enrich | yes | yes
| Poll | | yes
| PollEnrich | | yes
| WireTap | yes |
| Unmarshal | yes | yes
| Marshal | yes | yes
|===

The EIPs listed above have support for using variables when sending and receiving data. This is done by using the `variableSend` and `variableReceive` options
to specify the name of the variable.

The EIPs works in two modes where *variableSend* and *variableReceive* are a little bit different, so pay attention to the following table:

|===
| *VariableSend*       | *VariableReceive*
| *Sending Headers:* Message   | *Received Headers:* Variable
| *Sending Body:* Variable     | *Received Body:* Variable
|===

The *VariableSend* is intended for sending as regular Camel where the sending headers are from the current `Message` and the body is
from the variable. In other words it's only the message body taken from the variable instead of the current `Message` body.

The *VariableReceive* works in a different mode. The idea is that all the received data is stored as variables. This means the current `Message`
is not changed at all. The received body is stored in the variable, and the received headers (transport headers etc.) are stored as read-only
headers as variables as well. The names of the variable is `header:variableName.headerName`. For example, if the variable is `myVar` and the header is `Content-Type`
then the header is stored as a variable with the full name `header:myVar.Content-Type`.

=== Example using Variable Receive

When the EIP is using *VariableReceive*, then the `Message` on the `Exchange` is not in use, but the body and headers will be from the variable.
For example, given the following `Message` containing:

[source,properties]
----
header.foo=123
header.bar=456
body=Hello World
----

And a remote service is called via the route below, and this service returns a new header (`level`) and body: 'Bye World'

[tabs]
====
Java::
+
[source,java]
----
from("direct:service")
  .to("http:myservice")
  .to("log:after");
----
XML::
+
[source,xml]
----
<route>
  <from uri="direct:service"/>
  <to uri="http:myservice"/>
  <to uri="log:after"/>
</route>
----
YAML::
+
[source,yaml]
----
from:
  uri: "direct:service"
  steps:
    - to: "http:myservice"
    - to: "log:after"
----
====

Calling this route, the `Message` is updated to following:

[source,properties]
----
header.foo=123
header.bar=456
header.level=gold
body=Bye World
----

However, if you use *VariableReceive=myVar* to store the returned data from calling the remote service into a variable, then
the result changes as follows:

[tabs]
====
Java::
+
[source,java]
----
from("direct:service")
  .toV("http:myservice", null, "myVar")
  .to("log:after");
----
XML::
+
[source,xml]
----
<route>
  <from uri="direct:service"/>
  <to uri="http:myservice" variableReceive="myVar"/>
  <to uri="log:after"/>
</route>
----
YAML::
+
[source,yaml]
----
from:
  uri: "direct:service"
  steps:
    - to:
        uri: http:myservice
        variableReceive: myVar
    - to: "log:after"
----
====

The `Message` on the current `Exchange` is not changed:

[source,properties]
----
header.foo=123
header.bar=456
body=Hello World
----

And the variable contains all the data received from the remote HTTP service separated into two variables:

[source,properties]
----
myVar=Bye World
header:myVar.level=gold
----

IMPORTANT: Notice the headers are stored with the syntax `header:variable.key`. In the example above the variable name is `myVar`,
and the header key is `level`, which gives: `header:myVar.level`.


=== Using variable to store incoming message body

You can configure the `from` to store the message body into a variable, instead of the `Message`. This makes it easy to have quick access
to the original incoming message body via the variable. Notice that the body on the `Message` will be `null`.

The following example from a unit test shows how to do this. Notice how Java DSL uses `fromV` to make it possible to specify
the name of the variable. In XML and YAML DSL you specify this using the `variableReceive` parameter.

[tabs]
====
Java::
+
[source,java]
----
fromV("direct:start", "myKey")
    .transform().simple("Bye ${body}")
    .to("mock:foo")
    .setBody(variable("myKey"))
    .to("mock:result");
----
XML::
+
[source,xml]
----
<route>
  <from uri="direct:start" variableReceive="myKey"/>
  <transform>
    <simple>Bye ${body}</simple>
  </transform>
  <to uri="mock:foo"/>
  <setBody>
    <variable>myKey</variable>
  </setBody>
  <to uri="mock:result"/>
</route>
----
YAML::
+
[source,yaml]
----
from:
  uri: "direct:start"
  variableReceive: "myKey"
  steps:
    - transform:
        simple: "Bye ${body}"
    - to: "mock:foo"
    - setBody:
        variable: "myKey"
    - to: "mock:result"
----
====

NOTE: In the examples above the transform `Bye $\{body}` will result as `Bye&#160;` because the `Message` has no message body, as the incoming
message body is stored in the variable `myKey` instead.
= What are the dependencies?

== Java support

- Camel 2 requires JDK 8
- Camel 3 requires JDK 8 and supports JDK 11
- Camel 3.15.0+ requires JDK 11
- Camel 3.17.0+ requires JDK 11 and supports JDK 17
- Camel 4.0.0+ requires JDK 17

== Camel JAR Dependencies

Camel core itself is lightweight, and only requires the `slf4j-api` logging API jar.

== Components

All the xref:components::index.adoc[Components] have a range of 3rd party
jars they depend on. They are listed in the maven pom files which files
they require.

= Writing Components

Apache Camel is designed to make it very easy to drop in new components
whether they be routing components, transformers, transports etc. The
idea of a component is to be a factory and manager of
xref:endpoint.adoc[Endpoints].

Here are the main steps to add a new component:

* Write a POJO which implements the `Component` interface. The simplest approach is just to derive from `DefaultComponent`.
* To support auto-discovery of your component, add a file of
`META-INF/services/org/apache/camel/component/FOO` where FOO is the URI
scheme for your component and any related endpoints created on the fly.
This file should contain the information of the component class full name.
For example if your component is implemented by the
`com.example.CustomComponent` class, the file should contain the
following line -- `class=com.example.CustomComponent`.

Users can then either explicitly create your component, configure it and
register it with a `CamelContext` or they can use a URI which auto-creates your component.

[NOTE]
====
It is recommended to bootstrap your initial component using xref:camel-maven-archetypes.adoc[Camel Maven Archetypes], as it will give you all the necessary bits to start developing your component with ease.
You will need as well to make sure to have xref:camel-component-maven-plugin.adoc[Camel Component Maven Plugin] included in your component's `pom.xml` file, order to generate all the necessary metadata and Java files for your component.
====

== Writing Endpoints

When implementing an xref:endpoint.adoc[Endpoint] you typically may
implement one or more of the following methods:

* `createProducer` will create a producer for sending message exchanges to the endpoint
* `createConsumer` implements the xref:components:eips:eventDrivenConsumer-eip.adoc[Event Driven Consumer]
pattern for consuming message exchanges from the endpoint.

Typically, you just derive from `DefaultEndpoint`

== Annotating your Endpoint

If you want to benefit from the automatic generation
of HTML documentation for all the parameters on your endpoint as part of
the maven site reports, you need to
xref:endpoint-annotations.adoc[annotate your Endpoint's parameters].

So this means you add a `@UriEndpoint` annotation to your Endpoint class
and then annotate each parameter you wish to be configured via the URI
configuration mechanism with `@UriParam` (or `@UriParams` for nested
configuration objects).

Refer to the xref:endpoint-annotations.adoc[Endpoint Annotations guide
for details].


== Options

If your component has options you can let it have public getters/setters
and Camel will automatically set the properties when the endpoint is
created.

If you however want to take the matter in your own hands, then
you must remove the option from the given parameter list as Camel will
validate that all options are used. If not Camel will throw a
`ResolveEndpointFailedException` stating which options are unknown.

The parameters are provided by Camel in the `createEndpoint` method from
`DefaultComponent` class:

[source,java]
----
protected abstract Endpoint<E> createEndpoint(String uri, String remaining, Map parameters)
----

The code is an example from the xref:components::seda-component.adoc[SEDA] component that removes the size
parameter:

[source,java]
----
    public BlockingQueue<Exchange> createQueue(String uri, Map parameters) {
        int size = 1000;
        Object value = parameters.remove("size");
        if (value != null) {
            Integer i = convertTo(Integer.class, value);
            if (i != null) {
                size = i;
            }
        }
        return new LinkedBlockingQueue<Exchange>(size);
    }
----

