= Camel Spring XML Auto Configuration

This is only applicable when using Spring XML files with the `camel-spring-xml` JAR.

A spring XML file is the XML files that uses `<beans>` as root tag and have an embedded `<camelContext>`.
This is the classic way of using XML DSL with Apache Camel. That was implemented before Spring Boot.

If you use Camel on Spring Boot, then look at xref:camelcontext-autoconfigure.adoc[Camel Context Auto Configuration] instead.

== Autoconfiguration of Optional Services

Camel will configure these functions by doing a lookup in the Spring
bean registry to find beans of the given type.

The following list all requires at most one bean defined. If there is
more than one bean of this type, then Camel will *not* use it.

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Type |Number of beans |Description
|`AsyncProcessorAwaitManager` |0..1 |To use a third-party async process await manager.
|`BacklogTracer` |0..1 |To use a third-party xref:backlog-tracer.adoc[BacklogTracer].
|`ClassResolver` |0..1 |To use a third-party class resolver. More details at xref:pluggable-class-resolvers.adoc[Pluggable Class Resolvers].
|`Debugger` |0..1 |To use a xref:debugger.adoc[Debugger] usually for tooling.
|`Delayer` |0..1 |To use a third-party xref:components:eips:delay-eip.adoc[Delayer].
|`EventFactory` |0..1 |To use a third-party event factory.
|`ExecutorServiceManager` |0..1 |To use a third-party executor service manager. More details at xref:threading-model.adoc[Threading Model].
|`ExecutorServiceStrategy` |0..1 |To use a third-party executor service strategy. More details at xref:threading-model.adoc[Threading Model].
|`FactoryFinderResolver` |0..1 |To use a third-party factory finder.
|`HeadersMapFactory` |0..1|To use a third-party HeadersMapFactory implementation.
|`HealthCheckRegistry` |0..1|To use a third-party xref:health-check.adoc[HealthCheckRegistry] implementation.
|`InflightRepository` |0..1 |To use a third-party in flight repository.
|`Logger` |0..1 |To use provided org.slf4j.Logger for xref:components::log-component.adoc[Log] component and xref:components:eips:log-eip.adoc[log() EIP].
|`ManagementObjectNameStrategy` |0..1 |To use a third-party strategy for naming `MBeans` for xref:jmx.adoc[management].
|`ManagementStrategy` |0..1 |To use a third-party strategy for xref:jmx.adoc[management], for example, JMX management.
|`MessageHistoryFactory` |0..1 |To use a third-party MessageHistoryFactory implementation.
|`ModelJAXBContextFactory` |0..1 |To use a third-party model JAXB ContextFactory
|`NodeIdFactory` |0..1 |To use a third-party node id factory.
|`PackageScanClassResolver` |0..1 |To use a third-party package scan resolver. More details at xref:pluggable-class-resolvers.adoc[Pluggable Class Resolvers].
|`ProcessorFactory` |0..1 |To use a third-party processor factory.
|`Registry` |0..1 |To use a third-party bean registry. By default, Camel will use Spring ApplicationContext (when using Spring) as registry.
|`RuntimeEndpointRegistry` |0..1 |To use a third-party `RuntimeEndpointRegistry` implementation.
|`RuntimeEndpointRegistry` |0..1|To use a third-party `RuntimeEndpointRegistry` implementation.
|`ShutdownStrategy` |0..1 |To use a third-party shutdown strategy.
|`StreamCachingStrategy` |0..1 |To use a third-party xref:stream-caching.adoc[Stream caching] strategy.
|`ThreadPoolFactory` |0..1 |To use a third-party thread pool factory. More details at xref:threading-model.adoc[Threading Model].
|`TraceFormatter` |0..1 |To use a bean that has the tracing options configured.
|`Tracer`` |0..1 |To use a third-party xref:tracer.adoc[Tracer].
|`UnitOfWorkFactory`` |0..1 |To use third-party `UnitOfWork` implementations created by the factory.
|`UuidGenerator`` |0..1 |To use a third-party xref:uuidgenerator.adoc[UuidGenerator].
|=======================================================================

And the following options have support for any number of beans defined.

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Type |Number of beans |Description
|`CamelClusterService` |0..n |To detect xref:clustering.adoc[Clustering] services.
|`EndpointStrategy` |0..n |To use third-party endpoint strategies.
|`EventNotifier` |0..n |To use third-party event notifiers.
|`HealthCheckRepository` |0..n|To use Camel xref:health-check.adoc[Health Check] repositories.
|`InterceptStrategy` |0..n |To use your own xref:components:eips:intercept.adoc[Intercept]that intercepts every processing step in all routes in the xref:camelcontext.adoc[CamelContext]. For instance, you can use this to do an AOP like performance timer interceptor.
|`LifecycleStrategy` |0..n |To use third-party lifecycle strategies.
|`LogListener` |0..n|To use custom `LogListener` implementations.
|`MainListener` |0..n|To use custom `MainListener` implementations.
|`ModelLifecycleStrategy` |0..n |To use third-party model lifecycle strategies.
|`RoutePolicyFactory` |0..n |To use a third-party route policy factory to create a route policy for every route.
|`ServiceRegistry` |0..n |To use camel-cloud xref:service-registry.adoc[Service Registries].
|=======================================================================

= AdviceWith

AdviceWith is used for testing Camel routes where you can _advice_ an existing route before its being tested.

What `adviceWith` allows is to change some factors on the route before the test is being run, such as:

* Intercept sending to endpoints
* Replace incoming endpoint with another
* Take out or replace node(s) of the route
* Insert new node(s) into the route
* Mock endpoints

All these features are available from `AdviceWithRouteBuilder`, which is a specialized
`RouteBuilder`.

== AdviceWithRouteBuilder API

The `AdviceWithRouteBuilder` extends the regular `RouteBuilder` adding specialized methods for _advicing_ routes. The table below lists
the most commonly used methods:

[width="100%",cols="1m,4",options="header",]
|=======================================================================
|Method |Description
| mockEndpoints | Mocks all endpoints in the route.
| mockEndpoints(patterns) | Mocks all endpoints in the route that matches the patterns. You can use wildcards and regular expressions in the given pattern to match multiple endpoints.
| mockEndpointsAndSkip(patterns) | Mocks all endpoints and skip sending to the endpoint in the route that matches the patterns. You can use wildcards and regular expressions in the given pattern to match multiple endpoints.
| replaceFromWith(uri) | To replace the route input with a new endpoint.
| weaveByUri(pattern) | Manipulates the route at the nodes sending to endpoints matching the pattern.
| weaveById(pattern) | Manipulates the route at the node IDs that matches the pattern.
| weaveByToString(pattern) | Manipulates the route at the node string representation(output from toString method) that matches the pattern.
| weaveByType(Class) | Manipulates the route at the node type (class name) that matches the pattern.
| weaveAddFirst | Easily weaves in new nodes at the beginning of the route.
| weaveAddLast | Easily weaves in new nodes at the end of the route.
|=======================================================================

=== Pattern matching

The pattern option is used for matching. It uses the same rules as xref:components:eips:intercept.adoc[Intercept], which is applied in the following order:

* match exact
* match by wildcard (`*`)
* match by regular expression

For example, to match exact, you can use `weaveById("foo")` which will match only the id in the route which has the value foo.
The wildcard is when the pattern ends with a `\*` character, such as: `weaveById("foo*")` which will match any id's starting with foo, such as: foo, foobar, foobie and so forth.
The regular expression is more advanced and allows you to match multiple ids, such as `weaveById("(foo|bar)")` which will match both foo and bar.

If you try to match a pattern on an exact endpoint URI, then mind that URI options ordering may influence, and hence it's best to match by wildcard.

For example, using `mockEndpointsAndSkip("activemq:queue:foo?*")` To match the foo queue and disregard any options.

== Using AdviceWith

To _advice_ you need to use the `AdviceWithRouteBuilder` for manipulating the route.
But first, you need to select which route to manipulate which you can do by the route ID or the route index.

[source,java]
----
AdviceWith.adviceWith(context, "myRoute", new AdviceWithRouteBuilder() {
        @Override
        public void configure() throws Exception {
            weaveAddLast().to("mock:result");
        }
});
----

We introduce a more modern API for _advicing_ routes using Java lambda style.

Below, we are _advicing_ the route with ID myRoute:

[source,java]
----
AdviceWith.adviceWith(context, "myRoute", a ->
     a.weaveAddLast().to("mock:result")
);
----

The variable `a` is a lambda style of the `AdviceWithRouteBuilder` which can be used as shorthand
for inlining the route manipulation.

IMPORTANT: Before using `adviceWith` then it is best to tell Camel that advice is in use, which is covered in the following section.

=== Enabling advice during testing

When `adviceWith` is being used, then Camel will restart the adviced routes. This happens
because the route is manipulated, and Camel needs to:

1. Stop the existing route
2. Remove the existing route
3. Add the new advised route
4. Start the new route

This happens for every _adviced_ route during startup of your unit tests. It happens
quickly: a route is started and then is immediately stopped and removed. This is
an undesired behavior; you want to avoid restarts of the _adviced_ routes.
This is solved by following the following steps:

1. Tell Camel that routes are being _adviced_, which will prevent Apache Camel from automatic starting routes.
2. Advice the routes in your unit test methods
3. Start Camel after you have _adviced_ the routes

When using xref:components:others:test-junit5.adoc[camel-test-junit5] for unit testing, then you can tell Camel that advice is in use by either
overriding the `isUsedAdviceWith` method from `CamelTestSupport` as shown:

[source,java]
----
public class MyAdviceWithTest extends CamelTestSupport {
    @Override
    public boolean isUseAdviceWith() {
        return true; // turn on advice with
    }
}
----

Or when using xref:components:others:test-spring-junit5.adoc[camel-test-spring-junit5] for unit testing you can use the `@UseAdviceWith` annotation as shown:

[source,java]
----
@UseAdviceWith
public class MyAdviceWithTest extends CamelSpringTestSupport {
}
----

Then you advise the routes followed by starting Camel:

[source,java]
----
@Test
public void testMockEndpoints() throws Exception {
    AdviceWith.adviceWith(context, "myRoute", a ->
         a.mockEndpoints();
    );

    context.start();
----

In the unit test method above, we first advise the route by ID, where we auto mock all the endpoints.
After that we start Camel.

=== Logging before and after advicing routes

When using `adviceWith` then Camel will automatically log, the before and after, of each adviced route, in XML format.

However, this requires to have `camel-xml-jaxb` as dependency, which you can add as test scoped if using Maven:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-xml-jaxb</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
    <scope>test</scope>
</dependency>
----

It is possible to turn of logging as XML, by setting the logging to `false` as shown:

[source,java]
----
AdviceWith.adviceWith(context, "myRoute", false, a ->
     a.mockEndpoints();
);
----

=== Replacing route endpoints

You may have built Camel routes that start from endpoints that consume from databases,
message brokers, cloud systems, or other external systems.

To make unit testing these kinds of routes easier, you can replace the
route input endpoints with internal endpoints such as xref:components::direct-component.adoc[direct],
xref:components::seda-component.adoc[seda], xref:components::stub-component.adoc[stub].

The following illustrates how to do this:

[source,java]
----
@Test
public void testReplaceFrom() throws Exception {
    AdviceWith.adviceWith(context, "myRoute", a ->
        a.replaceFromWith("direct:start");
    );

    context.start();
----

This replaces the input endpoint (from) in the route with ID myRoute, with a direct endpoint, which makes it
easy to send a message to the route when unit testing.

=== Mocking endpoints

When using the `mockEndpoints` methods when _advicing_ routes, then Camel will log during startup
which endpoints have been _adviced_ and their corresponding mock uri, such as:

[source,log]
----
INFO  ceptSendToMockEndpointStrategy - Adviced endpoint [seda://camel] with mock endpoint [mock:seda:camel]
INFO  ceptSendToMockEndpointStrategy - Adviced endpoint [seda://other] with mock endpoint [mock:seda:other]
----

Here Camel have _adviced_ two endpoints:

- seda:camel --> mock:seda:camel
- seda:other --> mock:seda:other

This allows using the mock endpoints in your unit tests for testing, such as:

[source,java]
----
public void testMockEndpoints() throws Exception {
    // advice the route goes here
    // start camel after advice

    // use the auto mocked uris during testing
    getMockEndpoint("mock:seda:camel").expectedMessageCount(3);
    getMockEndpoint("mock:seda:other").expectedMessageCount(1);

    // send messages

    MockEndpoint.assertIsSatisfied(context);
}
----

Replacing the input endpoints, or mocking endpoints in Camel routes by using `adviceWith` is just the beginning
of the route manipulation capabilities available. The following section covers how to go even deeper.

=== Using weave to amend routes

When testing your Camel routes, you can use `adviceWith` to _weave_ the routes before testing.

The following methods are available for the `weave` methods:

[width="100%",cols="1m,4",options="header",]
|=======================================================================
|Method |Description
| remove| Removes the selected node(s).
| replace | Replaces the selected node(s) with the following nodes.
| before | Before the selected node(s), the following nodes is added.
| after | After the selected node(s), the following nodes is added.
|=======================================================================

For example, given the following route:

[source,java]
----
from("direct:start")
  .to("mock:foo")
  .to("mock:bar").id("bar")
  .to("mock:result");
----

Then let's go over the four methods to see how you can use them in unit tests

==== Replace

[source,java]
----
AdviceWith.adviceWith(context.getRouteDefinitions().get(0), context, new AdviceWithRouteBuilder() {
    @Override
    public void configure() throws Exception {
        // weave the node in the route which has id = bar
        // and replace it with the following route path
        weaveById("bar").replace().multicast().to("mock:a").to("mock:b");
    }
});
----

In this example we replace the `.to("mock:bar").id("bar")` with the `.multicast().to("mock:a").to("mock:b")`.
That means instead of sending the message to a mock:bar endpoint, we do a Multicast to mock:a and mock:b endpoints instead.

==== Remove

In the example below, we simply just remove the `.to("mock:bar").id("bar")` from the route:

[source,java]
----
AdviceWith.adviceWith(context.getRouteDefinitions().get(0), context, new AdviceWithRouteBuilder() {
    @Override
    public void configure() throws Exception {
        // weave the node in the route which has id = bar and remove it
        weaveById("bar").remove();
    }
});
----

==== Before

In the example below, we add the following nodes `to("mock:a").transform(constant("Bye World"))` before the node with the id bar.

[source,java]
----
AdviceWith.adviceWith(context.getRouteDefinitions().get(0), context, new AdviceWithRouteBuilder() {
    @Override
    public void configure() throws Exception {
        // weave the node in the route which has id = bar
        // and insert the following route path before the adviced node
        weaveById("bar").before().to("mock:a").transform(constant("Bye World"));
    }
});
----

That means the message being sent before to mock:bar would have been transformed to a constant message Bye World

==== After

In the example below, we add the following nodes `to("mock:a").transform(constant("Bye World"))` after the node with the id bar.

[source,java]
----
AdviceWith.adviceWith(context.getRouteDefinitions().get(0), context, new AdviceWithRouteBuilder() {
    @Override
    public void configure() throws Exception {
        // weave the node in the route which has id = bar
        // and insert the following route path after the advice node
        weaveById("bar").after().to("mock:a").transform(constant("Bye World"));
    }
});
----

That means the message being sent after mock:bar would have been transformed to a constant message Bye World

=== weave without using IDs

When weaving a route, you need to use one of the `weaveBy` methods
as criteria to select one or more nodes in the route graph.

Suppose you use the xref:components:eips:split-eip.adoc[Split] EIP in a route; then you can use `weaveByType` to select this EIP.
Given the following route:

[source,java]
----
from("file:inbox").routeId("inbox")
    .split(body())
    .transform(simple("${body.toLowerCase()}"))
        .to("mock:line")
    .end()
    .to("mock:combined");
----

Due to that route has only one xref:components:eips:split-eip.adoc[Split] EIP, you can use `weaveByType` to find this single
splitter in the route. Using `weaveByType` requires you to pass in the model type of
the EIP. The name of the model type is using the pattern _name_Definition.

[source,java]
----
weaveByType(SplitDefinition.class)
    .before()
        .transform(simple("${body},Camel is awesome"));
----

Here we weave and select the xref:components:eips:split-eip.adoc[Split] EIP and weave in a message transformation, that
is processed before calling the splitter. This means the message body is appended with _Camel is awesome_.

=== weaveByToUri

The `weaveByToUri` is a handy method that makes it easy to _weave_ a Camel route that
send messages to a given endpoint URI or pattern.

Given the following route having two branches in the xref:components:eips:choice-eip.adoc[Content Based Router] EIP:

[source,java]
----
from("direct:start")
    .choice()
        .when(header("foo")).to("direct:branch-1")
    .otherwise()
        .to("direct:branch-2");
----

Then we want to easily unit test this route, that messages are sent branch-1 or branch-2.
This can be done with the `weaveByToUri` as shown:

[source,java]
----
weaveByToUri("direct:branch*").replace().to("mock:cheese");
----

Notice the `weaveByToUri` method is using a wildcard (`*`) to match the two branches.

TIP: You can also use `mockEndpoints` to auto mock instead of `weaveByToUri` in the example above.
The `weave` methods have a lot more power to manipulate the route, such as message transformation, routing the message or much more.

=== weaveAddFirst and weaveAddLast

The `weaveAddFirst` and `weaveAddLast` is a shorthand to easily add nodes to the route.
These methods can only add to an existing route. If you want to manipulate the route, then use the other `weave` methods as already covered.

The `weaveAddFirst` method adds in the beginning of the route, and `weaveAddLast` at the end.
Using them works the same as the other `weaveBy` methods, so see above for examples.

=== weave using node selection

The `weaveBy` methods, select all matching nodes, which can be anything
from none, one, two, or more nodes. In those situations, you may want to narrow
the selection to a specific node. This can be done by using the select methods:

- `selectFirst` Selects only the first node.
- `selectLast` Selects only the last node.
- `selectIndex(index)` Selects only the nth node. The index is zero-based.
- `selectRange(from, to)` Selects the nodes within the given range. The index is zero-based.
- `maxDeep(level)` Limits the selection to at most N levels deep in the Camel route tree. The first level is number 1. So number 2 is the children of the first-level nodes.

Given the following route which has multiple xref:components:eips:filter-eip.adoc[Filter] EIP,
then we want to only advise the second filter.

[source,java]
----
from("file:inbox").routeId("inbox")
    .filter(header("foo"))
        .to("mock:foo")
    .end()
    .to("mock:a")
    .filter(header("bar"))
        .to("mock:bar")
    .end()
    .to("mock:b")
    .filter(header("cheese"))
        .to("mock:cheese")
    .end()
    .to("mock:c")
----

You can then use `weaveByType` to match the Filter EIPs and selectIndex to match the second found:

[source,java]
----
weaveByType(FilterDefinition.class).selectIndex(1).replace().to("mock:changed");
----

= Architecture

The following diagram shows a high-level view of the main concepts that make up Camel's architecture.

image::images/camel-architecture.png[image]

At the center of the diagram you have the _heart_ of Apache Camel; the xref:camelcontext.adoc[CamelContext].
The `CamelContext` is "Camel" ... the runtime Camel, that contains and holds everything together.

xref:routes.adoc[Routes] are defined using one of Camel’s xref:dsl.adoc[DSLs].
xref:processor.adoc[Processors] are used to transform and
manipulate messages during routing as well as to implement all the
xref:components:eips:enterprise-integration-patterns.adoc[EIP]s, which have
corresponding names in the DSLs. xref:component.adoc[Components] are the extension points in Camel
for adding connectivity to other systems. To expose these systems to the rest of Camel,
components provide an xref:endpoint.adoc[endpoint] interface.

== Routes 101

You use Camel for integration, and a key concept in Camel is xref:routes.adoc[routes] which
tells Camel how messages should be routed between systems.

A route has exactly one input xref:endpoint.adoc[endpoint],
and 0, 1 or more output xref:endpoint.adoc[endpoints].

You use Camel xref:dsl.adoc[DSL] to _code_ the xref:routes.adoc[routes].
For example the route below is coded in xref:java-dsl.adoc[Java DSL]:

[source,java]
----
public class MyRoute extends RouteBuilder {

    public void configure() throws Exception {
        from("ftp:myserver/folder")
            .to("activemq:queue:cheese");
    }
}
----

= BacklogDebugger

Camel supports a backlog debugger that is used for live debugging of
messages that are routed in Camel. 
The backlog debugger has additional functionality for easier debugging
aimed at tooling, than the Debugger. The backlog
debugger is exposed in JMX in the tracer node with the name
`BacklogDebugger`. The JMX API is defined in the
`org.apache.camel.api.management.mbean.ManagedBacklogDebuggerMBean`
interface.

You can enable or disable the BacklogDebugger dynamically, by calling
`enableDebugger` or `disableDebugger` methods.

NOTE: This requires to enabled JMX by including `camel-management` JAR in the classpath.

== Options

[width="100%",cols="10%,20%,70%",options="header",]
|=======================================================================
|Option |Default |Description
|`bodyIncludeFiles` |`true` |Whether to include the message body of file based messages. The overhead is that the file content has to be read from the file.
|`bodyIncludeStreams` |`false` |Whether to include the message body of stream based messages. If enabled then beware the stream may not be re-readable later. See more about Stream Caching.
|`bodyMaxChars` |`32kb` |To limit the message body to a maximum size in the traced message. Use 0 or negative value to use unlimited size.
|`includeExchangeProperties` |`true`|Whether to include the exchange properties in the traced message.
|`includeExchangeVariables` |`true`|Whether to include the exchange variables in the traced message.
|`standby` | `false` |Whether the debugger is standby. If a debugger is in standby then the debugger is activated during startup and are ready to be enabled manually via JMX or calling the enableDebugger method.
|`enabled` |`false` |Whether the debugger is enabled or not.
|`singleStepMode` |`false` |Whether currently in single step mode of a single Exchange.
|`singleStepLast` |`false` |In single step mode, then when the exchange is complete, then simulate a breakpoint as last, that allows to suspend and watch the exchange when complete (you can see message body as response, failed exception etc).
|=======================================================================

== Operations

[width="100%",cols="10%,20%,70%",options="header",]
|=======================================================================
|Option |Type |Description
|`addBreakpoint(nodeId)` |`void` |To add a breakpoint at the given node.
|`addConditionalBreakpoint(nodeId, language, predicate)` |`void` |To add a conditional breakpoint at the given node. The predicate is created from the language parameter.
|`disableBreakpoint(nodeId)` |`void` |To disable a breakpoint.
|`disableDebugger` |`void` |To disable the debugger
|`dumpTracedMessagesAsXml(nodeId)` |`String` |To dump the debugged messages from the give node id in XML format.
|`dumpTracedMessagesAsXml(nodeId, boolean)` |`String` |To dump the debugged messages from the give node id in XML format, optionally including the exchange properties.
|`enableBreakpoint(nodeId)` |`void` |To activate a breakpoint which has been disabled.
|`enableDebugger` |`void` |To enable the debugger
|`evaluateExpressionAtBreakpoint(nodeId, language, expression)` | `String`|To evaluate an expression in any supported language (e.g. Simple, CSimple, etc.) and convert the result to String
|`evaluateExpressionAtBreakpoint(nodeId, language, expression, resultType)` | `Object`|To evaluate an expression in any supported language (e.g. Simple, CSimple, etc.) and return the result as a given result type
|`getBreakpoints` |`Set<String>` |To get a set of all the nodes which has a breakpoint added.
|`getDebuggerCounter` |`long` |Gets the total number of debugged messages.
|`getSuspendedBreakpointNodeIds` |`Set<String>` |To get a set of all the nodes which has suspended breakpoints (eg an Exchange at the breakpoint which is suspended).
|`removeBreakpoint(nodeId)` |`void` |To remove the breakpoint from the given node id.
|`resetDebuggerCounter` |`void` |To reset the debugger counter.
|`resumeAll` |`void` |To resume all suspended breakpoints.
|`resumeBreakpoint(nodeId)` |`void` |To resume a suspend breakpoint, which will then continue routing the Exchange.
|`setExchangePropertyOnBreakpoint(nodeId,exchangePropertyName,value)` |`void` |To update/add the Exchange property on the suspended Exchange at the node.
|`setFallbackTimeout(value)` |`long` |Fallback Timeout in seconds (300 seconds as default) when block the message processing in Camel. A timeout used for waiting for a message to arrive at a given breakpoint. `
|`setMessageBodyOnBreakpoint(nodeId,body)` |`void` |To update the message body on the suspended Exchange at the node.
|`setMessageHeaderOnBreakpoint(nodeId,headerName,value)` |`void` |To update/add the message header on the suspended Exchange at the node.
|`stepBreakpoint(nodeId)` |`void` |To start single step mode from a suspended breakpoint at the given node. Then invoke `step` to step to next node in the route.
|`step` |`void` |To step to next node when in single step mode.
|`validateConditionalBreakpoint` |`String` |Used for validating if a given predicate is valid or not. Returns null if valid, otherwise a string with the error message.
|`messageHistoryOnBreakpointAsXml(nodeId)` |`String` |Returns message history at the given node Id in XML format
|=======================================================================

== Enabling

You would need to enable backlogger debugger using the JMX API.

== See Also

See xref:debugger.adoc[Debugger]= BacklogTracer

Camel supports a backlog tracer interceptor that is used for capturing a
trace message of each message as they are routed in Camel.
The trace message is stored in a backlog queue, which contains the last
N messages for each node in the routes (by default 10).

== What is the difference between BacklogTracer and Tracer

Camel also provides a xref:tracer.adoc[Tracer] which has similar
capabilities as this backlog tracer. The difference is that the backlog
tracer is storing a capture of the message in an internal backlog queue.

The xref:tracer.adoc[Tracer] is event based and logs the messages as they
happen (or route to another Camel destination).

Use the xref:tracer.adoc[Tracer] when all you need is to log the traced messages
as they happen.

The backlog tracer allows you to pull the messages from
the backlog queues on demand. The backlog tracer works better with JMX
capable tooling as it is simpler, allowing to bulk dump all its traced
messages in either a POJO or XML format.

== Options

[width="100%",cols="10%,10%,80%",options="header",]
|===

|Option |Default |Description

|standby | `false` |Whether the tracer is standby. If a tracer is in standby then the tracer is activated during startup and are ready to be enabled manually via JMX or calling the enabled method.
|enabled |`false` |Flag to enable or disable this tracer

|backlogSize |`100` |Maximum number of total traced messages to keep in the backlog (FIFO
queue). Should be between 1 - 1000.

|tracePattern |`null` |Allows to filter tracing using a pattern that matches against the node
id and route id. For example use `"to1,to2"` to match only nodes with
either the name "to1", or "to2". You can use * for wildcards. So you can
do "to*" to match any to. Or use "route-foo*" to match any foo routes.

|traceFilter |`null` |Allow to configure a filter as a xref:predicate.adoc[Predicate] using
any of the Camel xref:languages.adoc[languages]. But default the
xref:components:languages:simple-language.adoc[Simple] language is used. For example to filter on
messages with a given header, use `${header.foo} != null`. To use
xref:components:languages:groovy-language.adoc[Groovy] then prefix the value with "groovy:". And
similar for the other languages.

|traceRests |`false` | Whether tracing should trace inner details from Rest DSL.
Turning this on increases the verbosity of tracing by including events from internal routes by Rest DSL.

|traceTemplates |`false` | Whether tracing should trace inner details from route templates (or kamelets).
Turning this on increases the verbosity of tracing by including events from internal routes in the templates or kamelets.

|removeOnDump |`true` |Whether to remove the traced messages that was returned when invoking
the dump methods.

|bodyMaxChars |`32kb` |To limit the message body to a maximum size in the traced message. Use 0
or negative value to use unlimited size.

|bodyIncludeStreams |`false` |Whether to include the message body of stream based messages. If enabled
then beware the stream may not be re-readable later. See more about
xref:stream-caching.adoc[Stream Caching].

|bodyIncludeFiles |`true` |Whether to include the message body of file based messages. The overhead
is that the file content has to be read from the file.

|includeExchangeProperties |`true` |Trace messages to include exchange properties.

|includeExchangeVariables |`true` |Trace messages to include exchange variables.

|includeException |`true` |Trace messages to include exception if the message failed.

|===

[[BacklogTracer-Operations]]
== Operations

[width="100%",cols="10%,20%,70%",options="header",]
|===

|Option |Default |Description

|getTraceCounter |`long` |Gets the total number of traced messages.

|getQueueSize |`long` |Number of traced messages in the backlog.

|resetTraceCounter |`void` |To reset the trace counter.

|dumpTracedMessages(nodeOrRouteId) |`List<BacklogTracerEventMessage>` |To dump the traced messages from the give node or route id.

|dumpTracedMessagesAsXml(nodeOrRouteId) |`String` |To dump the traced messages from the give node or route id in XML format.

|dumpTracedMessagesAsJSon(nodeOrRouteId) |`String` |To dump the traced messages from the give node or route id in JSon format.

|dumpAllTracedMessages |`List<BacklogTracerEventMessage>` |To dump all the traced messages

|dumpAllTracedMessagesAsXml |`String` |To dump all the traced messages in XML format.

|dumpAllTracedMessagesAsJSon |`String` |To dump all the traced messages in JSon format.

|===

== Enabling

You can turn off backlog tracing on `CamelContext`

[source,java]
----
camelContext.setBacklogTracing(true);
----

And in Spring XML

[source,xml]
----
<camelContext backlogTrace="true">
  ...
</camelContext>
----

And in Camel Main you can enable this  in the `application.properties` file:

[source,properties]
----
camel.main.backlog-tracing = true
----

And in Spring Boot you can enable this in the `application.properties` file:

[source,properties]
----
camel.springboot.backlog-tracing = true
----

=== Tracing payloads of InputStream types

Beware that when enabling backlog tracing, and the message payloads is streaming types (such as `java.io.InputStream`),
then the backlog tracer will read the payload and make a copy as a _trace_ that are stored in the backlog tracer.
Then monitoring tooling is able to view these _traced_ events.

When working with `InputStream` types then Camel has xref:stream-caching.adoc[] that is able to automatic
make such types _safe_ to use as they are cached and able to be _re-read_. See more details at xref:stream-caching.adoc[].

However, Camel's stream caching is **ONLY** for message body. Having message headers of type `InputStream` is discouraged
and not common use. If you add custom message headers, then it is recommended to **NOT** use streaming types, but
convert these headers into `String` or `byte[]` or other standard Java types that are in-memory and _safe_ to re-read.

= Batch Consumer

Batch Consumer is basically a xref:components:eips:polling-consumer.adoc[Polling
Consumer] that is capable of polling multiple
Exchanges in a single pool.

To support batching the consumer must implement the `org.apache.camel.BatchConsumer` interface.

A range of Camel components support batching such as:

* xref:components::aws2-ddb-component.adoc[AWS2 DDB]
* xref:components::aws2-kinesis-component.adoc[AWS2 Kinesis]
* xref:components::aws2-s3-component.adoc[AWS2 S3]
* xref:components::aws2-sqs-component.adoc[AWS2 SQS]
* xref:components::file-component.adoc[File]
* xref:components::ftp-component.adoc[FTP]
* xref:components::ironmq-component.adoc[IronMQ]
* xref:components::jooq-component.adoc[Jooq]
* xref:components::jpa-component.adoc[JPA]
* xref:components::mail-component.adoc[Mail]
* xref:components::minio-component.adoc[Minio]
* xref:components::mybatis-component.adoc[MyBatis]
* xref:components::slack-component.adoc[Slack]
* xref:components::splunk-component.adoc[Splunk]
* xref:components::sql-component.adoc[SQL]

== Options

The `BatchConsumer` supports the following options:

[width="100%",cols="20%,80%",options="header",]
|=======================================================================
|Option |Description
|`maxMessagesPerPoll` |An integer to define a maximum messages to gather per poll. By default,
no maximum is set. It can be used to set a limit of e.g., 1000 to avoid when
starting up the server that there are thousands of files. Set a value of
0 or negative to disable it as unlimited.
|=======================================================================

Very often a `BatchConsumer` is scheduled and is based of the `ScheduledBatchPollingConsumer`
that has many options for configuring the scheduling. These options are listed with _(scheduler)_
as label in the endpoint options' in the xref:components::index.adoc[Components] documentation.

== Exchange Properties

The following properties are set on the Exchange for
each Exchange polled in the same batch.

[width="100%",cols="20%,80%",options="header",]
|=======================================================================
|Property |Description
|`CamelBatchSize` |The total number of Exchanges that was polled in this batch.
|`CamelBatchIndex` |The current index of the batch. Starts from 0.
|`CamelBatchComplete` |A boolean indicating the last Exchange in the batch.
Is only `true` for the last entry.
|=======================================================================

= Bean Binding

Bean Binding in Camel defines both which methods are invoked and also
how the xref:components:eips:message.adoc[Message] is converted into the parameters of
the method invoked.

NOTE: This requires to include `camel-bean` as dependency on the classpath.

== Choosing the method to invoke

The binding of a Camel xref:components:eips:message.adoc[Message] to a bean method call
can occur in different ways, in the following order of importance:

* You can qualify parameter types to select
exactly which method to use among overloads with the same name (see
below for more details).
* You can specify parameter values directly in
the method option (see below for more details).
* you can explicitly specify the method name in the xref:dsl.adoc[DSL]
or when using xref:pojo-consuming.adoc[POJO Consuming] or
xref:pojo-producing.adoc[POJO Producing].
* if the bean has a method annotated with the `@Handler` annotation, then
that method is selected.
* if the bean can be converted to a xref:processor.adoc[Processor] using
the xref:type-converter.adoc[Type Converter] mechanism, then this is
used to process the message. The ActiveMQ component
used this mechanism (in Camel 3) to allow any JMS MessageListener to be invoked
directly by Camel without having to write any integration glue code. You
can use the same mechanism to integrate Camel into any other
messaging/remoting frameworks.
* the type of the body is used to find a matching method; an
error is thrown if a single method cannot be chosen unambiguously.
* you can also use `Exchange` as the parameter itself
* the return type cannot be `Exchange`. However, you can use `Exchange` as input parameter, and let
the method be `void`, or return some other Object type (cannot be `Exchange`).
* if the bean class is private (or package-private), interface methods
will be preferred since Camel can't invoke class methods on such beans

In cases when Camel cannot choose a method to invoke, an
`AmbiguousMethodCallException` is thrown.

By default, the return value is set in the outbound message body.

== Asynchronous processing

You can return a `CompletionStage` implementation (e.g. `CompletableFuture`)
to implement asynchronous processing.

Please be sure to properly complete the CompletionStage with the result
or exception, including any timeout handling. Exchange processing would
wait for completion and would not impose any timeouts automatically.
It's extremely useful to
monitor `org.apache.camel.spi.InflightRepository` for any hanging messages.

Note that completing with `"null"` won't set out body message body to `null`,
but would keep message intact. This is useful to support methods that
don't modify exchange and return `CompletableFuture<Void>`. To set body to
null, just add `Exchange` method parameter and directly modify exchange messages.

Examples:

Simple asynchronous processor, modifying message body.

[source,java]
----
public CompletableFuture<String> doSomethingAsync(String body)
----

Composite processor that do not modify exchange

[source,java]
----
 public CompletableFuture<Void> doSomethingAsync(String body) {
     return CompletableFuture.allOf(doA(body), doB(body), doC()); 
 }
----

== Parameter binding

When a method has been chosen for invocation, Camel will bind to the
parameters of the method.

The following Camel-specific types are automatically bound:

* `org.apache.camel.Exchange`
* `org.apache.camel.Message`
* `org.apache.camel.CamelContext`
* `org.apache.camel.TypeConverter`
* `org.apache.camel.spi.Registry`
* `java.lang.Exception`

So, if you declare any of these types, they will be provided by Camel.
*Note that `Exception` will bind to the caught exception in the
xref:exchange.adoc[Exchange]* - so it's often usable if you employ a
xref:components::bean-component.adoc[Bean] to handle, e.g., an `onException` route.

What is most interesting is that Camel will also try to bind the body of
the xref:exchange.adoc[Exchange] to the first parameter of the method
signature (albeit not any of the types above). So if, for instance,
we declare a parameter as `String body`, then Camel will bind the message
body to this type. Camel will also automatically convert to the type
declared in the method signature.

Let's review some examples:

Below is a simple method with a body binding. Camel will bind the IN
body to the `body` parameter and convert it to a `String`.

[source,java]
----
public String doSomething(String body)
----

In the following sample we got one of the automatically bound types as
well. For instance, a `Registry` that we can use to lookup beans.

[source,java]
----
public String doSomething(String body, Registry registry) 
----

We can use xref:exchange.adoc[Exchange] as well:

[source,java]
----
public String doSomething(String body, Exchange exchange) 
----

You can also have multiple types:

[source,java]
----
public String doSomething(String body, Exchange exchange, TypeConverter converter) 
----

And imagine you use a xref:components::bean-component.adoc[Pojo] to handle a given custom
exception `InvalidOrderException` - we can then bind that as well:

[source,java]
----
public String badOrder(String body, InvalidOrderException invalid) 
----

Notice that we can bind to it even if we use a subtype of
`java.lang.Exception` as Camel still knows it's an exception and can
bind the cause (if any exists).

So what about headers and other stuff? Well, now it gets a bit tricky.
We can use annotations to help us or specify the binding in the method name option.

See the following sections for more detail.

== Binding Annotations

You can use the xref:parameter-binding-annotations.adoc[Parameter
Binding Annotations] to customize how parameter values are created from
the xref:components:eips:message.adoc[Message]

=== Examples

For example, a xref:components:eips:bean-eip.adoc[Bean] such as:

[source,java]
----
public class Bar {
    public String doSomething(String body) {
        // process the in body and return whatever you want
        return "Bye World";
    }
}
----

Or the Exchange example. Notice that the return type must be *void* when
there is only a single parameter of the type
`org.apache.camel.Exchange`:

[source,java]
----
 public class Bar {
     public void doSomething(Exchange exchange) {
         // process the exchange 
         exchange.getIn().setBody("Bye World");
     }
 }
----

=== Using @Handler

You can mark a method in your bean with the `@Handler` annotation to
indicate that this method should be used for xref:bean-binding.adoc[Bean
Binding].

This has an advantage as you don't need to specify a method name in the Camel
route, and therefore do not run into problems after renaming the method
in an IDE that can't find all its references.

[source,java]
----
public class Bar {
    @Handler 
    public String doSomething(String body) {
        // process the in body and return whatever you want 
        return "Bye World"; 
    }
} 
----

== Parameter binding using method option

Camel uses the following rules to determine if it's a parameter value in
the method option

* The value is either `true` or `false` which denotes a boolean value
* The value is a numeric value such as `123` or `7`
* The value is a String enclosed with either single or double quotes
* The value is null which denotes a `null` value
* It can be evaluated using the xref:components:languages:simple-language.adoc[Simple] language, which
means you can use, e.g., `$\{body}`, `${header.foo}` and others
xref:components:languages:simple-language.adoc[Simple] tokens. Notice the tokens must be enclosed with
`${ }`.
* The value ends with `.class` then it's a type declaration instead - see the
next section about specifying types for overloaded methods.

When invoking a xref:components:eips:bean-eip.adoc[Bean] you can instruct Camel to invoke a
specific method by providing the method name:

[source,java]
----
.bean(OrderService.class, "doSomething")
----

Here we tell Camel to invoke the `_doSomething_` method.
Camel handles the parameters' binding.
Now suppose the method has 2 parameters, and the
second parameter is a boolean where we want to pass in a true value:

[source,java]
----
public void doSomething(String payload, boolean highPriority) {
    ... 
}
----

This can be done as follows:

[source,java]
----
.bean(OrderService.class, "doSomething(*, true)") 
----

In the example above, we defined the first parameter using the wild card
symbol `*`, which tells Camel to bind this parameter to any type, and let
Camel figure this out. The second parameter has a fixed value of `true`.
Instead of the wildcard symbol, we can instruct Camel to use the message
body as shown:

[source,java]
----
.bean(OrderService.class, "doSomething(${body}, true)") 
----

The syntax of the parameters is using the xref:components:languages:simple-language.adoc[Simple]
language so we have to use `${ }` placeholders in the body to
refer to the message body.

If you want to pass in a `null` value, then you can explicitly define this
in the method option as shown below:

[source,java]
----
.to("bean:orderService?method=doSomething(null, true)")
----

Specifying `null` as a parameter value instructs Camel to force passing
a `null` value.

Besides the message body, you can pass in the message headers as a
`java.util.Map`:

[source,java]
----
.bean(OrderService.class, "doSomethingWithHeaders(${body}, ${headers})") 
----

You can also pass in other fixed values besides booleans. For example,
you can pass in a String and an integer:

[source,java]
----
.bean(MyBean.class, "echo('World', 5)") 
----

In the example above, we invoke the echo method with two parameters. The
first has the content 'World' (without quotes), and the second has the
value of 5. Camel will automatically convert these values to the parameters' types.

Having the power of the xref:components:languages:simple-language.adoc[Simple] language allows us to
bind to message headers and other values such as:

[source,java]
----
.bean(OrderService.class, "doSomething(${body}, ${header.high})") 
----

You can also use the OGNL support of the xref:components:languages:simple-language.adoc[Simple]
expression language. Now suppose the message body is an object that has
a method named `asXml`. To invoke the `asXml` method we can do as
follows:

[source,java]
----
.bean(OrderService.class, "doSomething(${body.asXml}, ${header.high})") 
----

Instead of using `.bean` as shown in the examples above, you may want to
use `.to` instead as shown:

[source,java]
----
.to("bean:orderService?method=doSomething(${body.asXml}, ${header.high})") 
----

=== Using type qualifiers to select among overloaded methods

If you have a xref:components:eips:bean-eip.adoc[Bean] with overloaded methods, you can now
specify parameter types (must use `.class` style, e.g. `com.foo.MyClass.class`) in the method name so Camel can match the method
you intend to use.

Given the following bean:

[source,java]
----
 from("direct:start")
    .bean(MyBean.class, "hello(String.class)")
    .to("mock:result");
----

Then the `MyBean` has 2 overloaded methods with the names `hello` and
`times`. So if we want to use the method which has two parameters, we can
do as follows in the Camel route:

[source,java]
----
from("direct:start")
    .bean(MyBean.class, "hello(String.class, String.class)")
    .to("mock:result"); 
----

We can also use a `*` as wildcard, so we can just say we want to execute
the method with two parameters we do:

[source,java]
----
 from("direct:start")
    .bean(MyBean.class, "hello(*,*)")
    .to("mock:result");
----

By default, Camel will match the type name using the simple name, e.g.,
any leading package name will be disregarded. However, if you want to
match using the FQN, then specify the FQN type and Camel will leverage
that. So if you have a parameter of type `com.foo.MyOrder` and you want to match against
the FQN, and *not* the simple name "MyOrder", then follow this example:

[source,java]
----
.bean(OrderService.class, "doSomething(com.foo.MyOrder.class)")
----

=== Declaring parameter type and value

*Available as of Camel 4.0*

Camel 3.x only supports either specifying parameter binding or
type per parameter in the method name option. You *cannot* specify both
at the same time, such as:

[source,text]
----
doSomething(com.foo.MyOrder.class ${body}, boolean ${header.high}, int 123)
----

However, we have implemented support for this in Camel 4,
where you can declare both using _name.class value_ syntax as shown:

[source,text]
----
doSomething(com.foo.MyOrder.class ${body}, boolean.class ${header.high}, int.class 123)
----

Notice that you *MUST* use `name.class` when declaring the type, also for String, int, boolean, etc.
= Bean Injection

We support the injection of various resources using `@EndpointInject` or
`@BeanInject`. This can be used to inject

* xref:endpoint.adoc[Endpoint] instances which can be used for testing
when used with xref:components::mock-component.adoc[Mock] endpoints; see the
xref:testing.adoc[Testing] for an example.
* xref:producertemplate.adoc[ProducerTemplate] instances for
xref:pojo-producing.adoc[POJO Producing]
* client side proxies for xref:pojo-producing.adoc[POJO Producing]

== Using @BeanInject

You can inject beans (obtained from the
xref:registry.adoc[Registry]) into your beans such as `RouteBuilder`
classes.

For example to inject a bean named foo, you can enlist the bean in the
xref:registry.adoc[Registry] such as in a Spring XML file:

[source,xml]
----
<bean id="foo" class="com.foo.MyFooBean"/>
----

And then in a Java `RouteBuilder` class, you can inject the bean using
`@BeanInject` as shown below:

[source,java]
----
public class MyRouteBuilder extends RouteBuilder {

   @BeanInject("foo")
   MyFooBean foo;

   public void configure() throws Exception {
     ..
   }
}
----

If you omit the name, then Camel does a lookup by type, and injects the
bean if there is exactly only one bean of that type enlisted in the
xref:registry.adoc[Registry].

[source,java]
----
   @BeanInject
   MyFooBean foo;
----

== Bean Injection with Quarkus

When using Camel with Spring Boot, or Quarkus, then the `@Inject`, or `@Named` annotations can
be used to inject Camel resources as well.

== Bean Injection with Spring Boot

Camel has first-class support for Spring Boot, and you can use the Spring annotations
such as `@Autowired` to also inject Camel resources.= Bean Integration

Camel supports the integration of beans and POJOs in a number of ways.

== Annotations

If a bean is defined in Spring XML or scanned using
the Spring component scanning mechanism, and a *<camelContext>* is used
or a `CamelBeanPostProcessor` then we process a number of Camel
annotations to do various things such as injecting resources or
producing, consuming or routing messages.

The following annotations is supported and inject by Camel's
`CamelBeanPostProcessor`

[width="100%",cols="10%,90%",options="header",]
|=======================================================================
|Annotation |Description
|`@EndpointInject` |To inject an endpoint, see more details at xref:pojo-producing.adoc[POJO Producing].
|`@BeanInject` |To inject a bean obtained from the xref:registry.adoc[Registry]. See xref:bean-injection.adoc[Bean Injection].
|`@BeanConfigInject` |To inject a configuration bean obtained from the xref:registry.adoc[Registry]. The bean is a POJO that represents
a set of configuration options, which is automatically configured with values loaded via Camel xref:using-propertyplaceholder.adoc[Property Placeholders].
|`@PropertyInject` |To inject a value using property placeholder.
|`@Produce` |To inject a producer to send a message to an endpoint. See xref:pojo-producing.adoc[POJO Producing].
|`@Consume` |To inject a consumer on a method. See xref:pojo-consuming.adoc[POJO Consuming].
|`@BindToRegistry` |Used for binding a bean to the registry.
  If no name is specified, then the bean will have its name auto computed based on the class name,
 field name, or method name where the annotation is configured.
|`@DeferredContextBinding` | Used to indicate that if the target type is `CamelContextAware` then the `CamelContext` is deferred and injected later; after the bootstrap of Camel so the `CamelContext` is ready for use.
|=======================================================================

See more details at:

* xref:pojo-consuming.adoc[POJO Consuming] to consume and possibly route messages from Camel
* xref:pojo-producing.adoc[POJO Producing] to make it easy to produce camel messages from your POJOs
* `@DynamicRouter` Annotation for creating a xref:components:eips:dynamicRouter-eip.adoc[Dynamic Router] from a POJO method
* `@RecipientList` Annotation for creating a xref:components:eips:recipientList-eip.adoc[Recipient List] from a POJO method
* `@RoutingSlip` Annotation for creating a xref:components:eips:routingSlip-eip.adoc[Routing Slip] for a POJO method
* xref:bean-injection.adoc[Bean Injection] to inject Camel related resources into your POJOs
* xref:using-exchange-pattern-annotations.adoc[Using Exchange Pattern Annotations]
  describes how the pattern annotations can be used to change
  the behaviour of method invocations with Spring Remoting or POJO Producing

*Example*

See the https://github.com/apache/camel-examples/tree/main/pojo-messaging[POJO Messaging Example]
for how to use the annotations for routing and messaging.

== Using @PropertyInject

Camel allows injecting property placeholders in POJOs using
the `@PropertyInject` annotation which can be set on fields and setter
methods. For example, you can use that with `RouteBuilder` classes,
such as shown below:

[source,java]
----
public class MyRouteBuilder extends RouteBuilder {

    @PropertyInject("hello")
    private String greeting;

    @Override
    public void configure() throws Exception {
        from("direct:start")
            .transform().constant(greeting)
            .to("{{result}}");
    }
}
----

Notice we have annotated the greeting field with `@PropertyInject` and
define it to use the key `hello`. Camel will then lookup the property
with this key and inject its value, converted to a String type.

You can also use multiple placeholders and text in the key, for example
we can do:

[source,java]
----
@PropertyInject("Hello {{name}} how are you?")
private String greeting;
----

This will lookup the placeholder with they key `name`.

You can also add a default value if the key does not exist, such as:

[source,java]
----
@PropertyInject(value = "myTimeout", defaultValue = "5000")
private int timeout;
----

=== Using @PropertyInject with arrays, lists, sets or maps

You can also use `@PropertyInject` to inject an array of values. For example, you may configure multiple hostnames
in the configuration file, and need to inject this into an `String[]` or `List<String>` field.
To do this, you need to tell Camel that the property value should be split using a separator, as follows:

[source,java]
----
@PropertyInject(value = "myHostnames", separator = ",")
private String[] servers;
----

TIP: You can also use list/set types, such as `List<String>` or `Set<String>` instead of array.

Then in the `application.properties` file you can define the servers:

[source,properties]
----
myHostnames = serverA, serverB, serverC
----

TIP: This also works for fields that are not String based, such as `int[]` for numeric values.

For `Map` types then the values are expected to be in `_key=value_` format, such as:

[source,properties]
----
myServers = serverA=http://coolstore:4444,serverB=http://megastore:5555
----

You can then inject this into a `Map` as follows:

[source,java]
----
@PropertyInject(value = "myServers", separator = ",")
private Map servers;
----

You can use generic types in the Map such as the values should be `Integer` values:

[source,java]
----
@PropertyInject(value = "ports", separator = ",")
private Map<String, Integer> ports;
----

NOTE: The generic type can only be a single class type, and cannot be a nested complex type such as `Map<String,Map<Kind,Priority>>`.

== See Also

** xref:bean-injection.adoc[Bean Injection]
** xref:bean-binding.adoc[Bean Binding]
= Getting Started with Apache Camel

This content was moved to the link:/camel-core/getting-started[Getting Started].
= BrowsableEndpoint

The `BrowseableEndpoint` is an extension interface an `Endpoint` may implement
to support the browsing of the Message xref:exchange.adoc[Exchanges]
which are pending or have been sent on it.

Some implementations include:

* xref:components::jms-component.adoc[JMS] for queues only
* xref:components::mock-component.adoc[Mock]
* xref:components::seda-component.adoc[SEDA]

= Building Camel from Source

This content was moved to link:/camel-core/contributing[Contributing To Apache Camel Core].

= Apache Camel 2.x to 3.0 Migration Guide

This document is intended to help you migrate your Apache Camel applications
from version 2.x to 3.0.

IMPORTANT: If you are upgrading Camel 3.x to 3.y then use the
xref:camel-3x-upgrade-guide.adoc[Camel 3.x Upgrade Guide].

== Java versions

Camel 3 supports Java 11. Support for Java 8 is best effort for early versions of Camel 3. However, at some time in the 3.x lifeline we will drop support for Java 8.

In Java 11, the JAXB modules have been **removed** from the JDK, therefore, you will need to add them as Maven dependencies (if you use JAXB such as when using XML DSL or the camel-jaxb component):

[source,xml]
----
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.1</version>
</dependency>

<dependency>
    <groupId>com.sun.xml.bind</groupId>
    <artifactId>jaxb-core</artifactId>
    <version>2.3.0.1</version>
</dependency>

<dependency>
    <groupId>com.sun.xml.bind</groupId>
    <artifactId>jaxb-impl</artifactId>
    <version>2.3.2</version>
</dependency>
----

== Modularization of camel-core

One of the biggest changes is the modularization of camel-core.
In Camel 2.x camel-core was one JAR file, it has now been split up into many JARs as follows:

- camel-api
- camel-base
- camel-caffeine-lrucache
- camel-cloud
- camel-core
- camel-jaxp
- camel-main
- camel-management-api
- camel-management
- camel-support
- camel-util
- camel-util-json

Maven users of Apache Camel can keep using the dependency `camel-core` which has transitive dependencies on all of its modules, except for `camel-main`, and therefore no migration is needed.
However, users who want to trim the size of the classes on the classpath, can use fine-grained Maven dependencies on only the modules needed.
You may find how to do that in the examples.

We have also modularized many of the core components and moved them out of `camel-core` to individual components:

- camel-attachments
- camel-bean
- camel-browse
- camel-controlbus
- camel-dataformat
- camel-dataset
- camel-direct
- camel-directvm
- camel-file
- camel-language
- camel-log
- camel-mock
- camel-ref
- camel-rest
- camel-saga
- camel-scheduler
- camel-seda
- camel-stub
- camel-timer
- camel-validator
- camel-vm
- camel-xpath
- camel-xslt
- camel-xslt-saxon
- camel-zip-deflater

== Spring Boot starters Maven coordinate change

The Maven `groupId` for the Spring Boot starters changed to: `org.apache.camel.springboot`.

Instead of:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-component-starter</artifactId>
</dependency>
----

Use:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel.springboot</groupId>
  <artifactId>camel-component-starter</artifactId>
</dependency>
----

== Multiple CamelContexts per application not supported

Support for multiple CamelContexts has been removed, and only 1 CamelContext per deployment is supported.
The latter was not recommended anyway and was also not 100% implemented, for example, in `camel-cdi`.
For Camel 3, only 1 `CamelContext` per deployment is recommended and supported.

The `context` attribute on the various Camel annotations such as `@EndpointInject`, `@Produce`, `@Consume` etc. has therefore been removed.

== Migrating custom components

You should depend on `camel-support` and not `camel-core` directly.

The classes from `org.apache.camel.impl` that are intended to support Camel developers building custom components have been moved out of `camel-core` into `camel-support` into the `org.apache.camel.support` package. For example classes such as `DefaultComponent`, `DefaultEndpoint` etc. have been moved and migration is necessary.

== Migrating custom languages

The `LanguageAnnotation` annotation class has been moved from package `org.apache.camel.language` to `org.apache.camel.support.language`.

== Migrating DefaultShutdownStrategy

The `DefaultShutdownStrategy` class has been moved from package `org.apache.camel.impl` to `org.apache.camel.impl.engine`.

== Deprecated APIs and Components

All deprecated APIs and components from Camel 2.x have been removed in Camel 3.

== Migrating Camel applications

=== Main class

The Camel `Main` class has been moved out of `camel-core` into `camel-main` so you should add that as dependency if you use Main.

=== Properties component

The `properties` component has configuring custom prefix and suffix tokens removed as if in use, they had potential issues with clashing with simple languages and elsewhere. The default tokens are now hardcoded and always in use.

The `properties` component has some advanced options removed: `propertyPrefix`, `propertySuffix`, and `fallbackToUnaugmented`; these options was never really useable for end users anyway. The option `propertiesResolver` has also been removed as you should use `PropertiesSource` instead.

The properties component will now use OS environment variables as preferred value. This means you can set an OS environment variable which will override any property values that has been set in property files, JVM system properties etc. You can configure this with the `environmentVariableMode` option on the properties component.

The `properties` component no longer support using endpoints, such as `properties:myKey`. The properties component is now only a property placeholder service.
You can therefore no longer lookup the properties component via `camelContext.getComponent("properties")`.
Instead, you can use `camelContext.getPropertiesComponent()`, which also returns an interface of the properties component as `org.apache.camel.spi.PropertiesComponent`.
The implementation is still named `org.apache.camel.component.properties.PropertiesComponent`, however, it should rarely be used, as you should favour using the interface instead.


=== Removed components

We have removed all deprecated components from Camel 2.x, including the old `camel-http`, `camel-hdfs`, `camel-mina`, `camel-mongodb`, `camel-netty`, `camel-netty-http`, `camel-quartz`, `camel-restlet` and `camel-rx` components.

We removed `camel-jibx` component which wasn't working on JDK 8.

We removed `camel-boon` dataformat which wasn't working on JDK 9 and later.

We removed the `camel-linkedin` component and there is no replacement.

The `camel-zookeeper` has its route policy functionality removed, instead use `ZooKeeperClusterService` or the `camel-zookeeper-master` component.

The `camel-jetty` component no longer supports producer (eg to) which has been removed, use `camel-http` component instead.

The `twitter-streaming` component has been removed as it relied on the deprecated Twitter Streaming API and is no longer functional.

=== Renamed components

The `test` component has been renamed to `dataset-test` and moved out of `camel-core` into `camel-dataset` JAR.

The `http4` component has been renamed to `http`, and it's corresponding component package from `org.apache.camel.component.http4` to `org.apache.camel.component.http`. The supported schemes are now only `http` and `https`.

The `hdfs2` component has been renamed to `hdfs`, and it's corresponding component package from `org.apache.camel.component.hdfs2` to `org.apache.camel.component.hdfs`. The supported scheme is now `hdfs`.

The `mina2` component has been renamed to `mina`, and it's corresponding component package from `org.apache.camel.component.mina2` to `org.apache.camel.component.mina`. The supported scheme is now `mina`.

The `mongodb3` component has been renamed to `mongodb`, and it's corresponding component package from `org.apache.camel.component.mongodb3` to `org.apache.camel.component.mongodb`. The supported scheme is now `mongodb`.

The `netty4-http` component has been renamed to `netty-http`, and it's corresponding component package from `org.apache.camel.component.netty4.http` to `org.apache.camel.component.netty.http`. The supported scheme is now `netty-http`.

The `netty4` component has been renamed to `netty`, and it's corresponding component package from `org.apache.camel.component.netty4` to `org.apache.camel.component.netty`. The supported scheme is now `netty`.

The `quartz2` component has been renamed to `quartz`, and it's corresponding component package from `org.apache.camel.component.quartz2` to `org.apache.camel.component.quartz`. The supported scheme is now `quartz`.

The `rxjava2` component has been renamed to `rxjava`, and it's corresponding component package from `org.apache.camel.component.rxjava2` to `org.apache.camel.component.rxjava`.

We have also renamed `camel-jetty9` to `camel-jetty`. The supported scheme is now `jetty`.

=== Hystrix EIP

The Hystrix EIP has been generalized as a circuit breaker to allow plugging in other implementations.

In the Java DSL you need to migrate from `.hystrix()` to `.circuitBreaker()`.
And in XML DSL `<hystrix>` should be `<circuitBreaker>`.


=== Using endpoint options with consumer. prefix

Endpoints with `consumer.` prefix such as `consumer.delay=5000` are no longer supported (deprecated in latest Camel 2.x) and you should just use the option without the `consumer.` prefix, eg `delay=5000`.

=== Calling a processor as an endpoint

Calling a processor as an endpoint from a route such as:

[source,java]
----
from("jms:cheese")
  .to("myProcessor");
----

Is no longer supported. Instead either use the bean component to call the processor or use `process`:

[source,java]
----
from("jms:cheese")
  .to("bean:myProcessor");
----

Or

[source,java]
----
from("jms:cheese")
  .process("myProcessor");
----

=== Tracing

A new tracer has been implemented and the old tracer has been removed.
The new tracer logs messages at the `org.apache.camel.Tracing` logger name which is hardcoded. The format of the output is also updated to make it better. The tracer can be customized.

In JMX the `BacklogTracer` is no longer enabled by default, which you need to enable by setting `backlogTracing=true` on CamelContext. The backlog tracer and tracer are not the same. The former is used for capturing a backlog of traced messages which you can poll via JMX (needed for 3rd party tooling), where as tracer is writing to the log. Neither of them are enabled by default, and they must be enabled to be in use.

=== <setHeader> and <setProperty> in XML DSL

We have renamed the attribute `headerName` and `propertyName` in the XML DSL for the `<setHeader>` and `<setProperty`> EIPs, to be just `name`.

So migrate

[source,xml]
----
<setHeader headerName="foo"><simple>Hello ${body}</simple></setHeader>
----

To

[source,xml]
----
<setHeader name="foo"><simple>Hello ${body}</simple></setHeader>
----

And the same for `<setProperty>`.

=== <aggregate> EIP in XML DSL

The aggregate EIP has renamed the expressions (not the attributes) for setting correlation size/timeout to avoid a name clash, so migrate:

[source,xml]
----
<completionSize>
  <header>mySize</header>
</completionSize>
----

To

[source,xml]
----
<completionSizeExpression>
  <header>mySize</header>
</completionSizeExpression>
----

And the same for `<completionTimeout>`.

=== <threads> <delay> <sample> <throttle> EIP in XML

These EIPs have been improved to no longer use children for routing, instead they
are collapsed as a single element like other EIPs.

So before you may have

[source,xml]
----
<route>
    <from uri="jms:cheese"/>
    <to uri="log:before"/>
    <threads poolSize="2">
        <to uri="bean:foo"/>
        <to uri="bean:bar"/>
    </threads>
    <to uri="log:after"/>
</route>
----

And now you would do:

[source,xml]
----
<route>
    <from uri="jms:cheese"/>
    <to uri="log:before"/>
    <threads poolSize="2"/>
    <to uri="bean:foo"/>
    <to uri="bean:bar"/>
    <to uri="log:after"/>
</route>
----

It is the same for the other EIPs `<delay>`, `<sample>`, and `<throttle>`.


==== camel-cdi

Support for multiple CamelContexts has been removed, and therefore `@ContextName` has been removed. Instead, use standard CDI annotations such as `@Named` and `@ApplicationScoped`.

=== javax.script

The `camel-script` component has been removed, and there is no support for `javax.script`, which is also deprecated in the JDK and to be removed from Java 11 onwards.

=== Attachments API on Message

The attachments API (`javax.activation`) has been moved out of `org.apache.camel.message` into an extension `org.apache.camel.attachment.AttachmentMessage` from the `camel-attachments` JAR.

To use this API, you can get it via the `getMessage` method on `Exchange`:

  AttachmentMessage am = exchange.getMessage(AttachmentMessage.class);
  am.addAttachment("myAtt", new DataHandler(...));

=== Fault API on Message

The fault API has been removed from `org.apache.camel.Message` as it was only used for SOAP-WS fault message. The `camel-cxf` and `camel-spring-ws` components for SOAP-WS has been modified to support fault messages from their components. The option `handleFault` has also been removed and you now need to turn this on as endpoint or component option on `camel-cxf` or `camel-spring-ws`.

=== getOut on Exchange

The `hasOut` and `getOut` methods on `Exchange` has been deprecated in favour of using `getMessage` instead.
(Side note: `camel-core` is still using these methods in a few places to be backwards compatible and relies on this logic as Camel was initially designed with the concept of IN and OUT messages inspired by the JBI and SOAP-WS specifications.)

=== OUT message removed from Simple language and Mock component

The simple language has removed the OUT message concepts eg `${out.body}`.
Also, the mock component has removed OUT message from its assertion API, eg

  mock.message(0).outBody()...

Also, the `@OutHeaders` annotation for bean parameter binding has been removed, instead use `@Headers` instead.

=== Mock component

The `mock` component has been moved out of `camel-core` and as part of this work, we had to remove a number of methods on its _assertion clause builder_ that were seldom in use.

=== ActiveMQ

If you are using the `activemq-camel` component, then you should migrate to use `camel-activemq` component, where the component name has changed from `org.apache.activemq.camel.component.ActiveMQComponent` to `org.apache.camel.component.activemq.ActiveMQComponent`.

=== AWS

The component `camel-aws` has been split into multiple components:

- camel-aws-cw
- camel-aws-ddb (which contains both ddb and ddbstreams components)
- camel-aws-ec2
- camel-aws-iam
- camel-aws-kinesis (which contains both kinesis and kinesis-firehose components)
- camel-aws-kms
- camel-aws-lambda
- camel-aws-mq
- camel-aws-s3
- camel-aws-sdb
- camel-aws-ses
- camel-aws-sns
- camel-aws-sqs
- camel-aws-swf

So you'll have to explicitly add the dependencies for these components. From the OSGi perspective, there is still a `camel-aws` Karaf feature, which includes all the components features.

=== FHIR

The camel-fhir component has upgraded it's hapi-fhir dependency to 4.1.0; Karaf support has been dropped until the hapi-fhir Karaf features are fixed and released.
The default FHIR version has been changed to R4. Therefore, if DSTU3 is desired, it has to be explicitly set.

=== Kafka

The `camel-kafka` component has removed the options `bridgeEndpoint` and `circularTopicDetection` as this is no longer needed as the component is acting as bridging would work on Camel 2.x. In other words `camel-kafka` will send messages to the topic from the endpoint uri. To override this use the `KafkaConstants.OVERRIDE_TOPIC` header with the new topic. See more details in the `camel-kafka` component documentation.

=== Telegram

The `camel-telegram` component has moved the authorization token from uri-path to a query parameter instead, e.g. migrate

    telegram:bots/myTokenHere

to

    telegram:bots?authorizationToken=myTokenHere

=== JMX

If you run Camel standalone with just `camel-core` as a dependency, and you want JMX enabled out of the box, then you need to add `camel-management` as a dependency.

For using `ManagedCamelContext` you now need to get this an extension from `CamelContext` as follows:

    ManagedCamelContext managed = camelContext.getExtension(ManagedCamelContext.class);

=== XSLT

The XSLT component has moved out of camel-core into `camel-xslt` and `camel-xslt-saxon`. The component is separated so `camel-xslt` is for using the JDK XSTL engine (Xalan), and `camel-xslt-saxon` is when you use Saxon.
This means that you should use `xslt` and `xslt-saxon` as component name in your Camel endpoint URIs.
If you are using XSLT aggregation strategy, then use `org.apache.camel.component.xslt.saxon.XsltSaxonAggregationStrategy` for Saxon support.
And use `org.apache.camel.component.xslt.saxon.XsltSaxonBuilder` for Saxon support if using xslt builder. Also notice that `allowStax` is also only supported in `camel-xslt-saxon` as this is not supported by the JDK XSLT.

=== camel-sql

The `JdbcAggregationRepository` optimistic locking feature has been fixed to work on a distributed environment and every database.
There is a new `version` column that is required and must be added to the repository:

[source,sql]
----
CREATE TABLE aggregation (
 id varchar(255) NOT NULL,
 exchange blob NOT NULL,
 version BIGINT NOT NULL,
 constraint aggregation_pk PRIMARY KEY (id)
);
CREATE TABLE aggregation_completed (
 id varchar(255) NOT NULL,
 exchange blob NOT NULL,
 version BIGINT NOT NULL,
 constraint aggregation_completed_pk PRIMARY KEY (id)
);
----

=== Configuring global options on CamelContext

In Camel 2.x we have deprecated `getProperties` on `CamelContext` in favour of `getGlobalOptions`, so you should migrate to:

[source,java]
----
context.getGlobalOptions().put("CamelJacksonEnableTypeConverter", "true");
context.getGlobalOptions().put("CamelJacksonTypeConverterToPojo", "true");
----

and in XML:

[source,xml]
----
<globalOptions>
  <globalOption key="CamelJacksonEnableTypeConverter" value="true"/>
  <globalOption key="CamelJacksonTypeConverterToPojo" value="true"/>
</globalOptions>
----

=== Main class

The `Main` class from `camel-core`, `camel-spring` and `camel-cdi` has been modified to only support a single `CamelContext` which was really its intention, but there was some old crufty code for multiple Camels. The methods `getCamelContextMap` and `getCamelContexts` have been removed, and there is just a `getCamelContext` method now.

=== POJO annotations

The `ref` attribute on `@Consume`, `@Produce` and `@EndpointInject` has been removed. Instead use the ref component in the `uri` attribute, eg `uri = "ref:myName"`.

The uri attribute has been deprecated, instead use value, which allows a shorthand style, from using `@Consume(uri = "jms:cheese")` to `@Consume("jms:cheese")`.

=== Routes with multiple inputs

In Camel 2.x you could have 2 or more inputs to Camel routes, however this was not supported in all use-cases in Camel, and this functionality is seldom in use. This has
also been deprecated in Camel 2.x. In Camel 3 we have removed the remaining code for specifying multiple inputs to routes, and its now only possible to specify exactly only 1 input to a route.

=== Crypto Component

The default signature algorithm has changed for the Crypto (JCE) Component - it
is now SHA256withRSA (before it was SHA1WithDSA).

=== Crypto DataFormat

The default encryption algorithm has changed for the Crypto (JCE) DataFormat -
it is now required to set a value for it (meaning that the default is null).
Before the default value was "DES/CBC/PKCS5Padding".

=== JSon DataFormat

The default JSON library with the JSON dataformat has changed from `XStream` to `Jackson`.

=== Shiro Component

The default encryption key for the Shiro component has been removed, so now it
is mandatory to supply the key/passphrase.

=== XML Security Component

The default signature algorithm has changed for the XML Security Component - it
is now RSA-SHA256 (before it was RSA-SHA1).

=== XML Security DataFormat

The default encryption key for the XML Security DataFormat has been removed,
so it is now mandatory to supply the key String/bytes if you are using
symmetric encryption. This means that some methods are removed that
used the `XMLSecurityDataFormat` without specifying a key.

In addition, the default symmetric encryption algorithm has changed from
Triple DES to AES-256 in GCM mode.

=== Zip and GZip DataFormat

The zip and gzip dataformat has been renamed to zipdeflater and gzipdeflater as they are for deflating using the zip/gzip compression; and not for working with zip/gzip files. Instead use camel-zipfile dataformat. Also these dataformats has been moved out of `camel-core` into `camel-zip-deflater` JAR. The XML and Java DSL has also been modified so you should migrate there too to use their new names. And if you use these data formats you need to add the `camel-zip-deflater` as dependency as they are no longer included as transitive dependency with `camel-core`.

=== Simple language

The functionality to change the simple language tokens for start/end functions has been removed. The default tokens with `+++${xxx}+++` and `+++$simple{xxx}+++` is now hardcoded (optimized). The functionality to change these tokens was never really in use and would only confuse Camel users if a new syntax are in use.

=== Moved APIs

The following API changes may affect your existing Camel applications, which needs to be migrated.

==== CamelContext

The methods on `CamelContext` that are related to catalog has been moved into a new `CatalogCamelContext` interface, which you can access by adapting:

  CatalogCamelContext ccc = context.adapt(CatalogCamelContext.class);

The `loadRouteDefinitions` and `loadRestDefinitions` on `ModelCamelContext` has been changed to `addRouteDefinitions` and `addRestDefinitions` to be aligned with the other methods. You can find `getModelToXMLDumper` and `getXMLRoutesDefinitionLoader` loader methods on the `ExtendedCamelContext` class.

==== ModelCamelContext

If you need to access the routes model (such as `addRouteDefinitions`, etc.), then you need to adapt form CamelContext as shown:

    ModelCamelContext mcc = camelContext.adapt(ModelCamelContext.class);

==== Extended CamelContext

The APIs on `CamelContext` has been reduced a bit to focus on relevant API for Camel end users. The advanced use-cases and for SPI and component developers, then some of the APIs from `CamelContext` has been moved to `ExtendedCamelContext` which you can access via adapt:

  ExtendedCamelContext ecc = context.adapt(ExtendedCamelContext.class);


=== Checked vs unchecked exceptions

Most of the Camel exception classes have been migrated to be unchecked (e.g., extends `RuntimeException`).

Also, the lifecycle of the `start`, `stop` and `suspend`, `resume` methods on `Service` and `SuspendableService` has been changed to not throw checked exceptions.

==== Generic Information

The class `SimpleRegistry` is moved from `org.apache.camel.impl` to `org.apache.camel.support`. Also you should favour using the `org.apache.camel.support.DefaultRegistry` instead. Also you should use the `bind` operation instead of `put` to add entries to the `SimpleRegistry` or `DefaultRegistry`.

The class `CompositeRegistry` and `PropertyPlaceholderDelegateRegistry` has been deleted. Instead use `DefaultRegistry`.

The classes from `org.apache.camel.impl` that was intended to support Camel developers building custom components has been moved out of `camel-core` into `camel-support` into the `org.apache.camel.support` package. If you have built custom Camel components that may have used some of these APIs you would then need to migrate.  A large part of classes from the `org.apache.camel.impl` package have been moved to the `org.apache.camel.impl.engine` package in `camel-base`.

All the classes in `org.apache.camel.util.component` has been moved from the camel-core JAR to the package `org.apache.camel.support.component` in the `camel-support` JAR.

The method `xslt` has been removed from `org.apache.camel.builder.AggregationStrategies`. Instead use the `XsltAggregationStrategy` from `camel-xslt` JAR directly.

The getter/setter for `bindingMode` on `RestEndpoint` has been changed to use type `org.apache.camel.spi.RestConfiguration.RestBindingMode` from `camel-api` JAR. Instead of using this type class you can also call the setter method with string type instead.

The `activemq-camel` component has been moved from ActiveMQ into Camel and it is now called `camel-activemq`, the package has been changed accordingly to `org.apache.camel.component.activemq`

The method `includeRoutes` on `RouteBuilder` has been removed. This functionality was not fully in use and was deprecated in Camel 2.x.

The exception `PredicateValidationException` has been moved from package `org.apache.camel.processor.validation` to `org.apache.camel.support.processor.PredicateValidationException`.

The class `org.apache.camel.util.toolbox.AggregationStrategies` has been moved to `org.apache.camel.builder.AggregationStrategies`.

The class `org.apache.camel.util.toolbox.AggregationStrategies` has been moved to `org.apache.camel.builder.AggregationStrategies`.

The class `org.apache.camel.processor.RedeliveryPolicy` has been moved to `org.apache.camel.processor.errorhandler.RedeliveryPolicy`.

The class `org.apache.camel.processor.loadbalancer.SimpleLoadBalancerSupport` has been removed, instead use `org.apache.camel.processor.loadbalancer.LoadBalancerSupport`.

The class `org.apache.camel.management.JmxSystemPropertyKeys` has been moved to `org.apache.camel.api.management.JmxSystemPropertyKeys`.

The class `org.apache.camel.builder.xml.XPathBuilder` has been moved to `org.apache.camel.language.xpath.XPathBuilder` and in the `camel-xpath` JAR.

The annotation `org.apache.camel.language.XPath` has been moved to `org.apache.camel.language.xpath.XPath` and in the `camel-xpath` JAR.

The exception `org.apache.camel.builder.xml.InvalidXPathExpression` has been renamed to `org.apache.camel.language.xpath.InvalidXPathException` and in the `camel-xpath` JAR.

The annotation `org.apache.camel.language.Bean` has been moved to `org.apache.camel.language.bean.Bean` and in the `camel-bean` JAR.

The annotation `org.apache.camel.language.Simple` has been moved to `org.apache.camel.language.simple.Simple`.

The annotation `org.apache.camel.Constant` has been removed, use `@Simple` instead.

The annotation `org.apache.camel.language.SpEL` has been moved to `org.apache.camel.language.spel.SpEL` and in the `camel-spring` JAR.

The annotation `org.apache.camel.InvokeOnHeader` and `org.apache.camel.InvokeOnHeaders` has been moved to the `org.apache.camel.spi` package.

The class `OutputStreamBuilder` has been moved from package `org.apache.camel.converter.stream` to `org.apache.camel.support.builder` package.

Rename various APIs in camel-core to fix the typo `chiper` to `cipher`.

The classes `ReloadStrategySupport` and `FileWatcherReloadStrategy` has been removed.

The `MessageHistoryFactory` interface has some options to filter and copy the message and a slight change in its API.

Removed `TypeConverterAware` as you should instead use `Exchange` as parameter to the type converter method.

The `Component` and `DataFormat` interfaces now extend `Service` as components and data formats should also have service contract to manage their lifecycle. The default base classes already implements these interfaces.

The class `FactoryFinder` has changed its API to use `Optional` as return types instead of throwing checked `FactoryNotFoundException` or `ClassNotFoundException` etc.

The option `resolvePropertyPlaceholders` on all the components has been removed,
as property placeholders are already supported via Camel Main, Camel Spring Boot and other means.

=== camel-test

If you are using camel-test and override the `createRegistry` method, for example to register beans from the `JndiRegistry` class, then this is no longer necessary, and instead
you should use the `bind` method from the `Registry` API which you can call directly from `CamelContext`, such as:

  context.getRegistry().bind("myId", myBean);

=== Controlling routes

The `startRoute`, `stopRoute`, `suspendRoute`, `resumeRoute`, `getRouteStatus`, and other related methods on `CamelContext` has been moved to the `RouteController` as shown below:

  context.getRouteController().startRoute("myRoute");

=== JMX events

All the events from package `org.apache.camel.management.event` has been moved to the class `org.apache.camel.spi.CamelEvent` as sub-classes, for example the event for CamelContext started would be `CamelEvent.CamelContextStartedEvent`.

=== AdviceWith

Testing using `adviceWith` currently needs to be changed from:

[source,java]
----
context.getRouteDefinition("start").adviceWith(camelContext, new AdviceWithRouteBuilder() {
  ...
}
----

to using style:

[source,java]
----
ModelCamelContext mcc = camelContext.adapt(ModelCamelContext.class);
RouteReifier.adviceWith(mcc.getRouteDefinition("start"), mcc, new AdviceWithRouteBuilder() {
  ...
}
----

However its even easier using lambda style with `AdviceWithRouteBuilder` directly:

[source,java]
----
AdviceWith.adviceWith(context, "myRoute", a -> {
  a.replaceFromWith("direct:start");
}
----

=== Generic Classes

The class `JNDIContext` has been moved from `org.apache.camel.util.jndi.JNDIContext` in the camel-core JAR to `org.apache.camel.support.jndi.JNDIContext` and moved to the `camel-support` JAR.

=== EIPs

The `circuitBreaker` load-balancer EIP was deprecated in Camel 2.x, and has been removed. Instead use Hystrix EIP as the load-balancer.

The class `ThreadPoolRejectedPolicy` has been moved from `org.apache.camel.ThreadPoolRejectedPolicy` to `org.apache.camel.util.concurrent.ThreadPoolRejectedPolicy`.

=== Languages

The simple language `property` function was deprecated in Camel 2.x and has been removed. Use `exchangeProperty` as function name.

The terser language has been renamed from `terser` to `hl7terser`.

=== JSSE

The classes from `org.apache.camel.util.jsse` has been moved to `org.apache.camel.support.jsse`.

=== Helpers and support

The class `AsyncProcessorHelper` has been moved from `org.apache.camel.util.AsyncProcessorHelper` in the camel-core JAR to `org.apache.camel.support.AsyncProcessorHelper` and moved to the `camel-support` JAR.

The class `AsyncProcessorConverterHelper` has been moved from `org.apache.camel.util.AsyncProcessorConverterHelper` in the camel-core JAR to `org.apache.camel.support.AsyncProcessorConverterHelper` and moved to the `camel-support` JAR.

The class `CamelContextHelper` has been moved from `org.apache.camel.util.CamelContextHelper` in the camel-core JAR to `org.apache.camel.support.CamelContextHelper` and moved to the `camel-support` JAR.

The class `EndpointHelper` has been moved from `org.apache.camel.util.EndpointHelper` in the camel-core JAR to `org.apache.camel.support.EndpointHelper` and moved to the `camel-support` JAR.

The class `EventHelper` has been moved from `org.apache.camel.util.EventHelper` in the camel-core JAR to `org.apache.camel.support.EventHelper` and moved to the `camel-support` JAR.

The class `ExchangeHelper` has been moved from `org.apache.camel.util.ExchangeHelper` in the camel-core JAR to `org.apache.camel.support.ExchangeHelper` and moved to the `camel-support` JAR.

The class `GZIPHelper` has been moved from `org.apache.camel.util.GZIPHelper` in the camel-core JAR to `org.apache.camel.support.GZIPHelper` and moved to the `camel-support` JAR.

The class `JsonSchemaHelper` has been moved from `org.apache.camel.util.JsonSchemaHelper` in the camel-core JAR to `org.apache.camel.support.JsonSchemaHelper` and moved to the `camel-support` JAR.

The class `MessageHelper` has been moved from `org.apache.camel.util.MessageHelper` in the camel-core JAR to `org.apache.camel.support.MessageHelper` and moved to the `camel-support` JAR.

The class `ObjectHelper` has been moved from `org.apache.camel.util.ObjectHelper` in the camel-core JAR and split into `org.apache.camel.support.ObjectHelper` and moved to the `camel-support` JAR and into `org.apache.camel.util.ObjectHelper` and moved to the `camel-util` JAR. This has been done to isolate the methods using `camel-api` JAR: those method are in the `camel-support` JAR, the other in the `camel-util` JAR.

The class `PlatformHelper` has been moved from `org.apache.camel.util.PlatformHelper` in the camel-core JAR to `org.apache.camel.support.PlatformHelper` and moved to the `camel-support` JAR.

The class `PredicateAssertHelper` has been moved from `org.apache.camel.util.PredicateAssertHelper` in the camel-core JAR to `org.apache.camel.support.PredicateAssertHelper` and moved to the `camel-support` JAR.

The class `ResolverHelper` has been moved from `org.apache.camel.util.ResolverHelper` in the camel-core JAR to `org.apache.camel.support.ResolverHelper` and moved to the `camel-support` JAR.

The class `ResourceHelper` has been moved from `org.apache.camel.util.ResourceHelper` in the camel-core JAR to `org.apache.camel.support.ResourceHelper` and moved to the `camel-support` JAR.

The class `RestProducerFactoryHelper` has been moved from `org.apache.camel.spi.RestProducerFactoryHelper` in the camel-core JAR to `org.apache.camel.support.RestProducerFactoryHelper` and moved to the `camel-support` JAR.

The class `ServiceHelper` has been moved from `org.apache.camel.util.ServiceHelper` in the camel-core JAR to `org.apache.camel.support.service.ServiceHelper` and moved to the `camel-api` JAR.

The class `UnitOfWorkHelper` has been moved from `org.apache.camel.util.UnitOfWorkHelper` in the camel-core JAR to `org.apache.camel.support.UnitOfWorkHelper` and moved to the `camel-support` JAR.

=== Idempotent Repositories

The class `FileIdempotentRepository` has been moved from `org.apache.camel.processor.idempotent.FileIdempotentRepository` in the camel-core JAR to `org.apache.camel.support.processor.idempotent.FileIdempotentRepository` and moved to the `camel-support` JAR.

The class `MemoryIdempotentRepository` has been moved from `org.apache.camel.processor.idempotent.MemoryIdempotentRepository` in the camel-core JAR to `org.apache.camel.support.processor.idempotent.MemoryIdempotentRepository` and moved to the `camel-support` JAR.

=== Route Policies

The class `org.apache.camel.support.RoutePolicySupport` has been moved to the `camel-support` JAR. The return type from `startConsumer` and `stopConsumer` has been changed from `boolean` to `void` as they always returned `true` before.

The class `org.apache.camel.impl.ThrottlingInflightRoutePolicy` has been moved to `org.apache.camel.throttling.ThrottlingInflightRoutePolicy`

=== Aggregation

The class `XsltAggregationStrategy` has been moved from `org.apache.camel.util.toolbox.XsltAggregationStrategy` in the camel-core JAR to `org.apache.camel.component.xslt.XsltAggregationStrategy` and moved to the `camel-xslt` JAR.

When using the option `groupedExchange` on the aggregator EIP then the output of the aggregation is now longer also stored in the exchange property `Exchange.GROUPED_EXCHANGE`. This behaviour was already deprecated from Camel 2.13 onwards.

=== Fallback type converters

The `@FallbackConverter` annotation has been removed, and you should use `@Converter(fallback = true)` instead. Also you can set `@Converter(generateLoader = true)` on the converter class to allow Camel to generate source code for loading type converters in a faster way.

=== Removed JMX APIs for explaining EIPs, components, etc.

The APIs that could find, and explain EIPs, components, endpoints, etc. have been removed. These APIs have little value for production runtimes, and you can obtain this kind of information via the `camel-catalog`. Also the related Camel Karaf commands that used these APIs has been removed.

=== Other changes

The default for use breadcrumbs has been changed from `true` to `false`.

The `ProducerTemplate` and `ConsumerTemplate` now fails when being used, if `CamelContext` has not been started first.

=== XML DSL Migration

The XML DSL has been changed slightly.

The custom load balancer EIP has changed from `<custom>` to `<customLoadBalancer>`

The XMLSecurity data format has renamed the attribute `keyOrTrustStoreParametersId` to `keyOrTrustStoreParametersRef` in the `<secureXML>` tag.

The `<zipFile>` data format has been renamed to `<zipfile>`.

== Migrating Camel Maven Plugins

The `camel-maven-plugin` has been split up into two maven plugins:

- camel-maven-plugin
- camel-report-maven-plugin

The former has the `run` goal, which is intended for quickly running Camel applications standalone.

The `camel-report-maven-plugin` has the `validate` and `route-coverage` goals which is used for generating reports of your Camel projects such as validating Camel endpoint URIs and route coverage reports, etc.

== Known Issues

There is an issue with MDC logging and correctly transferring the Camel breadcrumb id's under certain situations with routing over asynchronous endpoints, due to the internal routing engine refactorings. This change also affects the `camel-zipkin` component, which may not correctly transfer the span id's when using MDC logging as well.
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.0 to 3.1

=== camel-ahc, camel-netty-http, camel-undertow

These Camel components now no longer have dependency on Javax Servlet.

=== camel-undertow

The exception class `HttpOperationFailedException` is now from package `org.apache.camel.http.base` instead of `org.apache.camel.http.common`.
The Camel undertow producer throws this exception.

=== camel-bean

The bean component has been changed to behave as singleton scoped by default.
This means that the bean is created or looked up once and reused.

The option `cache` has been deprecated in favour of the new `scope` option that by default is `Singleton`. You can set this to `Prototype` to use the old behaviour.

[NOTE]
====
Setting this to Prototype will let Camel create/lookup a new bean instance, per use; which acts as prototype scoped. However beware that if you lookup the bean, then the registry that holds the bean, would return a bean accordingly to its configuration, which can be singleton or prototype scoped. For example if you use Spring, or CDI, which has their own settings for setting bean scopes.
====

=== camel-etcd

The `camel-etcd` component has changed its endpoint syntax from `etcd:action/path` to
`etcd-keys:path`, `etcd-stats:path`, or `etcd-watch:path`.

For example before

[source,text]
----
etcd:stats/leader
----

Should be changed to
----
etcd-stats:leader
----

This change was needed as the 3 actions could not share the same component/endpoint and had to be separated.

=== camel-ftp

 The stepwise functionality (stepwise=true) is not supported for stream download (treamDownload=true).

=== camel-irc

The `camel-irc` component has changed its endpoint syntax and removed option #room as a part of the url path. Allowed syntax is:

[source,text]
----
irc:nick@host[:port]?[options]
----

=== camel-milo

The `camel-milo` client component has changed its endpoint syntax from `milo-client:tcp` to `milo-client:opc.tcp`.
For example before

[source,text]
----
milo-client:tcp://foo:bar@localhost:1234
----

Should be changed to
----
milo-client:opc.tcp://foo:bar@localhost:1234
----

The `camel-milo` server component requires Java 9 at runtime.
Property `strictEndpointUrlsEnabled` is no longer supported.
Properties`hostName` and `serverName` are replaced by `path`.
To successfully use certificates for secured communication, JCE Jurisdiction Policy File Default
has to be *Unlimited* (which is by default since Java 9+).

=== camel-nats

The `camel-nats` component has changed its endpoint syntax from `nats:servers` to `nats:topic`.
For example before

[source,text]
----
nats:myserver:4222?topic=myTopic
----

Should be changed to
----
nats:myTopic?servers=myserver:4222
----

This change is motivated by allowing to configure servers on component level,
and also for Spring Boot auto-configuration etc.

=== camel-nsq

The `camel-nsq` component has changed its endpoint syntax from `nsq:servers` to `nsq:topic`.
For example before

[source,text]
----
nsq:myserver:4161/myTopic
----

Should be changed to
----
nsq:myTopic?servers=myserver:4161
----

This change is motivated by allowing to configure servers on component level,
and also for Spring Boot auto-configuration etc.

=== camel-ipfs

The `camel-ipfs` component has changed its endpoint syntax from `nsq:host:port/command` to `ipfs:command`.
The host and port is now configured on the component level instead.

For example before

[source,text]
----
ipfs:127.0.0.1:5001/add
----

Should be changed to
----
ipfs:add
----

=== camel-xmlsecurity

The `camel-xmlsecurity` component has changed its endpoint syntax from `xmlsecurity:command/name` to
`xmlsecurity-sign:name`, `xmlsecurity-verify:name`.

For example before

[source,text]
----
xmlsecurity:verify/foo
----

Should be changed to
----
xmlsecurity-verify:foo
----

This change was needed as the 2 commands could not share the same component/endpoint and had to be separated.

=== spi-annotations

The `spi-annotations` JAR is mandatory but was mistakenly defined as optional scope. The content of this JAR
is now embedded directly into `camel-api` JAR so end users does not have to include or depend on `spi-annotations` JAR anymore.

=== camel-core-engine and camel-jaxp

XML and JAXB has been moved out of camel-base and camel-core-engine.

The module camel-jaxp has been renamed to camel-xml-jaxp.

The camel-xml-jaxp JAR has XML parsers and type converters.
The camel-xml-jaxb has support for loading XML DSL routes using JAXB.
An alternative is to use the new camel-xml-io for loading XML routes which is more light-weight and faster than JAXB.

=== JAXB is now optional

JAXB is now optional in Camel and only needed when using XML routes with the `camel-xml-jaxb` JAR
for loading and parsing the routes with JAXB. There is an alternative implementation with `camel-xml-io` (see above).

This means that `jaxb-core` and `jaxb-impl` JARs no longer are needed on the classpath and as such has been removed
as dependency in the various Camel `pom.xml` files.

There are a number of components that uses JAXB such as `camel-spring`, `camel-blueprint`, `camel-cdi` for their support
of using XML for beans and Camel XML routes. And a few components such as `camel-soap` etc.

But at general then Camel is now lighter in classpath dependency by not requiring to have JAXB present.

=== Package scanning @TypeConverter

Camel has now been configured to not package scan for custom `@Converter` classes on startup.
Type converters are now loaded and registered in faster way via source code generated loader classes
by having `@Converter(loader = true)` specified. If you have custom converters and have not migrated to use
source code generated loaders, you can enable package scanning by setting

[source,java]
----
camelContext.setLoadTypeConverters(true);
----

And in XML:
[source,xml]
----
<camelContext loadTypeConverters="true">
...
</camelContext>
----

And in Spring Boot `application.properties`:
[source,properties]
----
camel.loadTypeConverters=true
----

=== Graceful Shutdown Timeout

When shutting down Camel, then the default timeout has changed from 300 seconds (5 minutes) to 45 seconds.
The 45 seconds was chosen as 30 seconds is a common timeout to use for remote protocols, so we wanted to give
Camel a bit more time, and hence added 15 seconds so the default is 45 seconds.

=== Message History

The message history is now default disabled (due to optimize core for lower footprint out of the box).
See the xref:components:eips:message-history.adoc[Message History] documentation for how to enabled message history.

=== Inflight Repository

The inflight repository now does no longer allow browsing each individual exchange (due to optimize core for lower footprint out of the box).
To enable browsing then you can turn this on via:

[source,java]
----
    context.getInflightRepository().setInflightBrowseEnabled(true);
----

And in XML DSL:

[source,xml]
----
<camelContext inflightRepositoryBrowseEnabled="true">

</camelContext>
----

=== Component Extension Verifier

When using component verifier (`org.apache.camel.component.extension.ComponentVerifierExtension`) then you
would know need to add `camel-core-catalog` to the classpath to make this useable. If the JAR is missing,
there will be an exception stating that `RuntimeCamelCatalog` is not found and that this JAR should be added.

=== ManagedRuntimeCatalog

The `ManagedRuntimeCatalog` JMX MBean is removed and no longer available.

=== Spring Boot JMX

The `camel-management` dependency of `camel-spring-boot` was removed as Spring Boot 2.2+ disables JMX by default.

To continue using JMX with Camel Spring Boot add the following dependency:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-management</artifactId>
</dependency>
----

=== Custom components

Camel now uses Camel Package Maven Plugin instead of `camel-apt` APT compiler to generate component meta data.

Custom components should then change in the pom.xml from:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>apt</artifactId>
  <scope>provided</scope>
</dependency>
----

To the following:

[source,xml]
----
      <plugin>
        <groupId>org.apache.camel</groupId>
        <artifactId>camel-package-maven-plugin</artifactId>
        <version>${camel-version}</version>
        <executions>
          <execution>
            <id>generate</id>
            <goals>
              <goal>generate-component</goal>
            </goals>
            <phase>process-classes</phase>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>build-helper-maven-plugin</artifactId>
        <executions>
          <execution>
            <phase>initialize</phase>
            <goals>
              <goal>add-source</goal>
              <goal>add-resource</goal>
            </goals>
            <configuration>
              <sources>
                <source>src/generated/java</source>
              </sources>
              <resources>
                <resource>
                  <directory>src/generated/resources</directory>
                </resource>
              </resources>
            </configuration>
          </execution>
        </executions>
      </plugin>
      <!--
      Recompile source after generated loader classes have been created.
      The maven-compiler-plugin must be defined in the POM after the
      camel-package-maven-plugin so recompile runs after generated
      sources have been created.

      Adjust configuration for the JDK version your project uses.
      -->
      <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.1</version>
          <configuration>
              <source>1.11</source>
              <target>1.11</target>
          </configuration>
          <executions>
              <execution>
                  <id>recompile</id>
                  <goals>
                      <goal>compile</goal>
                  </goals>
                  <phase>process-classes</phase>
              </execution>
          </executions>
      </plugin>
----

=== API changes

==== log changed to private static LOG

The `ServiceSupport` class has changed its logging from instance to static, which means any inherited class that
uses `log` would need to change the code to compile. This may happen in custom Camel components.

Before you may have:

[source,java]
----
    log.debug("Sending message to foobar service: {}", messageId);
----

You then need to migrate the logging to also be static:

[source,java]
----
    private static final Logger LOG = LoggerFactory.getLogger(FooBarProducer.class);

    LOG.debug("Sending message to foobar service: {}", messageId);
----

==== Exchange

The `Exchange` API has been modified slightly as part of an optimization effort.
The return value of `getCreated` was changed from `java.util.Date` to `long` which is the time millis.
The `Exchange.CREATED_TIMESTAMP` is no longer stored as exchange property, but you should use the `getCreated` method on `Exchange`.
The return value of `isExternalRedelivered` was changed from `Boolean` to `boolean`.

Some of the advanced and API for component developers on `Exchange` has been moved to an extended interface `ExtendedExchange`.
The following methods have been moved:

- setFromEndpoint
- setFromRouteId
- setUnitOfWork
- addOnCompletion
- containsOnCompletion
- handoverCompletions

You can use these methods by adapting to the extended exchange as shown below:

[source,java]
----
exchange.adapt(ExtendedExchange.class).addOnCompletion(...);
----

==== Message

The message ID will now default to use the same id as Exchange ID as messages are associated with the exchange
and using different IDs does not offer much value. Another reason is to optimize for performance to avoid generating new IDs.
A few Camel components do provide their own message IDs such as the JMS components.

==== UnitOfWork

Advanced Camel users whom implement a custom `UnitOfWork` should implement the new `isBeforeAfterProcess()' method and return true or false,
whether Camel should invoke the before and after processor methods.

The method `getId` has been removed.

==== Cookies

Cookies from `camel-http-common` has been moved into a new `camel-http-base` JAR.
The package `org.apache.camel.http.common.cookie` is renamed to `org.apache.camel.http.base.cookie`.

==== Exchange.ROUTE_STOP

To signal an `Exchange` to stop continue routing has changed from setting the exchange property `Exchange.ROUTE_STOP` to true.
Instead you should now use the `setRouteStop` method on the `Exchange` API.

[source,java]
----
    exchange.setProperty(Exchange.ROUTE_STOP, Boolean.TRUE);
----

Should now be:
[source,java]
----
    exchange.setRouteStop(true);
----

==== Exchange.ROLLBACK_ONLY and Exchange.ROLLBACK_ONLY_LAST

To signal an `Exchange` to rollback a transaction has changed from setting the exchange property `Exchange.ROLLBACK_ONLY` to true.
Instead you should now use the `setRollbackOnly` method on the `Exchange` API (the same for rollback only last).

[source,java]
----
    exchange.setProperty(Exchange.ROLLBACK_ONLY, Boolean.TRUE);
----

Should now be:

[source,java]
----
    exchange.setRollbackOnly(true);
----

==== Exchange.ERRORHANDLER_HANDLED

The exchange property `Exchange.ERRORHANDLER_HANDLED` was used to indicate that the error handling mechanism for a given exchange
had completed.  This property sometimes had to be conveyed by aggregation strategies, so instead of

[source,java]
----
    oldExchange.getProperties().put(
            Exchange.ERRORHANDLER_HANDLED,
            newExchange.getProperties().get(Exchange.ERRORHANDLER_HANDLED));
----

one should now use:

[source,java]
----
    Boolean handled = newExchange.adapt(ExtendedExchange.class)
            .getErrorHandlerHandled();
    oldExchange.adapt(ExtendedExchange.class)
            .setErrorHandlerHandled(handled);
----

==== ModelHelper removed

The class `org.apache.camel.model.ModelHelper` has been removed. Instead you can use its functionality from `ExtendedCamelContext` by
the `getModelToXMLDumper` and `getXMLRoutesDefinitionLoader` methods which has APIs similar to `ModelHelper`.

==== JsonSchemaHelper removed

The class `org.apache.camel.tooling.util.JSonSchemaHelper` has been removed. Instead you can use utils coming from camel-util-json
and the class `org.apache.camel.tooling.util.PackageHelper`

==== camel-xml-jaxp

The class `org.apache.camel.processor.validation.PredicateValidatingProcessor` has moved from `camel-xml-jaxp` JAR
to `camel-support` JAR and renamed to `org.apache.camel.support.processor.PredicateValidatingProcessor`.

==== Java DSL

The Java DSL has been revisited and the following methods have been removed:

* ExpressionClause::body(Supplier<Object>)
* MulticastDefinition::onPrepare(Supplier<Processor>)
* ProcessorDefinition::process(Supplier<Processor>)
* ProcessorDefinition::setBody(Supplier<Result>)
* RecipientListDefinition::onPrepare(Supplier<Processor>)
* SplitDefinition::onPrepare(Supplier<Processor>)
* WireTapDefinition::newExchange(Supplier<Processor>)
* WireTapDefinition::onPrepare(Supplier<Processor>)

This change is motivated by the need to remove method ambiguity for untyped languages such as Groovy and JavaScript, for more info see https://issues.apache.org/jira/browse/CAMEL-14300

==== CamelContext

Some unused methods have been removed from `CamelContext` which were not part of the public API. The following methods have been removed:

* getProducerServicePool
* setProducerServicePool
* getPollingConsumerServicePool
* setPollingConsumerServicePool

==== Internal API changes

Removed the method `getProcessors` from `Pipeline` as you should use the `next` method instead to access a read-only view of the processors.

==== @Experimental

The `@Experimental` annotation is moved from `meta-annotations` JAR to `camel-api`
and moved from package `org.apache.camel.meta` to `org.apache.camel`.
And the meta-annotations has been removed.

==== Property Placeholders

The support for out-of-band property placeholders has been removed.
This means that XML that were using the `http://camel.apache.org/schema/placeholder`
namespace and that the java builders using the `.placeholder(key, value).` have to
be modified.

[source,java]
----
    from("direct:start")
        .multicast()
        .placeholder("stopOnException", "stop")
        .to("mock:a")
----
should be rewritten as:
[source,java]
----
    from("direct:start")
        .multicast()
        .stopOnException("{{stop}}")
        .to("mock:a")
----

and
[source,xml]
----
   <route>
        <from uri="direct:start"/>
        <multicast prop:stopOnException="stop">
            <to uri="mock:a"/>
        </multicast>
    </route>
----
should be rewritten as:
[source,xml]
----
   <route>
        <from uri="direct:start"/>
        <multicast stopOnException="{{stop}}">
            <to uri="mock:a"/>
        </multicast>
    </route>
----

= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.9 to 3.10

=== API changes

The method `concurrentTasks` on `org.apache.camel.support.DefaultScheduledPollConsumerScheduler ` has been renamed to `concurrentConsumers`.

The `org.apache.camel.cloud.ServiceFilter` and `org.apache.camel.cloud.ServiceLoadBalancer` 
functional interface methods take the current `Exchange` as additional parameter 
to allow for content-based filtering of service candidates. `RibbonServiceLoadBalancer` 
has no notion of a current exchange, service filters therefore receive a dummy exchange when used with Ribbon.

The two methods `filterTypeInOutputs` on `org.apache.camel.model.ProcessorDefinitionHelper` has changed
to return `Collection` instead of `Iterator`.

The annotation `@Consume` has removed its target for field/constructor injection as the `@Consume` is only to be used on methods.
The annotations `@Produce` and `@EndpointInject` has removed its target for constructor injection as that is not supported (Camel only does bean post processing)

=== camel-scheduler

The option `concurrentTasks` has been renamed to `poolSize` to better reflect its purpose.
The scheduler has also been fixed to only schedule triggering by one, and not as mistakenly by causing
concurrent triggering which causes routing mistakes.

The option configures the pool size of the scheduled thread pool used by the scheduler.

If the scheduler thread is being blocked by anywhere in the downstream routing, and you want the scheduler
to schedule with a fixed interval, you can use the Threads EIP as queue for pending tasks.

=== camel-jdbc

The `camel-jdbc` component no longer depends on Spring Framework, instead a new `camel-spring-jdbc` component
has been created. You should use `camel-spring-jdbc` if you use Spring and need Spring Transaction support.
The `camel-jdbc` is using plain Java JDBC API only.

=== camel-jsonpath

This component now uses Jackson as the default json parser instead of json-smart.

Usage of `JacksonJsonAdapter` has been slightly changed.

Component was trying to use `JacksonJsonAdapter` ahead of automatic conversion of the payload to the `InputStream`
in the previous version. New version tries to convert the payload into `InpuStream` first. `JacksonJsonAdapter` is used
only if conversion to `InputStream` is not possible.

Order of the basic payload types (like `String`, `Map`, `File`) has not been changed.

=== camel-huaweicloud-smn

Initialization options for SMN client has slightly changed. 

Earlier, the library configured the smn server url based on the region parameter provided in endpoint configurations. Now, it provides more flexibility by allowing camel users by providing fully qualified http url for more customizability.

When endpoint URL is provided, it carries the higher precedence than region based configuration. Any region configuration entered along with endpoint url will be ignored.

=== Camel-Azure-Storage-Blob

The service client is now autowired. No need to set explicitly on your route if it is already in the registry. This is the reason why the autoDiscoverClient option has been removed.

=== Camel-Azure-Storage-Queue

The service client is now autowired. No need to set explicitly on your route if it is already in the registry.

=== Spring Boot Starters

Some of the Camel Spring Boot starters have additional auto configuration options that clashed with component.
Therefore those configurations has renamed their configuration keys:

|====
| *Old Key prefix* | *New key prefix*
| camel.component.atomix.cluster.service | camel.cluster.atomix
| camel.component.consul.cluster.service | camel.cluster.consul
| camel.component.consul.service-registry | camel.cloud.consul.service-registry
| camel.component.file.cluster.service | camel.cluster.file
| camel.component.hystrix.mapping | camel.hystrix.mapping
| camel.component.jgroups.lock.cluster.service | camel.cluster.jgroups
| camel.component.jgroups.raft.cluster.service | camel.cluster.jgroups-raft
| camel.component.kubernetes.cluster.service | camel.cluster.kubernetes
| camel.component.servlet.mapping | camel.servlet.mapping
| camel.component.undertow.spring.security | camel.security.undertow
| camel.component.zookeeper.cluster.service | camel.cluster.zookeeper
| camel.component.zookeeper.service-registry | camel.cloud.zookeeper
|====
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example, if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.10 to 3.11

=== Bean Language

When using `beanType` (full qualified class name) with the bean language,
then the bean language will *now* look up in the registry, and if there is a single instance of the same type, then the existing bean is used.
If not, then a new bean is created (same behavior as before).

=== Aggregate EIP

The aggregate EIP will now always use a worker thread pool for processing outgoing messages.
Previously a worker pool was only created when `parallelProcessing=true`. When having `parallelProcessing=false`
then a single-threaded worker pool is created and used by the aggregator.

Camels routing engine works better when a dedicated worker pool that eliminates a _hack_ that otherwise was necessary in other EIPs that
was affected if using the aggregator in some special configurations.

=== RemoveHeader EIP

In XML and YAML DSL the `headerName` attribute has been deprecated, and you should use `name` instead.
This is to make the EIP consistent with the naming used by other similar EIPs.

=== Routes loader

The default pattern for discovering Camel routes et all from the classpath has changed from only including XML files to now include all files.

The option `routesIncludePattern` is changed  from:
----
classpath:camel/*.xml,classpath:camel-template/*.xml,classpath:camel-rest/*.xml`
----

to:

----
classpath:camel/*,classpath:camel-template/*,classpath:camel-rest/*
----

This is from the `camel-main` module which is for running Camel standalone, but also reused for Camel on Spring Boot, or Camel on Quarkus.

=== camel-apns

The `camel-apns` component has been removed as the APNS (Apple Push Notification Service) online service has been retired y Apple.

=== camel-mongodb

The `streamFilter` option should now be configured as endpoint uri parameter, instead of a route property.

=== camel-saxon

The camel-saxon component no longer depends on camel-xslt-saxon.
Any applications in need of XSLT transformation with saxon should now declare an explicit dependency upon camel-xslt-saxon.

=== camel-maven-plugin with OSGi blueprint

The `run` goal of the `camel-maven-plugin` has moved its OSGi Blueprint support out to its own `camel-karaf-maven-plugin`.

This means if you use Camel on OSGi Blueprint then you need to migrate from:
[source,xml]
----
<plugin>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-maven-plugin</artifactId>
    <version>3.11.0</version>
</plugin>
----

to

[source,xml]
----
<plugin>
    <groupId>org.apache.camel.karaf</groupId>
    <artifactId>camel-karaf-maven-plugin</artifactId>
    <version>3.11.0</version>
</plugin>
----

In the `pom.xml` file.

Also remember to execute the `run` goal, you should use `camel-karaf:run` instead of `camel:run` as shown:

[source,bash]
----
mvn camel-karaf:run
----

=== camel-sql

Support for deprecated use of named dataSource in the URI has been removed.

You have to use `sql:select * from table where id=# order by name?dataSource=\#myDS` instead of `sql:select * from table where id=# order by name?dataSource=myDS`.

=== Spring Boot Starters

Some of the Camel Spring Boot starters have additional autoconfiguration options that clashed with component.
Therefore, those configurations have renamed their configuration keys:

|====
| *Old Key prefix* | *New key prefix*
| camel.component.consul.service-registry | camel.cloud.consul
| camel.cloud.consul.service-registry | camel.cloud.consul
|====

=== Apache Karaf

The `camel-grpc` feature has been removed.
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.11 to 3.12

=== API changes

The methods `getComponentNames` and `getLanguageNames` on `CamelContext` have been changed to
return `Set<String>` instead of `List<String>`.

Added `getExchangePattern` to `Endpoint` which is a method that already exists on `DefaultEndpoint`.
However the method is needed to be exposed in the API as well.

The `ThroughputLogger` has changed the return type from `int` to `long` in the `getReceivedCounter` method.

Removed the `dataSonnet(Expression)` methods from `RouteBuilder` as they should not be used;
use the methods that take `String` as type.

=== Data Formats

We had to fix all the data-formats options that take a Java classname to support
using the `.class` type in Java vs using a string value in XML/YAML.

This means the following options have been renamed:

- `camel-asn1` renamed `clazzName` to `unmarshalType`
- `camel-avro` renamed `collectionTypeName` to `collectionType`, and `jsonViewTypeName` to `jsonView`, and `unmarshalTypeName` to `unmarshalType`
- `camel-cbor` renamed `collectionTypeName` to `collectionType`, and `unmarshalTypeName` to `unmarshalType`
- `camel-jacksonxml` renamed `collectionTypeName` to `collectionType`, and `jsonViewTypeName` to `jsonView`, and `unmarshalTypeName` to `unmarshalType`
- `camel-json` renamed `collectionTypeName` to `collectionType`, and `jsonViewTypeName` to `jsonView`, and `unmarshalTypeName` to `unmarshalType`
- `camel-protobuf` renamed `collectionTypeName` to `collectionType`, and `jsonViewTypeName` to `jsonView`, and `unmarshalTypeName` to `unmarshalType`
- `camel-yaml` renamed `unmarshalTypeName` to `unmarshalType`

=== Rest DSL

The `clientRequestValidation` now includes one more check:

- Parsing error of the message body (JSon, XML or Auto binding mode must be enabled). (Returns HTTP Status 400)


=== camel-aws2-ddb

The `iteratorType` option has been dropped in favour of the `streamIteratorType` option. Possible values are `FROM_LATEST` and `FROM_START`.

The `sequencenumberprovider` functionality is no longer supported.

=== camel-catalog

Remove the APIs to return the website documentation in ascii doc and html format, it is the methods
with naming pattern `...AsciiDoc` and `...HtmlDoc`.

=== camel-cdi

The XML DSL with `camel-cdi` has removed the deprecated `<proxy>` functionality.

=== camel-http-common

The method `org.apache.camel.http.common.HttpHelper.readResponseBodyFromInputStream` is renamed to `cacheResponseBodyFromInputStream`,
because it must cache the response body as it is used with the `PollingConsumer` in `camel-http`,
that otherwise may fail if the original `InputStream` is closed by the underlying HTTP client.

=== camel-jms

The `camel-jms` component now better support Apache Artemis in streaming mode for large messages support,
when Artemis is using a pooled connection pool (previously pooled was not supported). Now the option `artemisStreamingEnabled`
must explicit be set to `true` to enable support for Artemis streaming mode. Previously Camel tried to auto-detect this.

=== camel-google-sheets

The `google-sheets-stream` component has changed the syntax, from: `google-sheets-stream:apiName` to: `google-sheets-stream:spreadsheetId`

The old `apiName` option was not in use, and therefore it has been replaced with `spreadsheetId`
which used to be query parameter.

=== camel-kamelet / route templates

Kamelet parameters that are named such as `host`, `port` are now always used with their configured value.
Before the value in use may have been from an ENV variable with the same name.

=== camel-kafka

The `camel-kafka` component was refactored to avoid blocking API calls in the Kafka consumer. As part of the refactoring the configuration `consumerStreams` was removed. In previous versions this setting configured the size thread pool used by the component to create Kafka consumers. As of 3.12, the size of the thread pool is set to be the same as the number of concurrent consumers (set by `consumersCount`).

=== camel-spark

The `camel-spark` component has been upgraded from Spark 2.x to 3.x.

=== camel-influxdb

The `camel-influxdb` won't autocreate the database if not present anymore.
With CAMEL-16892 we introduced the checkDatabaseExistence and autoCreateDatabase options for this purpose. 
Both of the options are false by default. So, you'll need to set both to true if you want to have the older releases' behavior, or create the database yourself before using the camel component.

=== camel-huawei

All Huawei Cloud components use AK/SK as security keys to authenticate against the hauwei cloud backend services. Initally AK was mapped to authenticationKey in the endpoint class. To be in-line with Huawei Cloud's naming conventions, we have renamed this option from `authenticationKey` to `accessKey` for all components. This is a breaking change for users who are already using huawei cloud components until version 3.11.x. 

=== camel-spring-cloud-*-starter

The deprecated camel-spring-boot cloud-starter components camel-spring-cloud-starter, camel-spring-cloud-consul-starter, camel-spring-cloud-netflix-starter and camel-spring-cloud-zookeeper-starter have been removed.
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.12 to 3.13

=== API changes

Added method `getStartedEventNotifiers` to `org.apache.camel.spi.ManagementStrategy`.

Added method `scheduleQueue` to `org.apache.camel.spi.ReactiveExecutor`.

The `org.apache.camel.support.ObjectHelper#createIterable` now supports `java.util.Map` returning
an `Iterable<Map.Entry>` iterating each row in the map.

The `org.apache.camel.spi.RestApiProcessorFactory` has removed
the following two parameters (`String contextIdPattern, boolean contextIdListing`)
from the `createApiProcessor` method.

=== Split EIP

The Split EIP now supports splitting message bodies that are of type `java.util.Map`, which
now splits that into a `Set<Map.Entry>` - eg a set of each map entry as key/value pairs.

=== SimpleBuilder

The `org.apache.camel.builder.SimpleBuilder` has been deprecated. This builder
was mostly used internally in Camel with the Java DSL in some situations.

End users that may use `SimpleBuilder` in Camel Java DSL can migrate from:

[source,java]
----
simple("1").resultType(Integer.class))
----

to

[source,java]
----
simple("1", Integer.class)
----

=== CamelContextInitializing and CamelContextInitialized events

These two events are fired during bootstrap of `CamelContext` even if a custom `EventNotifier`
may not have been fully started. This is due to that these events happen very early in the
bootstrap process, but are of importance for event notifiers to be able to react upon.

=== Using custom Debugger

Previously when setting a custom `org.apache.camel.spi.Debugger`, then Camel would automatically
enable debug mode. Now debugging must be enabled by setting `setDebugging(true)` on `CamelContext`.

=== Using Transactions

The routing engine has been changed to route exchanges in a different order
when using transactions (`.transacted()`). When an `Exchange` is continued
routed a task is scheduled to the `ReactiveExecutor`. This fixed issues
with could lead to `StackOverflowException`.

=== camel-couchdb

The `since` configuration was replaced by the `resumeStrategy`. Integrations can now manage the last update sequence for tracking the changes directly. Check the samples section on the component documentation page for a sample.

=== camel-file

In order to reduce memory pressure, the component was modified to avoid using Lists for certain file operations (CAMEL-17059). This affected the APIs of some the APIs and interfaces provided by the component.

- `GenericFileOperations`: the return type for the methods `listFiles` and `listFiles(String)` was modified to return an array of (generic) objects instead of a List
- `GenericFileConsumer`: the signature of the methods `isValidFile` and `isMatched` was modified to receive an array of files.

=== camel-ftp

The `FtpConsumer`, `FtpOperations`, `SftConsumer` and `SftpOperations` classes were modified to comply with the API changes on the `camel-file` component.

=== camel-hazelcast-starter

The `camel-hazelcast-starter` for Spring Boot no longer has _customer_ auto configuration options for all its components

eg the following configuration keys have been removed

- `...customizer.hazelcast-instance.enabled`
- `...customizer.hazelcast-instance.override`

Any Camel component can be customized by using the `org.apache.camel.spi.ComponentCustomizer` SPI.

=== camel-jsch

The `ScpOperations` class were modified to comply with the API changes on the `camel-file` component.

=== camel-kafka

The `KafkaManualCommit` class were modified in order to support async manual commit. Please use the new function `commit()` instead of the old deprecated one `commitSync()`.

=== camel-mllp

This component has been refactored to be similar to other Camel components.
The old component had an unusual static configuration of the `MllpComponent` which now is
refactored to be Camel standard with regular getter/setters. The component is now also
configured _reflection free_. We also cleaned up how the component dealt with which charset
to use when processing HL7 messages. Users using `camel-mllp` is recommended to test
their applications when upgrading to ensure this continues to work.

=== camel-openapi-java / camel-swagger-java

When using Rest DSL and the `restConfiguration` has a `contextPath` configured, then this value
is used as leading base path for all API services that are in the generated api-docs.

This is i.e. needed when using `camel-servlet` which runs under a specific `context-path`.

Support for rendering api docs by discovering other CamelContext via JMX in the same JVM has been removed.
Rendering of api docs is now only supported for the same CamelContext.

=== camel-quartz

The `fireNow` parameter was removed because have no effect.
The `triggerStartDelay` parameter supports negative value to shift trigger start time in the past. It allows to fire the trigger immediately by configured `MISFIRE_INSTRUCTION_FIRE_ONCE_NOW`.

=== camel-aws2-sqs

Since the maximum number of attributes per SQS message is 10, we are limiting the number of headers to be converted to attributes to 10.

=== When using muteException

HTTP based components that are using `muteException=true` will return an empty message body,
instead of the text `Exception`.

This applies to camel-jetty, camel-undertow, camel-servlet, camel-netty-http
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example, if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.14.x to 3.14.10

The option `synchronous` in `camel-ftp` has been removed, as this is always enabled to ensure
thread safety for the underlying FTP client.

== Upgrading Camel 3.13 to 3.14

=== API changes

Added method `updateRoutesToCamelContext` to `org.apache.camel.RoutesBuilder` interface.

Added parameter `Resource` in `createRoute` method on `org.apache.camel.spi.RouteFactory`.

Added method `reloadProperties` to `org.apache.camel.spi.LoadablePropertiesSource`.

Removed the deprecated `headerName` option from RemoveHeader EIP. Use `name` instead.

=== camel-kafka

The APIs in `camel-kafka` component changed from using the Kafka Client classes `org.apache.kafka.clients.producer.KafkaProducer` and `org.apache.kafka.clients.consumer.KafkaConsumer`
to their interfaces `org.apache.kafka.clients.producer.Producer` and `org.apache.kafka.clients.consumer.Consumer` instead.

The option `KafkaManualCommitFactory` on component is now autowired, if there exists a single
custom factory in the registry.

=== camel-jbang

The option `debug-level` has been renamed to `logging-level` because the option is for configuring the logging level.

=== camel-zookeeper/camel-master

When using Zookeeper with the Master component, the given namespace is now used to define leadership. In other words, a route defined with `master:lock1` will result in one leader election, while a route defined with `master:lock2` will result in a separate leader election, which may or may not result in the same leader as `lock1`. This matches the existing behavior of the Master component when using Consul.

=== camel-aws2-ses

The to and replyTo parameters are now comma separated String and no more List of Strings, this is true even for the related headers.
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.14 to 3.15

IMPORTANT: Java 8 is no longer supported. Camel 3.15 onwards requires Java 11 or 17.

=== Removed components

The `camel-kamelet-reify` and `camel-spring-javaconfig` has been removed.

=== Removed Maven Archetypes

The `camel-archetype-endpointdsl` has been removed.

=== API changes

Added `getScheme` method to `org.apache.camel.spi.Resource`.

=== Core Dependency changes

As part of CAMEL-17429 and CAMEL-17435, the following dependencies are no longer included by default on all the Camel modules:

 * com.sun.xml.messaging.saaj:saaj-impl
 * jakarta.xml.bind:jakarta.xml.bind-api
 * javax.annotation:javax.annotation-api
 * javax.xml.soap:javax.xml.soap-api
 * javax.xml.ws:jaxws-api
 * org.apache.geronimo.specs:geronimo-jta_1.1_spec
 * org.apache.geronimo.specs:geronimo-ws-metadata_2.0_spec
 * org.glassfish.jaxb:jaxb-runtime

These dependencies were included on the specific modules and components that required them on a per-case basis.

Applications with dependency on any of those, but using them transitively, should be modified to include them.

=== camel-core

Removed the deprecated `Classic` value from `startupSummaryLevel` enums.

The deprecated `propertyName` on `removeProperty` EIP has been removed, use `name` instead.

=== Data Formats

The data formats naming has been made consistent to use Camel Case:

[width="100%",cols="1m,1m",options="header"]
|====
| Old Name | New Name
| bindy-csv | bindyCsv
| bindy-fixed | bindyFixed
| bindy-kvp | bindyKvp
| customDataFormat | custom
| gzip-deflater | gzipDeflater
| jacksonxml | jacksonXml
| json-fastjson | fastjson
| json-gson | gson
| json-jackson | jackson
| json-johnzon | johnzon
| json-jsonb | jsonb
| json-xstream | xstreamJson
| mime-multipart | mimeMultipart
| protobuf-jackson | protobufJackson
| secureXML | xmlSecurity
| soapjaxb | soap
| tarfile | tarFile
| univociy-csv | univociyCsv
| univociy-fixed | univociyFixed
| univociy-tsv | univociyTsv
| yaml-snakeyaml | snakeYaml
| zip-deflater | zipDeflater
| zipfile | zipFile
|====

The Spring Boot auto-configuration names has also been renamed
(uses dash case as this is Spring Boot naming style):

[width="100%",cols="1m,1m",options="header"]
|====
| Old Name | New Name
| camel.dataformat.fhirjson | camel.dataformat.fhir-json
| camel.dataformat.fhirxml | camel.dataformat.fhir-xml
| camel.dataformat.gzipdeflater | camel.dataformat.gzip-deflater
| camel.dataformat.jacksonxml | camel.dataformat.jackson-xml
| camel.dataformat.jsonapi | camel.dataformat.json-api
| camel.dataformat.mimemultipart | camel.dataformat.mime-multipart
| camel.dataformat.securexml | camel.dataformat.xml-security
| camel.dataformat.tarfile | camel.dataformat.tar-file
| camel.dataformat.tidymarkup | camel.dataformat.tidy-markup
| camel.dataformat.univocitycsv | camel.dataformat.univocity-csv
| camel.dataformat.univocityfixed | camel.dataformat.univocity-fixed
| camel.dataformat.univocitytsv | camel.dataformat.univocity-tsv
| camel.dataformat.yaml-snakeyaml | camel.dataformat.snake-yaml
| camel.dataformat.zipdeflater | camel.dataformat.zip-deflater
| camel.dataformat.zipfile | camel.dataformat.zip-file
|====

==== Message History

The message history output has changed to include source column, which refers to the Java class/XML file
from the DSL the message was at the given time. (line precise error reporting).

This default formatting are (Source, ID, Processor, Elapsed):

[source,properties]
----
MESSAGE_HISTORY_HEADER = "%-40s %-30s %-50s %-12s";
MESSAGE_HISTORY_OUTPUT = "%-40.40s %-30.30s %-50.50s %12.12s";
----

If you are using custom sizes then you need to adjust accordingly.

=== camel-endpointdsl

The Endpoint DSL is now more type-safe, where previously an option would be declared as `Object` type,
is now declared using its actual type, such as `javax.sql.DataSource`.

Option that are enums is now using the real enum FQN class name, instead of a duplicate enum
class that was embedded inside the Endpoint DSL. For example when using `aws2sq` the
namingStrategy enum is changed from `org.apache.camel.builder.endpoint.dsl.AWS2S3EndpointBuilderFactory`
to `org.apache.camel.component.aws2.s3.stream.AWSS3NamingStrategyEnum` class name.

=== camel-management

The route controller MBeans are moved from `routecontrollers` to the existing `services`
node in the JMX MBean tree.

Removed deprecated operations on `CamelContextMBean` and `CamelRouteMBean`.

=== camel-util

Deleted the `replaceAll` method of `org.apache.camel.util.StringHelper`. Please use the `replace` method of `java.lang.String` instead, as it is much faster from Java 11 onward.

=== camel-yaml-dsl

Removed `steps` from `route` because steps should only be configured on `from` making
the DSL consistent and similar to Java DSL.

Before it was possible to do:

[source,yaml]
----
- route:
    id: demo-route
    from:
      uri: "timer:info"
    steps:
      - log: "message"
----

This should correctly be done with `steps` as child of `from`:

[source,yaml]
----
- route:
    id: demo-route
    from:
      uri: "timer:info"
      steps:
        - log: "message"
----

The `tod` EIP name has been removed, the correct names to use is `toD`.

=== camel-jbang

The JBang app that was previously named `CamelJBang` is now named `camel`. It is still possible to use the older name by installing it using `CamelJBang@apache/camel` but this approach is deprecated and should not be used in the future.

=== camel-debezium

Upgraded to Debezium 1.8 which requires Java 11 and Kafka Client 3.0 JARs.

=== camel-cdi

The legacy XML in `camel-cdi` with `<camelContext>` is deprecated, instead the XML DSL route loader should be used.

JTA support is moved out of `camel-cdi` to its own `camel-cdi-jta` module.

The `org.apache.camel.cdi.Main` class has moved from `camel-cdi` to `camel-cdi-main` JAR.

=== camel-kafka

The following classes were moved from `org.apache.camel.component.kafka` to `org.apache.camel.component.kafka.consumer`:

* `DefaultKafkaManualAsyncCommit`
* `DefaultKafkaManualAsyncCommitFactory`
* `DefaultKafkaManualSyncCommit`
* `DefaultKafkaManualSyncCommitFactory`
* `KafkaAsyncManualCommit`
* `KafkaManualCommit`
* `KafkaManualCommitFactory`

The signature for `KafkaManualCommitFactory` and its classes has been adjusted to abstract some runtime parameters. The old signature is still available but will be removed in 3.16.0.

=== camel-karaf

The `camel-endpointdsl` and `camel-componentdsl` is no longer supported on Apache Karaf.

The `camel-osg-activator`, `camel-google-calendar`, `camel-google-drive`, `camel-google-mail`, `camel-google-sheets`, and `camel-jooq` has been removed.

=== camel-netty / camel-netty-http

The netty producer has migrated from commons-poll v1 to v2.
The option `producerPoolMaxActive` is renamed to `producerPoolMaxTotal`.

=== camel-quartz

Removed the option `startDelaySeconds` as this does not work correctly and causes problems if in use.

=== camel-rabbitmq

The rabbitmq producer has migrated from commons-poll v1 to v2.

=== camel-openapi-java

The contextPath specified in the REST configuration is no longer added to the paths of the operations in the generated openapi specification.

=== camel-google-drive

The `camel-google-drive` component has upgraded to the latest version of `google-api-services-drive`. This means that support for access to the Google Drive Realtime APIs 
via URIs like `google-drive:drive-realtime` has been removed. Google deprecated and retired the realtime APIs some time ago.  
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.15 to 3.16

=== camel-core

Change the default from `Override` to `Ignore` in the `TypeConverterExists` option,
and the TypeConverterExistsLoggingLevel from `WARN` to `DEBUG`.

Previously when Camel detected a duplicate type converter during startup, Camel would
override the existing converter and log a WARN. A more correct behaviour would be
to keep the existing and ignore the duplicate.

Removed the deprecated class `org.apache.camel.impl.RouteIdFactory`.

=== Rest DSL

The Rest DSL have some changes.

==== Removed support for embedded routes

The Rest DSL no longer allows embedding routes directly into each REST service.
Instead, you must use `to` to route to a Camel endpoint. If you have an embedded
route you can them make this into an individual route using `direct` as the input endpoint,
and then link to this route from the REST service.

For example

[source,java]
----
rest("/users")
  .get("/{id}")
  .route().
    // embedded route here
----

Should now be:

[source,java]
----
rest("/users")
  .get("/{id}")
  .to("direct:users-by-id");

from("direct:users-by-id")
    // embedded route here
----

And in XML:

[source,xml]
----
<rest path="/users">
  <get path="/{id}">
    <route>
      ...
   </route>
  </get>
</rest>
----

Should now be:

[source,xml]
----
<rest path="/users">
  <get path="/{id}">
    <to uri="direct:users-by-id"/>
  </get>
</rest>

<route>
  <from uri="direct:users-by-id"/>
  ...
</route>
----

==== Renamed uri to path

Rename `uri` to `path` on the verb classes listed above.
When using XML or YAML DSL then migration is needed such as:

[source,xml]
----
<rest>
  <get uri="/hello/{name}">
    ...
  </get>
</rest>
----

Should be:

[source,xml]
----
<rest>
  <get path="/hello/{name}">
    ...
  </get>
</rest>
----

And in YAML DSL:

[source,yaml]
----
rest:
  get:
    - uri: "/hello/{name}"
      to: "direct:hello"
----

Should be:

[source,yaml]
----
rest:
  get:
    - path: "/hello/{name}"
      to: "direct:hello"
----

==== Renamed classes

The generic verb-based definition, where the HTTP verb can be specified as a string value
is no longer supported for defining a REST service.
Only the built-in verbs (get, post, put etc.) must be used.

Renamed the following classes in package `org.apache.camel.model.rest`:

- `DeleteVerbDefinition` to `DeleteDefinition`
- `GetVerbDefinition` to `GetDefinition`
- `HeadVerbDefinition` to `HeadDefinition`
- `PatchVerbDefinition` to `PatchDefinition`
- `PostVerbDefinition` to `PostDefinition`
- `PutVerbDefinition` to `PutDefinition`
- `RestSecurityApiKey` to `ApiKeyDefinition`
- `RestSecurityBasicAuth` to `BasicAuthDefinition`
- `RestSecurityBearerToken` to `BearerTokenDefinition`
- `RestSecurityMultalTLS` to `MutalTLSDefinition`
- `RestSecurityOAuth2` to `OAuth2Definition`
- `RestSecurityOpenIdConnect` to `OpenIdConnectDefinition`
- `RestOperationParamDefinition` to `ParamDefinition`
- `RestOperationResponseHeaderDefinition` to `ResponseHeaderDefinition`
- `RestOperationResponseMsgDefinition` to `ResponseMessageDefinition`

==== Removed classes

For the sake of simplicity, the class `RestSecuritiesRequirement` has been removed because it contains only elements of type `SecurityDefinition` which have been moved directly into `RestDefinition`.

=== Aggregate EIP

Renamed `strategyRef` to `aggregationStrategy`, and marked this option as required.
Renamed `strategyMethodName` to `aggregationStrategyMethodName`.
Renamed `strategyMethodAllowNull` to `aggregationStrategyMethodAllowNull`.
Renamed `aggregationRepositoryRef` to `aggregationRepository`.
Renamed `aggregateControllerRef` to `aggregateController`.
Renamed `executorServiceRef` to `executorService`.
Renamed `timeoutCheckerExecutorServiceRef` to `timeoutCheckerExecutorService`.
Removed some deprecated methods, and some unnecessary methods in Java DSL.

=== Circuit Breaker EIP

Renamed `circuitBreakerRef` to `circuitBreaker`.
Renamed `configRef` to `config`.
Renamed `bulkheadExecutorServiceRef` to `bulkheadExecutorService`.
Renamed `timeoutScheduledExecutorServiceRef` to `timeoutScheduledExecutorService`.

=== Claim Check EIP

Renamed `strategyRef` to `aggregationStrategy`, and marked this option as required.
Renamed `strategyMethodName` to `aggregationStrategyMethodName`.
Removed some unnecessary methods in Java DSL.

=== Delay EIP

Renamed `executorServiceRef` to `executorService`.

=== DoSwitch EIP

Replaced by Choice EIP in precondition mode.

Before it was:
[source,java]
----
.doSwitch()
    .when(simple("{{?red}}")).to("mock:red")
    .when(simple("{{?blue}}")).to("mock:blue")
.end()
----

Now it is:
[source,java]
----
.choice().precondition()
    .when(simple("{{?red}}")).to("mock:red")
    .when(simple("{{?blue}}")).to("mock:blue")
.end()
----

=== Enrich & Poll Enrich EIPs

Renamed `strategyRef` to `aggregationStrategy`, and marked this option as required.
Renamed `strategyMethodName` to `aggregationStrategyMethodName`.
Renamed `strategyMethodAllowNull` to `aggregationStrategyMethodAllowNull`.
Removed some deprecated methods, and some unnecessary methods in Java DSL.

=== Idempotent Consumer EIP

Renamed `messageIdRepositoryRef` to `idempotentRepository`.
Removed some unnecessary methods in Java DSL.

=== Log EIP

Renamed `loggerRef` to `logger`.

=== Multicast, Recipient List & Split EIP

Renamed `strategyRef` to `aggregationStrategy`.
Renamed `strategyMethodName` to `aggregationStrategyMethodName`.
Renamed `strategyMethodAllowNull` to `aggregationStrategyMethodAllowNull`.
Renamed `onPrepareRef` to `onPrepare`.
Renamed `executorServiceRef` to `executorService`.
Removed some deprecated methods, and some unnecessary methods in Java DSL.

=== OnCompletion EIP

Renamed `executorServiceRef` to `executorService`.

=== Resequence EIP

Renamed `comparatorRef` to `comparator`.

=== Sort EIP

Renamed `comparatorRef` to `comparator`.

=== Threads EIP

Renamed `executorServiceRef` to `executorService`.

=== Throttle EIP

Renamed `executorServiceRef` to `executorService`.

=== Saga EIP

Renamed `sagaServiceRef` to `sagaService`.
Removed the deprecated `timeoutInMilliseconds` option, use `timeout` instead.

In the `<option>` the `optionName` is renamed to `key`. When using XML DSL then this is affected as follows:

[source,xml]
----
<saga sagaServiceRef="mySagaService">
    <compensation uri="mock:compensation"/>
    <completion uri="mock:completion"/>
    <option optionName="myOptionKey">
        <constant>myOptionValue</constant>
    </option>
    <option optionName="myOptionKey2">
        <constant>myOptionValue2</constant>
    </option>
</saga>
----

To:

[source,xml]
----
<saga sagaServiceRef="mySagaService">
    <compensation uri="mock:compensation"/>
    <completion uri="mock:completion"/>
    <option key="myOptionKey">
        <constant>myOptionValue</constant>
    </option>
    <option key="myOptionKey2">
        <constant>myOptionValue2</constant>
    </option>
</saga>
----

=== WireTap EIP

Renamed `onPrepareRef` to `onPrepare`.
Renamed `executorServiceRef` to `executorService`.
Removed the _new message_ mode as this functionality is better done by using onPrepare processor in copy mode.

=== camel-health

The `HealthCheck` API has been simplified and removed the following configurations:

- interval
- success threshold
- failure threshold

These options would complicate health checks as they affect the outcome of health checks.
It is better the checks always execute and the responsibility of the monitoring systems
how to deal with interval between checks and thresholds.

Removed the option to disable context health check as it should always be enabled.

==== Disabling health checks

The configuration for disabling individual health-checks has changed

Before each health-check could be configured and set `enabled=false`. For example
to disable health-checks for route with id `netty` you would do:

[source,properties]
----
camel.health.config[netty].check = routes
camel.health.config[netty].enabled = false
----

With Camel 3.16 onwards you instead specify pattern(s) for health checks to be excluded
from being invoked, which is done in a single configuration:

[source,properties]
----
camel.health.exclude-pattern = netty
----

You can specify multiple patterns (and use wildcards) such as:

[source,properties]
----
camel.health.exclude-pattern = netty,foo,bar*
----

=== camel-main

The option `camel.main.packageScanRouteBuilders` has been renamed to `camel.main.basePackageScan`.

Using configuration classes must now implement the interface `org.apache.camel.main.CamelConfiguration`
and the `configure` method now takes a `CamelContext` as argument.

=== camel-any23

The option `baseURI` is renamed to `baseUri`.

=== camel-aws2-kinesis

The `camel-aws2-kinesis` component will now set only the raw data as body while consuming from a stream. The data will be an input stream.
This changes the behavior from the old versions because in the past the component was returning the full record as part of the body.

=== camel-aws2-sqs

The `camel-aws2-sqs` component will now map message headers from their original type
such as boolean, integer, etc. This requires using Camel for both sending and receiving
as AWS only have string or binary types, so Camel stores custom metadata in the message header
to know its original type.

=== camel-stream

The producer will now by default append new line character to end of output.
The option `appendNewLine` can be used to turn this off.

=== camel-testcontainers

This component was deprecated and is removed on this version. Users should migrate to xref:test-infra.adoc[camel-test-infra].

=== camel-testcontainers-junit5

This component was deprecated and is removed on this version. Users should migrate to xref:test-infra.adoc[camel-test-infra].

=== camel-testcontainers-spring

This component was deprecated and is removed on this version. Users should migrate to xref:test-infra.adoc[camel-test-infra].

=== camel-testcontainers-spring-junit5

This component was deprecated and is removed on this version. Users should migrate to xref:test-infra.adoc[camel-test-infra].

=== camel-salesforce

The `sObjectName` query parameter and header now take precedence over the class name of the `AbstractSObjectBase` DTO for
determining the name of the SObject. We suggest testing your existing routes to identify any potential issues. See
https://issues.apache.org/jira/browse/CAMEL-17608 for more details.
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.16 to 3.17

=== camel-core

==== Stream Caching

We have enabled xref:stream-caching.adoc[Stream Caching] by default on `CamelContext`. The reason is that Camel users
may often hit this problem without knowing what is causing this, and blaming it on Apache Camel.

This means that Camel would automatically cache message bodies that are based on `java.util.InputStream`
such as often seen with HTTP components. This makes it safe to log the message body, and elsewhere.

The cost is a tiny overhead in the routing engine as Camel will automatic type convert
to `StreamCache` if needed. Users can turn this off:

[source,java]
----
CamelContext context = ...
context.setStreamCaching(false);
----

Or via Camel Main / Camel K / Quarkus:

[source,properties]
----
camel.main.streamCachingEnabled=false
----

Or in Spring Boot

[source,properties]
----
camel.springboot.streamCachingEnabled=false
----

And in legacy Spring XML or OSGi Blueprint:

[source,xml]
----
<streamCaching enabled="true" .../>
----

We also changed the default settings for stream caching to not spool to disk, meaning that the cache
is an in-memory on cache.

To enable spool to disk, you can configure this as follows:

[source,java]
----
CamelContext context = ...
context.getStreamCachingStrategy().setSpoolEnabled(true);
----

Or via Camel Main / Camel K / Quarkus:

[source,properties]
----
camel.main.streamCachingSpoolEnabled=true
----

Or in Spring Boot

[source,properties]
----
camel.springboot.streamCachingSpoolEnabled=true
----

And in legacy Spring XML or OSGi Blueprint:

[source,xml]
----
<streamCaching spoolEnabled="true" .../>
----

=== camel-health

Camel now reports DOWN when Camel is being stopped, during the graceful shutdown process.
This ensures that Camel reports that it's not ready to accept new traffic.

=== camel-main

Added method `findRouteResourcesFromDirectory` to `org.apache.camel.main.RoutesCollector`.

=== camel-yaml-dsl

Removed deprecated `spec/flows` and `spec/flow` from the kamelet yaml loader.
Must use `spec/template` as key for the kamelet template.

Removed _endpoint-dsl_ notation which was not well known,
causing problems for tools, and yaml-validation against the json-schema standard.

For example the following notation:

[source,yaml]
----
- from:
    uri: "direct:start"
    steps:
      - to:
          kafka:
            topic: cheese
            brokers: mykafka:1234
----

Should be change to:

[source,yaml]
----
- from:
    uri: "direct:start"
    steps:
      - to:
          uri: "kafka:cheese?brokers=mykafka:1234"
----

Or

[source,yaml]
----
- from:
    uri: "direct:start"
    steps:
      - to:
          uri: "kafka"
          parameters:
            topic: "cheese"
            brokers: "mykafka:1234"
----

=== camel-spring-xml / camel-blueprint

The error handling has been made universal and exposed generally in the `camel-core-model`
with intent to align error handling across DSLs.

However, the XML DSL for Spring `<beans>` and OSGi blueprint is legacy, and they
have their own special XML parsing and error handling.

This means the model classes has been renamed, which only affect Camel end users whom
has defined error handling as `<bean>` in Spring or Blueprint XML files:

- `org.apache.camel.builder.DeadLetterChannelBuilder` to `org.apache.camel.builder.LegacyDeadLetterChannelBuilder`
- `org.apache.camel.builder.DefaultErrorHandlerBuilder` to `org.apache.camel.builder.LegacyDefaultErrorHandlerBuilder`
- `org.apache.camel.builder.NoErrorHandlerBuilder` to `org.apache.camel.builder.LegacyNoErrorHandlerBuilder`
- `org.apache.camel.spring.spi.TransactionErrorHandlerBuilder` to `org.apache.camel.spring.spi.LegacyTransactionErrorHandlerBuilder`

Users who has been configured error handling using `<errorHandler>` in Spring or Blueprint XML files should not be affected.

=== camel-cdi / camel-cdi-jta

The class `org.apache.camel.cdi.CdiRouteBuilder` has been removed as you can use `jtaTransactionErrorHandler` builder
methods from `camel-core` instead.

The class `org.apache.canel.jta.JtaTransactionErrorHandlerBuilder` has been removed, as the JTA error handler builder
can be used with the `jtaTransactionErrorHandler` from `camel-core-model`.

=== camel-kafka

The option `autoCommitOnStop` was removed from the Camel Kafka component. When using `autoCommitEnable` (which is enabled by default) the Kafka consumer will automatically commit on close.

When the `autoCommitEnable` is turned off, the component issues a call to the respective commit manager during shutdown.

Asynchronous, Synchronous or NO-OP commit policies from the former `autoCommitOnStop` are now determined by automatically by the value of the `kafkaManualCommitFactory` option:

* NO-OP is the default behavior if no `kafkaManualCommitFactory` is provided
* Async can be set using `kafkaManualCommitFactory=#class:org.apache.camel.component.kafka.consumer.DefaultKafkaManualAsyncCommitFactory`
* Sync can be set using `kafkaManualCommitFactory=#class:org.apache.camel.component.kafka.consumer.DefaultKafkaManualCommitFactory`

The deprecated constructors for the kafkaManualCommitFactory have been removed. The constructor should now receive the following parameters:

[source,java]
----
CamelExchangePayload camelExchangePayload, KafkaRecordPayload kafkaRecordPayload, CommitManager commitManager
----

=== camel-platform-http-vertx

The configuration for body handler file uploads has changed from `true` to `false`.
The configuration can be enabled via the `VertxPlatformHttpServerConfiguration` class.

=== camel-opentracing / camel-opentelemetry

We aligned the MDC keys with OpenTelemetry, so they are changed from:

- `traceId` -> `trace_id`
- `spanId` -> `span_id`

=== camel-atom

This component was refactored to support the Resume API v2. As such, the options `filter` and `lastUpdate` where removed.

[source,java]
----
from("atom:file:src/test/data/feed.atom?splitEntries=true&delay=500")
    .resumable().resumeStrategy(new UpdatedDateFilter(new Date()))
    .to("mock:result");
----

More complex filters can be implemented by extending the `UpdatedDateFilter` or by implementing a new `EntryFilter` resume strategy.

=== camel-cdi

The support for the Camel XML configuration import, that had been marked as deprecated in previous releases, was removed.

=== camel-cxf-blueprint

When using OSGi Blueprint with CXF endpoints defined in their own namespace as below,
then you must use `depends-on` to refer to the ID of the `<camelContext>`.

Notice how we must use `depends-on="VerySimple-context"` in the `cxf:cxfEndpoint` to refer to the `CamelContext`.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<osgi:blueprint xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:camel="http://camel.apache.org/schema/blueprint"
                xmlns:osgi="http://www.osgi.org/xmlns/blueprint/v1.0.0"
                xmlns:cxf="http://camel.apache.org/schema/blueprint/cxf">

	<camel:camelContext id="VerySimple-context">
		<camel:route id="VerySimple-route">
			<camel:from uri="VerySimple"/>
			<camel:to uri="log:proxy.VerySimple"/>
		</camel:route>
	</camel:camelContext>

	<cxf:cxfEndpoint id="VerySimple" depends-on="VerySimple-context" address="http://localhost:8088/VerySimple" serviceName="tns:VerySimple" endpointName="tns:VerySimplePort" wsdlURL="file:deploy/VerySimple.wsdl" xmlns:tns="http://www.talend.org/service/">
		<cxf:properties>
			<osgi:entry key="dataFormat" value="PAYLOAD"/>
		</cxf:properties>
	</cxf:cxfEndpoint>

</osgi:blueprint>
----

=== camel-sftp

The underlying JSch library has been updated (https://issues.apache.org/jira/browse/CAMEL-17835[CAMEL-17835]) to a
more secure and actively maintained fork which has removed key types and algorithms that rely on SHA1. For
information on how these can be restored, consult the xref:components::sftp-component.adoc[SFTP component] documentation.

=== camel-rabbitmq

When using `skipQueueDeclare=true` you now must also set `skipQueueBind=true` to skip both declaring and binding the queue.

=== Deprecated Components

The following components that had been marked as deprecated, were removed in this release:

* camel-atomix
* camel-beanstalk
* camel-beanio
* camel-etcd
* camel-elsql
* camel-ganglia
* camel-nsq
* camel-hystrix
* camel-jing
* camel-leveldb-legacy
* camel-msv
* camel-nagios
* camel-ribbon
* camel-sip
* camel-soroush
* camel-tagsoup
* camel-yammer
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example, if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.17 to 3.18

=== camel-core

Camel will now mask all known secret values when logging endpoint URIs to avoid leaking sensitive details
such as from stack traces. Previously only a subset of known _secret_ keys was masked.

The type converter from `InputStream` to `byte[]` will now close the input stream after the conversion.

The `TimeUtils.printDuration` method outputs now in a more compact format (especially for long durations).
Before `4d12h57m49s` and now `4d12h`. Use `precise=true` to include all details.

=== camel-console

The `AbstractDevConsole` has changed the method `doCall` into two separate methods `doCallText` and `doCallJson`
to better separate output between text and json based.

=== camel-cxf

The `camel-cxf` JAR has been split up into SOAP vs. REST and Spring and non-Spring JARs.

Users should therefore choose `camel-cxf` to migrate among the following JARs:

- `camel-cxf-soap`
- `camel-cxf-spring-soap`
- `camel-cxf-rest`
- `camel-cxf-spring-rest`
- `camel-cxf-transport`
- `camel-cxf-spring-transport`

For example, if you were using CXF for SOAP and with Spring XML, then you would need to migrate
from using `camel-cxf` to `camel-cxf-spring-soap` and `camel-cxf-spring-transport`.

When using Spring Boot, then you need to migrate from `camel-cxf-starter` to use SOAP or REST:

- `camel-cxf-soap-starter`
- `camel-cxf-rest-starter`

The `camel-cxf` XML XSD schemas have also changed namespaces:

|===
|Old Namespace | New Namespace

| `http://camel.apache.org/schema/cxf`
| `http://camel.apache.org/schema/cxf/jaxws`

| `http://camel.apache.org/schema/cxf/camel-cxf.xsd`
| `http://camel.apache.org/schema/cxf/jaxws/camel-cxf.xsd`

| `http://camel.apache.org/schema/cxf`
| `http://camel.apache.org/schema/cxf/jaxrs`

| `http://camel.apache.org/schema/cxf/camel-cxf.xsd`
| `http://camel.apache.org/schema/cxf/jaxrs/camel-cxf.xsd`

|===

IMPORTANT: The namespace for Apache Camel Karaf (`camel-cxf-blueprint`) has *not* changed.
This module has not been split-up and comes with both SOAP and REST combined as before.

And the `camel-cxf` SOAP component is moved to a new `jaxws` sub-package,
i.e. `org.apache.camel.component.cxf` is now `org.apache.camel.component.cxf.jaws`.

This means, for example, the `CxfComponent` class is now located
in `org.apache.camel.component.cxf.jaxws`.

Some classes in the following packages were refactored, and the package was updated.
If you were using one of those packages and, after the migration, a `ClassNotFoundException` is thrown,
an update should be considered

|===
|Old Package | New Package

| `org.apache.camel.component.cxf`
| `org.apache.camel.component.cxf.common`

| `org.apache.camel.component.cxf.interceptors`
| `org.apache.camel.component.cxf.util`

| `org.apache.camel.component.cxf.converter`
| `org.apache.camel.component.cxf.jaxrs`

| `org.apache.camel.component.cxf`
| `org.apache.camel.component.cxf.jaxws`

| `org.apache.camel.component.cxf.spring`
| `org.apache.camel.component.cxf.spring.jaxrs`

| `org.apache.camel.component.cxf.spring`
| `org.apache.camel.component.cxf.spring.jaxws`

| `org.apache.camel.component.cxf`
| `org.apache.camel.component.cxf.spring.jaxws`

| `org.apache.camel.component.cxf.transport.spring`
| `org.apache.camel.component.cxf.spring.transport`

| `org.apache.camel.component.cxf.common.header`
| `org.apache.camel.component.cxf.transport.header`

| `org.apache.camel.component.cxf.common.message`
| `org.apache.camel.component.cxf.transport.message`

|===

=== camel-endpointdsl

The options for `lazyStartProducer` and `bridgeErrorHandler` has moved into the _advanced_ group.

=== camel-google-calendar

The `keyResource` option has been changed to `serviceAccountKey` to match to Google semantic. Then, if you use the `keyResource`
to Google Calendar component, you should update it to  `serviceAccountKey`.

=== camel-google-drive

The `keyResource` option has been changed to `serviceAccountKey` to match to Google semantic. Then, if you use the `keyResource` 
to Google Drive component, you should update it to  `serviceAccountKey`.

=== camel-jsonpath

There is a new option `unpackArray` in *Camel 3.18.3* that unpacks a single-element Json array, matched by a Jsonpath, into an object. This option is disabled by default (this behaviour was enabled by default in previous Camel versions).
There is a new expression `jsonpathUnpack(String text, Class<?> resultType)` that makes use of this new option.

=== camel-yaml-dsl

The YAML DSL schema files `camel-yaml-dsl.json` and `camelYamlDsl.json` has been moved from root to `schema` sub folder in the JAR.

=== camel-karaf

The `camel-milo` feature has been removed.

= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.18 to 3.19

=== camel-api

Added `addClassLoader` method to `org.apache.camel.spi.ClassResolver`.

The default TLS protocol is changed from `TLSv1.2` to `TLSv1.3` in Camel JSSE support.

=== camel-management

The context MBean (`ManagedCamelContextMBean`) total counter is changed to count only once
while an _exchange_ is being routed through multiple routes. Previously the counter was
a total aggregation of all the routes the _exchange_ was processed. For example if an _exchange_
is routed via A, B and C; then previously the total counter was +3 (+1 for route A, +1 for route B, +1 for route C).
This is now corrected so the total is +1 on the context MBean.

=== camel-main

The option `camel.main.eager-classloading` has been removed.

=== camel-ftp

The default TLS protocol is changed from `TLSv1.2` to `TLSv1.3`.

=== camel-kafka

Updated the documentation to reflect the default TLS protocol in Kafka Clients running on JDK11+
is `TLSv1.2,TLSv1.3` (prefer v1.3 but can fall back to v1.2).

=== camel-netty / camel-netty-http

The default TLS protocol is changed from `TLSv1,TLSv1.1,TLSv1.2` to `TLSv1.2,TLSv1.3`.

=== camel-yaml-dsl

Removed using `template` as a custom alias for `routeTemplate` or `route-template`.

Removed the `tod` custom alias for `toD` or `to-d`.

A route template can now also define a `route` which allows specifying route
options that otherwise is not possible when using `from`.

For example, you can now disable stream-caching, as shown in the snippet below that are from a Kamelet:

[source,yaml]
----
spec:
  template:
    route:
      stream-caching: false
      message-history: true
      from:
        uri: timer:tick
        parameters:
          period: "{{period}}"
        steps:
          - set-body:
              constant: "{{message}}"
          - set-header:
              name: "Content-Type"
              constant: "{{contentType}}"
          - to: kamelet:sink
----

=== camel-salesforce

The URI format for consumer operations has changed. All consumer URIs now use the `subscribe` operation. E.g., `salesforce:subscribe:<topic_name>`, `salesforce:subscribe:event/<event_name>`, `salesforce:subscribe:data/ChangeEvents`.

=== camel-consul

The deprecated options were removed and should be replaced by the following options:

|===
|Deprecated |Replace with

|`connectTimeoutMillis`
|`connectTimeout`

|`readTimeoutMillis`
|`readTimeout`

|`writeTimeoutMillis`
|`writeTimeout`
|===

=== camel-google-bigquery-sql

Parameters in form of `@name` are extracted from the body or message and their type is preserved and translated into corresponding `com.google.cloud.bigquery.StandardSQLTypeName`. See the https://cloud.google.com/java/docs/reference/google-cloud-bigquery/latest/com.google.cloud.bigquery.QueryParameterValue[documentation] for more information. (Conversion to StandardSQLTypeName.STRING was used for each type before)


=== camel-telegram

The component was migrated from the Async HTTP Client to the builtin HTTP client from Java 11 and newer. As such,
* the parameter `clientConfig`, that received an `AsyncHTTPClientConfiguration` instance was removed
* the parameter `client`, that received an `AsyncHttpClient` instance, was modified to receive a HTTPClient instance.


=== xtokenize language

The xtokenize language has moved from `camel-xml-jaxp` to `camel-stax` JAR because
a stax parser was needed anyway to use the language.


=== camel-karaf

Upgraded from Karaf 4.3.x to Karaf 4.4.x, which requires JDK11+.

=== camel-http

Added `followRedirects` option with default value `false` on component and endpoint level. 
The introduction of this option changes the default redirect behaviour for producers from following all `GET` and `HEAD` redirects, to not following any redirects.

=== Deprecated Components

The following components that had been marked as deprecated, were removed in this release:

* camel-ahc
* camel-ahc-ws
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.1 to 3.2

=== JndiRegistry

The deprecated class `org.apache.camel.impl.JndiRegistry` has been removed. The class `org.apache.camel.support.jndi.JndiBeanRepository` located in `org.apache.camel:camel-support` should be used instead.

=== Rest Configuration

The rest configuration has been simplified and there is now a single RestConfiguration instance (https://issues.apache.org/jira/browse/CAMEL-13844[CAMEL-13844]) per Camel Context.

The following methods have been removed:

* org.apache.camel.CamelContext#addRestConfiguration(RestConfiguration restConfiguration)
* org.apache.camel.CamelContext#getRestConfiguration(String component, boolean defaultIfNotFound)
* org.apache.camel.CamelContext#getRestConfigurations

https://issues.apache.org/jira/browse/CAMEL-13844

=== Camel Cloud

The following `ServiceDiscovery` implementation has been removed: 

* org.apache.camel.impl.cloud.CachingServiceDiscovery
* org.apache.camel.impl.cloud.CachingServiceDiscoveryFactory

https://issues.apache.org/jira/browse/CAMEL-14813

=== Camel with Karaf and OSGi

Camel on Apache Karaf / OSGi has been moved to its own project at: https://github.com/apache/camel-karaf

The Maven dependencies has changed the groupid from `org.apache.camel` to `org.apache.camel.karaf`.

For example the `camel-blueprint` would be changed from

[source,xml]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-blueprint</artifactId>
  <version>3.1.0</version>
</dependency>
----

To:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel.karaf</groupId>
  <artifactId>camel-blueprint</artifactId>
  <version>3.2.0</version>
</dependency>
----

The Camel Karaf features are the same as before, you can still install Camel in Karaf shell via:
[source,text]
----
feature:repo-add camel 3.2.0
feature:install camel
----

==== Other components involved

- Camel-test-blueprint

[source,xml]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-test-blueprint</artifactId>
  <version>3.1.0</version>
</dependency>
----

To:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel.karaf</groupId>
  <artifactId>camel-test-blueprint</artifactId>
  <version>3.2.0</version>
</dependency>
----

- Camel-test-karaf

[source,xml]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-test-karaf</artifactId>
  <version>3.1.0</version>
</dependency>
----

To:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel.karaf</groupId>
  <artifactId>camel-test-karaf</artifactId>
  <version>3.2.0</version>
</dependency>
----

- Camel-eventadmin

[source,xml]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-eventadmin</artifactId>
  <version>3.1.0</version>
</dependency>
----

To:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel.karaf</groupId>
  <artifactId>camel-eventadmin</artifactId>
  <version>3.2.0</version>
</dependency>
----

- Camel-kura

[source,xml]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-kura</artifactId>
  <version>3.1.0</version>
</dependency>
----

To:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel.karaf</groupId>
  <artifactId>camel-kura</artifactId>
  <version>3.2.0</version>
</dependency>
----

- Camel-osgi-activator

[source,xml]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-osgi-activator</artifactId>
  <version>3.1.0</version>
</dependency>
----

To:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel.karaf</groupId>
  <artifactId>camel-osgi-activator</artifactId>
  <version>3.2.0</version>
</dependency>
----

- Camel-paxlogging

[source,xml]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-paxlogging</artifactId>
  <version>3.1.0</version>
</dependency>
----

To:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel.karaf</groupId>
  <artifactId>camel-paxlogging</artifactId>
  <version>3.2.0</version>
</dependency>
----

==== Introducing a camel-karaf-bom

We introduce a camel-karaf-bom too, so the end-users should be able to have all of this dependencies easier:

[source,xml]
----
    <dependencyManagement>
        <dependencies>
            <!-- Add Camel BOM -->
            <dependency>
                <groupId>org.apache.camel</groupId>
                <artifactId>camel-bom</artifactId>
                <version>${project.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!-- Add Camel Karaf BOM -->
            <dependency>
                <groupId>org.apache.camel.karaf</groupId>
                <artifactId>camel-karaf-bom</artifactId>
                <version>${camel.karaf.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
----

In this way you'll get both the boms and all the "goodies"

=== camel-elytron

Transitive dependencies from org.wildfly.security:wildfly-elytron were removed.

=== camel-spark-rest

This component has been removed. Use any of the other REST capable components, such as `camel-jetty`, `camel-netty-http`
or `camel-undertow`.

=== EIPs with cacheSize option

The `cacheSize` option on EIPs has been improved to reduce memory usage when the cache is disabled by
setting the value to -1. One of the optimizations is that new endpoints will not be added to the endpoint registry,
but discarded after use. This avoids storing additional endpoints in the cache (memory) as the cache should be disabled (cacheSize=-1).

See more details in the documentation for the `cacheSize` option on the EIPs.

=== Configuring components via Java setters

Configuring Camel components from plain Java code has changed in some components where they were using
delegate setters for a nested configuration class. These delegates has been removed, to ensure configuration
is more consistent and aligned with how endpoints is configured as well, and by using source code generated configurer classes.

The following Camel components has been affected and changed on the component level:

- camel-aws
- camel-aws2
- camel-consul
- camel-etcd
- camel-infinispan
- camel-kafka
- camel-servicenow
- camel-ssh
- camel-stomp
- camel-xmlsecurity
- camel-yammer

This only affects if you are configuring these components using Java code or XML `<bean>` style.

For example

[source,java]
----
KafkaComponent kafka = new KafkaComponent();
kafka.setBrokers("mybroker1:1234,mybroker2:1234");
----

Should now be:

[source,java]
----
KafkaComponent kafka = new KafkaComponent();
kafka.getConfiguration().setBrokers("mybroker1:1234,mybroker2:1234");
----

And in XML:

[source,xml]
----
<bean id="kafka" class="org.apache.camel.component.kafka.KafkaComponent">
  <property name="brokers" value="mybroker1:1234,mybroker2:1234"/>
</bean>
----

Should now be:

[source,xml]
----
<bean id="kafka" class="org.apache.camel.component.kafka.KafkaComponent">
  <property name="configuration">
    <property name="brokers" value="mybroker1:1234,mybroker2:1234"/>
  </property>
</bean>
----

=== Configuring components via Spring Boot auto configuration

Configuring Camel spring boot components has changed its option keys to be flattened and have the `.configuration` prefix
removed now.

Before in application.properties

[source,properties]
----
camel.component.kafka.configuration.brokers=mybroker1:1234,mybroker2:1234
----

Should now be
[source,properties]
----
camel.component.kafka.brokers=mybroker1:1234,mybroker2:1234
----

This applies to all the Camel spring boot _starter_ JARs where basically `.configuration` should be removed.

=== Configuring camel-activemq, camel-amqp and camel-stomp via Spring Boot auto configuration

When configuring these components from spring boot auto-configuration then the URL for the broker was named `broker-u-r-l`
in the spring boot auto configuration support. This has been renamed to `broker-url` and a few other options too.

Before:

[source,properties]
----
camel.component.activemq.broker-u-r-l=tcp://localhost:61616
----

After:

[source,properties]
----
camel.component.activemq.broker-url=tcp://localhost:61616
----

=== camel-any23

The XML DSL has changed for the `<configuration>` element, which now
is flattened so the key/values should be configured on it directly:

Before:
[source,xml]
----
<dataFormats>
  <any23 id="any23" baseURI ="http://mock.foo/bar" outputFormat="TURTLE" >
    <configuration>
      <property key="any23.extraction.metadata.nesting" value="off" />
      <property key="another-key" value="another-value" />
    </configuration>
    <extractors>html-head-title</extractors>
  </any23>
</dataFormats>
----

After:

[source,xml]
----
<dataFormats>
  <any23 id="any23" baseURI ="http://mock.foo/bar" outputFormat="TURTLE" >
    <configuration key="any23.extraction.metadata.nesting" value="off"/>
    <configuration key="another-key" value="another-value"/>
    <extractors>html-head-title</extractors>
  </any23>
</dataFormats>
----

=== camel-avro

The avro component and data format has been split up into two JARs. The dataformat is in `camel-avro` JAR
and the component in `camel-avro-rpc` JAR.

=== camel-infinispan

Camel now requires endpoint URIs to include context-path which means
the endpoint URI `infinispan` should be changed to `infinispan:current`.

=== google-pubnub

The google-pubnub component has been improved to use a new Java library and become faster.

Support for Apache Karaf has been removed.

=== camel-xstream

The XML DSL has changed for the `<converters>`, `<alias>`, `implicitCollections`, and `omitFields` elements,
which now is flattened so the key/values should be configured on it directly.

Before:
[source,xml]
----
<xstream id="xstream-1" mode="NO_REFERENCES"
    permissions="-org.apache.camel.dataformat.xstream.*,org.apache.camel.dataformat.xstream.PurchaseHistory,org.apache.camel.dataformat.xstream.PurchaseOrder">
    <converters>
        <converter class="org.apache.camel.dataformat.xstream.XStreamConfigurationTest$PurchaseOrderConverter" />
    </converters>
    <aliases>
                <alias name="purchase-order" class="org.apache.camel.dataformat.xstream.PurchaseOrder" />
    </aliases>
    <implicitCollections>
       <class name="org.apache.camel.dataformat.xstream.PurchaseHistory">
          <field>history</field>
       </class>
    </implicitCollections>
</xstream>
----

After:
[source,xml]
----
<xstream id="xstream-1" mode="NO_REFERENCES"
    permissions="-org.apache.camel.dataformat.xstream.*,org.apache.camel.dataformat.xstream.PurchaseHistory,org.apache.camel.dataformat.xstream.PurchaseOrder">
    <converters key="purchase-converter" value="org.apache.camel.dataformat.xstream.XStreamConfigurationTest$PurchaseOrderConverter"/>
    <aliases key="purchase-order" value="org.apache.camel.dataformat.xstream.PurchaseOrder"/>
    <implicitCollections key="org.apache.camel.dataformat.xstream.PurchaseHistory" value="history"/>
</xstream>
----

Multiple values for `implicitCollections` and `omitFields` can be separated by comma

For example:
[source,xml]
----
<implicitCollections key="org.apache.camel.dataformat.xstream.PurchaseHistory" value="history,adress"/>
----

=== camel-weather

This component has been upgraded from using Apache Http Client 3.x to 4.x and is therefore not fully backwards compatible.
Some options for configurer and setting proxy is removed. You can however configure this directly on a custom `HttpClient` instance
and set this on the `WeatherComponent` to use.

=== Endpoint URIs without context path

Previously Camel components may work by referring to their name only without a colon and context path (eg `log`)
that for a few components would allow them to create an endpoint anyway.

Now this is not allowed and Camel will throw an `NoSuchEndpointException`.

An endpoint by its logical id can still be referred by the id only, eg
[source,java]
----
Endpoint endpoint = camelContext.getEndpoint("myCoolEndpoint");
----

=== Error handling

The context scope error handling has been modified a bit.  The processors in those `onException` and
`onCompletion` are not shared between routes anymore.  This should have little effect in most cases.
If there is a need to have a single set of processors involved (such as when using a loadbalancer or
other stateful patterns), then an intermediary route needs to be used. The following excerpt:

[source,java]
----
onException(Exception.class).handled(true)
    .loadBalance().roundRobin().id("round")
    .to("mock:error", "mock:error2", "mock:error3");
----

... needs to be rewritten as:

[source,java]
----
onException(Exception.class).handled(true).to("direct:error");

from("direct:error").loadBalance().roundRobin().id("round")
    .to("mock:error", "mock:error2", "mock:error3");
----

=== camel-cluster

The base support for cluster in `org.apache.camel.cluster` has been moved
out of `camel-core-engine` into separate JAR named `camel-cluster`.

=== Configuring milli seconds

NOTE: If upgrading to Camel 3.4 or newer then do NOT do this because Camel 3.4 adds back support for this.

Camel was using a type converter from `String` -> `long` that accepted
a time pattern which allowed to configure long values such as `2s` for 2 seconds, e.g. `2000`.
And more complex such as `8h15m` for 8 hours and 15 minutes.

However as this was implemented as part of `String` -> `long` type conversion
which then adds a little bit of overhead during routing, when converting from String to plain numbers.

To make Camel routing engine as fast as possible this feature has been removed.

For example a timer with a 5 second period

[source,java]
----
from("timer:foo?period=5s")
----

Should now be specified as numeric only:

[source,java]
----
from("timer:foo?period=5000")
----

=== Main in camel-spring

The `org.apache.camel.spring.Main` class has been moved out of `camel-spring` JAR into its own
JAR named `camel-spring-main`.

=== Main in camel-test-blueprint

The `org.apache.camel.test.blueprint.Main` class has been renamed to `org.apache.camel.test.blueprint.Main`
and moved into its own `camel-test-blueprint` JAR.

To use the camel-maven-plugin goal `camel:run` with OSGi plugin, you now need to add the following dependency
to the classpath `org.apache.camel.karaf:camel-blueprint-main`.

=== API changes

==== DefaultComponent

The deprecated method `preProcessUri` has been removed.

==== CamelContext

The method `getEndpoint` now throws `NoSuchEndpointException` directly instead of being wrapped
within an `FailedToResolveEndpoint`.

==== JavaUuidGenerator

The `org.apache.camel.impl.engine.JavaUuidGenerator` class has been removed.
Its a very slow UUID generator and its not recommended to be used.

==== PropertiesComponent

The `org.apache.camel.component.properties.PropertiesFunction` has been moved to `org.apache.camel.spi.PropertiesFunction`
and its now possible to add custom functions on the `org.apache.camel.spi.PropertiesComponent` interface.

====  JMX Connector configuration removed

The JMX Connector configuration in camel-management has been https://issues.apache.org/jira/browse/CAMEL-14811[removed]
in Camel 3.2.0. If you want to support the ability to use JMX with Camel remotely, then
just use the default JVM JMX remote capabilities. For example, use the following (insecure)
JVM settings to be able to manage Camel remotely on localhost, port 9913:

[source]
----
-Dcom.sun.management.jmxremote.port=9913
-Dcom.sun.management.jmxremote.authenticate=false
-Dcom.sun.management.jmxremote.ssl=false
-Djava.rmi.server.hostname=localhost
----

= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example, if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.20.6 to 3.20.7

The option `replyTimeout` in `camel-spring-rabbitmq` has been fixed and the default value from 5 to 30 seconds
(this is the default used by Spring).

In `camel-jbang` the _Placeholders substitutes_ is changed to use `#name` instead of `$name` syntax.

== Upgrading Camel 3.20.5 to 3.20.6

No changes

== Upgrading Camel 3.20.4 to 3.20.5

In Camel JBang the `-dir` parameter for `init` and `run` goal has been renamed to require 2 dashes `--dir` like all the other options.

== Upgrading Camel 3.20.3 to 3.20.4

No changes

== Upgrading Camel 3.20.2 to 3.20.3

The option `backlogTracing=true` now automatic enabled the tracer on startup. The previous behavior
was _surprisingly_ that the tracer was only made available, and had to be manually enabled afterwards.
The old behavior can be archived by setting `backlogTracingStandby=true`.

The xref:backlog-tracer.adoc[Backlog Tracer] has been enhanced and _fixed_ to trace message headers (also streaming types).
This means that previously headers of type `InputStream` was not traced before, but is now included. This could mean that
the header stream is positioned at the end, and logging the header afterward may appear as the header value is empty.

=== camel-micrometer-starter

The `uri` tags are now static instead of dynamic (by default), as potential too many tags generated due to URI with dynamic values.
This can be enabled again by setting `camel.metrics.uriTagDynamic=true`.

== Upgrading Camel 3.20.1 to 3.20.2

No changes

== Upgrading Camel 3.20.0 to 3.20.1

=== XML DSL

A route now have `<routeProperty>` in the top instead of the bottom.

=== YAML DSL

Using _allowable values_ in Rest with YAML DSL is fixed to use the correct name as other DSLs.

Before:

[source,yaml]
----
    value:
    - available
    - pending
    - sold
----

After:

[source,yaml]
----
    allowableValues:
    - available
    - pending
    - sold
----

=== camel-fhir

The following 4 advanced options in fhir data format has been made available for all DSLs:

- fhirContext
- parserErrorHandler
- parserOptions
- forceResourceId

Previously they were only possible to configure by manually creating a bean instance of the model,
and configure them via Java code or classic Spring XML `<bean>` style.

=== camel-kafka

The following options have changed default value as they were mistakenly out of sync with Apache Kafka.
This caused camel-kafka producer to not enable idempotence out of the box, that otherwise plain Apache Kafka client would do:

- `enableIdempotence`: changed from `false` to `true`
- `requestRequiredAcks`: changed from `1` to `all`
- `retries`: changed from `0` to `_unset_`

== Upgrading Camel 3.19 to 3.20

=== camel-api

The `org.apache.camel.support.jsse.SSLContextParameters` is now using `ResourceLoader` from `CamelContext`
to load keystore and other resources in a standard way. Therefore, the `SSLContextParameters` now must have been pre-configured
with a `CamelContext` otherwise an exception is thrown. This also changes the default resource type from file to classpath.
If using a file resource for a keystore and the keystore is not found, or entries/aliases aren't found, try explicitly
specifying the file resource type, .e.g `file:myKeystore.jks`.

The model class `org.apache.camel.model.errorhandler.ErrorHandlerRefDefinition`
has been renamed to `org.apache.camel.model.errorhandler.RefErrorHandlerDefinition`.

== camel-bom

The `camel-bom` BOM no longer includes dependencies with `<type>test-jar</type>` as these are for internal testing
of the Apache Camel project.

The following Maven Plugins has been fixed to use correct GAV:

- camel-debezium-maven-plugin
- camel-salesforce-maven-plugin
- camel-servicenow-maven-plugin

from `<groupdId>org.apache.camel</groupdId>` to `<groupdId>org.apache.camel.maven</groupdId>`.

Dependencies not intended for end users has been removed, such as all `-parent` JARs.

=== camel-base64

The `base64` property placeholder function will now look up the value as a property key.
For example

[source,text]
----
{{base64:myKey}}
----

Will now look up myKey as a property placeholder value, which then is decoded.
If you want to decode the value as-is, then use `base64:decode:` as shown below:

[source,text]
----
{{base64:decode:Q2FtZWw==}}
----

=== camel-log

The log component now shows cached streams (`org.apache.camel.StreamCache`) message bodies by default.
Camel comes with stream caching enabled out-of-the-box, and therefore using the log component you would
expect to see the message body. Setting `showCachedStreams=false` to use old behaviour.

The log component now does not show MEP by default. You can turn this on by `showExchangePattern=true`.

=== camel-jsonpath

There is a new option `unpackArray` that unpacks a single-element Json array, matched by a Jsonpath, into an object. This option is disabled by default (this behaviour was enabled by default in previous Camel versions). There is a new expression `jsonpathUnpack(String text, Class<?> resultType)` that makes use of this new option.

=== camel-yaml-dsl

The `error-handler` has been refactored to be aligned with `errorHandler` from the `camel-core-model` DSL, meaning
that it is now the same, how error handlers are in other DSLs.

- `none` is now called `no-error-handler`
- `log` has been removed, as you can use `dead-letter-channel` with a log endpoint as the `dead-letter-uri`.
- `ref` is now `ref-error-handler`.

=== camel-mongodb

The Mongodb Driver core has been updated to version 4.8.1

This fully supports MongoDB 6.1

=== camel-google-pubsub

The Camel Google Pubsub headers have been renamed, since dotted keys are not allowed. 

This means all the headers will be "CamelGooglePubsub" prefixed instead of "CamelGooglePubsub."

For more information, have a look at CAMEL-18773

= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example, if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.21 to 3.21.3

=== camel-kafka

The behavior for `breakOnFirstError` was altered as numerous issues were fixed. The behavior related to committing 
the offset is now determined by the `CommitManager` that is configured. 

When the default `CommitManager` is used (`NoopCommitManager`) then no commit is performed. The route implementation will
be responsible for managing the offset using `KafkaManualCommit` to manage the retrying of the payload.

When using the `SyncCommitManager` then the offset will be committed so that the payload is continually retried. This was
the behavior described in the documentation.

When using the `AsyncCommitManager` then the offset will be committed so that the payload is continually retried. This was
the behavior described in the documentation.

== Upgrading Camel 3.20 to 3.21

=== camel-core

XML parsers & XML transformers has been made more secure by disabling DOCTYPE and/or access to external DTD/Schema.

The `org.apache.camel.support.EventNotifierSupport` abstract class now implements `CamelContextAware`.

==== Tracing

The xref:tracer.adoc[Tracer] and xref:backlog-tracer.adoc[Backlog Tracer] no longer includes internal tracing events
from routes that was created by Rest DSL or route templates or Kamelets. You can turn this on, by setting
`traceTemplates=true` in the tracer.

The xref:backlog-tracer.adoc[Backlog Tracer] has been enhanced and _fixed_ to trace message headers (also streaming types).
This means that previously headers of type `InputStream` was not traced before, but is now included. This could mean that
the header stream is positioned at end, and logging the header afterward, may appear as the header value is empty.

==== UseOriginalMessage / UseOriginalBody

When `useOriginalMessage` or `useOriginalBody` is enabled in `OnException`, `OnCompletion` or error handlers,
then the original message body is defensively copied and if possible converted to `StreamCache` to ensure
the body can be re-read when accessed. Previously the original body was not converted to `StreamCache` which
could lead to the body not able to be read or the stream has been closed.

=== camel-console

The class `org.apache.camel.impl.console.AbstractDevConsole` has moved from `camel-console` to `camel-support`
and moved to package `org.apache.camel.support.console.AbstractDevConsole`.

Component developers that has plugins for Camel Developer Console, should just use
`camel-support` and `camel-util-json` as dependencies,
and then extend `AbstractDevConsole` for custom console implementations.

=== camel-health

The `org.apache.camel.health.HealthCheck` method `isLiveness` is now default `false` instead of `true`.

Camel provides the `CamelContextCheck` as both readiness and liveness checks, so there is at least
one of each out of the box.

=== camel-main

The option `camel.main.routesReloadRestartDuration` has changed its default value from `true` to `false`.

=== camel-micrometer

The metrics has been renamed to follow Micrometer naming convention https://micrometer.io/docs/concepts#_naming_meters[Naming Meters].

|===
| Old Name | New Name
| CamelExchangeEventNotifier | camel.exchange.event.notifier
| CamelExchangesFailed | camel.exchanges.failed
| CamelExchangesFailuresHandled | camel.exchanges.failures.handled
| CamelExchangesInflight | camel.exchanges.external.redeliveries
| CamelExchangesSucceeded | camel.exchanges.succeeded
| CamelExchangesTotal | camel.exchanges.total
| CamelMessageHistory | camel.message.history
| CamelRoutePolicy | camel.route.policy
| CamelRoutePolicyLongTask | camel.route.policy.long.task
| CamelRoutesAdded | camel.routes.added
| CamelRoutesRunning | camel.routes.running
|===

=== camel-http-common

The API in `org.apache.camel.http.common.HttpBinding` has changed slightly to be more reusable.
The `parseBody` method now takes in `HttpServletRequest` as input parameter. And all `HttpMessage`
has been changed to generic `Message` types.

=== camel-jaxb

When using schema validation, then access to external DTD/Schema is disabled by default.
To enable access, then set `accessExternalSchemaProtocols=all` or specify allowed protocols, such as
`accessExternalSchemaProtocols=file`.

=== camel-platform-http-vertx

If the route or consumer is suspended, then http status 503 is now returned instead of 404.

=== camel-spring-rabbitmq

The option `replyTimeout` in `camel-spring-rabbitmq` has been fixed and the default value from 5 to 30 seconds
(this is the default used by Spring).

=== camel-stax

XML parser in `StAXJAXBIteratorExpression` has been made more secure by disabling DOCTYPE and/or access to external DTD/Schema.

=== camel-cm-sms

XML parsers have been made more secure by disabling `DOCTYPE` and/or access to external DTD/Schema.

=== camel-schematron

XML parsers have been made more secure by disabling `DOCTYPE` and/or access to external DTD/Schema.

=== camel-xmlsecurity

XML parsers have been made more secure by disabling `DOCTYPE` and/or access to external DTD/Schema.

=== camel-jbang

The command `camel dependencies` has been renamed to `camel dependency`.

In Camel JBang the `-dir` parameter for `init` and `run` goal has been renamed to require 2 dashes `--dir` like all the other options.

The _Placeholders substitutes_ is changed to use `#name` instead of `$name` syntax.

=== camel-java-joor-dsl

The `camel-java-joor-dsl` cannot anymore load routes defined in class files as we consider it no more needed, consequently the ability to configure the compile directory and the compile load first flag using the corresponding `camel-main` properties is no longer possible.

=== camel-elasticsearch

The `certificatePath` parameter can now be specified as resource: for user pointing to a local certificate, the file should be now prefixed with `file:`. It's also possible to use the classic resource helper prefixes, like `classpath`, `https` etc.

=== camel-rest

The deprecated option `componentName` was removed. Please use either `producerComponentName` or `consumerComponentName`.

=== Deprecated Components

The following components that had been marked as deprecated, were removed in this release:

* camel-dozer
* camel-cmis
* camel-vertx-kafka

=== Backlog Tracing

The option `backlogTracing=true` now automatic enabled the tracer on startup. The previous behavior
was _surprisingly_ that the tracer was only made available, and had to be manually enabled afterwards.
The old behavior can be archived by setting `backlogTracingStandby=true`.

Move the following class from `org.apache.camel.api.management.mbean.BacklogTracerEventMessage` in `camel-management-api` JAR
to `org.apache.camel.spi.BacklogTracerEventMessage` in `camel-api` JAR.


== Camel Spring Boot

The `camel-spring-boot` dependency no longer includes `camel-spring-xml`. To use legacy Spring XML files `<beans>`
with Camel on Spring Boot, then include the `camel-spring-boot-xml-starter` dependency.

=== Health Check

The health-check has aligned to be more similar to microprofile-health in the JSon output.
Spring Boot now also includes additional data per check, when using full exposure level.

For example, as shown below for the context health check:

[source,json]
----
{
  "status": "UP",
  "components": {
    "camelHealth": {
      "status": "UP",
      "details": {
        "name": "camel-health-check",
        "context": "UP",
        "context.data": {
          "invocation.count": "1",
          "context.phase": "5",
          "invocation.time": "2022-12-21T09:12:03.307871+01:00[Europe/Oslo]",
          "check.group": "camel",
          "context.name": "MyCamel",
          "success.time": "2022-12-21T09:12:03.307871+01:00[Europe/Oslo]",
          "success.count": "1",
          "check.id": "context",
          "context.version": "3.21.0",
          "context.status": "Started",
          "success.start.time": "2022-12-21T09:12:03.307871+01:00[Europe/Oslo]",
          "check.kind": "READINESS",
          "failure.count": "0"
        }
      }
    }
  }
}
----

=== camel-micrometer-starter

The `uri` tags are now static instead of dynamic (by default), as potential too many tags generated due to URI with dynamic values.
This can be enabled again by setting `camel.metrics.uriTagDynamic=true`.

=== camel-platform-http-starter

If the route or consumer is suspended, then http status 503 is now returned instead of 404.

The `platform-http-starter` has been changed from using `camel-servlet` to use Spring HTTP server directly.
Therefore, all the HTTP endpoints are no longer prefixed with the servlet context-path (default is `camel`).

For example:

[source,java]
----
from("platform-http:myservice")
  .to("...")
----

Then calling `_myservice_` would before require including the context-path, such as `http://localhost:8080/camel/myservice`.
Now the context-path is not in use, and the endpoint can be called with `http://localhost:8080/myservice`.

NOTE: The `platform-http-starter` can also be used with Rest DSL.
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example, if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.21 to 3.22

No changes expected.

== Upgrading Camel 3.22.x to 3.22.3

=== camel-file

The `readLock=changed` with using `readLockMinAge` has been restored to same behaviour as previously in 3.x.

For example, using `readLockMinAge=5s` would pickup files that are older than 5 seconds from startup time.
If you have many existing files on startup that are old, then Camel will now again be fast,
and pick up these files immediately.

= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.2 to 3.3

=== camel-jackson

The dependency on `jackson-module-jaxb-annotations` and the option `enableJaxbAnnotationModule` have been removed. To
enable support for JAXB annotations, users have to:

* explicit add `jackson-module-jaxb-annotations`
* configure the `JacksonDataFormat` and/or the `JacksonTypeConverters` module classes, example:
+
.JacksonDataFormat
[source,java]
----
JacksonDataFormat formatPojo = new JacksonDataFormat(TestJAXBPojo.class);
formatPojo.setModuleClassNames(JaxbAnnotationModule.class.getName());
----
+
.JacksonTypeConverters
[source,java]
----
context.getGlobalOptions().put(JacksonConstants.ENABLE_TYPE_CONVERTER, "true");
context.getGlobalOptions().put(JacksonConstants.TYPE_CONVERTER_TO_POJO, "true");
context.getGlobalOptions().put(JacksonConstants.TYPE_CONVERTER_MODULE_CLASS_NAMES, JaxbAnnotationModule.class.getName());
----

this change affects also the Java DSL and as consequence the `enableJaxbAnnotationModule` option for the Json 
DataFormat definition has been removed.

=== Template components

The template components which supports using a header to specify a dynamic resource to use as template, instead
of the configured template on the endpoint is now enabled out of the box. If you want to use this feature then
you must turn on `allowTemplateFromHeader=true` on either the endpoint or component level.

This applies to the following templating components: camel-freemarker, camel-velocity, camel-mvel, camel-mustache,
camel-string-template, camel-chunk, camel-jolt, camel-jslt, camel-robotframework.

=== SupervisingRouteController

The `SupervisingRouteController` has been refactored and its configuration has been simplified.
And when configuring from spring boot, then the auto configuration parameters has
been changed from `camel.supervising.controller` into the general `camel.springboot` which
allows to share the same configuration across runtimes so its the same in Spring Boot, Camel Main,
Camel K, Camel Quarkus, etc.

=== Camel Karaf

The following components is no longer supported in OSGi and has been removed from the Camel Karaf features file:
camel-undertow, camel-jgroups, camel-jgroups-raft, camel-infinspan.

=== camel-maven-plugin

The `embedded` goal has been removed (was never really in use). Use `run` goal instead.

=== API changes

The dump model classes in package `org.apache.camel.support.dump` has been removed
as they were not in use by Camel.

In relation to the dump model classes removal, in camel-karaf the following commands were removed: `context-info`, `route-info`, `route-profile` and `route-step`.

=== camel-main

The following methods have been https://issues.apache.org/jira/browse/CAMEL-15005[relocated] from `org.apache.camel.main.BaseMainSupport` to `org.apache.camel.main.MainConfigurationProperties`:

- getConfigurationClasses
- setConfigurationClasses
- addConfigurationClass
- addConfiguration
- getConfigurations
- setConfigurations
- getRouteBuilderClasses
- setRouteBuilderClasses
- getRouteBuilders
- getRoutesBuilders
- setRoutesBuilders
- addRoutesBuilder

This means that as example, the following snippet:

[source,java]
----
Main main = new Main();
main.addRoutesBuilder(....)
----

Should become

[source,java]
----
Main main = new Main();
main.configure().addRoutesBuilder(....)
----

See https://issues.apache.org/jira/browse/CAMEL-15005


= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.3 to 3.4

=== camel-test and JMX

The `camel-test` module no longer has dependency on `camel-management` out of the box.
In Camel JMX is optional and to use JMX then `camel-management` must be added as dependency.

For example to use JMX during testing you the following dependency as test scope:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-management</artifactId>
    <scope>test</scope>
</dependency>
----

=== Health Check

The default health check implementation has been moved out of `camel-base` into `camel-health` as a separate module.
The health check has been refactored and there are some APIs and classes that has been changed.
The health check in `camel-consul` has been removed.

The old health check was not fully implemented and was only targeting Spring Boot.
The new system is more generic and supports all Camel runtimes.

An example is provided in `camel-example-main-health`.

=== Template components

The template components which allows access to the current `Exchange` and `CamelContext` API
from the context map available for templating has now been restricted to only the message body and headers.

This option can be enabled (`allowContextMapAll=true`) for full access to the current Exchange and CamelContext.
Doing so impose a potential security risk as this opens access to the full power of CamelContext API.

This applies to the following templating components: camel-freemarker, camel-velocity, camel-mvel, camel-mustache,
camel-string-template, camel-chunk, camel-robotframework.

=== Using custom language in RouteBuilder

The Java DSL `RouteBuilder` allows referring to a custom language as shown below:

[source,java]
----
from("direct:start")
    .filter(language("foo", "Bla bla bla"))
      .to("mock:camel");
----

This functionality is seldom in use, as you would use the provided languages from Camel.
If using, then the `language` method now requires a static import as shown below:

[source,java]
----
import static org.apache.camel.builder.Builder.language;
----

=== Using custom type converters

If you are using custom type converters, you can now generate loader classes and have Camel discover them automatically. To generate loader class, Change  `@Converter` to `@Converter(generateLoader = true)` at class level and implement maven plugin as described in xref:camel-component-maven-plugin.adoc[here].

If a loader class is not to be used, Camel needs to be instructed to scan for custom converters. This can be done as shown:

[source,java]
----
context.setLoadTypeConverters(true);
----

And in XML:
[source,xml]
----
<camelContext loadTypeConverters="true">

</camelContext>
----

If you are using Camel on Spring Boot, Quarkus or via Camel Main this can also be configured in the `application.properties`:
[source,properties]
----
camel.main.loadTypeConverters=true
----

=== camel-spring-boot

The `/actuator/camelroutes` HTTP endpoint has been removed from provided Spring Boot actuators in `camel-spring-boot`.
This actuator was becoming problematic to maintain during Spring Boot upgrades due to changes in Spring Boot.

=== camel-servlet and camel-http-common

`HttpRegistry` and `DefaultHttpRegistry` classes from camel-servlet are moved from camel-servlet into camel-http-common.
`HttpRegistryProvider` is added and used in `DefaultHttpRegistry` instead of `CamelServlet`.

These changes had effects on camel-atmosphere-websocket and camel-servlet and also camel-resteasy.
Users of these components where they would have custom implemetations on `DefaultHttpRegistry` and using `CamelServlet` class should take this change into account.

=== camel-sql

The `JdbcAggregationRepository` optimistic locking feature has been fixed to work on a distributed environment and every database.
There is a new `version` column that is required and must be added to the repository:

[source,sql]
----
CREATE TABLE aggregation (
 id varchar(255) NOT NULL,
 exchange blob NOT NULL,
 version BIGINT NOT NULL,
 constraint aggregation_pk PRIMARY KEY (id)
);
CREATE TABLE aggregation_completed (
 id varchar(255) NOT NULL,
 exchange blob NOT NULL,
 version BIGINT NOT NULL,
 constraint aggregation_completed_pk PRIMARY KEY (id)
);
----

=== Thread Pool default changed

The thread pools managed and created by Camels 'ExecutorServiceManager' or `ThreadPoolFactory` is now set to default created thread pools
with `allowCoreThreadTimeOut=true`. This means that the thread pool can shrink and terminate also the core threads if the pool is idle.

In older versions this was `allowCoreThreadTimeOut=false` and the default core size was 10, which means thread pools would typically have 10 threads as minimum.
With this change those thread pools can shrink to lower value when core threads become idle as well.

=== camel-lra-starter

The Spring Boot LRA starter component have changed its auto configuration keys to be similar to using camel-lra with camel-main or camel-quarkus.
Change the keys from `camel.service.lra` to `camel.lra`, eg `camel.service.lra.coordinator-url` to `camel.lra.coordinator-url`.

=== Maven Archetypes

The `camel-archetype-java8` has been removed, as you can just use `camel-archetype-java` instead.

=== Maven Plugins

A new maven plugin called `camel-component-maven-plugin` has been added which intents to help third party component developers to generate all required metadata and configurations Java files. For more info on how to use it in your project, please take a look at plugin's documentation xref:camel-component-maven-plugin.adoc[here].

=== Camel-Kafka

From a lot of time, the headerFilterStrategy application in consumer and producer was done in an interchanged way.
You need to have a look at the following issue for more information: https://issues.apache.org/jira/browse/CAMEL-15121

=== Camel-Karaf

Removed `camel-hdfs` and `camel-pulsar` Karaf features.
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.4 to 3.5

=== FluentProducerTemplate

The template will now automatic clear its state when sending the message, this avoids end users having to call `clearAll` after usage,
in case the template should be reused to send other messages.

After the template has been started / used the first time, then its general configuration cannot be altered later,
instead create a new template.

=== PackageScanClassResolver

The `PackageScanClassResolver` will now skip abstract classes in its `findImplementations` method.

=== camel-bean

The `bean(class)` EIP will now lookup in the registry first whether there is a single bean instance of the given class type
and use the existing bean (for singleton scope) instead of creating a new instance.

=== camel-cassandraql

Load-balancing policy has changed. There are no existing load balancing policies (see https://docs.datastax.com/en/developer/java-driver/4.3/upgrade_guide/#load-balancing-policy[upgrade guide]).
To customize load balancing policy, please use the parameter `loadBalancingPolicyClass` and provide own implementation
of load balancing policy.

Session impelentation class has changed from `com.datastax.driver.core.Session` to
`com.datastax.oss.driver.api.core.CqlSession` (see https://docs.datastax.com/en/developer/java-driver/4.3/upgrade_guide/#session[upgrade guide]).
This could have direct impact on the type of parameter `beanRef` if you are using `Provided Session reference`.

There is a new parameter `datacenter` (with default value `datacenter1`). Data center has to be defined for the proper
behavior of the default load balancing policy.

=== camel-sjms

The default value for `keepAliveDelay` was changed from `-1` to `5000` in the batch jms consumer.

=== camel-weather

The option `httpClient` is now a query parameter.

A new parameter `geoLocationProvider` was introduced to allow the use of a custom `GeolocationProvider` implementation.

=== Camel Karaf

The following feature has been removed due to no longer being compatible with OSGi: `camel-couchbase`.

=== LifecycleStrategy

The `LifecycleStrategy` has been enhanced and provides some additional methods and changes in the behavior:

* **onContextInitializing**: is invoked when the context is about to be initialized, this was previopusly achieved by `onContextInitialized` but as the name was a misleading
* **onContextInitialized**: is now invoked when the context is initialized
* **onContextStarting**: is invoked when the context is about to start, this was previously achieved by the `onContextStart` which is now deprecated.
* **onContextStarted**: is now invoked when the context is started
* **onContextStopping**: is invoked when the context is about to be stopped, this was previously achieved by the `onContextStop` which is now deprecated.
* **onContextStop**: is now invoked when the context is stopped

=== JUnit 5 testing

Camel has been migrated from JUnit 4 to JUnit 5 as our default testing in all the components.
The new test components reflect this with the following JAR names:

- camel-test-junit5
- camel-test-spring-junit5
- camel-testcontainers-junit5
- camel-testcontainers-spring-junit5

The older test components supports only JUnit 4.

=== Spring Boot testing with JUnit 5

Testing Camel on Spring Boot with JUnit 5 have also changed slightly to use JUnit 5 APIs and testing style.

The following set of dependencies can be used:

[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-test-spring-junit5</artifactId>
    <scope>test</scope>
</dependency>
----

Then in your test classes you should annotate the Spring Boot test class with the new `@CamelSpringBootTest`
(from package `org.apache.camel.test.spring.junit5.CamelSpringBootTest` in camel-test-spring-junit5 JAR)
annotation as shown:

[source,java]
----
@CamelSpringBootTest
@SpringBootTest(classes = MyCamelApplication.class)
public class MyCamelApplicationJUnit5Test {

    @Autowired
    private CamelContext camelContext;

    @Test
    public void shouldProduceMessages() throws Exception {
        // here you can write your unit test
    }

}
----
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.5 to 3.6

=== UUID Generator

The default UUID Generator in Camel has switched to a faster algorithm based on UUID that were used by Camel Quarkus and Camel K.
This generator does not use the hostname as part of the ID generation and avoids any network IO calls during initialization.

The old generator has been renamed and moved into a new package at `org.apache.camel.support.ClassicUuidGenerator`.
The new default generator is now also located in camel-support as `org.apache.camel.support.DefaultUuidGenerator`
where all the out of the box generators reside.

Users that want to use the old UUID generator can configure Camel to use `org.apache.camel.support.ClassicUuidGenerator`
as the generator.

=== Simple language

The simple language have been optimized to handle numeric and boolean values more naturally.
We have also optimized for unneeded type conversions in predicates such as comparing left and right hand side in operators
with their given type as-is, or the least amount of conversion when possible.

The `contains` and `not contains` operator now handles numerics naturally. For example `${header.numbers} contains '123,456'`
would return `false` if the numbers header has the value `-123`, as the operator now compares numerically. Previously it
would compare with String based values.

=== Bean component

We have now implemented bean scope (singleton, request, and prototype) for all kinds of using the bean component, whether
it's the bean endpoint, bean language (method call), bean EIP, or the bean function in the simple language (eg `${bean:foo}`).

The default scope is now singleton. Previously the bean function in simple language would be prototype scope (always lookup the bean on each use).
With singleton scope we improve the performance by avoiding the repetitive lookup of the same bean on each usage.

You can use the old behaviour by setting the scope to prototype.

=== API components upgrade

The `camel-braintree`, `camel-twilio` and `camel-zendesk` has updated to newer versions and regenerated their API
signatures in the Camel components which changed a few existing API methods and adding new API methods as well.

=== API components overhauled

The following API component has been overhauled, by having a new Java source parser to inspect API and fully generate
Camel endpoint configuration and documentation gathered from javadoc.

The components affected are:

- camel-as2
- camel-box
- camel-braintree
- camel-fhir
- camel-google-calendar
- camel-google-drive
- camel-google-email
- camel-google-sheets
- camel-olingo2
- camel-olingo4
- camel-twilio
- camel-zendesk

=== Languages

All the out of the box supported languages (simple, bean, groovy, jsonpath, xpath etc.) have been optmized to be _singleton_
which improves performance for concurrent processing that uses those languages that would be resolved on each use.
Now the languages are resolved once during startup or first usage.

=== Expressions

Expressions built via `ExpressionBuilder` and similar now often require to be initialized by calling `init` before use.
This is part of an effort to optimize Camel to eager initialize its expression and languages.
This only impacts Camel end users whom use the `ExpressionBuilder` directly.
Normal usage of Camel should not be impacted by this change.

=== Customizers

Customizers, which are objects used to configure some of the Camel services such as component, language and data formats, that were previously limited to Camel Spring Boot, are now consistently used across runtimes.
To make that possible, the interfaces have been changed and they do not use generics anymore.

Impacted interfaces:

* org.apache.camel.spi.ComponentCustomizer
* org.apache.camel.spi.LanguageCustomizer
* org.apache.camel.spi.DataFormatCustomizer

As example the signature of the `ComponentCustomizer` interface in Camel 3.5 is:

[source,java]
----
@FunctionalInterface
public interface ComponentCustomizer<T extends Component> {
    /**
     * Customize the specified {@link Component}.
     *
     * @param component the component to customize
     */
    void customize(T component);
}
----

And below the Camel 3.6 version:

[source,java]
----
@FunctionalInterface
public interface ComponentCustomizer {
    /**
     * Customize the specified {@link Component}.
     *
     * @param name   the unique name of the component
     * @param target the component to configure
     */
    void configure(String name, Component target);

    /**
     * Checks whether this customizer should be applied to the given {@link Component}.
     *
     * @param  name   the unique name of the component
     * @param  target the component to configure
     * @return        <tt>true</tt> if the customizer should be applied
     */
    default boolean isEnabled(String name, Component target) {
        return true;
    }

    @Override
    default int getOrder() {
        return 0;
    }
}
----

As the customizers are now taken into account as part of the standard lifecycle of the `CamelContext`, to programmatically configure a component, it is enough to register the appropriate customizer in the `Registry`. For example:

[source,java]
----
public class Application {

    public static void main(String args) throws Exception {
        Main main = new Main();
        main.addConfigurationClass(MyConfiguration.class);
        main.run(args);
    }

    public static class MyConfiguration {
        @BindToRegistry
        public ComponentCustomizer logCustomizer() {
            // Use a fluent Component Customizer builder to ease the process of creating an customizer.
            return ComponentCustomizer.builder(LogComponent.class)
                    .build(component -> component.setExchangeFormatter(new DefaultExchangeFormatter()));
        }
    }
}
----

[NOTE]
====
As a consequence of this change, the Camel Spring Boot starters have been amended to use Customizers instead of creating instances of components, languages or data formats.
====

=== Component Verifiers

Camel components which provides `ComponentVerifierExtension` should have `camel-core-catalog` added as dependency at runtime, if the verifier are in use.
You will see an exception about `camel-core-catalog` not found on classpath otherwise.

=== SendDynamicAware

The API in `org.apache.camel.spi.SendDynamicAware` has changed and any custom implementations must be updated accordingly.
There is a new abstract `org.apache.camel.support.component.SendDynamicAwareSupport` class which can be used as base for custom implementations.

=== Stream Caching

If stream caching is enabled and an exception is thrown while converting the message payload to `StreamCache` then the error handler
can now handle this exception (e.g. `onException`). The exception is regarded as non-recoverable and redelivery is not in use.

=== Camel Caffeine

To configure the component to use a pre-configured cache, it is no longer required to use the now removed `cache` option as the component performs a look-up in the registry based on the `cacheName` URI param.

For example, the following code:

[source,java]
----
.to("caffeine-cache://cache?cache=#myCache&action=PUT&key=1")
----

Should be replaced by:

[source,java]
----
.to("caffeine-cache://myCache?action=PUT&key=1")
----

=== Camel Karaf

The following feature has been removed due to being no longer compatible with OSGi: `camel-atmosphere-websocket`.

=== CamelFileDataSource

The class `CamelFileDataSource` has moved from `camel-http-common` package `org.apache.camel.http.common` to `camel-attachments` package `org.apache.camel.attachment`.

If your code directly depends on this class, you will need to update the package reference to the new location.

=== Message History

When message history is enabled then there is a slight performance overhead as the history data is now stored
in a `java.util.concurrent.CopyOnWriteArrayList` due to the need of being thread safe.

=== Default limit set on decompressed file size

From Apache Camel 3.6.0, a default limit is enforced on the maximum size of a decompressed file, to prevent possible denial of service attacks.
This applies to the camel-zipfile and camel-tarfile data formats. This can be configured as follows:

[source,java]
----
ZipFileDataFormat maxDecompressedSizeZip = new ZipFileDataFormat();
maxDecompressedSizeZip.setMaxDecompressedSize(100000000000L);

.unmarshal(maxDecompressedSizeZip)
----

The default value if not specified corresponds to one gigabyte. An `IOException` will be thrown if the decompressed size exceeds this amount.
Set to `-1` to disable setting a maximum decompressed size.

=== Camel RabbitMQ

The `camel-rabbitmq` server component properties have been changed. The properties prefix `rabbitmq.` was replaced by `CamelRabbitmq`.

=== Camel-Slack

The options username, iconUrl and iconEmoji have been deprecated and they will be removed in 3.7.0.

=== Camel-Hipchat

This component has been removed.
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example, if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.6 to 3.7

=== Modularized core

The core has been further modularized and is now split up into three new core modules:

- camel-core-model
- camel-core-reifier
- camel-core-processor

This separates the route model from the runtime processors via the reifiers, by having the classes in their own modules.

=== API changes

The class `BreakpointSupport` has moved from `org/apache/camel/processor/interceptor/BreakpointSupport` to `org.apache.camel.support.BreakpointSupport`.

The following internal classes have been moved to locations that better suit where other similar processors are located:

The class `org.apache.camel.impl.validator.ProcessorValidator` moved to `org.apache.camel.processor.validator.ProcessorValidator`.
The class `org.apache.camel.impl.transformer.ProcessorTransformer` moved to `org.apache.camel.processor.transformer.ProcessorTransformer`.
The class `org.apache.camel.impl.transformer.DataFormatTransformer` moved to `org.apache.camel.processor.transformer.DataFormatTransformer`.
The class `org.apache.camel.impl.validator.ValidatorKey` moved to `org.apache.camel.impl.engine.ValidatorKey`.
The class `org.apache.camel.impl.transformer.TransformerKey` moved to `org.apache.camel.impl.engine.TransformerKey`.

The class `org.apache.camel.impl.DefaultExecutorServiceManager` was moved from `camel-core-engine` JAR to
`org.apache.camel.impl.engine.DefaultExecutorServiceManager` in the `camel-base` JAR.

The class `org.apache.camel.processor.ConvertBodyProcessor` was moved
to `org.apache.camel.support.ConvertBodyProcessor` in the `camel-support` JAR.

The class `org.apache.camel.impl.engine.DefaultClaimCheckRepository` moved
to `org.apache.camel.processor.DefaultClaimCheckRepository` in the `camel-core-processor` JAR.

The class `org.apache.camel.impl.engine.DefaultProducerCache` was moved to `org.apache.camel.support.cache.DefaultProducerCache`.
The class `org.apache.camel.impl.engine.DefaultConsumerCache` was moved to `org.apache.camel.support.cache.DefaultConsumerCache`.
The class `org.apache.camel.impl.engine.EmptyProducerCache` was moved to `org.apache.camel.support.cache.EmptyProducerCache`.
The class `org.apache.camel.impl.engine.ServicePool` was moved to `org.apache.camel.support.cache.ServicePool`.
The class `org.apache.camel.impl.engine.ProducerServicePool` was moved to `org.apache.camel.support.cache.ProducerServicePool`.
The class `org.apache.camel.impl.engine.PollingConsumerServicePool` was moved to `org.apache.camel.support.cache.PollingConsumerServicePool`.
The class `org.apache.camel.impl.engine.EventNotifierCallback` was moved to `org.apache.camel.support.cache.EventNotifierCallback`.

Two methods related to adding and removing error handlers were removed from the interface `org.apache.camel.spi.LifecycleStrategy`.

=== Type Converters

Camel 3.7 has optimized its type converter system, which can impact 3rd party components which contain type converters.
Previously, the type converter system would attempt to find a type converter that would be capable of
converting between two given types (also by walking up the parent classes and super interfaces).
But this leads to slower performance, and Camel now relies on there being converter methods with the exact combo
of converting from/to types.

==== Converting to milliseconds from text

When converting to milliseconds using the shorthands for time precision with hours, minutes and seconds, support
for fractions was removed. For example `delay=0.5m` (half minute) is no longer supported, use `delay=30s` instead.

Support for using units as `days`, `hours`, `minutes`, `seconds`, and `millis` has been removed.
Units must now be one of `d` for days, `h` for hours, `m` for minutes, `s` for seconds, and `ms` for millis (can be omitted).
So you can use `1h12m37s42ms` for 1 hour, 12 minutes, 37 seconds and 42 milliseconds.

=== JMX

The MBeans for error handlers have been removed.

=== ProcessorFactory

If a custom `org.apache.camel.spi.ProcessorFactory` is in use, the factory should extend the default implementation
`org.apache.camel.processor.DefaultProcessorFactory` and in the overridden methods, super should be called to let
the default implementation create the processor when no custom processors is created.

The class `org.apache.camel.impl.engine.TypedProcessorFactor` moved from `camel-base` JAR
to `org.apache.camel.support.TypedProcessorFactor` in the `camel-support` JAR.

=== AdviceWith

Advice routes moved the `adviceWith` method from `org.apache.camel.reifier.RouteReifier` to `org.apache.camel.builder.AdviceWith`.
Also `adviceWith` methods on `org.apache.camel.builder.AdviceWithRouteBuilder` are deprecated in favour
of using methods on `org.apache.camel.builder.AdviceWith`.

=== toD EIP

Support for using multiple languages in the toD EIP has been removed as it was a rarley used feature and was causing
problems for maintenance. `toD` uses simple language by default, but an alternative language can still be specified.

=== Components

The deprecated option `basicPropertyBinding` has been removed.

=== camel-couchbase

The original URI path has been changed, now the bucket part is simply a required option and it's not part of the URI anymore.

=== camel-file-watch

The event type header is no longer an enum, but it is now the explicit event as a `String` value.

=== camel-leveldb

Component uses a different serialization mechanism, which is not backwards compatible with the original one.
For full compatibility, use the camel-leveldb-legacy component (the legacy component will be removed in a future release).

=== camel-mock

The class `InterceptSendToMockEndpointStrategy` in `camel-base` JAR was moved from `org.apache.camel.impl.engine.InterceptSendToMockEndpointStrategy`
to `org.apache.camel.component.mock.InterceptSendToMockEndpointStrategy` in the `camel-mock` JAR.

=== camel-saga

The class `org.apache.camel.impl.saga.InMemorySagaService` was moved to `org.apache.camel.saga.InMemorySagaService`.
The class `org.apache.camel.impl.saga.InMemorySagaCoordinator` was moved to `org.apache.camel.saga.InMemorySagaCoordinator`.

=== camel-management

The `listTypeConverters` operation on `ManagedTypeConverterRegistryMBean` has been removed.

=== camel-kafka

We changed some option's naming because they were a bit misleading:

- From kafkaHeaderDeserializer to headerDeserializer
- From kafkaHeaderSerializer to headerSerializer
- From keySerializerClass to keySerializer
- From serializerClass to valueSerializer

For more information, have a look at CAMEL-15770

=== camel-git

The Camel Git Commit consumer has been changed a bit.

For each exchange now in the body, you'll get the commit full message as a String and the Commit Object like before.

Other information has been stored in headers declared in GitConstants class:

* `GIT_COMMIT_ID` - "CamelGitCommitId" - The commit Id
* `GIT_COMMIT_AUTHOR_NAME` - "CamelGitAuthorName" - The commit Author name
* `GIT_COMMIT_COMMITTER_NAME` - "CamelGitCommiterName" - The commit committer name
* `GIT_COMMIT_TIME` - "CamelGitCommitTime" - The commit time

The Camel Git Branch consumer has been changed a bit.

For each exchange now in the body, you'll get the branch ref name and not the full ref like before.

Other information has been stored in headers declared in `GitConstants` class:

* `GIT_BRANCH_LEAF` - "CamelGitBranchLeaf" - Leaf
* `GIT_BRANCH_OBJECT_ID` - "CamelGitBranchObjectId" - Object Id

The Camel Git Tag consumer has been changed a bit.

For each exchange now in the body, you'll get the tag ref name and not the full ref like before.

Other information has been stored in headers declared in GitConstants class:

* `GIT_TAG_LEAF` - "CamelGitTagLeaf" - Leaf
* `GIT_TAG_OBJECT_ID` - "CamelGitTagObjectId" - Object Id

=== camel-github

Login using username and password is no longer supported by GitHub and these options have been removed
(https://developer.github.com/changes/2020-02-14-deprecating-password-auth/).

Login must be done using the `oauthToken` option.

=== Camel-AWS2-S3 Autowire support

The camel-aws2-s3 component now has support for autowiring the `amazonS3Client` option with a `S3Client` instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-S3 UseIamCredentials

The option useIamCredentials has been renamed to `useDefaultCredentialsProvider`, since we changed to a `DefaultCredentialsProvider` approach.

=== Camel-AWS2-Cloudwatch Autowire support

The camel-aws2-cw component now has support for autowiring the `amazonCwClient` option with a CloudWatchClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-DDB Autowire support

The camel-aws2-ddb component now has support for autowiring the `amazonDDBClient` option with a DynamoDbClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

The camel-aws2-ddbstreams component now has support for autowiring the `amazonDynamoDbStreamsClient` option with a DynamoDbStreamsClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-EC2 Autowire support

The camel-aws2-ec2 component now has support for autowiring the `amazonEc2Client` option with an Ec2Client instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-ECS Autowire support

The camel-aws2-ecs component now has support for autowiring the `ecsClient` option with an EcsClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-EKS Autowire support

The camel-aws2-eks component now has support for autowiring the `eksClient` option with an EksClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-Eventbridge Autowire support

The camel-aws2-eventbridge component now has support for autowiring the `eventBridgeClient` option with an EventBridgeClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-IAM Autowire support

The camel-aws2-iam component now has support for autowiring the `iamClient` option with an IamClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-Kinesis Autowire support

The camel-aws2-kinesis component now has support for autowiring the `amazonKinesisClient` option with a KinesisClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

The camel-aws2-kinesis-firehose component now has support for autowiring the `amazonKinesisFirehoseClient` option with a FirehoseClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-KMS Autowire support

The camel-aws2-kms component now has support for autowiring the `awsLambdaClient` option with a LambdaClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-Lambda Autowire support

The camel-aws2-kms component now has support for autowiring the `kmsClient` option with a KmsClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-MQ Autowire support

The camel-aws2-mq component now has support for autowiring the `amazonMqClient` option with a MqClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-MSK Autowire support

The camel-aws2-msk component now has support for autowiring the `mskClient` option with a KafkaClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-SES Autowire support

The camel-aws2-ses component now has support for autowiring the `amazonSESClient` option with a SesClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-SNS Autowire support

The camel-aws2-sns component now has support for autowiring the `amazonSNSClient` option with a SnsClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-SNS UseIamCredentials

The option useIamCredentials has been renamed to `useDefaultCredentialsProvider`, since we changed to a DefaultCredentialsProvider approach.

=== Camel-AWS2-SQS Autowire support

The camel-aws2-sqs component now has support for autowiring the 1 `amazonSQSClient` option with a SqsClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-SQS UseIamCredentials

The option useIamCredentials has been renamed to `useDefaultCredentialsProvider`, since we changed to a `DefaultCredentialsProvider` approach.

=== Camel-AWS2-STS Autowire support

The camel-aws2-sts component now has support for autowiring the `stsClient` option with a StsClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-Translate Autowire support

The camel-aws2-translate component now has support for autowiring the `translateClient` option with a TranslateClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== Camel-AWS2-Athena Autowire support

The camel-aws2-athena component now has support for autowiring the `amazonAthenaClient` option with an AthenaClient instance coming from the registry.
In this context, it wasn't making sense to maintain the `autodiscoverClient` option, which has been removed.

=== camel-salesforce

The default API version for camel-salesforce has been updated to 50.0. Older versions are still 
supported and can be set via the `apiVersion` component option. 

The `packages` option must be set if using the XML `format` option. This change is a result of 
adopting XStream's Security Framework.

CAMEL-15890 fixed a bug in which values for External Ids that contained spaces would have spaces converted to "{plus}". This has been fixed. 
However, any such values that now have the plus sign in salesforce will no longer match as Camel will now preserve the space. Therefore
you may need to have a transformation that explicitly converts spaces to "{plus}" if you need to preserve the old behavior.

=== camel-google-bigquery

The camel-google-bigquery component was updated to use the latest version of `google-cloud-bigquery`. Some features of `GoogleBigQueryConnectionFactory` are no longer supported.

It is no longer possible to provide the service account private key as a String parameter to `GoogleBigQueryConnectionFactory`. Instead, you should use `setCredentialsFileLocation` to 
discover the private key from your credential's file. Or use the fallback mechanism for discovering credentials by setting the `GOOGLE_APPLICATION_CREDENTIALS` environment variable. Refer to the
component documentation for more information. 
= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.7 to 3.8

=== Route startup procedure change

Camel will now initialize all routes during initialization of `CamelContext` itself.
Before all routes where lazy initialized when they were started, which happens in the starting phase of `CamelContext`.
By moving this forward to initialization phase, we ensure all is done together.

This means that all the resources used in the routes such as EIPs, processors, beans, components, data formats, languages etc.
are also initialized. An affect of this change is that any custom Camel component that may do initialization logic in
the constructors of `Consumer` or `Producer` should *not* do this, but move this logic to `doInit` or `doStart` where
such logic belongs.

=== API changes

The following type names are renamed in `CamelEvent.Type` enum:

- `CamelContextRoutesStarting` to `RoutesStarting`
- `CamelContextRoutesStarted` to `RoutesStarted`
- `CamelContextRoutesStopping` to `RoutesStopping`
- `CamelContextRoutesStopped` to `RoutesStopped`

The method `isOnlyDynamicQueryParameters` was removed from `org.apache.camel.spi.SendDynamicAware` and
`org.apache.camel.support.component.SendDynamicAwareSupport` classes.

The class `PackageScanResourceResolver` has been revisited and the method `findResources` now returns a collection of `org.apache.camel.spi.Resource`
which provide both the location of the resolved resources and a method to open the related `InpuStream`:

[source,java]
----
Collection<Resource> findResources(String location) throws Exception;
----

=== OnCompletion EIP

The `onCompletion` EIP has been fixed. It could trigger multiple completions for a given `Exchange` before.

=== Transactions and Multicast, Splitter, or Recipient List EIPs

When using `transacted` in Camel routes with Multicast, Splitter, or Recipient List EIPs, the exection strackframe
could grown deep and this could cause a stack overflow exception. This has been fixed by refactoring the EIP into a special
transacted mode and the existing reactive mode.

We do not anticipate any issues but if you are using transactions and these EIPs then we would like to have feedback
if you encounter any problems with upgrading.

=== Configuration changes

The configuration for specifying directory for loading XML routes have been consolidation into a single option (supporting all kinds):

For Spring Boot users:

`camel.springboot.xml-routes` to `camel.springboot.routes-include-pattern`
`camel.springboot.xml-route-templates` to `camel.springboot.routes-include-pattern`
`camel.springboot.xml-rests` to `camel.springboot.routes-include-pattern`

For Camel Main users:

`camel.main.xml-routes` to `camel.springboot.routes-include-pattern`
`camel.main.xml-route-templates` to `camel.springboot.routes-include-pattern`
`camel.main.xml-rests` to `camel.springboot.routes-include-pattern`


=== camel-jackson

In the XML DSL `jsonView` has been renamed to `jsonViewTypeName` and made general available in the model
and for the lightweight `camel-xml-io` route parser.

=== camel-caffeine-lrucache

This LRUCache implementation is using an algorithm where elements that are removed may not be in strict order, and therefore
not ideal for LRU caches assuming ordering.

The implementation is not needed anymore in Camel 3, as we are using a simpler default implementation internally.
This component was deprecated, and has been removed as Maven dependency in `camel-core` pom.xml file.

=== camel-activemq and camel-jms

The JMS and ActiveMQ components now support the optimized toD EIP pattern by using a single endpoint/producer for dynamic destination names.

=== camel-sjms and camel-sjms2

These two components have been overhauled and re-written with the goal of being more feature complete with the Spring JMS component.
They no longer uses their own connection pooling, but let you use the existing 3rd party pooling for `ConnectionFactory` which is common practice.
The components are now reactive and non-blocking, and support the optimized toD EIP pattern by using a single endpoint/producer for dynamic destination names.

Many of the previous features and configuration options have been removed/renamed.
The sjms-batch sub component has been removed and is scheduled to be reimplemented in the future.
To migrate you need to read their documentation and see what options they now offer.

=== camel-aws2-sns

The policy option now expects a file, since the policy is going to be complex. It can be from classpath:, http: or file: etc.

=== camel-aws2-sqs

The policy option now expects a file, since the policy is going to be complex. It can be from classpath:, http: or file: etc.

=== camel-github

The Camel Github Commit consumer has been changed a bit.

For each exchange now in the body you'll get the commit full message as a String and not the Commit Object like before.

Other information has been stored in headers declared in `GitHubConstants` class:

* GITHUB_COMMIT_AUTHOR - `CamelGitHubCommitAuthor` - The commit Author
* GITHUB_COMMIT_COMMITTER - `CamelGitHubCommitCommitter` - The committer name
* GITHUB_COMMIT_SHA - `CamelGitHubCommitSha` - The commit sha
* GITHUB_COMMIT_URL - `CamelGitHubCommitUrl` - The commit url

The Camel Github Events consumer has been changed a bit.

For each exchange now in the body you'll get the event type as a String and not the Event Object like before.

Other information has been stored in headers declared in GitHubConstants class:

* GITHUB_EVENT_PAYLOAD - `CamelGitHubEventPayload` - The event payload

=== camel-infinispan

There are now two components for Infinispan:

- *camel-infinispan* to integrate with remote caches through the Hot Rod protocol (scheme: *infinispan*).
- *camel-infinispan-embedded* to integrate with local/embedded caches (scheme: *infinispan-embedded*).

As consequence of the refactor:

The remote and embedded endpoints provide support the same capabilities, as example queries were only possible on a remote cache and now they are supported on both remote and local/embedded caches.
The configuration options for the endpoint are now specific to the context which remove the possibility to mix unrelated properties.
Some classes have been relocated (such as indempotent and aggregation repositories) have been moved from `org.apache.camel.component.infinispan.processor.*` to `org.apache.camel.component.infinispan.embedded` or `org.apache.camel.component.infinispan.remote`:
- `org.apache.camel.component.infinispan.embedded.InfinispanEmbeddedAggregationRepository`
- `org.apache.camel.component.infinispan.embedded.InfinispanEmbeddedIdempotentRepository`
- `org.apache.camel.component.infinispan.remote.InfinispanRemoteAggregationRepository`
- `org.apache.camel.component.infinispan.remote.InfinispanRemoteIdempotentRepository`

=== camel-aws

All the camel-aws components except camel-aws-xray have been deprecated. We suggest migrating to camel-aws2-* components,
because in future releases the AWS components will be removed and with the next LTS release (3.10 probably)
camel-aws2 components will be renamed to camel-aws.


= Apache Camel 3.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

== Upgrading Camel 3.8 to 3.9

=== API changes

The `Consumer` API in `camel-api` has been enhanced to help support Camel reducing the footprint during routing.
One aspect is that we allow recycling `Exchange` instances created by the consumers. This avoids creating new `Exchange`
instances in the memory for each incoming message consumers process. By recycling `Exchange`s we reduce the overhead
on the JVM garbage collector. This requires Camel to know if the `Exchange` should be recycled or not,
and some API changes took place.

The `Consumer` API has two new methods which a consumer must use to create an `Exchange` with `createExchange`.
Default the exchange is auto released when its complete in use, but some consumers needs custom control,
and can turn off auto release, which then requires the consumer to manually release the exchange by calling `releaseExchange`
when the consumer is done with the exchange.

The default implementations in `DefaultConsumer` has adapted this API and 3rd party components can continue as is, by using
the older APIs. For these 3rd party components to support recycling exchanges, then they must be updated to use this new API.

A new `org.apache.camel.spi.ResourceLoader` has been introduced as part of https://issues.apache.org/jira/browse/CAMEL-16285[CAMEL-16285] which provide a way to support additional schemas to resolve resources. As a consequece:

- `org.apache.camel.support.ResourceHelper` has been updated to use such mechanism instead fo the old one.
- it is not more possible to provide support for additional schemas using the URL protocol handler mechanism but instead, custom schemas can be added by implementing `org.apache.camel.spi.ResourceResolver` and either bind an instance to the Camel Registry (using `resource-loader-` as a prefix) or using the Service Factory mechanism (under the path `META-INF/services/org/apache/camel/resource-resolver/`)

As example, assuming you want to provide a support for the schema `foo`, then you either have to binbd your instance to the Camel Registry with `resource-loader-foo` as a key, or create a factory finder file with path `META-INF/services/org/apache/camel/resource-resolver/foo`
The method for retrieving a resource URL provided by the `org.apache.camel.support.ResourceHelper` class, i.e. `resolveMandatoryResourceAsUrl` ad ` resolveResourceAsUr` have been amended to accept a `CamelContext` instance instead of a `ClassResolver`.

=== Exchange properties

The properties on `Exchange` have been optimized to separate into two: internal state vs user properties.

The method `getProperties()` now only returns user properties. To include internal properties as well,
then use `getAllProperties()`.

The other APIs such as `getProperty(String)` works the same way as before, being able to lookup a property
regardless if it is internal or custom.

The internal properties is a fixed set of known keys defined in the `ExchangePropertyKey` enum class.
These keys are used in camel-core such as the routing engine, EIPs and others that needs to store internal
state on the `Exchange` which is done as exchange properties. Because Camel end users can also store
exchange properties then before they would get mixed together. What we have done now is to separate them.

=== Choice and Filter EIP

The `choice` and `filter` EIPs no longer store exchange property `Exchange.FILTER_MATCHED`.
The reason is the information is seldom in use, and by removing we were able to optimize camel-core.

=== OnCompletion EIP

Camel now validates that a route has only 1 onCompletion. Previously users could have code such as:

[source,java]
----
from("direct:start")
        .onCompletion().onCompleteOnly().to("mock:ok").end()
        .onCompletion().onFailureOnly().to("mock:error").end()
        .to("mock:result");
----

Which would lead to the last onCompletion override the first, meaning that only `onCompletion().onFailureOnly()`
would be active. Now this is checked on startup and Camel reports an error.

=== Modularized camel-spring

The `camel-spring` component has been modularized into:

- `camel-spring` - Core module for Camel Spring support
- `camel-spring-xml` - XML DSL when using Spring XML (eg `<beans>`)

Also for Camel on Spring Boot:

- `camel-spring-boot-starter` - Camel with Spring Boot
- `camel-spring-boot-xml-starter` - XML DSL when using Spring XML (eg `<beans>`) with Spring Boot

The motivation is to move out the XML DSL from `camel-spring` which reduces the number of dependencies and makes
the module lighter.

Users that use the Spring XML DSL (eg the top XML tag is Spring `<beans>`) should migrate from using `camel-spring`
to `camel-spring-xml` as dependency.

Users that do not use Spring XML should not be affected.

In Spring XML `<proxy>` and <remote>` have been removed. They were only available in Spring XML
and not in the other XML DSLs (Blueprint and CDI).

=== camel-spring-boot-starter vs camel-spring-boot-engine-starter

Based on the modularization of camel-spring we have made two starters available when using Camel on Spring Boot

- camel-spring-boot-starter - The regular starter that includes all the core components (similar to camel-core)
- camel-spring-boot-engine-starter - A minimal starter with just Camel core engine (similar to camel-core-engine)

We also made all the component -starter JARs not depend on any of the above starters, which means you must pick
the one to use above, and then add which -starter JARs you want to use in your Camel spring boot applications.

=== Camel-AWS components removed

- Camel-AWS-SDB has been removed. There will be no substitution for this, because there isn't a SDK v2 client for this and furthermore the service is not listed in the AWS console anymore.
- Camel-AWS-Translate has been removed. Please switch to Camel-AWS2-Translate.
- Camel-AWS-SQS has been removed. Please switch to Camel-AWS2-SQS.
- Camel-AWS-SNS has been removed. Please switch to Camel-AWS2-SNS.
- Camel-AWS-MSK has been removed. Please switch to Camel-AWS2-MSK.
- Camel-AWS-MQ has been removed. Please switch to Camel-AWS2-MQ.
- Camel-AWS-KMS has been removed. Please switch to Camel-AWS2-KMS.
- Camel-AWS-Kinesis has been removed. Please switch to Camel-AWS2-Kinesis.
- Camel-AWS-Kinesis Firehose has been removed. Please switch to Camel-AWS2-Kinesis-firehose.
- Camel-AWS-IAM has been removed. Please switch to Camel-AWS2-IAM.
- Camel-AWS-EKS has been removed. Please switch to Camel-AWS2-EKS.
- Camel-AWS-ECS has been removed. Please switch to Camel-AWS2-ECS.
- Camel-AWS-EC2 has been removed. Please switch to Camel-AWS2-EC2.
- Camel-AWS-DDB has been removed. Please switch to Camel-AWS2-DDB.
- Camel-AWS-DDB Streams has been removed. Please switch to Camel-AWS2-DDB Streams.
- Camel-AWS-CW has been removed. Please switch to Camel-AWS2-CW.
- Camel-AWS-S3 has been removed. Please switch to Camel-AWS2-S3.
- Camel-AWS-SWF has been removed. There won't be a replacement for it.

=== camel-aws2-sqs

The option `deleteIfFiltered` has been changed to use a different exchange property with key `Sqs2Constants.SQS_DELETE_FILTERED`
which must be set. Beforehand a property by Filter EIP was being used, however this property has been removed due
to optimizing core Camel.

=== Camel-Azure component

- Camel-Azure has been removed. Please switch to Camel-Azure-Storage-Blob and Camel-Azure-Storage-Queue.

=== camel-freemarker component

The freemarker component now has turned off localized lookup for templates.
This can be turned back on by setting `localizedLookup=true` on the component.

=== Camel-AWS2 components

- Camel-AWS2-sqs has now the autoCreateQueue option set to false as default, so you'll need to create entities before or set the option explicitly to true
- Camel-AWS2-sns has now the autoCreateTopic option set to false as default, so you'll need to create entities before or set the option explicitly to true
- Camel-AWS2-s3 has now the autoCreateBucket option set to false as default, so you'll need to create entities before or set the option explicitly to true

=== Camel-jmh, camel-performance and camel-itest-performance

Camel-jmh, camel-performance and camel-itest-performance have been moved to a new repository https://github.com/apache/camel-performance-tests

=== Camel-Debezium

The camel-debezium-parent module has been renamed to camel-debezium-common-parent, while the old the name is now used as parent name for the middle folder. This is an internal change that shouldn't affect end users, added here for tracking purpose anyway.

=== camel-jclouds

The camel-jclouds feature for Camel on Karaf has been removed.

=== camel-kafka

The camel-kafka consumer has been improved to be more roboust and have more confirations how to deal with exceptions while polling from Kafka Brokers.
In case of any exception thrown, then previously the consumer will re-connect and therefore try again. This leads to Kafka broker would reasign the partions,
but it may assign back the same consumer again, or another standby consumer.

The new behavior is to only retry certain kind of exceptions which Kafka has marked as retryable. Any other exceptions is now
causing Camel error handler to handle the caused exception (will log by default but you can use onException etc), and then
skip to next offset so the next message can be polled and processed by Camel.

See the updated camel-kafka documentation for more details.

= Apache Camel 3.x Upgrade Guide

IMPORTANT: If you are migrating from Camel 2.x then use the
xref:camel-3-migration-guide.adoc[Camel 2.x to 3.0 Migration Guide] first.

This document is for helping you upgrade your Apache Camel application
from Camel 3.x to 3.y. For example if you are upgrading Camel 3.0 to 3.2, then you should follow the guides
from both 3.0 to 3.1 and 3.1 to 3.2.

You can find upgrade guide for each release in the following pages:

- xref:camel-3x-upgrade-guide-3_1.adoc[Upgrade guide 3.0 -> 3.1]
- xref:camel-3x-upgrade-guide-3_2.adoc[Upgrade guide 3.1 -> 3.2]
- xref:camel-3x-upgrade-guide-3_3.adoc[Upgrade guide 3.2 -> 3.3]
- xref:camel-3x-upgrade-guide-3_4.adoc[Upgrade guide 3.3 -> 3.4]
- xref:camel-3x-upgrade-guide-3_5.adoc[Upgrade guide 3.4 -> 3.5]
- xref:camel-3x-upgrade-guide-3_6.adoc[Upgrade guide 3.5 -> 3.6]
- xref:camel-3x-upgrade-guide-3_7.adoc[Upgrade guide 3.6 -> 3.7]
- xref:camel-3x-upgrade-guide-3_8.adoc[Upgrade guide 3.7 -> 3.8]
- xref:camel-3x-upgrade-guide-3_9.adoc[Upgrade guide 3.8 -> 3.9]
- xref:camel-3x-upgrade-guide-3_10.adoc[Upgrade guide 3.9 -> 3.10]
- xref:camel-3x-upgrade-guide-3_11.adoc[Upgrade guide 3.10 -> 3.11]
- xref:camel-3x-upgrade-guide-3_12.adoc[Upgrade guide 3.11 -> 3.12]
- xref:camel-3x-upgrade-guide-3_13.adoc[Upgrade guide 3.12 -> 3.13]
- xref:camel-3x-upgrade-guide-3_14.adoc[Upgrade guide 3.13 -> 3.14]
- xref:camel-3x-upgrade-guide-3_15.adoc[Upgrade guide 3.14 -> 3.15]
- xref:camel-3x-upgrade-guide-3_16.adoc[Upgrade guide 3.15 -> 3.16]
- xref:camel-3x-upgrade-guide-3_17.adoc[Upgrade guide 3.16 -> 3.17]
- xref:camel-3x-upgrade-guide-3_18.adoc[Upgrade guide 3.17 -> 3.18]
- xref:camel-3x-upgrade-guide-3_19.adoc[Upgrade guide 3.18 -> 3.19]
- xref:camel-3x-upgrade-guide-3_20.adoc[Upgrade guide 3.19 -> 3.20]
- xref:camel-3x-upgrade-guide-3_21.adoc[Upgrade guide 3.20 -> 3.21]
- xref:camel-3x-upgrade-guide-3_22.adoc[Upgrade guide 3.21 -> 3.22]
= Apache Camel 3.x to 4.0 Migration Guide

This document is intended to help you migrate your Apache Camel applications
from version 3.20 or higher to 4.0. If you are upgrading from an older Camel 3.x release,
such as 3.14, then make sure to read the individual xref:camel-3x-upgrade-guide.adoc[Camel 3.x Upgrade Guide]
to upgrade to the 3.20 release, prior to upgrade to Camel 4.

IMPORTANT: If you are upgrading Camel 4.x to 4.y then use the
xref:camel-4x-upgrade-guide.adoc[Camel 4.x Upgrade Guide].

== Java versions

Camel 4 supports Java 17. Support for Java 11 is dropped.

== Removed Components

The following components have been removed:

[options="header"]
|===
| Component | Alternative component(s)
| camel-any23                          | none
| camel-atlasmap                       | none
| camel-atmos                          | none
| camel-caffeine-lrucache              | camel-cache, camel-ignite, camel-infinispan
| camel-cdi                            | camel-spring-boot, camel-quarkus
| camel-corda                          | none
| camel-directvm                       | camel-direct
| camel-dozer                          | camel-mapstruct
| camel-elasticsearch-rest             | camel-elasticsearch
| camel-gora                           | none
| camel-hbase                          | none
| camel-hyperledger-aries              | none
| camel-iota                           | none
| camel-ipfs                           | none
| camel-jbpm                           | none
| camel-jclouds                        | none
| camel-johnzon                        | camel-jackson, camel-fastjson, camel-gson
| camel-microprofile-metrics           | camel-micrometer, camel-opentelemetry
| camel-milo                           | none
| camel-opentracing                    | camel-micrometer, camel-opentelemetry
| camel-rabbitmq                       | spring-rabbitmq-component
| camel-rest-swagger                   | camel-openapi-rest
| camel-restdsl-swagger-plugin         | camel-restdsl-openapi-plugin
| camel-resteasy                       | camel-cxf, camel-rest
| camel-spark                          | none
| camel-spring-integration             | none
| camel-swagger-java                   | camel-openapi-java
| camel-websocket                      | camel-vertx-websocket
| camel-websocket-jsr356               | camel-vertx-websocket
| camel-vertx-kafka                    | camel-kafka
| camel-vm                             | camel-seda
| camel-weka                           | none
| camel-xstream                        | camel-jacksonxml
| camel-zipkin                         | camel-micrometer, camel-opentelemetry
|===

== Logging

Camel 4 has upgraded logging facade API `slf4j-api` from 1.7 to 2.0.

== JUnit 4

All the `camel-test` modules that were JUnit 4.x based has been removed. All test modules now use JUnit 5.

== API Changes

[options="header"]
|===
| Type of Change | API | Alternative
| Removed   | `InOptionalOut` from `org.apache.camel.ExchangePattern` | `InOut`
| Removed   | `@FallbackConverter` | `@Converter(fallback = true)`
| Removed   | `getEndpointMap()` |
| Removed   | `uri` attribute on `@EndpointInject`, `@Produce`, and `@Consume` | Use `value` (default) instead. For example `@Produce(uri = "kafka:cheese")` should be changed to `@Produce("kafka:cheese")`
| Removed   | `label` on `@UriEndpoint` | use `category` instead.
| Removed   | `consumerClass` on `@UriEndpoint` |
| Removed   | all `asyncCallback` methods on `ProducerTemplate` | `asyncSend` or `asyncRequest`.
| Removed   | `org.apache.camel.spi.OnCamelContextStart` | `org.apache.camel.spi.OnCamelContextStarting`
| Removed   | `org.apache.camel.spi.OnCamelContextStop` | `org.apache.camel.spi.OnCamelContextStopping`
| Removed   | `Discard` and `DiscardOldest` from `org.apache.camel.util.concurrent.ThreadPoolRejectedPolicy` |
| Removed   | `org.apache.camel.builder.SimpleBuilder` | This API was mostly used internally in Camel with the Java DSL in some situations.
| Removed   | `archetypeCatalogAsXml` method from `org.apache.camel.catalog.CamelCatalog` |
| Removed   | `configure` from the interface `org.apache.camel.main.Listener` |
| Removed   | `getExtension` from the interface `CamelContext` | Use `getCamelContextExtension` instead. For example `ManagedCamelContext managed = context.getCamelContextExtension().getContextPlugin(ManagedCamelContext.class);`
| Moved   | Moved `org.apache.camel.support.IntrospectionSupport` to `camel-core-engine` for internal use only | End users should use `org.apache.camel.spi.BeanIntrospection` instead.
| Moved   | Exchange failure handling status has moved from being a property defined as `ExchangePropertyKey.FAILURE_HANDLED` to a member of the ExtendedExchange, accessible via `isFailureHandled()`method.
 |
| Replaced   | Replaced `adapt()` from `org.apache.camel.CamelContext` with `getCamelContextExtension` |
| Replaced   | Replaced `adapt()` from `org.apache.camel.ExtendedExchange` with `getExchangeExtension` |
| Added   | Added `position` method to `org.apache.camel.StreamCache` |
| Decoupled   |Decoupled the `org.apache.camel.ExtendedCamelContext` from the `org.apache.camel.CamelContext` |
| Decoupled   | Decoupled the `org.apache.camel.ExtendedExchange` from the `org.apache.camel.Exchange`. |
| Changed   | The type for `dumpRoutes` on `CamelContext` has changed from `boolean` to `String` to allow specifying either xml or yaml. |
| Changed   | The `org.apache.camel.health.HealthCheck` method `isLiveness` is now default `false` instead of `true`. |
| Added   | Added `position` method to `org.apache.camel.StreamCache` |
| Added   | The `org.apache.camel.support.EventNotifierSupport` abstract class now implements `CamelContextAware`. |
|===

TIP: The `org.apache.camel.support.PluginHelper` gives easy access to various extensions and context plugins, that
was available previously in Camel v3 directly from `CamelContext`.

NOTE: You can get access to the advanced APIs in `CamelContext` known as `ExtendedCamelContext` via `context.getCamelContextExtension()`.

To get hold of `ManagedCamelContext` then you should use the following way:

[source,java]
----
ManagedCamelContext managed = camelContext.getCamelContextExtension().getContextPlugin(ManagedCamelContext.class);
----

This can be done by many other advanced Camel features such as `RoutesLoader` or `ModelToXMLDumper`:

[source,java]
----
RoutesLoader loader = camelContext.getCamelContextExtension().getContextPlugin(RoutesLoader.class);
----

== EIP Changes

Removed `lang` attribute for the `<description>` on every EIPs.

The `InOnly` and `InOut` EIPs has been removed.
Instead, use `SetExchangePattern` or `To` where you can specify exchange pattern to use.

=== Poll Enrich EIP

The polled endpoint URI is now stored as property on the `Exchange` (with key `CamelToEndpoint`) like all other EIPs.
Before the URI was stored as a message header.

== CircuitBreaker EIP

The following options in `camel-resilience4j` was mistakenly not defined as attributes:

|===
| *Option*
| bulkheadEnabled
| bulkheadMaxConcurrentCalls
| bulkheadMaxWaitDuration
| timeoutEnabled
| timeoutExecutorService
| timeoutDuration
| timeoutCancelRunningFuture
|===

These options were not exposed in YAML DSL, and in XML DSL you need to migrate from:

[source,xml]
----
<circuitBreaker>
    <resilience4jConfiguration>
        <timeoutEnabled>true</timeoutEnabled>
        <timeoutDuration>2000</timeoutDuration>
    </resilience4jConfiguration>
...
</circuitBreaker>
----

To use attributes instead:

[source,xml]
----
<circuitBreaker>
    <resilience4jConfiguration timeoutEnabled="true" timeoutDuration="2000"/>
...
</circuitBreaker>
----


== XML DSL

The `<description>` to set a description on a route or node, has been changed from an element to an attribute.

Before:

[source,xml]
----
<route id="myRoute">
  <description>Something that this route do</description>
  <from uri="kafka:cheese"/>
  ...
</route>
----

After:

[source,xml]
----
<route id="myRoute" description="Something that this route do">
  <from uri="kafka:cheese"/>
  ...
</route>
----

== Type Converter

The `String` -> `java.io.File` converter has been removed.

== Tracing

The xref:tracer.adoc[Tracer] and xref:backlog-tracer.adoc[Backlog Tracer] no longer includes internal tracing events
from routes that was created by Rest DSL or route templates or Kamelets. You can turn this on, by setting
`traceTemplates=true` in the tracer.

The xref:backlog-tracer.adoc[Backlog Tracer] has been enhanced and _fixed_ to trace message headers (also streaming types).
This means that previously headers of type `InputStream` was not traced before, but is now included. This could mean that
the header stream is positioned at the end, and logging the header afterward may appear as the header value is empty.

== UseOriginalMessage / UseOriginalBody

When `useOriginalMessage` or `useOriginalBody` is enabled in `OnException`, `OnCompletion` or error handlers,
then the original message body is defensively copied and if possible converted to `StreamCache` to ensure
the body can be re-read when accessed. Previously the original body was not converted to `StreamCache` which
could lead to the body not able to be read or the stream has been closed.

== Camel Health

Health checks are now by default only readiness checks out of the box.

Camel provides the `CamelContextCheck` as both readiness and liveness checks, so there is at least
one of each out of the box.

Only consumer-based health checks are enabled by default.

=== Producer Health Checks

The option `camel.health.components-enabled` has been renamed to `camel.health.producers-enabled`.

Some components, in particular AWS, also provide health checks for producers. In Camel 3.x
these health checks did not work properly and has been disabled in the source.
To continue this behaviour in Camel 4, then producer-based health checks are disabled.

Notice that `camel-kafka` comes with producer based health-check that worked in Camel 3,
and therefore this change in Camel 4, means that this health-check is disabled.

You *MUST* enable producer health-checks globally, such as in `application.properties`:

[source,properties]
----
camel.health.producers-enabled = true
----

== JMX

Camel now also include MBeans for `doCatch` and `doFinally` in the tree of processor MBeans.

The `ManagedChoiceMBean` have renamed `choiceStatistics` to `extendedInformation`.
The `ManagedFailoverLoadBalancerMBean` have renamed `exceptionStatistics` to `extendedInformation`.

The `CamelContextMBean` and `CamelRouteMBean` has removed method `dumpRouteAsXml(boolean resolvePlaceholders, boolean resolveDelegateEndpoints)`.

== YAML DSL

The backwards compatible mode Camel 3.14 or older, which allowed to have _steps_ as child to _route_ has been removed.

The old syntax:

[source,yaml]
----
- route:
    from:
      uri: "direct:info"
    steps:
    - log: "message"
----

should be changed to:

[source,yaml]
----
- route:
    from:
      uri: "direct:info"
      steps:
      - log: "message"
----

== Backlog Tracing

The option `backlogTracing=true` now automatic enabled the tracer on startup. The previous behavior
was _surprisingly_ that the tracer was only made available, and had to be manually enabled afterward.
The old behavior can be archived by setting `backlogTracingStandby=true`.

Move the following class from `org.apache.camel.api.management.mbean.BacklogTracerEventMessage` in `camel-management-api` JAR
to `org.apache.camel.spi.BacklogTracerEventMessage` in `camel-api` JAR.

The `org.apache.camel.impl.debugger.DefaultBacklogTracerEventMessage` has been refactored into an interface `org.apache.camel.spi.BacklogTracerEventMessage`
with some additional details about traced messages. For example Camel now captures a _first_ and _last_ trace
that contains the input and outgoing (if `InOut`) messages.

== XML serialization

The default XML serialization using `ModelToXMLDumper` has been improved and now uses a generated XML
serializer located in the `camel-xml-io` module instead of the JAXB based one from `camel-jaxb`.

== OpenAPI Maven Plugin

The `camel-restdsl-openapi-plugin` Maven plugin now uses `platform-http` as the default rest component
in the generated Rest DSL code. Previously, the default was servlet. However, platform-http is a better
default that works out of the box with Spring Boot and Quarkus.

== Component changes

=== Category

The number of enums for `org.apache.camel.Category` has been reduced from 83 to 37, which means custom components
that are using removed values need to choose one of the remainder values. We have done this to consolidate
the number of categories of components in the Camel community.

=== camel-openapi-rest-dsl-generator

This dsl-generator has updated the underlying model classes (`apicurio-data-models`) from 1.1.27 to 2.0.3.

=== camel-atom

The `camel-atom` component has changed the third party atom client from Apache Abdera to RSSReader.
This means the feed object is changed from `org.apache.abdera.model.Feed` to `com.apptasticsoftware.rssreader.Item`.

=== camel-azure-cosmosdb

The `itemPartitionKey` has been updated. It's now a String a not a PartitionKey anymore. More details in CAMEL-19222.

=== camel-bean

When using the `method` option to refer to a specific method, and using parameter types and values, such as:
`"bean:myBean?method=foo(com.foo.MyOrder, true)"` then any class types must now be using `.class` syntax,
i.e. `com.foo.MyOrder` should now be `com.foo.MyOrder.class`.

The example from above should now be as follows:

    "bean:myBean?method=foo(com.foo.MyOrder.class, true)"

This also applies to Java types such as String, int, etc.:

    "bean:myBean?method=bar(String.class, int.class)"

=== camel-box

Upgraded from Box Java SDK v2 to v4, which have some method signature changes.
The method to get a file thumbnail is no longer available.

=== camel-caffeine

The `keyType` parameter has been removed. The Key for the cache will now be only `String` type. More information in CAMEL-18877.

=== camel-fhir

The underlying `hapi-fhir` library has been upgraded from 4.2.0 to 6.2.4. Only the `Delete` API method has changed and now returns `ca.uhn.fhir.rest.api.MethodOutcome` instead of `org.hl7.fhir.instance.model.api.IBaseOperationOutcome`. See https://hapifhir.io/hapi-fhir/blog/ for a more detailed list of underlying changes (only the hapi-fhir client is used in Camel).

=== camel-google

The API-based components `camel-google-drive`, `camel-google-calendar`, `camel-google-sheets` and `camel-google-mail`
has been upgraded from Google Java SDK v1 to v2 and to latest API revisions. The `camel-google-drive` and `camel-google-sheets`
have some API methods changes, but the others are identical as before.

=== camel-http

The component has been upgraded to use Apache HttpComponents v5 which has an impact on how the underlying client is configured. There are 4 different
timeouts (`connectionRequestTimeout`, `connectTimeout`, `soTimeout` and `responseTimeout`) instead of initially 3
(`connectionRequestTimeout`, `connectTimeout` and `socketTimeout`) and the default value of some of them has changed so please refer to the documentation
for more details.

Please note that the `socketTimeout` has been removed from the possible configuration parameters of `HttpClient`, use `responseTimeout` instead.

Finally, the option `soTimeout` along with any parameters included into `SocketConfig`, need to be prefixed by `httpConnection.`,
the rest of the parameters including those defined into `HttpClientBuilder` and `RequestConfig` still need to be prefixed by `httpClient.` like before.

=== camel-http-common

The API in `org.apache.camel.http.common.HttpBinding` has changed slightly to be more reusable.
The `parseBody` method now takes in `HttpServletRequest` as input parameter. And all `HttpMessage`
has been changed to generic `Message` types.

=== camel-kubernetes

The `io.fabric8:kubernetes-client` library has been upgraded and some deprecated API usage has been removed. Operations previously prefixed with `replace` are now prefixed with `update`.

For example `replaceConfigMap` is now `updateConfigMap`, `replacePod` is now `updatePod` etc. The corresponding 
constants in class `KubernetesOperations` are also renamed. `REPLACE_CONFIGMAP_OPERATION` is now `UPDATE_CONFIGMAP_OPERATION`, `REPLACE_POD_OPERATION` is now `UPDATE_POD_OPERATION` etc.

=== camel-web3j

The `camel-web3j` has upgraded the `web3j` JAR from 3.x to 5.0 which has many API changes, and so
some previous API calls are no long provided.

=== camel-main

The following constants has been moved from `BaseMainSupport` / `Main` to `MainConstants`:

|===
| Old Name | New Name
| Main.DEFAULT_PROPERTY_PLACEHOLDER_LOCATION | MainConstants.DEFAULT_PROPERTY_PLACEHOLDER_LOCATION
| Main.INITIAL_PROPERTIES_LOCATION | MainConstants.INITIAL_PROPERTIES_LOCATION
| Main.OVERRIDE_PROPERTIES_LOCATION | MainConstants.OVERRIDE_PROPERTIES_LOCATION
| Main.PROPERTY_PLACEHOLDER_LOCATION | MainConstants.PROPERTY_PLACEHOLDER_LOCATION
|===


=== camel-micrometer

The metrics has been renamed to follow Micrometer naming convention https://micrometer.io/docs/concepts#_naming_meters[Naming Meters].

|===
| Old Name | New Name
| CamelExchangeEventNotifier | camel.exchange.event.notifier
| CamelExchangesFailed | camel.exchanges.failed
| CamelExchangesFailuresHandled | camel.exchanges.failures.handled
| CamelExchangesInflight | camel.exchanges.external.redeliveries
| CamelExchangesSucceeded | camel.exchanges.succeeded
| CamelExchangesTotal | camel.exchanges.total
| CamelMessageHistory | camel.message.history
| CamelRoutePolicy | camel.route.policy
| CamelRoutePolicyLongTask | camel.route.policy.long.task
| CamelRoutesAdded | camel.routes.added
| CamelRoutesRunning | camel.routes.running
|===

=== camel-jbang

The command `camel dependencies` has been renamed to `camel dependency`.

In Camel JBang the `-dir` parameter for `init` and `run` goal has been renamed to require 2 dashes `--dir` like all the other options.

The `camel stop` command will now by default stop all running integrations (the option `--all` has been removed).

The _Placeholders substitutes_ is changed to use `#name` instead of `$name` syntax.

=== camel-jpa

The option `transactionManager` has been removed, and a new option named `transactionStrategy`
has been added, that acts as vendor neutral abstraction to make it easier to configure Spring Transaction
or Quarkus Transaction.

=== camel-openapi-java

The `camel-openapi-java` component has been changed to use `io.swagger.v3` libraries instead of `io.apicurio.datamodels`.
As a result, the return type of the public method org.apache.camel.openapi.RestOpenApiReader.read() is now `io.swagger.v3.oas.models.OpenAPI` instead of `io.apicurio.datamodels.openapi.models.OasDocument`.
When an OpenAPI 2.0 (swagger) specification is parsed, it is automatically upgraded to OpenAPI 3.0.x by the swagger parser.
This version also supports OpenAPI 3.1.x specifications.
The related spring-boot starter components have been modified to use the new return type.

=== camel-optaplanner

The `camel-optaplanner` component has been change to use `SolverManager`. If you were using `SoverManager` in Camel 3, you don't need anymore the boolean useSolverManager in the Route.
Deprecated `ProblemFactChange` has been replaced by `ProblemChange`.

The new URI path is:

[source,java]
----
from("optaplanner:myProblemName")
  .to("...")
----

You can pass the OptaPlanner SolverManager in 2 ways:

- as #parameter
- as header

When running `camel-optaplanner` on Spring Boot or Quarkus, it is preferable to use the Spring Boot or Quarkus way of creating the SolverManager.

It is possible to migrate legacy Camel OptaPlanner Routes, by putting the XML config file, as show in the code below. Camel OptaPlanner will handle creating the SolverManager for those legacy Routes:

[source,java]
----
from("optaplanner:myProblemName?configFile=PATH/TO/CONFIG.FILE.xml")
  .to("...")
----

Solver Daemon solutions should be migrated to use SolverManager.

=== camel-platform-http-vertx

If the route or consumer is suspended, then http status 503 is now returned instead of 404.

=== camel-salesforce

Property names of blob fields on generated DTOs no longer have 'Url' affixed. E.g., the `ContentVersionUrl` property is now just `ContentVersion`.

=== camel-slack

The default delay (on Slack consumer) is changed from 0.5s to 10s to avoid being rate limited to often by Slack.

=== camel-spring-rabbitmq

The option `replyTimeout` in `camel-spring-rabbitmq` has been fixed and the default value from 5 to 30 seconds
(this is the default used by Spring).


== Camel Spring Boot

The `camel-spring-boot` dependency no longer includes `camel-spring-xml`. To use legacy Spring XML files `<beans>`
with Camel on Spring Boot, then include the `camel-spring-boot-xml-starter` dependency.

=== Graceful Shutdown

Apache Camel shutdowns a bit later during Spring Boot shutdown. This allows Spring Boot graceful shutdown
to complete first (stopping Spring Boot HTTP server gracefully),
and then afterward Camel is doing its own xref:graceful-shutdown.adoc[].

Technically `camel-spring` has changed `getPhase()` from returning `Integer.MAX_VALUE` to
`Integer.MAX_VALUE - 2049`. This gives room for Spring Boot services to shut down first.

=== camel-micrometer-starter

The `uri` tags are now static instead of dynamic (by default), as potential too many tags generated due to URI with dynamic values.
This can be enabled again by setting `camel.metrics.uriTagDynamic=true`.

=== camel-platform-http-starter

The `platform-http-starter` has been changed from using `camel-servlet` to use Spring HTTP server directly.
Therefore, all the HTTP endpoints are no longer prefixed with the servlet context-path (default is `camel`).

For example:

[source,java]
----
from("platform-http:myservice")
  .to("...")
----

Then calling _myservice_ would before require to include the context-path, such as `http://localhost:8080/camel/myservice`.
Now the context-path is not in use, and the endpoint can be called with `http://localhost:8080/myservice`.

NOTE: The `platform-http-starter` can also be used with Rest DSL.

If the route or consumer is suspended, then http status 503 is now returned instead of 404.

=== camel-twitter

The component was updated to use Twitter4j version 4.1.2, which https://twitter4j.org/2022/10/21/264[has moved the packages] used by a few of its classes. If accessing certain twitter-related data, such as the Tweet status, you need to update the packages used from `twitter4j.Status` to `twitter4j.v1.Status`.


== Upgrading Camel 4.0.1 to 4.0.2

=== camel-file

The `readLock=changed` with using `readLockMinAge` has been restored to same behaviour as 3.x.

For example, using `readLockMinAge=5s` would pick up files that are older than 5 seconds from startup time.
If you have many existing files on startup that are old, then Camel will now again be fast,
and pick up these files immediately.


== Upgrading Camel 4.0.0 to 4.0.1

=== camel-aws2-sns

The `queueUrl` parameter has been replaced by the `queueArn` parameter

For Example before

----
from("direct:start")
  .to("aws2-sns://mytopic?subject=mySubject&autoCreateTopic=true&subscribeSNStoSQS=true&queueUrl=https://xxxx")
----

Should be changed to

----
from("direct:start")
  .to("aws2-sns://mytopic?subject=mySubject&autoCreateTopic=true&subscribeSNStoSQS=true&queueArn=arn:aws:sqs:xxxxx")
----
= Apache Camel 4.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

== Upgrading Camel 4.0 to 4.1

=== camel-api

Added method `newInstance(Class<T> type, Class<?> factoryClass, String factoryMethod)`
to `org.apache.camel.spi.Injector`.

Added `isIgnoreLoadingError` and `setIgnoreLoadingError` methods to `org.apache.camel.spi.RoutesLoader`,
and `org.apache.camel.main.RoutesCollector`.

Added `getDuration` method to `org.apache.camel.StartupStep`.

=== XML and YAML DSL

==== Creating beans from script

In route templates (or kamelets), for advanced use cases, you are able to create beans from an inlined script.

The name of the script was defined in `type`, but has been changed to a new `scriptLanguage` attribute.
And `beanType` has been removed as you must use `type` instead.

Before:

[tabs]
====
XML::
+
[source,xml]
----
    <bean name="myBean" type="groovy" beanType="com.foo.MyBean">
        <script>
          <!-- groovy code here to create the bean -->
        </script>
    </bean>
----
YAML::
+
[source,yaml]
----
- beans:
  - name: "myClient"
    beanType: "com.foo.MyBean"
    type: "groovy"
    script: |
      # groovy script here
----
====

After:

[tabs]
====
XML::
+
[source,xml]
----
    <bean name="myBean" type="com.foo.MyBean"
          scriptLanguage="groovy">
        <script>
          <!-- groovy code here to create the bean -->
        </script>
    </bean>
----
YAML::
+
[source,yaml]
----
- beans:
  - name: "myClient"
    type: "com.foo.MyBean"
    scriptLanguage: "groovy"
    script: |
      # groovy script here
----
====

=== camel-management

Dumping routes to JMX no longer includes `customId="true"` in the XML nodes.

=== camel-scheduler

The `scheduler` no longer includes header with the timestamp of when the exchange was fired.
This means the exchange by default has no headers, and `null` body.

The option `includeMetadata` can be set to `true` on the endpoint or component level, to turn on
these additional metadata headers again.

=== camel-timer

The `timer` no longer includes header `firedTime` with the timestamp of when the exchange was fired.
This means the exchange by default has no headers, and `null` body.

The `firedTime` header has been renamed to `CamelTimerFireTime`.

The option `includeMetadata` can be set to `true` on the endpoint or component level, to turn on
these additional metadata headers again.

=== camel-aws2-step-functions

The following Message Headers of `camel-aws2-step-functions` component have been renamed to follow standard camel naming convention.

[cols="1,1"]
|===
|Old Name|New Name

|CamelAwsStateMachineOperation
|CamelAwsStepFunctionsOperation

|CamelAwsStateMachinesMaxResults
|CamelAwsStepFunctionsStateMachinesMaxResults

|CamelAwsStepFunctionsStateMachineActivityName
|CamelAwsStepFunctionsActivityName

|CamelAwsStepFunctionsStateMachineActivityArn
|CamelAwsStepFunctionsActivityArn

|CamelAwsStateMachineActivitiesMaxResults
|CamelAwsStepFunctionsActivitiesMaxResults

|CamelAwsStateMachineExecutionArn
|CamelAwsStepFunctionsExecutionArn

|CamelAwsStateMachineExecutionName
|CamelAwsStepFunctionsExecutionName

|CamelAwsStateMachineExecutionInput
|CamelAwsStepFunctionsExecutionInput

|CamelAwsStateMachineExecutionTraceHeader
|CamelAwsStepFunctionsExecutionTraceHeader

|CamelAwsStateMachineExecutionHistoryMaxResults
|CamelAwsStepFunctionsExecutionHistoryMaxResults

|CamelAwsStateMachineExecutionHistoryIncludeExecutionData
|CamelAwsStepFunctionsExecutionHistoryIncludeExecutionData

|CamelAwsStateMachineExecutionHistoryReverseOrder
|CamelAwsStepFunctionsExecutionHistoryReverseOrder

|CamelAwsStateMachineExecutionMaxResults
|CamelAwsStepFunctionsExecutionMaxResults
|===

This is applicable only if literal constant headers are used such as `CamelAwsStateMachinesMaxResults`. If the headers are used from StepFunctions2Constants Interface like StepFunctions2Constants.STATE_MACHINES_MAX_RESULTS , then there is no change;

For Example before

----
from("direct:listActivities")
  .setHeader("CamelAwsStepFunctionsActivitiesMaxResults",5)
   .to("aws2-step-functions://test?awsSfnClient=#awsSfnClient&operation=listActivities")
----

Should be changed to

----
from("direct:listActivities")
  .setHeader("CamelAwsStepFunctionsActivitiesMaxResults",5)
    .to("aws2-step-functions://test?awsSfnClient=#awsSfnClient&operation=listActivities")
----

=== camel-aws2-sns

The `queueUrl` parameter has been replaced by the `queueArn` parameter

For Example before

----
from("direct:start")
  .to("aws2-sns://mytopic?subject=mySubject&autoCreateTopic=true&subscribeSNStoSQS=true&queueUrl=https://xxxx")
----

Should be changed to

----
from("direct:start")
  .to("aws2-sns://mytopic?subject=mySubject&autoCreateTopic=true&subscribeSNStoSQS=true&queueArn=arn:aws:sqs:xxxxx")
----

=== camel-pdf

The Camel-PDF component has been updated to Apache PDFBox 3.0.0, and the font parameter is now defined through the following enum values: COURIER,COURIER_BOLD,COURIER_OBLIQUE,COURIER_BOLD_OBLIQUE, HELVETICA,HELVETICA_BOLD,HELVETICA_OBLIQUE,HELVETICA_BOLD_OBLIQUE,TIMES_ROMAN,TIMES_BOLD,TIMES_ITALIC,TIMES_BOLD_ITALIC,SYMBOL and ZAPF_DINGBATS

=== camel-jbang

The `pipe` command has been renamed to `script`.

The `--secrets-refresh` and `--secret-refresh-providers` have been removed, since they were logically incorrect in the export command context. More information at CAMEL-19927 issue.

The generated XML route, created using the command `camel init`, now uses `<camel>` as the root tag instead of `<routes>`.

=== camel-jetty / camel-servlet / camel-atmosphere-websocket / camel-http-common

By default, stack traces will not be included in HTTP responses,
exceptions are muted.
Stack traces can be included in HTTP responses by disabling `muteException`.
For example:

----
from("jetty:http://localhost:{{port}}/myapp/myservice?muteException=false")
----

When exceptions are muted stack traces may be logged by enabling `logException`.
For example

----
from("jetty:http://localhost:{{port}}/myapp/myservice?logException=true")
----

=== YAML DSL

The kebab-case style schema file,  `camel-yaml-dsl.json` has been removed from the distribution in favor of the camelCase style schema file, `camelYamlDsl.json`. While the Camel runtime stays supporting kebab-case style also for the moment, it is recommended to migrate to camelCase style. Any tooling should encourage users to use camelCase style.

=== camel-tracing

The `Tag` Enum containing constants for tagging spans has been deprecated.
Instead,
use constants from the `TagConstants` Class that align to Open Telemetry v1.21.0 semantic conventions.

For example, instead of

----
span.setTag(Tag.URL_SCHEME, scheme);
----

use

----
span.setTag(TagConstants.URL_SCHEME, scheme);
----

=== camel-kafka

The default value for `sessionTimeoutMs` has been updated to  `45000` ms, while the default value for `consumerRequestTimeoutMs` has been updated to `30000`. More information in CAMEL-19921 issue.

=== camel-core, rest

A new rest configuration option, `enableNoContentResponse`,
allows HTTP 204 to be returned with an empty body if a Message contains an empty JSON object or empty XML root object when set to `true`.
= Apache Camel 4.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

== Upgrading from 4.10.1 to 4.10.2

=== EIPs

==== Recipient List, Split and Multicast EIP

In parallel processing mode, you can also enable `synchronous=true` to force these EIPs to process
the sub-tasks using the upper bounds of the thread-pool. If using `synchronous=false` then Camel
will allow its reactive routing engine to use as many threads as possible, which may be available
due to sub-tasks using other thread-pools such as `CompletableFuture.runAsync` or others.

Setting `synchronous=true` is the same behaviour is in Camel 2 which did not have the reactive routing engine.

==== WireTap and OnCompletion EIP

When MDC is enabled, then the WireTap and OnCompletion (in parallel mode) will now propagate MDC
context when creating threads to process the exchanges. This makes these EIPs similar to how
other EIPs such as Multicast EIP already does this.

=== camel-bean

The header `Exchange.BEAN_METHOD_NAME` with constant value `CamelBeanMethodName` has been deprecated, and support for using this header has been removed.
Instead, you can specify the `method` option directly as shown, or using any other header of your choosing as follows.

[source,java]
----
    toD("bean:myBean?method=${header.myMethodName}");
----

=== camel-sql

When inserting or updating many rows in `batch=true` mode (producer) then this component
has been optimized to execute the entire batch operation in a single transaction; by turning off auto-commit
on the SQL Connection, and doing a manual `commit` or `rollback`. This can dramatically improve performance
on some databases. The old behaviour can be restored by setting the `batchAutoCommitDisabled=false` on the component or endpoint.

== Upgrading from 4.10.0 to 4.10.1

=== camel-api

Added `removeTraits` method to `org.apache.camel.Message`.

Added `bind` method that accepts `Supplier` for the bean and also accepts init and destroy methods,
to the `org.apache.camel.spi.Registry` interface.

=== camel-attachments

The attachments have been refactored to be stored internally as a _message trait_,
and the `org.apache.camel.attachment.AttachmentMessage` is only a facade to provide
end user access to the fine-grained Attachment APIs. The underlying message implementation
such as `DefaultMessage` in the `Exchange` is un-affected when converting from `Message` to `AttachmentMessage` via:

[source,java]
----
AttachmentMessage am = exchange.getMessage(AttachmentMessage.class);
am.addAttachment("message1.xml", new DataHandler(new FileDataSource(new File("src/test/data/message1.xml"))));
----

The class `org.apache.camel.attachment.AttachmentMap` has been removed.
Removed `getDelegateMessage` method from `org.apache.camel.attachment.AttachmentMessage`.

=== camel-ftp

The file name header `Exchange.FILE_NAME` now includes the relative path such as `subdir/hello.txt`
when using `recursive=true`, to be similar to how `camel-file` component behaves.

=== camel-kafka

The camel-kafka option `recordMetadata` has changed default from `true` to `false`.

=== camel-jbang

The option `lazy-bean` has changed to be default `true` when exporting to make the export
work in more situations out of the box.

== Upgrading Camel 4.9 to 4.10

=== XML DSL changes

In `<intercept`> and `<interceptSendToEndpoint>` then `<when>` has been
renamed to `<onWhen>`.

For example:

[source,xml]
----
<intercept>
  <when>...</when>
  ...
</intercept>
----

Should now be:

[source,xml]
----
<intercept>
  <onWhen>...</onWhen>
  ...
</intercept>
----

In `<circuitBreaker` the `<onFallback>` section must be configured last.

For example:

[source,xml]
----
  <circuitBreaker>
    <resilience4jConfiguration timeoutEnabled="true" timeoutDuration="2000"/>
    <onFallback>
      <transform>
        <constant>Fallback message</constant>
      </transform>
    </onFallback>
    <to uri="direct:foo"/>
    ...
  </circuitBreaker>
----

Should now be:

[source,xml]
----
  <circuitBreaker>
    <resilience4jConfiguration timeoutEnabled="true" timeoutDuration="2000"/>
    <to uri="direct:foo"/>
    ...
    <onFallback>
      <transform>
        <constant>Fallback message</constant>
      </transform>
    </onFallback>
  </circuitBreaker>
----

And `inheritErrorHandler` has been moved from `<loadBalance>` to `<failoverLoadBalancer` which
is the only load balancer support this option.

For example:

[source,xml]
----
  <loadBalance inheritErrorHandler="true">
    <failoverLoadBalancer maximumFailoverAttempts="3" roundRobin="true"/>
    ...
  </loadBalance>
----

Should now be:

[source,xml]
----
  <loadBalance>
    <failoverLoadBalancer maximumFailoverAttempts="3" roundRobin="true" inheritErrorHandler="true"/>
    ...
  </loadBalance>
----

=== camel-kamelet

The error handling when using kamelets has been refactored to let Kamelets re-use the same error handling
that are from the route where the kamelets are being used. Previously Kamelets did not have
any error handling.

Suppose you have kamelets that would cause an exception during processing, such
as the source below. Now because the route has been configured with a _dead letter channel_
as the error handler, then the exception from the kamelet will be handled by the route error handler.
Which means you will se a WARN being logged.

Previously the exception would **not** be handled by the route error handler, and the kamelet source
would always fail internally and cause a WARN being logged. Meaning that you did not have
any power to handle these errors.

Now the kamelets are _first class_ and gives users the full power to handle errors as they see fit.

[source,yaml]
----
- route:
    errorHandler:
      deadLetterChannel:
        deadLetterUri: log:dead?level=WARN
    id: myRoute
    from:
      uri: "kamelet:my-error-source/source"
      steps:
        - log: "${body}"
----

This change has most an effect on source Kamelets. For sink or action Kamelets,
then any error would be propagated back to the route, that could still handle the error.
However, if the error handler is configured to perform retries, then the retry would be
starting all over again calling the sink Kamelet. This change will let the error handler
perform retries at the original of the error (also inside the Kamelet), the same as
regular Camel routes.

So suppose you have the following route:

[source,yaml]
----
- route:
    errorHandler:
      deadLetterChannel:
        deadLetterUri: log:dead?level=WARN
        redeliveryPolicy:
          maximumRedeliveries: 5
          redeliveryDelay: "5000"
    id: myRoute
    from:
      uri: "direct:start"
      steps:
        - to:
            uri: "kamelet:my-error-sink/sink"
        - log: "${body}"
----

Then notice the error handler has been configured to do redeliveries up till 5 times with 5 sec delay between.
Suppose the sink kamelet is throwing an exception, then Camel will now perform the redelivery attempt
at the point of origin, which means inside the Kamelet. Previously the redelivery will
only happen at the route level, calling the kamelet all over again.

The option `noErrorHandler` has changed default from `true` to `false`. You should only
use this option if you want to turn on error handling inside Kamelets all together. However,
this should only be used in advanced/rare use-cases. This option may in the future be deprecated and removed.

=== camel-azure-files

The class `org.apache.camel.component.file.azure.FilesHeaders` has been renamed to `org.apache.camel.component.file.azure.FilesConstants`.

=== camel-aws2-s3

The header `CamelAwsS3BucketName` for setting a bucket to write to, on the producer side, cannot be used anymore: the header `CamelAwsS3OverrideBucketName` must be used 
instead. This was done to avoid situation in which you're moving a file from a bucket to a different one, and the header coming from the S3 consumer is used as bucket name for S3 Producer.
You can find more information on CAMEL-21680. 

=== camel-file

The `camel-file` consumer has been optimized when filtering file names using name matching only,
to avoid creating an `GenericFile` object that represent the file. This is unnessasary if the file
is to be excluded due the filtering.

This optimization has changed APIs in the `camel-file` component to let methods that accept
`GenericFile` as parameter, has been changed to use a `Supplier<GenericFile>` to lazy create the wrapper.

Camel users who have created 3rd party component extending `camel-file` may need to migrate your components.

=== camel-google-storage

The header `CamelGoogleCloudStorageBucketName` for setting a bucket to write to, on the producer side, cannot be used anymore: the header `CamelGoogleCloudStorageOverrideBucketName` must be used 
instead. This was done to avoid situation in which you're moving a file from a bucket to a different one, and the header coming from the Google Storage consumer is used as bucket name for Google Storage Producer.
You can find more information on CAMEL-21682. 

=== camel-jgroups

The cluster lock has been removed as it has been removed in JGroups 5.4 onwards, and it was
not recommended to be used in older JGroups releases. You can use another Camel component such as
`camel-infinispan` that has cluster locking.

The `camel-jgroups-cluster-service-starter` in Camel Spring Boot has been removed.

=== camel-jbang

The camel-jbang commands for `camel-k` has been removed.

The `camel dependency update` has removed the option `--source` to specify the source file,
but to refer to the source file directly such as:

`camel dependency update --source=MyRoute.java` to be `camel dependency update MyRoute.java`.

=== camel-micrometer

We have fixed a flawed behavior when using dynamic endpoints which made the generation of endpoint events to grow in an uncontrolled way. From now on the component will generate events for the endpoint base URI as a default behavior. If you still want to collect events for the extended URI (including the parameters), then, you can use the `camel.metrics.baseEndpointURIExchangeEventNotifier=false` configuration. Mind that this is strongly discouraged as it can make your number of events growing out of control.

=== camel-mina

If using object codec, then you should configure the `objectCodecPattern` configuration to specify
which java classes (FQN) to allow for Object serialization. You can use `*` to accept all patterns.

=== camel-minio

The header `CamelMinioBucketName` for setting a bucket to write to, on the producer side, cannot be used anymore: the header `CamelMinioOverrideBucketName` must be used 
instead. This was done to avoid situation in which you're moving a file from a bucket to a different one, and the header coming from the Minio consumer is used as bucket name for Minio Producer.
You can find more information on CAMEL-21678. 

=== camel-google-pubsub-lite

The component `camel-google-pubsub-lite` has been deprecated following the deprecation of the corresponding service by Google Cloud Platform.

Google recommends migrating your Pub/Sub Lite service to either Google Cloud Managed Service for Apache Kafka or Google Cloud Pub/Sub. Depending on your choice, you should use `camel-kafka` or `camel-google-pubsub component`, respectively.

=== camel-tracing

We have deprecated the setting of MDC `trace_id` and `span_id` in favour of implementation specific feature. You need to check the specific tracing/telemetry component configuration to learn how to switch from the deprecated configuration to the new one. Most of the time you will need to remove the `camel.main.use-mdc-logging` Camel property (or set it to `false`) and add dependencies and configuration settings to enable the specific component instrumentation.

=== camel-langchain4j-chat

The function calling feature was removed. Please use the `camel-langchain4j-tools` component for function calling.

=== camel-smb

The `camel-smb` component has been updated to extend `GenericFile` classes and now supports more consumer and producer options.
The Consumer includes options for filtering, pre and post processing, duplicate handling, directory traversal, polling, and readlocks.
The Producer includes options for writing to temporary files, writing content, and handling existing files.

=== camel-solr

The `camel-solr` component has been refactored. The `solrs` and `solrCloud` schemes have been deprecated in the uri format (but can still be enabled via the enableSSL and solrClient configuration options).
The solr operations have been simplified and some solr operations will be no longer be available in the next release. For those operations, a warning message will tell you how to get the same results with the new operations.
The Solr component exchange headers have been renamed and extended. As a consequence, the user should review the use of the Solr exchange headers and rename them when applicable.

All the solr headers has been renamed to use `CamelSolr` as prefix, such as `operation` -> `CamelSolrOperation`.

== camel-spring-boot

The `camel-k-starter` has been removed.

= Apache Camel 4.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

== Upgrading Camel 4.10 to 4.11

=== EIPs

==== Recipient List, Split and Multicast EIP

In parallel processing mode, you can also enable `synchronous=true` to force these EIPs to process
the sub-tasks using the upper bounds of the thread-pool. If using `synchronous=false` then Camel
will allow its reactive routing engine to use as many threads as possible, which may be available
due to sub-tasks using other thread-pools such as `CompletableFuture.runAsync` or others.

Setting `synchronous=true` is the same behaviour is in Camel 2 which did not have the reactive routing engine.

==== WireTap and OnCompletion EIP

When MDC is enabled, then the WireTap and OnCompletion (in parallel mode) will now propagate MDC
context when creating threads to process the exchanges. This makes these EIPs similar to how
other EIPs such as Multicast EIP already does this.

=== camel-api

Added `removeTraits` method to `org.apache.camel.Message`.

Added `bind` method that accepts `Supplier` for the bean and also accepts init and destroy methods,
to the `org.apache.camel.spi.Registry` interface.

=== camel-attachments

The attachments have been refactored to be stored internally as a _message trait_,
and the `org.apache.camel.attachment.AttachmentMessage` is only a facade to provide
end user access to the fine-grained Attachment APIs. The underlying message implementation
such as `DefaultMessage` in the `Exchange` is un-affected when converting from `Message` to `AttachmentMessage` via:

[source,java]
----
AttachmentMessage am = exchange.getMessage(AttachmentMessage.class);
am.addAttachment("message1.xml", new DataHandler(new FileDataSource(new File("src/test/data/message1.xml"))));
----

The class `org.apache.camel.attachment.AttachmentMap` has been removed.
Removed `getDelegateMessage` method from `org.apache.camel.attachment.AttachmentMessage`.

=== camel-bean

The header `Exchange.BEAN_METHOD_NAME` with constant value `CamelBeanMethodName` has been deprecated, and support for using this header has been removed.
Instead, you can specify the `method` option directly as shown, or using any other header of your choosing as follows.

[source,java]
----
    toD("bean:myBean?method=${header.myMethodName}");
----

=== camel-main

Remove the deprecated `camel.main.lightweight` option that was not in use.

=== file based components

The file based component such as `camel-file`, `camel-ftp`, `camel-smb`, and `camel-azure-files` has
been improved to allow optimized dynamic poll when using dynamic `fileName` header.

This change means that there is a new `DynamicPollingConsumer` API the consumer implements.
And as such some APIs inside these components has been changed.

This will only affect if you have built your own custom Camel component on top of `camel-file`.
And if so, your custom code may need to be changed slightly as well.

=== camel-ftp

The file name header `Exchange.FILE_NAME` now includes the relative path such as `subdir/hello.txt`
when using `recursive=true`, to be similar to how `camel-file` component behaves.

=== camel-as2

The `camel-as2` component has been made more tooling friendly to configure options.

The option `signedReceiptMicAlgorithms` is changed from a `String[]` to a single `String` using comma to separate algorithm names.

The option `ediMessageType` is changed from `ContentType` into two options as `String` fields.
This allows to define the content-type and charset separately and more user-friendly.

=== camel-kafka

The camel-kafka option `recordMetadata` has changed default from `true` to `false`.

=== camel-jbang

The option `lazy-bean` has changed to be default `true` when exporting to make the export
work in more situations out of the box.

From this version onward the `export` command add the `camel-observability-services` dependency (which includes telemetry, metrics, health and JMX management services out of the box).

The `--health` and `--metrics` flags of `run` command have been deprecated in favor of the newly `--observe` flag which add the `camel-observability-services` dependency (hence including telemetry, metrics, health and JMX management out of the box). For the run command, this has to be explicitly enabled (ie, `camel run  ... --observe`).

=== camel-sql

When inserting or updating many rows in `batch=true` mode (producer) then this component
has been optimized to execute the entire batch operation in a single transaction; by turning off auto-commit
on the SQL Connection, and doing a manual `commit` or `rollback`. This can dramatically improve performance
on some databases. The old behaviour can be restored by setting the `batchAutoCommitDisabled=false` on the component or endpoint.

=== camel-etcd3

This deprecated component was removed in this release.

=== camel-platform-http

The `org.apache.camel.component.platform.http.PlatformHttpHeaderFilterStrategy` class has been removed. Use the `org.apache.camel.http.base.HttpHeaderFilterStrategy`

=== camel-undertow

The `org.apache.camel.component.undertow.UndertowHeaderFilterStrategy` class has been deprecated. The default header filter strategy is now the `org.apache.camel.http.base.HttpHeaderFilterStrategy`

=== camel-metrics

A new gauge metric, `app.info` is available by default. This is providing a few information related to the runtime provider such as:

```
# HELP app_info
# TYPE app_info gauge
app_info{camel_context="camel-1",camel_runtime_provider="Spring-Boot",camel_runtime_version="3.4.3",camel_version="4.10.2"} 1
```

This information is evaluated at runtime startup and available through the usual metrics endpoint. To disable this metric you need to use the `camel.metrics.skipCamelInfo=true` property.

=== camel-observability-services

In this version we're moving the telemetry component from `camel-opentelemetry` to `camel-opentelemetry2`.
= Apache Camel 4.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

== Upgrading Camel 4.11 to 4.12

=== camel-as2

Add options allowing the addition of an `Authorization` header for Basic or Bearer authentication to client and
asynchronous MDN requests.
= Apache Camel 4.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

== Upgrading Camel 4.1 to 4.2

=== camel-api

Added `boolean` parameter to `matchProcess` method on `org.apache.camel.spi.Condition`.

=== camel-base-engine

The class `org.apache.camel.impl.DebuggerBacklogDebugger` has been refactored to an interface `org.apache.camel.spi.BacklogDebugger` and a default implementation `org.apache.camel.impl.debugger.DefaultBacklogDebugger`.

=== camel-main

The option `camel.main.debugger` has been renamed to `camel.debug.enabled`.

=== camel-management-api

The `org.apache.camel.api.management.mbean.ManagedBacklogDebuggerMBean.dumpTracedMessagesAsXml(String, boolean)` has been deprecated.
The second parameter is ignored with default implementation.

To continue to have access to exchange properties, call `setIncludeExchangeProperties(true)` before messages
are sent to have access to exchange properties.

=== camel-file

The `readLock=changed` with using `readLockMinAge` has been restored to same behaviour as 3.x.

For example, using `readLockMinAge=5s` would pick up files that are older than 5 seconds from startup time.
If you have many existing files on startup that are old, then Camel will now again be fast,
and pick up these files immediately.

=== camel-kafka

The consumer will now pre-validate `hostname:port` and DNS resolution on startup, and fail-fast
in case of mis-configuration or invalid hostname.

This can be disabled by setting `preValidateHostAndPort=false`, which will postpone validation
to consumer is started, and will instead re-connect endlessly (5 sec delay by default) until success.

=== camel-observation / camel-opentelemetry

The `excludePatterns` option has changed from `Set<String>` to be `String` where multiple patterns are separated by comma.
This is more configuration and tooling friendly and used by other components.

=== camel-saga, camel-lra

The `org.apache.camel.service.lra.LRAClient` can now access `Exchange` to retrieve further context information. Therefore, there are following changes in interface methods
- `org.apache.camel.saga.CamelSagaService.compensate()` changed to `org.apache.camel.saga.CamelSagaService.compensate(Exchange exchange)`
- `org.apache.camel.saga.CamelSagaService.complete()` changed to `org.apache.camel.saga.CamelSagaService.complete(Exchange exchange)`
- `org.apache.camel.saga.CamelSagaCoordinator.newSaga` is now `org.apache.camel.saga.CamelSagaCoordinator.newSaga(Exchange exchange)`
to support the transport of `Exchange`.

As a result of interface changes, also the known implementation classes and usages have been adopted.

=== camel-ignite

The Apache Ignite project (v2.15) is not yet Java 21 compatible and therefore `camel-ignite` is not
expected to function correctly if using Java 21.

A new release of Apache Ignite is expected that will start to support Java 21.

=== camel-dynamic-router EIP component (non-core)

The Dynamic Router EIP component has been refactored to use the Multicast Processor for sending messages to recipients,
and this brought some additional configuration options:

- `parallelProcessing`, `parallelAggregate`, `stopOnException`, `ignoreInvalidEndpoints`, `streaming`, `timeout`,
`onPrepare`, `shareUnitOfWork`, `executorService`, and `aggregationStrategy`.  These configuration items are for
configuring the Multicast Processor within the Dynamic Router EIP component, so their description, meaning, and effect
are identical to that of the Multicast Processor.

When upgrading to this version, you should still be able to use this component with the configuration from previous
versions.  The new options allow more specific configuration if you need it.

=== camel-spring & camel-spring-boot

==== Autowiring Primary beans

Camel will now take into account `@Primary` beans from Spring when autowiring by type.
For example, a JDBC `DataSource` in the SQL component will now use the `@Primary` data source
when multiple data sources are defined.

Previously, Camel would not autowire if there are two or more beans for a given type.

NOTE: This is a change in behaviour, that can affect your applications when upgrading.

==== Properties

The `initialProperties` and `overrideProperties` on Camel `PropertiesComponent` will now
take precedence over Spring Boot properties. This can be used for testing purpose,
to allow overriding properties when using `CamelTestSupport` for unit testing.

=== camel-opentelemetry-starter

The `excludePatterns` option has changed from `Set<String>` to be `String` where multiple patterns are separated by comma.
This is more configuration and tooling friendly and used by other components.
= Apache Camel 4.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

== Upgrading Camel 4.2 to 4.3

=== camel-core

Moved class `org.apache.camel.impl.engine.MemoryStateRepository` from camel-base-engine to `org.apache.camel.support.processor.state.MemoryStateRepository` in camel-support.

Moved class `org.apache.camel.impl.engine.FileStateRepository` from camel-base-engine to `org.apache.camel.support.processor.state.FileStateRepository` in camel-support.

=== Resequence EIP

The configuration for batch and stream has been renamed from `batch-config` to `batchConfig` and `stream-config` to `streamConfig`.

For example before:

[source,xml]
----
<resequence>
    <stream-config timeout="1000" deliveryAttemptInterval="10"/>
    <simple>${header.seqnum}</simple>
    <to uri="mock:result" />
</resequence>
----

And now after:

[source,xml]
----
<resequence>
    <streamConfig timeout="1000" deliveryAttemptInterval="10"/>
    <simple>${header.seqnum}</simple>
    <to uri="mock:result" />
</resequence>
----

=== Throttle EIP

Throttle now uses the number of concurrent requests as the throttling measure instead of the number of requests
per period.

Update throttle expressions configured with `maxRequestsPerPeriod` to use `maxConcurrentRequests` instead,
and remove any `timePeriodMillis` option.

For example, update the following:

[source,java]
----
long maxRequestsPerPeriod = 100L;

from("seda:a")
  .throttle(maxRequestsPerPeriod).timePeriodMillis(500)
  .to("seda:b")

// 1000 ms default time period
from("seda:c")
  .throttle(maxRequestsPerPeriod)
  .to("seda:d")
----

to use `maxConcurrentRequests`:

[source,java]
----
long maxConcurrentRequests = 30L;

from("seda:a")
  .throttle(maxConcurrentRequests)
  .to("seda:b")

from("seda:c")
  .throttle(maxConcurrentRequests)
  .to("seda:d")
----

=== Consumer health checks

The scheduled consumers have been improved to mark the consumer as _ready_ sooner, when possible. Previously a consumer
would mark as ready after the first poll was completed. For example, an FTP consumer downloading a big file on the first poll
could take so long time that the readiness check would timeout and fail during the startup of your Camel application.

The following components are now marking the consumer as ready sooner:

- camel-aws
- camel-azure
- camel-box
- camel-dhis2
- camel-fhir
- camel-couchbase
- camel-ftp
- camel-google
- camel-ironmq
- camel-jooq
- camel-jpa
- camel-mail
- camel-minio
- camel-mybatis
- camel-olingo2
- camel-olingo4
- camel-slack
- camel-splunk
- camel-sql
- camel-twilio
- camel-zendesk

=== camel-management

If the `nodeIdPrefix` has been configured on routes, then the MBeans for the processors will now use the prefix
in their `ObjectName` also.

=== camel-console

The context and route consoles have changed some values in their JSON output data for timestamp for created, completed and failed exchanges.

|===
|**Old Key** |**New Key**
| `sinceLastCreatedExchange` | `lastCreatedExchangeTimestamp`
| `sinceLastCompletedExchange` | `lastCompletedExchangeTimestamp`
| `sinceLastFailedExchange` | `lastFailedExchangeTimestamp`
|===

The values are also changed from String ago to timestamp in millis.For example, old value `3m5s` is now `1701599263337`.

=== camel-jbang

The `camel transform` command has been renamed to `camel transform route` as this command is used for transforming
routes between DSLs such as XML to YAML.

There is a new `camel transform message` command to do message transformation.

=== camel-jetty

Jetty has been upgraded from v11 to v12. End users may need to adjust to changes in Jetty.

=== camel-kafka

The behavior for `breakOnFirstError` was altered as numerous issues were fixed. The behavior related to committing
the offset is now determined by the `CommitManager` that is configured.

When the default `CommitManager` is used (`NoopCommitManager`) then no commit is performed. The route implementation will
be responsible for managing the offset using `KafkaManualCommit` to manage the retrying of the payload.

When using the `SyncCommitManager` then the offset will be committed so that the payload is continually retried. This was
the behavior described in the documentation.

When using the `AsyncCommitManager` then the offset will be committed so that the payload is continually retried. This was
the behavior described in the documentation.

=== camel-yaml-dsl

Using kebab-case in general has been deprecated, and you will see a WARN logs. Please migrate to camelCase.

The language for exchange property now only supports camelCase style, i.e. `exchange-property` is now `exchangeProperty`.

The `camelYamlDsl.json` Schema file has removed `inheritErrorHandler` option for all EIPs where it was not applicable.
This option is only intended for the Load Balancer EIP. This makes the YAML schema in-line with the XML DSL schema.

=== camel-hdfs

The HDFS component has been deprecated, and planned to be removed in 4.4 (see CAMEL-20196).

=== camel-kafka

The header name for the `List<RecordMetadata>` metadata has changed from
`org.apache.kafka.clients.producer.RecordMetadata` to `kafka.RECORD_META`,
and the header constant from `KAFKA_RECORDMETA` to `KAFKA_RECORD_META`.= Apache Camel 4.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

== Upgrading from 4.4.4 to 4.4.5

=== camel-mina

If using object codec, then you should configure the `objectCodecPattern` configuration to specify
which java classes (FQN) to allow for Object serialization. You can use `*` to accept all patterns.

== Upgrading from 4.4.3 to 4.4.4

The `camel-opentelemetry` component has had significant bug fixes to handle span activation/deactivations
better when Camel route messages synchronously and asynchronously. This component should also work better
on Spring Boot.

== Upgrading Camel 4.3 to 4.4

=== camel-core

The `org.apache.camel.spi.DataFormat` has changed exception thrown from `IOException` to `Exception`
in the unmarshal(Exchange exchange, InputStream stream)` method.

Removed the deprecated constructor from the internal class `org.apache.camel.util.StopWatch`. Users of this class are advised to use the default constructor if necessary.

The method `getCreated` from the `org.apache.camel.Exchange` is now deprecated. Access to the time-related information from the exchange should be done via `getClock`.

We standardized and consolidated code computing durations so that they use a monotonic clock.

Durations and some time-related information were consolidated in a new internal Clock API.

The `lookup` method in `org.apache.camel.component.properties.PropertiesLookup` now has a 2nd parameter for the default value.

Some of the Java DSL for `tokenize`, `xmlTokenize`, `xpath`, `xquery` and `jsonpath` has been removed as part of making the DSL model consistent.

Here are a few examples of migration before vs after:

[source,java]
----
 from("direct:in")
    .choice()
        .when().xpath("/invoice/@orderType = 'premium'", "invoiceDetails")
            .to("mock:premium")
        .when() .xpath("/invoice/@orderType = 'standard'", "invoiceDetails")
            .to("mock:standard")
        .otherwise()
            .to("mock:unknown")
    .end();
----

You can use the _fluent expression_ builder to configure all the options:

[source,java]
----
// use fluent builder expression to create the languages
var premium = expression().xpath().expression("/invoice/@orderType = 'premium'").source("header:invoiceDetails").end();
var standard = expression().xpath().expression("/invoice/@orderType = 'standard'").source("header:invoiceDetails").end();

from("direct:in")
    .choice()
        .when(premium)
            .to("mock:premium")
        .when(standard)
            .to("mock:standard")
        .otherwise()
            .to("mock:unknown")
    .end();
----

In the example above notice how we use `source` to specify the input to use, in this case a header named invoiceDetails.
The `source` can also be variable, or exchange property.

And another example with `tokenize`:

[source,java]
----
from("direct:start")
    .split().tokenize("\r\n|\n", true, 2, "\n", true)
        .log("${body}")
        .to("mock:line");
----

You can use the _fluent expression_ builder to configure all the options:

[source,java]
----
// use fluent builder expression to create the languages
var token = expression().tokenize().token("\r\n|\n").regex(true).group(2).groupDelimiter("\n").skipFirst(true).end();

from("direct:start")
    .split(token)
        .log("${body}")
        .to("mock:line");
----

==== Languages

The way languages are created and configured by Camel has been refactored to be aligned and avoid a thread-safety issues
when using Java DSL. The setter/getter on the `Language` classes for options that are not general has been removed (such as in `TokenizeLanguage`).

In XML and YAML DSL the `type` option in `<xquery>` has been renamed to `resultType` to be aligned with the other languages.

In XML and YAML DSL The `headerName` on `<xpath>`, `<xquery>` has been renamed to `source` and you should prefix the value with `header:name` to declare
it is a header, because other kind of sources can be specified also. The same change has applied to `@XPath` and `@XQuery`
language annotations.

==== WireTap EIP

The copied exchange is no longer having exchange property CORRELATION_ID set that links to the original exchange.
The reason is that this link should only be for EIPs with sub exchanges such as Splitter and Multicast.

==== Throttle EIP

Previously, Camel used a throttler based on the total number of requests over a period of time ("TotalRequests" mode). That was
the default on Camel up to version 4.2.0. On Camel 4.3.0 we introduced a new one based on the number of concurrent requests and
replaced the former.

With Camel 4.4.0 we refactored the xref:components:eips:throttle-eip.adoc[Throttle EIP] implementation so that Camel can support two different modes of throttling.

Check the component documentation for details about how to use each mode.

==== MDC logging

When using custom MDC keys (need to configure `MDCLoggingKeysPattern`) then these custom keys are cleared at the end of routing.
Also, custom keys is allowed to be changed during routing, using the `MDC.set(myKey, ...)` Java API.

=== camel-main

The route controller configuration has been moved from general main to its own group.
All keys started with `camel.main.routesController` should be renamed to `camel.routecontroller.`, for example
`camel.main.routeControllerBackOffDelay` should be renamed to `camel.routecontroller.backOffDelay`.
And the option `camel.main.routeControllerSuperviseEnabled` has been renamed to `camel.routecontroller.enabled`.

=== camel-kamelet

All Kamelets are now turned off error handling in the route templates. This is done to make using Kamelets
the same as calling a regular Camel component endpoint. Backwards mode can be enabled by setting `noErrorHandler=false`
on the `KameletComponent` or as URI parameter `to("kamelet:http-sink?noErrorHandler=false&uri=xxxxx")`.

=== camel-azure-cosmosdb

The `useDefaultIdentity` parameter has been removed in favor of the credentialType parameter.
Now user should select between `SHARED_ACCOUNT_KEY` and `AZURE_IDENTITY`.
This is part of the effort explained in CAMEL-18590.

=== camel-azure-eventhubs

The credentialType parameter has been introduced with three possible values: `AZURE_IDENTITY`, `CONNECTION_STRING` and `TOKEN_CREDENTIAL`.
With the `CONNECTION_STRING` mode the user could explicitly set the `connectionString` parameters or use the `sharedAccessName` and `sharedAccessKey` to automatically build the connection string.
With the `TOKEN_CREDENTIAL` mode the user could pass a `TokenCredential` instance.
With the `AZURE_IDENTITY` mode the user will be able to use the Default Azure Credentials Chain.
This is part of the effort explained in CAMEL-18590.

=== camel-azure-servicebus

The credentialType parameter has been introduced with three possible values: `AZURE_IDENTITY`, `CONNECTION_STRING` and `TOKEN_CREDENTIAL`.
With the `CONNECTION_STRING` mode the user could explicitly set the `connectionString` parameter.
With the `TOKEN_CREDENTIAL` mode the user could pass a `TokenCredential` instance.
With the `AZURE_IDENTITY` mode the user will be able to use the Default Azure Credentials Chain.
This is part of the effort explained in CAMEL-18590.

=== camel-azure-files

The credentialType parameter has been introduced with three possible values: `AZURE_IDENTITY`, `SHARED_ACCOUNT_KEY` and `AZURE_SAS`.
With the `SHARED_ACCOUNT_KEY` mode the user could explicitly set the `sharedKey` parameter.
With the `AZURE_IDENTITY` mode the user will be able to use the Default Azure Credentials Chain.
With the `AZURE_SAS` mode the user could explicitly set the token parameter.
This is part of the effort explained in CAMEL-18590.

=== camel-azure-storage-datalake

The useDefaultIdentity parameter has been removed in favor of the `credentialType` parameter. Now user should select between `AZURE_IDENTITY`, `CLIENT_SECRET`, `SHARED_KEY_CREDENTIAL`, `AZURE_SAS` and `SERVICE_CLIENT_INSTANCE`.
With the `SHARED_KEY_CREDENTIAL` mode the user could explicitly set the `sharedKey` parameter or a `SharedKeyCredential` instance.
With the `AZURE_IDENTITY` mode the user will be able to use the Default Azure Credentials Chain.
With the `AZURE_SAS` mode the user could explicitly set the `sasSignature` or `sasCredential` parameter.
With the `CLIENT_SECRET` mode the user could explicitly set `clientId`, `clientSecret` and `tenantId` or specify a `ClientSecretCredential` instance.
With the `SERVICE_CLIENT_INSTANCE` the user could explicitly set a `serviceClient` parameter by passing a `DataLakeServiceClient` instance.
This is part of the effort explained in CAMEL-18590.

=== camel-azure-storage-queue

The `useDefaultIdentity` parameter has been removed in favor of the `credentialType` parameter. Now user should select between `AZURE_IDENTITY`, `SHARED_KEY_CREDENTIAL` and `SHARED_ACCOUNT_KEY`.
With the `SHARED_KEY_CREDENTIAL` mode the user could explicitly set the `SharedKeyCredential` instance.
With the `AZURE_IDENTITY` mode the user will be able to use the Default Azure Credentials Chain.
With the `SHARED_ACCOUNT_KEY` mode the user could explicitly set the `accessKey` parameter.
This is part of the effort explained in CAMEL-18590.

=== camel-cassandraql

The `NamedCassandraAggregationRepository` now provides a `deserializationFilter` parameter.
The default value for it is allowing all java packages and subpackages and all `org.apache.camel` packages and subpackages.
If you plan to use particular classes, and you want to expand the filter, you should change the value according to your needs.
More details in CAMEL-20306.

=== camel-coap

Upgraded from `org.eclipse.californium` v2 to v3 which was a painful upgrade. Removed the `"CamelCoapUri` header that would
allow a producer to create the dynamic client to send to another URL. Use Camel's existing `toD` EIP for that instead.

=== camel-consul

This component has migrated from `com.orbitz.consul:consul-client` to `org.kiwiproject:consul-client` as the former is no longer maintained,
and kiwiproject took over.

=== camel-dynamic-router

The dynamic router EIP component now handles control messages through a separate control component: `dynamic-router-control`.
These changes were made after a user reported a bug that resulted in query-parameter-based subscriptions being ignored
after the first URI control message was processed.
All control message parameters can be submitted as query parameters when subscribers are within the same JVM as the
dynamic router instance. Users must use "dynamic to", or `toD` when sending these control message properties as query
parameters.
Predicates that are not string expressions may be specified in the message body, or bound to the registry and specified
as a reference with the `predicateBean` parameter.
Control messages can still be sent in the message body, as in the previous version.
The `DynamicRouterControlMessage` no longer has separate builders for `subscribe` and `unsubscribe` messages, so there
is only one builder that you can use for any type of control message.
The control channel will now report subscription details for a routing channel if a message with a control action of
`list` is submitted, along with the dynamic router channel of interest.
Please see the `dynamic-router-eip` module in the `camel-spring-boot-examples` repository for
useful examples of how you might need to change your code to be compatible with the changes in this version.

=== camel-hdfs

The component has been removed after deprecation in 4.3.0

=== camel-jms

The header with key `JMSCorrelationIDAsBytes` has changed value from `String` to `byte[]`.

=== camel-jsonata

Replaced the previous JSONata library with a new one that offers complete compatibility with the JSONata reference implementation's features.

=== camel-sql

The JdbcAggregationRepository now provides a deserializationFilter parameter. The default value for it is allowing all java packages and subpackages and all org.apache.camel packages and subpackages. If you plan to use particular classes and you want to expand the filter, you should change the value according to your needs. More details in CAMEL-20303.

=== camel-facebook

The component was removed without deprecation. The library supporting this component has been unmaintained for a long time. We found no indications that the library itself nor the component are working with modern Facebook, along with the absence of community interest, which lead us to decide to remove this component without deprecation.

=== camel-kafka

The component now has support for batch processing.

=== camel-json-validator

Removed deprecated `org.apache.camel.component.jsonvalidator.DefaultJsonSchemaLoader`,
use `org.apache.camel.component.jsonvalidator.DefaultJsonUriSchemaLoader` instead.

=== camel-splunk-hec

Removed `token` from the URI's path in favor of setting it through a `token` query parameter. While the `token` was in the URI path, it could potentially be leaked within the logs.

=== camel-openapi-java and camel-rest-openapi

Deprecated support for the old Swagger 2.0 spec. Only OpenAPI v3 specs is supported from Camel 4.5 onwards.

== Camel Spring Boot

=== Ordering of BOM imports

When using Camel on Spring Boot, it's recommended to use BOMs to import Camel and Spring dependencies.
In Camel 4.4 onwards we changed the order to let Camel be first as shown below:

[source,xml]
----
<dependencyManagement>
    <dependencies>
        <!-- Camel BOM -->
        <dependency>
            <groupId>org.apache.camel.springboot</groupId>
            <artifactId>camel-spring-boot-bom</artifactId>
            <version>${camel-version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <!-- Spring Boot BOM -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>${spring-boot-version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
----

In previous versions, then we would have `spring-boot-dependencies` before `camel-spring-boot-bom`. However, to better
align and ensure Camel starters are using supported dependencies, then it's recommended to let Camel be first.

=== Auto Configuration

The route controller configuration has been moved from general main to its own group.
All keys started with `camel.springboot.routesController` should be renamed to `camel.routecontroller.`, for example
`camel.springboot.routeControllerBackOffDelay` should be renamed to `camel.routecontroller.backOffDelay`.
And the option `camel.springboot.routeControllerSuperviseEnabled` has been renamed to `camel.routecontroller.enabled`.

=== Routes Collector

Camel Spring Boot will not honor the `camel.springboot.includeNonSingletons` option (default false). This means
that only singleton `RouteBuilder` beans is added by default. Previously then prototype scoped beans would be added as well.

=== camel-platform-http-vertx

Added configuration to enable Vert.x session handling.
Sessions are disabled by default, but can be enabled by setting the `enabled` property on `VertxPlatformHttpServerConfiguration.SessionConfig`
to `true`.
Other properties include `sessionCookieName`, `sessionCookiePath`, `sessionTimeout`, `cookieSecure`, `cookieHttpOnly`
`cookieSameSite` and `storeType`.
The session `storeType` defaults to the Vert.x `LocalSessionStore` and `cookieSameSite` to `Strict`. The remainder
of the properties are configured with Vert.x defaults if not set.
= Apache Camel 4.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

== Upgrading Camel 4.4 to 4.5

=== camel-core

Camel startup summary will now report total number of routes without (internal routes created by Kamelets or Rest DSL).
This ensures the total number better reflect the total number of user created routes. The summary now includes a separate
number of Kamelets and Rest DSL routes. See also the camel-kamelet section.

The following deprecated methods from the `AbstractCamelContext`, deprecated on 4.2 as part of CAMEL-19998, were finally removed:

* `setTypeConverter`
* `getOrCreateTypeConverter`
* `setManagementMBeanAssembler`
* `getRestRegistryFactory`
* `setRestRegistryFactory`
* `setTransformerRegistry`
* `setValidatorRegistry`
* `setName`
* `setDescription`
* `getBootstrapFactoryFinder`
* `getFactoryFinder`
* `addInterceptStrategy`
* `getStartupStepRecorder`
* `setStartupStepRecorder`
* `resolvePropertyPlaceholders`
* `getBasePackageScan`
* `setBasePackageScan`

Users of these methods should use the respective operations from the `ExtendedCamelContext` (accessed via `getCamelContextExtension()`),
instead.

The following deprecated methods from the `CamelContext`, deprecated on 4.4 as part of CAMEL-20225, were finally removed and/or modified:

* `getUptime`: modified to return a regular `Duration` instance.
* `getUptimeMillis`: removed.
* `getStartDate` removed.

Users of this method should proceed as following:

* `getUptime`: use `ContextHelper.getUptime`.
* `getUptimeMillis`: use `getUptime().toMillis()`.
* `getStartDate`: use `ContextHelper.getStartDate`.

=== Rest DSL

Camel has changed the default value for `inlineRoutes=false` to `inlineRoutes=true` in `restConfiguration`.
It is very typical to define Rest DSL and for each service api, then call a Camel route via `direct` endpoints.
By inlining these two, then you only have 1 route in Camel instead of 2. This helps reduce the clutter of routes
that otherwise is in use when using Rest DSL and many services. You can restore to old behaviour by setting the option back to `inlineRoutes=false`.

However, the inlining requires that each REST endpoint inlined with `direct` endpoints must use unique direct names, ie.

[source,java]
----
rest("/rest")
    .get("/").to("direct:printMethod")
    .post("/").to("direct:printMethod")
    .put("/").to("direct:printMethod");
----

Should be changed to:

[source,java]
----
rest("/rest")
    .get("/").to("direct:printMethod1")
    .post("/").to("direct:printMethod2")
    .put("/").to("direct:printMethod3");
----

Or to keep old behaviour, you can turn off inlining.

Rest DSL will now eagerly resolve property placeholders that are used during building the `rest:` endpoint.

For example with a Rest DSL using a placeholder (`app.mypath = helloapp`) in the `path`:

[source,yaml]
----
- rest:
    path: "{{app.mypath}}"
    post:
      - to: direct:demo
----

Will not be resolved in the `rest` endpoint which can be seen during startup logging:

[source,text]
----
Routes startup (total:2)
Started demo (rest://post:%7B%7Bapp.mypath%7D%7D)
----

The placeholder is now resolved eagerly, and you will see _nicer_ startup logs such as:

[source,text]
----
Routes startup (total:2)
Started demo (rest://post:helloapp)
----

The `restConfiguration` has changed default value in the `useXForwardHeaders` option from `true` to `false`.
Using X-Forward headers is only used in special use-cases such as involving reverse proxies.


=== Avro Data Format

The default library for the `avro` data format has changed from Apache Avro to Jackson Avro. We also use Jackson as default for the JSon dataformat.


=== Intercept EIP

The `interceptFrom` and `interceptSentToEndpoint` EIPs is now storing the intercepted endpoint using key `Exchange.INTERCEPTED_ENDPOINT`
as exchange property instead of a header.

Before:

[source,java]
----
String uri = exchange.getIn().getHeader(Exchange.INTERCEPTED_ENDPOINT, String.class);
----

After:

[source,java]
----
String uri = exchange.getProperty(Exchange.INTERCEPTED_ENDPOINT, String.class);
----

=== camel-bom / camel-spring-boot-bom

The Camel Maven BOMs (`camel-bom` and `camel-spring-boot-bom`) has been changed to use hardcoded
Camel release versions to ensure the BOM is always correct.

=== camel-main

The options `camel.main.backlogTracing`, `camel.main.backlogTracingStandby`, and `camel.main.backlogTracingTemplates` has been
moved into a new group `camel.trace` with more options to configure the backlog tracer.

To enable backlog tracing you should now set `camel.trace.enabled=true` instead of `camel.main.backlogTracing=true`.

=== camel-console

The `@DevConsole` annotation has been enhanced to include more information.

Migrate from

[source,java]
----
@DevConsole("stub")
----

To

[source,java]
----
@DevConsole(name = "stub", description = "Browse messages on stub endpoints")
----

We also renamed the `route-curcuit-breaker` console to `circuit-breaker`.

=== camel-jbang

The `--profile` option on `export` command has been removed.

The `--profile` option on `run` command is now used by `camel-main` to choose profile mode when running Camel with JBang,
or standalone with Camel Main. The default mode is `dev` for development which comes with some additional features enabled
in Camel to gather more information that are relevant for development and the Camel JBang CLI.

You can run with `--profile=prod` to turn off all of this, which makes Camel run more similar to a production situation.

The command `camel generate rest` have removed all the shorthand arguments `such as `-i -o` instead use the long names `--input --output`.

The shorthand `-p` option from `run` and `script` command has been removed. Use `--prop` instead.

=== camel-jsonpath

The `camel-jsonpath` will now work more similar as `camel-jq` when you specify a `resultType` and have a list of entities.
Before `camel-jsonapath` would attempt to convert the `List` to the given `restultType` which often is not usable. What
users want is to be able to convert each entry in the list to a given type such as a POJO.

For example, the snippet below selects all books from a JSON document, which will be in a `List<Map>` object where each
book is an entry as a `Map`. Before Camel would attempt to convert `List` to `Book` which would not be possible.
From this release onwards, Camel will convert each entry to a `Book` so the result is `List<Book>`.

This is also how `camel-jq` works.

[source,java]
----
.transform().jsonpath(".book", Book.class)
----

=== camel-kamelet

Routes created by Kamelets are no longer registered as JMX MBeans to avoid cluttering up with unwanted MBeans, as a Kamelet
is intended to act like a Camel component, despite its implementation is Camel routes. This means that the number of routes
listed from JMX will no longer include Kamelet routes.

The old behaviour can be enabled by setting `registerRoutesCreateByKamelet=true`
on the `ManagementAgent` object. See more in the xref:jmx.adoc[JMX] documentation.

=== camel-micrometer and camel-metrics

The `camel-micrometer` have renamed tag `serviceName` to `kind` and use naming that indicate that its from Camel:

|===
|**Before** | **After**
| serviceName="MicrometerEventNotifierService" | kind="CamelExchangeEvent"
| serviceName="MicrometerMessageHistoryService" | kind="CamelMessageHistory"
| serviceName="MicrometerRoutePolicyService" | kind="CamelRoute"
|===

Because the Kamelets were changed to act more like a Camel component, and not expose internal details as JMX MBeans, then
micrometer and metrics no longer include statistics for those Kamelet routes.

The old behaviour can be enabled by setting `registerRoutesCreateByKamelet=true`
on the `ManagementAgent` object. See more in the xref:jmx.adoc[JMX] documentation.

Added context level metrics to `camel-micrometer`. The metrics with key `camel.route.policy` now include
tag `eventType` that specifies if the metrics is for a route or the entire camel context.
You can turn off context level metrics, by setting `contenxtEnabled=false` on the factory such as:

[source,java]
----
factory.getPolicyConfiguration().setContextEnabled(false);
----

This can also be done easily from `application.properties` such as:

[source,properties]
----
camel.metrics.routePolicyLevel=route
----

=== camel-openapi-java and camel-rest-openapi

Dropped support for the old Swagger 2.0 spec. Only OpenAPI v3 specs is supported now.
Fixed maven dependencies to be JakartaEE compatible.

When using Rest DSL and have `api-doc` enabled via `camel-rest` and `camel-openapi-java`, then
the OpenAPI specification is now generated once during startup instead of on-demand when a client
calls the `/api-doc` endpoint.

=== camel-platform-http-vertx

Added a Cookie Handler allowing the addition, retrieval and expiry of Cookies.

=== camel-shiro

Upgraded Apache Shiro from 1.13 to 2.0.

=== camel-twilio

Upgraded to Twilio 10.1.0 which removed `call-feedback` and `call-feedback-summary` from the available APIs,
to use from Camel.

=== camel-elasticsearch / camel-opensearch

The class `org.apache.camel.component.opensearch.aggregation.BulkRequestAggregationStrategy` has been renamed to `org.apache.camel.component.opensearch.aggregation.OpensearchBulkRequestAggregationStrategy`
The class `org.apache.camel.component.es.aggregation.BulkRequestAggregationStrategy` has been renamed to `org.apache.camel.component.es.aggregation.ElastichsearchBulkRequestAggregationStrategy`

=== camel-spring-redis

The class `org.apache.camel.component.redis.processor.idempotent.RedisIdempotentRepository` has been renamed to `org.apache.camel.component.redis.processor.idempotent.SpringRedisIdempotentRepository`
The class `org.apache.camel.component.redis.processor.idempotent.RedisStringIdempotentRepository` has been renamed to `org.apache.camel.component.redis.processor.idempotent.SpringRedisStringIdempotentRepository`


== Camel Spring Boot

The autoconfiguration with `camel.springboot.xxx` properties has been harmonized to use same naming for
all the Camel runtimes (`camel-main`, `camel-quarkus`, and `camel-spring-boot`). These options have been marked
as deprecated, and you can migrate to use `camel.main.xxx` naming instead.

For example, `camel.springboot.name = Foo` to `camel.main.name = Foo`.

Only the special Spring Boot options are still named `camel.springboot.xxx`.
= Apache Camel 4.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

== Upgrading Camel 4.5 to 4.6

=== variables

When using `variableReceive` then the variable is only set if processing the `Exchange` was completely successfully.

For example, calling a route that fails due to an exception being thrown (even if `onException` or `errorHandler` are in use)
then the variable is no longer set. Also, if the route is marked for rollback, or to stop continuing routing with `.stop()`.

This is the same logic that the routing engine uses, whether to continue routing the `Exchange` or not.

=== camel-core-model

Harmonized model for defining custom beans to be the same for Kamelets and generic beans in XML/YAML DSLs.
Before, there used to be three specialized model classes that have been refactored into a single class, offering the same capabilities
for configuring beans (constructors, properties, builder classes, init/destroy methods etc.)

=== XML DSL

When using XML DSL to define properties on `<bean>` then `<property>` must now be declared inside `<properties>`.

=== YAML DSL

When using YAML DSL to define properties on `bean` then `property` has been removed in favour of using `properties`.

Before:
[source,yaml]
----
    beans:
      - name: "myProcessor"
        type: "#class:com.foo.MyClass"
        property:
          - key: "payload"
            value: "test-payload"
----

After:
[source,yaml]
----
    beans:
      - name: "myProcessor"
        type: "#class:com.foo.MyClass"
        properties:
          payload: "test-payload"
----

Renamed `streamCaching` to `streamCache` on the `route`

Before:

[source,yaml]
----
route:
  streamCaching: false
  from:
    uri: "direct:foo"
    steps:
      - to: "mock:bar"
----

After:

[source,yaml]
----
route:
  streamCache: false
  from:
    uri: "direct:foo"
    steps:
      - to: "mock:bar"
----

=== camel-elasticsearch

The class `org.apache.camel.component.es.aggregation.ElastichsearchBulkRequestAggregationStrategy` has been renamed to `org.apache.camel.component.es.aggregation.ElasticsearchBulkRequestAggregationStrategy`.

=== camel-rest-openapi

The `specifciationUri` in the `rest-api` component has changed from being a `java.net.URI` to a `String` type
, as it uses Camels `ResourceLoader` to load from pluggable resources and also more tooling friendly.

The validator using Atlassian `swagger-request-validator` JAR has been removed, as this library is not JakartaEE compatible,
and was causing classloading problems. The validator is now using a similar validation as Rest DSL. However, the validator
no longer checks for JSON payloads if any required nodes are missing.

=== camel-langchain4j-chat

The Camel Langchain4j Chat component name has been changed from `camel-langchain-chat`to `camel-langchain4j-chat` to adhere to the standardized naming conventions within the LangChain4j ecosystem.

If you are migrating from Camel 4.5, please ensure the following:

- Update your maven dependencies, changing from `camel-langchain-chat`to `camel-langchain4j-chat`
- Adjust your endpoints, replacing `langchain-chat` with `langchain4j-chat`
- Transfer any Camel class references from `org.apache.camel.component.chat.ChatLangchain*` to `org.apache.camel.component.langchain4j.chat.ChatLangchain4j*`
- Modify the header name `The prompt Template`  from  `CamelLangChainChatPromptTemplate` to `CamelLangChain4jChatPromptTemplate`

=== camel-langchain4j-embeddings

The Camel Langchain4j Embeddings component name has been changed from `camel-langchain-embedings` to `camel-langchain4j-embedings` to adhere to the standardized naming conventions within the LangChain4j ecosystem.

If you are migrating from Camel 4.5, please ensure the following

- Update your maven dependencies, changing from  `camel-langchain-embedings`to `camel-langchain4j-embedings`
- Adjust your endpoints, replacing `langchain-embedings` with `langchain4j-embedings`
- Transfer any Camel class references from `org.apache.camel.component.langchain.embeddings.LangChainEmbeddings*` to `org.apache.camel.component.langchain4j.embeddings.LangChain4jEmbeddings*`
- Modify the header name `The Finish Reason` from  `CamelLangChainEmbeddingsFinishReason` to `CamelLangChain4jEmbeddingsFinishReason`
- Modify the header name `The Input Token Count` from  `CamelLangChainEmbeddingsInputTokenCount` to `CamelLangChain4jEmbeddingsInputTokenCount`
- Modify the header name `The Output Token Count` from  `CamelLangChainEmbeddingsOutputTokenCount` to `CamelLangChain4jEmbeddingsOutputTokenCount`
- Modify the header name `The Total Token Count` from  `CamelLangChainEmbeddingsTotalTokenCount` to `CamelLangChain4jEmbeddingsTotalTokenCount`
- Modify the header name `A dense vector embedding of a text` from  `CamelLangChainEmbeddingsVector` to `CamelLangChain4jEmbeddingsVector`

=== camel-platform-http

The `PlatformHttpEngine` class has changed the `createConsumer` method to return a `org.apache.camel.component.platform.http.spi.PlatformHttpConsumer` type,
instead of `org.apache.camel.Consumer`.

=== camel-platform-http-vertx

The id used for multipart file upload attachments on `AttachmentMessage` has changed from being the name of the uploaded file, to the value specifed on the `name` field of the `Content-Disposition` header sent in the request body.

=== camel-google-sheets

The option `scopes` is changed from a `Collection` to be a `String` type to make it easy to configure in endpoint URI from all DSLs and tooling.
Multiple scopes can be separated by comma.

=== camel-kafka

The Kafka component now supports custom subscription adapters for applications with very complex subscription logic.

=== camel-azure-servicebus

The Camel Azure ServiceBus consumer has been refactored to internally use the high-level client instead of the low-level client to more easily support automatic reconnection, competing consumers and high availability, amongst other concerns. The corresponding changes to configuration options are:

- The consumer now supports the Competing Consumers EIP. This can be enabled by increasing the newly added `maxConcurrentCalls` option to a value greater than 1.
- The `disableAutoComplete` option has been removed. Auto-complete is always disabled on the underlying client to ensure that Camel is able to correctly complete, abandon or dead-letter consumed messages as appropriate. The presence of the `disableAutoComplete` option made little sense, since it is not propagated to the underlying client and enabling this option caused Camel not to take any steps to acknowledge/reject consumed messages. Enabling this option would result in message locks being held indefinitely, which is almost certainly not the desired behaviour.
- The high level client always operates in `receiveMessages` mode (peek mode is not supported), so the `consumerOperation` option has been removed, along with the `ServiceBusConsumerOperationDefinition` enum. The associated `peekNumMaxMessages` option has also been removed.
- The `receiverAsyncClient` option has been replaced with a `processorClient` option to enable use of a custom-configured client. The parameter type accepted by this option is `ServiceBusProcessorClient`.
- The `reconnectDelay` option has been removed, since reconnection is now handled internally by the client.

=== camel-jbang

When running using `camel run --source-dir=mydir` then Camel JBang will now preload existing files on startup, such as `application.properties`,
and beans and routes (same as if you run with `cd mydir; camel run *`). This allows configuring settings on Camel on startup, which was not possible beforehand.

The `--open-api` option has changed from _code-first_ to use the new _contract-first_ Rest DSL style by using the specification file direct as-is.

=== camel-as2

The `camel-as2` component has upgraded HTTP Client 4.x to 5.x, and because of that, there are some options that have changed.

Changes for AS2-MDN asynchronous delivery:

 - Added an option allowing clients to request an asynchronous receipt by including a 'Receipt-Delivery-Option' header specifying
the return URL in the request that is sent to the server.
 - Added a consumer capable of receiving signed or unsigned asynchronous message disposition notifications sent by the
message receiver confirming receipt of the message.

=== camel-spring-boot

The autoconfiguration of xref:clustering.adoc[Cluster Service] implementations has been moved to dedicated starters:

[%header, cols="1,2"]
|===
| Type         | Starter
| Consul       | camel-consul-cluster-service-starter
| File         | camel-file-cluster-service-starter
| Infinispan   | camel-infinispan-cluster-service-starter
| JGroups Lock | camel-jgroups-cluster-service-starter
| JGroups Raft | camel-jgroups-raft-cluster-service-starter
| Kubernetes   | camel-kubernetes-cluster-service-starter
| Zookeeper    | camel-zookeeper-cluster-service-starter
|===


The Cluster Services are turned on by default unless they are explicitly disabled, for example:

[source, properties]
----
camel.cluster.consul.enabled = false
----

= Apache Camel 4.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

== Upgrading Camel 4.6 to 4.7

=== API changes

The class `org.apache.camel.impl.engine.ValidatorKey` moved to `org.apache.camel.spi.ValidatorKey`.
The class `org.apache.camel.impl.engine.TransformerKey` moved to `org.apache.camel.spi.TransformerKey`.

The `org.apache.camel.spi.RestRegistry` method `addRestService` has added `boolean contractFirst` parameter to define
if the Rest service is _contract-first_ or _code-first_.

=== camel-core

Add default values to `ThrottlingExceptionRoutePolicy` route policy.

The `EndpointRegistry` interface has been slightly changed to now directly extends `Map<NormalizedEndpointUri, Endpoint>` 
instead of being a parameterized type. This may cause some compilation failures if the code is declaring a variable for the registry.

The statistics collector in the registry has been made immutable. As such, enabling collection of statistics has to be done
prior to creating the type converter registry

=== camel-health

Routes that have been set to **not** auto-startup are reported as UP in health-checks.
We have now implemented similar logic for the consumer health check as well. In this case, the route and consumer health check
are linked together.

Previously a route that has not been started due to `auto-startup=false` would still have its consumer health-check being executed,
which could lead to DOWN due to consumer failing the check.

The `SupervisingRouteController` has now been pre-configured to report `DOWN` during restart attempts, and also when
giving up starting a route. It is the `UnhealthyOnExhausted` and `UnhealthyOnRestarting` options that have been changed to be default `true`.
To have previous behavior, you can set these options to `false`.

== camel-cloud

The camel-cloud component has been deprecated.

=== camel-crypto

PGP dataformat functionality was extracted from `camel-crypto` JAR and placed into `camel-crypto-pgp`.

=== DSL

The WireTap EIP in copy mode, will now do a deep-copy if the message body is of `StreamCache` type to make access to the message body thread-safe.

The Load Balancer EIP has aligned naming and the following balancers has been renamed in XML and YAML DSL:

|===
|*Old Name* |*New Name*

| failOver | failOverLoadBalancer
| random | randomLoadBalancer
| roundRobin | roundRobinLoadBalancer
| sticky | stickyLoadBalancer
| topic | topicLoadBalancer
| weighted | weightedLoadBalancer
|===

For example in XML, you need to change from:

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <loadBalance>
      <failover>
          <exception>java.io.IOException</exception>
      </failover>
      <to uri="direct:x"/>
      <to uri="direct:y"/>
      <to uri="direct:z"/>
  </loadBalance>
</route>
----

To:

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <loadBalance>
      <failoverLoadBalancer>
          <exception>java.io.IOException</exception>
      </failoverLoadBalancer>
      <to uri="direct:x"/>
      <to uri="direct:y"/>
      <to uri="direct:z"/>
  </loadBalance>
</route>
----

=== camel-file

When using `idempotent=true` then the file consumer will now run in eager mode, and `add` the file to the repository
before processing, and call `confirm` when done. Setting `idempotentEager=false` will use the old behaviour.

=== camel-jbang

The `generate` commands has been moved into separate plugin which you need to install first to be able to use.

[source,bash]
----
camel plugin add generate
----

TIP: You can see the list of available plugins using `camel plugin get --all`.

=== camel-jetty / camel-servlet / camel-undertow

When using embedded HTTP server (consumer) then the headers `CamelHttpServletRequest` and `CamelHttpServletResponse`
has been removed.

To gain access to these, then you need to use the `HttpMessage` API instead as shown below:

[source,java]
----
ServletRequest request = exchange.getIn().getHeader(Exchange.HTTP_SERVLET_REQUEST, ServletRequest.class);
ServletResponse request = exchange.getIn().getHeader(Exchange.HTTP_SERVLET_RESPONSE, ServletResponse.class);
----

Should be changed to:

[source,java]
----
ServletRequest request = exchange.getMessage(HttpMessage.class).getRequest();
ServletResponse response = exchange.getMessage(HttpMessage.class).getResponse();
----

=== camel-seda / camel-disruptor

When using `InOnly` exchange pattern then the producer makes a copy of the message to be added to the queue.
Camel will now do a deep-copy if the message body is of `StreamCache` type to make access to the message body thread-safe.

=== camel-debug

The debugger (using `org.apache.camel.spi.BacklogDebugger`) used for tooling such as IDEA and Visual Studio, is fixed
to work better out-of-the-box by just having `camel-debug` JAR or `camel-debug-starter` (for Spring Boot) on the classpath.

An internal change is that the MBean operation `messageHistoryOnBreakpointAsXml` on `ManagedBacklogDebugger` now includes
the current node as last message history, which was expected by IDEA tooling, to make it function again.

=== camel-spring-security

The `camel-spring-security` component has been updated to improve readiness for Spring Security 7.x. Since Spring Security 5.8 the `AccessDecisionManager` interface and the related cooperating classes have been deprecated in favor of `AuthorizationManager` based patterns.
If you are creating Spring Security route policies in your code, you must now refactor them to be based on an `AuthorizationManager`.

For example, you might have a route policy defined as follows:

[source,java]
----
SpringSecurityAuthorizationPolicy authorizationPolicy = new SpringSecurityAuthorizationPolicy();
authorizationPolicy.setAuthenticationManager(authenticationManager);
authorizationPolicy.setSpringSecurityAccessPolicy(new SpringSecurityAccessPolicy("ROLE_ADMIN"));
authorizationPolicy.setAccessDecisionManager(new AffirmativeBased(Collections.singletonList(new RoleVoter())));
----

With the changes implemented in this release, that must be refactored to:

[source,java]
----
SpringSecurityAuthorizationPolicy authorizationPolicy = new SpringSecurityAuthorizationPolicy();
authorizationPolicy.setAuthenticationManager(authenticationManager);
authorizationPolicy.setAuthorizationManager(AuthorityAuthorizationManager.hasRole("ADMIN"));
----

This new pattern supports a more expressive language to define your own authorization rules, exposing the full power of the Spring Security framework to Camel route policies.
See the https://docs.spring.io/spring-security/reference/5.8/migration/servlet/authorization.html#servlet-replace-permissionevaluator-bean-with-methodsecurityexpression-handler[spring documentation] for further details on how to migrate your custom code from `AccessDecisionManager` to `AuthorizationManager`.

=== camel-cloudevents

Moved the `camel-cloudevents` api into `camel-api` and removed the `camel-cloudevents` dependency from all components that provide CloudEvent transformers.

=== camel-hashicorp-vault

The `HashicorpVaultPropertiesFunction` from the hashicorp vault has been changed to avoid declaring statically the Vault Engine.

This means the `camel.vault.hashicorp.engine` property and the support for `CAMEL_HASHICORP_VAULT_ENGINE` environment variable have been removed.

You can now use the following syntax:

`hashicorp:engine:secret`

Where engine will be the Hashicorp Vault Engine to be used. This means you'll be able to use multiple engines at the same time. More details at CAMEL-20775 issue.

=== camel-test

As part of CAMEL-20785, we have started to rework the `CamelTestSupport` class. At this point, it should be highly compatible with
previous versions, as we are laying down the foundations for greater cleanups in the future. However, several methods have been
marked as deprecated. Users of this class are advised to look at the deprecation notices and adjust the code accordingly.

=== camel-pubnub

Upgraded PubNub client from v6 to v9 and the `wherenow` operation is removed due to no longer present in the client.

=== camel-as2

The `camel-as2` component has been updated so that the client can compress a MIME body before signing or compress a MIME body before signing and encrypting as described in
sections https://datatracker.ietf.org/doc/html/rfc5402/#section-3.2[3.2] and https://datatracker.ietf.org/doc/html/rfc5402/#section-3.5[3.5] of https://datatracker.ietf.org/doc/html/rfc5402/[rfc 5402].

When the AS2 server is configured with a decryption key, all received messages require encryption. Otherwise, the server
will return an 'insufficient-security' error disposition. Only messages with valid encryption will be successfully processed,
for instance, 'encrypted', 'signed-encrypted', 'encrypted-compressed', 'encrypted-compressed-signed' and 
'encrypted-signed-compressed' message types.

Messages that cannot be successfully decrypted will return a 'decryption-failed' error disposition.
This includes messages encrypted with a invalid key or if the server receives encrypted messages but is not 
configured with a decryption key.

When the AS2 server is configured with a message signature validation certificate chain, all received messages
require a signature. Otherwise, the server will return an 'insufficient-security' error disposition.
Only messages with a valid signature will be processed, for instance, 'signed', 'compressed-signed',
and 'signed-compressed' message types.

The server will return an 'authentication-failure' error when a message fails signature validation.

When the AS2 server is configured with a message signature validation certificate chain and a decryption key,
all received messages require encryption and a signature.
Otherwise, the server will return an 'insufficient-security' error disposition.
Only messages with a valid signature and encryption will be processed, for instance, 'signed-encrypted', 'encrypted-compressed-signed', 
and 'encrypted-signed-compressed'.

|===
| *signing cert* | no | yes | no | yes
| *decryption key* | no | no | yes | yes

| *plain* | | insufficient-security | insufficient-security | insufficient-security
| *signed* | | | insufficient-security | insufficient-security
| *encrypted* | decryption-failure | decryption-failure | | insufficient-security
| *signed-encrypted* | decryption-failure | decryption-failure | |
| *plain-compressed* | | insufficient-security | insufficient-security  | insufficient-security
| *compressed-signed* | |  | insufficient-security | insufficient-security
| *signed-compressed* | |  | insufficient-security | insufficient-security
| *encrypted-compressed* | decryption-failure | decryption-failure | | insufficient-security
| *encrypted-compressed-signed* | decryption-failure | decryption-failure | |
| *encrypted-signed-compressed* | decryption-failure | decryption-failure | |
|===


=== Camel Spring Boot

==== camel-debug-starter

Using camel debugger with Spring Boot is now moved from `camel-spring-boot` into `camel-debug-starter` where you can configure the debugger
via `camel.debug.` options in `application.properties`.

The `camel-debug-starter` now has `camel.debug.enabled=true` by default to let the debugger be installed out of the box,
by having the JAR on the classpath (as intended). You can turn this off via `camel.debug.enabled=false`.

=== Camel Kotlin deprecation

Camel Kotlin DSL is deprecated.
= Apache Camel 4.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

== Upgrading from 4.8.2 to 4.8.3

=== camel-mina

If using object codec, then you should configure the `objectCodecPattern` configuration to specify
which java classes (FQN) to allow for Object serialization. You can use `*` to accept all patterns.

== Upgrading from 4.8.1 to 4.8.2

=== camel-management

==== Using Route Templates

Camel will now ensure the created routes via route templates
always use unique _nodePrefixId_ to ensure there are no duplicate id clashes, when the template
is used for creating multiple routes.

=== camel-debezium

To avoid split package that can be a problem in environments like OSGI, each camel-debezium module has its own
sub package corresponding to the database type. So for example, all the classes of the module `camel-debezium-postgres`
have been moved to a dedicated package which is `org.apache.camel.component.debezium.postgres` instead of having
everything under the root package `org.apache.camel.component.debezium`.

== Upgrading from 4.8.0 to 4.8.1

The `camel-opentelemetry` component has had significant bug fixes to handle span activation/deactivations
better when Camel route messages synchronously and asynchronously. This component should also work better
on Spring Boot.

In order to fix the problems reported we had to align the Opentelemetry dependencies to a version which is different from the one used in Spring Boot 3.3.x BOM. 
If you're using such BOM for your **Camel Spring Boot runtime** application, you will need to make sure to force the usage of the Opentelemetry dependencies below:
```
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-sdk</artifactId>
    <version>1.43.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-api</artifactId>
    <version>1.43.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-context</artifactId>
    <version>1.43.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-logs</artifactId>
    <version>1.43.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-metrics</artifactId>
    <version>1.43.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-sdk-common</artifactId>
    <version>1.43.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-sdk-metrics</artifactId>
    <version>1.43.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-sdk-logs</artifactId>
    <version>1.43.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-sdk-trace</artifactId>
    <version>1.43.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-api-incubator</artifactId>
    <version>1.43.0-alpha</version>
</dependency>
```

== Upgrading Camel 4.7 to 4.8

=== camel-api

Added `void bind(String id, Class<?> type, Object bean, String initMethod, String destroyMethod)` method to `org.apache.camel.spi.Registry`
to support init and destroy method on beans.

=== camel-core

The `UseOriginalAggregationStrategy` class will now propagate the caught exception stored in the exchange property `Exchange.EXCEPTION_CAUGHT`
as well. For example, when using the Splitter EIP with this, then any caught exception during splitting would be stored
as well, which allows access to this information afterward, for example, in an `onCompletion` where the caught exception
can be used to know some error happened during splitting.

Internally, Camel will now use Java's own `InputStream.transferTo` for copying data between streams whenever such copies don't
require customized buffer sizes or data flushing policies. Additionally, the size of the data buffer used by Camel when
performing these copies has increased from 4096 bytes to 16384 bytes (the default buffer size used by Java 21).

The tracer (`BacklogTracer`) has changed the `backlogSize` default value from `1000` to `100`, and `maxBodySize` from `128kb` to `32kb`.
This reduces the amount of data captured and stored and helps reduce the tracing overhead.

The `org.apache.camel.support.DefaultExchangeHolder` will now include both exchange variables and properties,
if the parameter `includeProperties` is set to true.

=== camel-jbang

The `camel trace` command has changed to show tracing status (by default). To dump traced messages use `camel trace --action=dump`.

*Breaking changes only in 4.8.0* The parameter `--repos` has been renamed `--repository` for `run` and `export` commands. It requires to be updated when using from command-line and in `application.properties`. In 4.8.1, the `--repos` has been set back and  `--repository` removed.

=== Deprecated Components

The following components that were marked as deprecated:

* camel-univocity-parsers

=== camel-as2

The header prefixes have been corrected from `CamelAS2.` -> `CamelAs2.` to be consistent with naming convention
used by other API-based components. The documentation uses the correct naming prefix as `CamelAs2.`.

=== camel-kafka

The `KafkaIdempotentRepository` will now continue to sync cache updates after Camel has been started.
You can configure `startupOnly=true` to only sync the cache once on startup,
(however, then the cache is not synced with other Camel nodes in a cluster).

=== camel-langchain4j-chat

The chat-with-tools feature was deprecated. Use the new `camel-langchain4j-tool` component.

=== camel-tests

Continuing the multi-release tests cleanups, on this one, restricted methods from the `CamelTestSupport` class
have been marked as final and cannot be extended.

=== Preferred JAX-B implementation: `org.glassfish.jaxb:jaxb-runtime`

We stopped relying on `com.sun.xml.bind:jaxb-impl` in favor of `org.glassfish.jaxb:jaxb-runtime`.
This change should have no impact on existing code, because recent versions of the two artifacts bring the same classes.
The main motivation for this change is to allow projects that still require classes from `javax.xml.bind` package
to be able to depend on pre-3.x versions of `com.sun.xml.bind:jaxb-impl` together with the recent version of
`org.glassfish.jaxb:jaxb-runtime` brought by Camel.
= Apache Camel 4.x Upgrade Guide

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

== Upgrading Camel 4.8 to 4.9

=== camel-api

Added `setLazyBeanStrategy`/`getLazyBeanStrategy` methods to `org.apache.camel.spi.CamelBeanPostProcessor`.

Renamed `Exchange.ACTIVE_SPAN` to `Exchange.OTEL_ACTIVE_SPAN`.
Renamed `ExchangePropertyKey.ACTIVE_SPAN` to `ExchangePropertyKey.OTEL_ACTIVE_SPAN`.

=== camel-management

The `queueSize` attribute on endpoints which are `ManagedBrowseableEndpoint` is changed from returning a `Long` value
to an `Integer` value.

==== Using Route Templates

Camel will now ensure the created routes via route templates
always use unique _nodePrefixId_ to ensure there are no duplicate id clashes when the template
is used for creating multiple routes.

=== camel-xml-io

The XML dumper no longer includes attributes which are using default values.

=== camel-jackson

The option `useWriter` on JSON data format and camel-jackson,
has been replaced with `combineUnicodeSurrogates` as it is intended for 4-bytes characters such as Japanese.

=== camel-jms

The camel-jms component has changed its default `HeaderFilterStrategy` to also remove any `Camel...` headers,
to act similar to other Camel components. If the old classic behavior is needed then you can configure the `JmsComponent` to use `org.apache.camel.component.jms.ClassicJmsHeaderFilterStrategy`
as header filter strategy which is the old implementation.

Added `int limit` as parameter to the `browse` method in `org.apache.camel.component.jms.QueueBrowseStrategy`.

=== camel-opentelemetry

The `camel-opentelemetry` component has had significant bug fixes to handle span activation/deactivations
better when Camel route messages synchronously and asynchronously. This component should also work better
on Spring Boot.

=== camel-pubnub

Upgraded the pubnub client to 10.x, which removed the `cipherKey` option.

=== camel-smooks

Upgraded Smooks from version 2.0.0-RC4 to version 2.0.1 which has
https://www.smooks.org/documentation/#migrating_from_smooks_1_7_to_2_0[API breaking changes] in Smooks.

=== camel-hashicorp-vault properties function

The syntax for retrieving a single field of a secret has been changed.

From this:

`{{hashicorp:secret:database/username}}`

to this:

`{{hashicorp:secret:database#username}}`

You could find more details on CAMEL-21179 issue

=== camel-aws-secrets-manager properties function

The syntax for retrieving a single field of a secret has been changed.

From this:

`{{aws:database/username}}`

to this:

`{{aws:database#username}}`

You could find more details on CAMEL-21179 issue

=== camel-google-secret-manager properties function

The syntax for retrieving a single field of a secret has been changed.

From this:

`{{gcp:database/username}}`

to this:

`{{gcp:database#username}}`

You could find more details on CAMEL-21179 issue

=== camel-azure-key-vault properties function

The syntax for retrieving a single field of a secret has been changed.

From this:

`{{azure:database/username}}`

to this:

`{{azure:database#username}}`

You could find more details on CAMEL-21179 issue

=== camel-aws

The `camel-aws2-s3` when using `headBucket` operation will now store the result
in a header named `CamelAwsS3BucketExists` whether the bucket exists or not.

Previously an `software.amazon.awssdk.services.s3.model.NoSuchBucketException` was thrown.
However, this would require using error handling to just check whether the bucket existed.
Returning a boolean makes it easier in Camel routes to decide what to do.
You may also set the option `ignoreBody=true` to not change the message body.

=== camel-test

The `CamelTestSupport` class was modified so that the JUnit 5 extension code that was part of the class itself,
was moved to a separate class. This is part of the work being done on https://issues.apache.org/jira/browse/CAMEL-20837[CAMEL-20837]
to modernize the base test code.

In many cases, code should work with no changes provided they are not using any of the API methods that
were deprecated in Camel 4.7.0.
Additionally, starting with Camel 4.9, we strongly recommend users to avoid relying on single-instance contexts (created
via `@TestInstance(TestInstance.Lifecycle.PER_CLASS)`), as this is considered a deprecated functionality that will be removed in the
future.
The logs will print a warning message if this behavior is detected.

=== camel-debezium

To avoid split package that can be a problem in environments like OSGI, each camel-debezium module has its own
subpackage corresponding to the database type. So for example, all the classes of the module `camel-debezium-postgres`
have been moved to a dedicated package which is `org.apache.camel.component.debezium.postgres` instead of having
everything under the root package `org.apache.camel.component.debezium`.

=== Deprecated components

The following components were marked as deprecated:

- `camel-etcd3`

=== Removed deprecated components

The following experimental DSL has been removed:

- `camel-groovy-dsl`
- `camel-js-dsl`
- `camel-jsh-dsl`

The Camel team is only focusing on Java, XML and YAML DSL.

=== Removed API

==== Kotlin DSL

The Kotlin DSL, which was deprecated in Camel 4.7.0, has now been removed. The routes must be migrated to another DSL such as Java, YAML or XML.

The following modules have been removed:

* `camel-kotlin-dsl`
* `camel-kotlin-api`
= Apache Camel 4.x Upgrade Guide

IMPORTANT: If you are migrating from Camel 3.x then use the
xref:camel-4-migration-guide.adoc[Camel 3.x to 4.0 Migration Guide] first.

This document is for helping you upgrade your Apache Camel application
from Camel 4.x to 4.y. For example, if you are upgrading Camel 4.0 to 4.2, then you should follow the guides
from both 4.0 to 4.1 and 4.1 to 4.2.

You can find the upgrade guide for each release in the following pages:

- xref:camel-4x-upgrade-guide-4_1.adoc[Upgrade guide 4.0 -> 4.1]
- xref:camel-4x-upgrade-guide-4_2.adoc[Upgrade guide 4.1 -> 4.2]
- xref:camel-4x-upgrade-guide-4_3.adoc[Upgrade guide 4.2 -> 4.3]
- xref:camel-4x-upgrade-guide-4_4.adoc[Upgrade guide 4.3 -> 4.4]
- xref:camel-4x-upgrade-guide-4_5.adoc[Upgrade guide 4.4 -> 4.5]
- xref:camel-4x-upgrade-guide-4_6.adoc[Upgrade guide 4.5 -> 4.6]
- xref:camel-4x-upgrade-guide-4_7.adoc[Upgrade guide 4.6 -> 4.7]
- xref:camel-4x-upgrade-guide-4_8.adoc[Upgrade guide 4.7 -> 4.8]
- xref:camel-4x-upgrade-guide-4_9.adoc[Upgrade guide 4.8 -> 4.9]
- xref:camel-4x-upgrade-guide-4_10.adoc[Upgrade guide 4.9 -> 4.10]
- xref:camel-4x-upgrade-guide-4_11.adoc[Upgrade guide 4.10 -> 4.11]
- xref:camel-4x-upgrade-guide-4_12.adoc[Upgrade guide 4.11 -> 4.12]
= Camel Catalog

Each release includes a catalog with all sorts of information about what’s included in the release.

== About Camel Catalog

The catalog is shipped in an independent standalone `camel-catalog` JAR containing the following information:

- List of all components, data formats, languages, EIPs, and everything else in the release
- Curated lists for Camel Quarkus, Camel Spring Boot, and Camel Main runtimes
- JSON schema with extensive details for every option
- Human-readable documentation for every option
- Categorization of options (for example, find all database components)
- XML schema for the XML DSLs

There is also a Java API for tooling:

- validating Camel endpoints and the Simple language
- creating Camel endpoint URLs

The catalog provides a wealth of information that tooling can tap into and use.

=== Tooling using Camel Catalog

The following tools uses the catalog in their editor:

- https://plugins.jetbrains.com/plugin/9371-apache-camel-idea-plugin[Camel tooling for IDEA]
- https://marketplace.eclipse.org/content/language-support-apache-camel[Camel tooling for Eclipse]
- https://marketplace.visualstudio.com/items?itemName=redhat.vscode-apache-camel[Camel tooling for VS Code]
- https://marketplace.visualstudio.com/items?itemName=camel-karavan.karavan[Camel Karavan for VS Code]
- https://marketplace.visualstudio.com/items?itemName=redhat.vscode-kaoto[Kaoto for VS Code]
- https://hawt.io/[Hawtio]

The xref:camel-report-maven-plugin.adoc[Camel Maven validation] plugin uses the catalog during validation of all the
Camel endpoints found while scanning the source code.

=== Layout of camel-catalog

JAR includes the information using the following directory layout:

[source,text]
----
org
└── apache
  └── camel
    └── catalog
      ├── beans (JSON schema)
      ├── components (JSON schema)
      ├── dataformats (JSON schema)
      ├── dev-consoles (JSON schema)
      ├── languages (JSON schema)
      ├── main (JSON schema)
      ├── models (JSON schema)
      ├── others (JSON schema)
      ├── releases (JSON schema)
      ├── schemas (XML schema)
      └── transformers (JSON schema)
----

Each directory contains files with the information. Every Camel component is included
as JSON schema files in the components directory. For example, the Timer component
is included in the file timer.json.
= Camel Component Maven Plugin

The
https://github.com/apache/camel/tree/main/tooling/maven/camel-component-maven-plugin[Camel Component
Maven Plugin] allows third party component developers to generate all the necessary metadata and Java classes for configurations to be used since Camel 3.x. These metadata files and Java files allows for more efficiency and faster runs for your component.

== Goals Supported

The following goal is supported:

=== generate

This goal will generate the following metadata files and Java files:

* Jandex index: it will generate a Jandex index for used Java annotations within the project which allows to more efficiency to search and load the annotations to generate other metadata as mentioned below.
* Type Converter Loader: it will generate a loader for xref:type-converter.adoc[type converter] annotated with `@Converter(loader = true)` to allow faster way for Camel to load these converters.
* SPIs: it will generate all Service Provider Interfaces (SPI) for the component. This allows Camel to auto-discover your component without adding it manually to the Camel context.
* Configurers: it will generate all configurer Java classes from `@Configurer` annotated classes.
* Endpoint Schema: it will generate the property configurers as well as schema JSONs extracted from the component's Endpoint and Component classes. This allows Camel to avoid reflections while configuring the properties, thus allows for better efficiency.
* Endpoint URI Factory: it will generate endpoint factory to build URIs from a map of properties.
* Invoke on Header: it will generate source code for components using `@InvokeOnHeader`
* Prepare Component: it analyzes if the maven module contains Camel modules such as `components`, `dataformats`, `languages` and others. And for each of those generates extra descriptors and schema files for easier auto-discovery in Camel and tooling. 
* Validate Component: it validates the Camel component if the meta-files for `components`, `dataformats`, `languages` and others, all contains the needed meta-data such as assigned labels, documentation for each option.

[NOTE]
====
In order for the plugin to work probably, you will need to have the proper Camel annotations in your component. Example, `@Component` for component class, `@UriEndpoint` for endpoint class, `@UriParams` ..etc. You can take a look at these annotation how being used in any of the existing Camel components in github. Or even better, you can use xref:camel-maven-archetypes.adoc[Camel Maven Archetypes] to bootstrap the initial component, this already include all the necessary batteries for your component such as necessary initial Java classes, annotation and maven `pom.xml`.
====

== Adding the plugin to your pom.xml

In case you *did not* use the Camel Maven Archetypes to bootstrap the initial component project, you will need to add the following to your `pom.xml` build section:

[source,xml]
----
<plugin>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-component-maven-plugin</artifactId>
  <version>${camel-version}</version>
  <executions>
    <execution>
      <id>generate</id>
      <goals>
        <goal>generate</goal>
      </goals>
      <phase>process-classes</phase>
    </execution>
   </executions>
</plugin>
----

This will attach the plugin `generate` goal to Maven's `process-classes`,
in order to generate all the necessary files being described above upon compilation.

Thus, `mvn test`, `mvn package`, `mvn verify` and `mvn install` phases should run this plugin.

=== Re-compile to include latest generated code

The `camel-component-maven-plugin` is executed after the compiler, and because it outputs java source
code, then the compiler must execute again (will only compile if source code has actually changed).

To ensure this the following should be added to the `pom.xml` file:

[source,xml]
----
<plugin>
    <artifactId>maven-compiler-plugin</artifactId>
    <executions>
        <execution>
            <id>recompile</id>
            <goals>
                <goal>compile</goal>
            </goals>
            <phase>process-classes</phase>
        </execution>
    </executions>
</plugin>
----

=== Configuring output directory

The plugin will by default generate outputs to

- `src/generated/java` - for generated java source code
- `src/generated/resources` - for generated resource files

To include these folders with the Java compiler, then you can configure Maven to include those directories:

[source,xml]
----
<plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>build-helper-maven-plugin</artifactId>
    <executions>
        <execution>
            <phase>generate-sources</phase>
            <goals>
                <goal>add-source</goal>
                <goal>add-resource</goal>
            </goals>
            <configuration>
                <sources>
                    <source>src/generated/java</source>
                </sources>
                <resources>
                    <resource>
                        <directory>src/generated/resources</directory>
                    </resource>
                </resources>
            </configuration>
        </execution>
    </executions>
</plugin>
----

However, if you want, you can also configure the `camel-component-maven-plugin` to output directly
to `src/main` as shown (then you do not need to use the `build-helper-maven-plugin` as we do above):

[source,xml]
----
<plugin>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-component-maven-plugin</artifactId>
  <version>${camel-version}</version>
  <configuration>
    <sourcesOutputDir>src/main/java</sourcesOutputDir>
    <resourcesOutputDir>src/main/resources</resourcesOutputDir>
  </configuration>
  <executions>
    <execution>
      <id>generate</id>
      <goals>
        <goal>generate</goal>
      </goals>
      <phase>process-classes</phase>
    </execution>
   </executions>
</plugin>
----
= JSSE Utility

The JSSE Utility allows you to easily configure aspects of the
https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide.html[Java
Secure Socket Extension] (JSSE) API in order to greatly simplify the use
of custom transport layer security (TLS) settings on Camel components.

== Supported JSSE Components

A number of Camel components support this (such as but not limited to):

* xref:components::cometd-component.adoc[Cometd]
* xref:components::http-component.adoc[HTTP]
* xref:components::irc-component.adoc[IRC]
* xref:components::jetty-component.adoc[Jetty]
* xref:components::netty-component.adoc[Netty]
* xref:components::mail-component.adoc[Mail]

== Configuring JSSE with Camel

The key component in configuring TLS through the JSSE API is the `SSLContext`.

The `SSLContext` provides socket factories for both client side and server side sockets
as well as another component called an `SSLEngine` that is used by non-blocking IO to support TLS.

The JSSE configuration utility provides an easy-to-use builder for configuring
these JSSE components, among others, in a manner that allows you to provide all
configuration options up front during the initialization of your
application such that you don't have to customize library code or dig
though the inner workings of a third-party library in order to inject
hooks for the configuration of each component in the JSSE API.  The
central builder in the JSSE configuration utility is the
SSLContextParameters. This class serves as the entry point for most
configuration in the JSSE utility.

=== SSLContextParameters

`SSLContextParameters` (`<sslContextParameters>` XML tag)
contain the following elements:

* provider (attribute)
* secureSocketProtocol (attribute)
* certAlias (attribute)
* sessionTimeout (attribute)
* cipherSuites (element)
* cipherSuitesFilter (element)
* secureSocketProtocols (element)
* secureSocketProtocolsFilter (element)
* keyManagers (element)
* trustManagers (element)
* secureRandom (element)
* clientParameters (element)
* serverParameters (element)

provider::
The optional provider identifier for the JSSE implementation to use when
constructing the SSLContext. If omitted, the standard provider look-up
mechanism is used to resolve the provider.
secureSocketProtocol::
The optional secure socket protocol. See https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html[Java Security Standard Algorithm Names]
for information about standard protocol names. If omitted, TLS is used by default.
Note that this property is related to but distinctly different from the
secureSocketProtocols and secureSocketProtocolsFilter properties.
certAlias::
An optional certificate alias to use. This is useful when
the keystore has multiple certificates.
sessionTimeout::
This optional property defines the timeout period, in seconds, for
sessions on both the client and server side as well as in the SSLEngine.
cipherSuites::
This optional property represents a collection of explicitly named
cipher suites to enable on both the client and server side as well as in
the SSLEngine. These values take precedence over filters supplied in
cipherSuitesFilter. The utility attempts to enable the listed cipher
suites regardless of whether the JSSE provider actually supports
them or not. This behavior guarantees that listed cipher suites are
always enabled when listed. For a more lenient option, use
cipherSuitesFilter.
cipherSuitesFilter::
This optional property represents a collection of include and exclude
patterns for cipher suites to enable on both the client and server side
as well as in the SSLEngine. The patterns are applied over only the
available cipher suites. The excludes patterns have precedence over the
includes patterns. If no cipherSuites and no cipherSuitesFilter are
present, the default patterns applied are:

[source,text]
----
Includes .\*;
Excludes .*_NULL_.*, .\*_anon_.*, .\*DES.*, .\*EXPORT.*, .\*MD5, .*RC4.*
----

secureSocketProtocols::
This optional property represents a collection of explicitly named
secure socket protocols, such as SSLv3/TLS/etc., to enable on both the
client and server side as well as in the SSLEngine. These values take
precedence over filters supplied in secureSocketProtocolsFilter.  The
utility attempts to enable the listed protocols regardless of whether
the JSSE provider actually supports them or not. This behavior
guarantees that listed protocols are always enabled when listed. For a
more lenient option, use secureSocketProtocolsFilter.
secureSocketProtocolsFilter::
This optional property represents a collection of include and exclude
patterns for secure socket protocols to enable on both the client and
server side as well as in the SSLEngine. The patterns are applied over
only the available protocols. The excludes patterns have precedence over
the includes patterns. If no secureSocketProtocols and no
secureSocketProtocolsFilter are present, the default patterns applied
are:

[source,text]
----
Includes .*
----

keyManagers::
This optional property configures the source of key material for
providing identity of client and server side connections as well as in
the SSLEngine. If omitted, no source of key material is provided and
the SSLContext is suitable only for client-side usage when mutual
authentication is not in use. You typically configure this property
with a key store containing a client or server private key.
trustManagers::
This optional property configures the source of material for verifying
trust of key material used in the handshake process. If omitted, the
default trust manager is automatically used. See the
https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150[JSSE
documentation] for more information on how the default trust manager is
configured. You typically configure this property with a key store
containing trusted CA certificates.
secureRandom::
This optional property configures the secure random number generator
used by the client and server side as well as in the SSLEngine. If
omitted, the default secure random number generator is used.
clientParameters::
This optional property configures additional settings that apply only to
the client side aspects of the SSLContext. If present, these settings
override the settings specified at the SSLContextParameters level.
serverParameters::
This optional property configures additional settings that apply only to
the server side aspects of the SSLContext. If present, these settings
override the settings specified at the SSLContextParameters level.


=== KeyManagersParameters

KeyManagersParameters contain the following elements:

* keyPassword (attribute)
* provider (attribute)
* algorithm (attribute)
* keyStore (element)

keyPassword::
The optional password for recovering/accessing the private key in the
key store.  This is typically the password for the private key in the
configured key store; however, in some cases, such as when using
PKCS#11, the key password may be provided through other means and is
omitted entirely in this configuration.
provider::
The optional provider identifier for the KeyManagerFactory used to
create the KeyManagers represented by this object's configuration. If
omitted, the default look-up behavior is used.
algorithm::
The optional algorithm name for the KeyManagerFactory used to create the
KeyManager represented by this object's configuration. See the
https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide.html[Java
Secure Socket Extension Reference Guide] for information about standard
algorithm names.
keyStore::
This optional property represents the key store that provides key
material to the key manager. This is typically configured with a key
store containing a user or server private key. In some cases, such as
when using PKCS#11, the key store is omitted entirely.

=== TrustManagersParameters

TrustManagersParameters contain the following elements:

* provider (attribute)
* algorithm (attribute)
* trustManager (attribute)
* keyStore (element)

provider::
The optional provider identifier for the TrustManagerFactory used to
create the TrustManagers represented by this object's configuration. If
omitted, the default look-up behavior is used.
algorithm::
The optional algorithm name for the TrustManagerFactory used to create
the TrustManager represented by this object's configuration.  See the
https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide.html[Java
Secure Socket Extension Reference Guide] for information about standard
algorithm names.
trustManager::
To use an existing configured trust manager instead of using
TrustManagerFactory to get the TrustManager.
keyStore::
See <<CamelConfigurationUtilities-KeyStoreParameters>>.
This optional property represents the key store that provides key
material to the trust manager. This is typically configured with a key
store containing trusted CA certificates / public keys.  In some cases,
such as when using PKCS#11, the key store is omitted entirely.

[[CamelConfigurationUtilities-KeyStoreParameters]]
=== KeyStoreParameters

KeyStoreParameters contain the following elements:

* type (attribute)
* password (attribute)
* provider (attribute)
* resource (attribute)

type::
The optional type of the key store. See the
https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html[Java Security Standard Algorithm Names]
for more information on standard names. If omitted, defaults to the default
lookup mechanism as defined by `KeyStore.getDefaultType()`
password::
The optional password for reading/opening/verifying the key store.
provider::
The optional provider identifier for the provider used to create the
KeyStores represented by this object's configuration. If omitted, the
default look-up behavior is used.
resource::
Optional property to load the key store resource from a uri. By default the class path is used, otherwise 
the uri needs to be specified. For example to use file path as a resource, the prefix file is needed (file:/path/to/keystore). 
In some cases, the resource is omitted as the key store is provided by other means. 

=== FilterParameters

FilterParameters contain the following elements:

* include (element, multiple string)
* exclude (element, multiple string)
include::
This optional property represents zero or more regular expression
patterns for which matching values should be included. The list of
excludes takes precedence over the includes patterns.
exclude::
This optional property represents zero or more regular expression
patterns for which matching values should be included. The list of
excludes takes precedence over the includes patterns.


=== SecureRandomParameters

SecureRandomParameters contain the following elements:

* algorithm (attribute)
* provider (attribute)
algorithm::
This optional property represents the Random Number Generator (RNG)
algorithm identifier for the SecureRandom factory method used to create
the SecureRandom represented by this object's configuration. See
https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html[Java Security Standard Algorithm Names]
for information about standard RNG algorithm names.
provider::
The optional provider identifier for the SecureRandom factory method
used to create the SecureRandom represented by this object's
configuration. If omitted, the default look-up behavior is used.

=== SSLContextServerParameters

SSLContextServerParameters contain the following elements:

* clientAuthentication (attribute)
* sessionTimeout (attribute)
* cipherSuites (element)
* cipherSuitesFilter (element)
* secureSocketProtocols (element)
* secureSocketProtocolsFilter (element)

clientAuthentication::
This optional property indicates if the server side does not request,
requests, or requires clients to provide authentication credentials
during the handshake process. This is commonly referred to as mutual
authentication, two direction SSL/TLS, or two-legged SSL/TLS.
Valid values are: NONE, WANT, REQUIRE

sessionTimeout::
This optional property defines the timeout period, in seconds, for
sessions on the server side. This setting affects both the
SSLServerSocketFactory/SSLServerSocket and the server side of the
SSLEngine.
cipherSuites::
This optional property overrides the value of this
setting in the SSLContextParameters. This option has no effect on the
SSLEngine configuration.
cipherSuitesFilter::
This optional property overrides the value of this
setting in the SSLContextParameters.  This option has no effect on the
SSLEngine configuration.
secureSocketProtocols::
This optional property overrides the
value of this setting in the SSLContextParameters. This option has no
effect on the SSLEngine configuration.
secureSocketProtocolsFilter::
This optional property overrides the value of this
setting in the SSLContextParameters. This option has no effect on the
SSLEngine configuration.

=== SSLContextClientParameters

SSLContextClientParameters contains the following elements:

* sniHostNames (elements)
* sessionTimeout (attribute)
* cipherSuites (element)
* cipherSuitesFilter (element)
* secureSocketProtocols (element)
* secureSocketProtocolsFilter (element)

sniHostNames::
Contains a list of sniHostName elements which provides a list
of SNIHostNames to be used for SSL.
sessionTimeout::
See above
cipherSuites::
See above
cipherSuitesFilter::
See above
secureSocketProtocols::
See above
secureSocketProtocolsFilter::
See above

== Examples

=== Setting Client Authentication on the Server Side

This configuration sets the server side aspects of the TLS configuration
to require client authentication during the handshake process.  This
configuration uses the default trust store and a custom key store to
provide key material for both the server and client sides of the
SSLContext.

[source,java]
-------------------------------------------------------------------
KeyStoreParameters ksp = new KeyStoreParameters();
ksp.setResource("file:/users/home/server/keystore.jks");
ksp.setPassword("keystorePassword");

KeyManagersParameters kmp = new KeyManagersParameters();
kmp.setKeyStore(ksp);
kmp.setKeyPassword("keyPassword");

SSLContextServerParameters scsp = new SSLContextServerParameters();
scsp.setClientAuthentication(ClientAuthentication.REQUIRE);
SSLContextParameters scp = new SSLContextParameters();
scp.setServerParameters(scsp);
scp.setKeyManagers(kmp);

SSLContext context = scp.createSSLContext();
SSLEngine engine = scp.createSSLEngine();
-------------------------------------------------------------------

== Configuring Different Options on the Client and Server Side

In this example, both the client and server sides share the same custom
key store; however, the client side allows any supported cipher suite
while the server side will use the default cipher suite filter and
exclude any cipher suites that match the patterns:

[source,text]
----
.*_NULL_.*
.*_anon_.*
----

[source,java]
-------------------------------------------------------------------
KeyStoreParameters ksp = new KeyStoreParameters();
ksp.setResource("file:/users/home/server/keystore.jks");
ksp.setPassword("keystorePassword");

KeyManagersParameters kmp = new KeyManagersParameters();
kmp.setKeyStore(ksp);
kmp.setKeyPassword("keyPassword");

FilterParameters filter = new FilterParameters();
filter.getInclude().add(".*");

SSLContextClientParameters sccp = new SSLContextClientParameters();
sccp.setCipherSuitesFilter(filter);

SSLContextParameters scp = new SSLContextParameters();
scp.setClientParameters(sccp);
scp.setKeyManagers(kmp);

SSLContext context = scp.createSSLContext();
SSLEngine engine = scp.createSSLEngine();
-------------------------------------------------------------------

= Camel Console

The `camel-console` is available from *Camel 3.15* and newer versions.

IMPORTANT: The Camel Developer Console is intended assisting developers and can display
various information about a running Camel application. This is very handy during development and testing.
However, the Camel Developer Console is not recommended for production use.

Camel comes with a set of consoles out of the box from `camel-console` and `camel-catalog-console` JARs.
These consoles can display general information about the running JVM and the OS Environment, and of course
Camel related information such as runtime metrics of the Camel routes, and a lot more.

== Using Camel Console

The `camel-console` must be added to the classpath, and enabled either via

[source,java]
----
CamelContext context = ...
context.setDevConsole(true);
----

If using Camel Main / Spring Boot / Quarkus etc then the console can be enabled via
configuration:

[source,properties]
----
camel.main.dev-console-enabled = true
----

=== Dev Console and Camel Spring Boot

The Camel developer console is available in Spring Boot as an _actuator_. To enable the console
you need to add dependency:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.springboot</groupId>
    <artifactId>camel-console-starter</artifactId>
</dependency>
----

To include more details such as route metrics you need to include JMX management:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.springboot</groupId>
    <artifactId>camel-management-starter</artifactId>
</dependency>
----

And finally you **must** enable `camel` in the exposed list of HTTP actuator endpoints in `application.properties` as shown:

[source,properties]
----
management.endpoints.web.exposure.include=info,health,camel
----

The console is then available on HTTP (using default port):

[source,text]
----
http://localhost:8080/actuator/camel
----

This will list the available consoles, and you can then call a console by its id, such as `routes`:

[source,text]
----
http://localhost:8080/actuator/camel/routes
----

=== Dev Console and Camel JBang

The Developer Console is easily available when using xref:camel-jbang.adoc[Camel JBang],
by the `--console` argument when running Camel JBang.

For example to run a Camel route from `foo.yaml` and additional configurations from `myapp.properties` you can run as follows
and have the console started and accessible from `http://localhost:8080/q/dev`

[source,bash]
----
$ camel run foo.yaml myapp.properties --console
----

== Writing Custom Dev Consoles

To write a custom console, you need to add `camel-console` as dependency, as it comes with the
base class `AbstractDevConsole` which we extend for our console.

[source,java]
----
@DevConsole("foo")
public class FooConsole extends AbstractDevConsole {

    public FooConsole() {
        super("acme", "foo", "Foolish", "A foolish console that outputs something");
    }

    @Override
    protected String doCallText(Map<String, Object> options) {
        StringBuilder sb = new StringBuilder();
        sb.append("Hello from my custom console");

        // more stuff here

        return sb.toString();
    }

    @Override
    protected JsonObject doCallJson(Map<String, Object> options) {
        JsonObject root = new JsonObject();
        root.put("message", "Hello from my custom console");

        // more stuff here

        return root;
    }

}
----

The class must be annotated with `DevConsole` and the unique id of the console (must be unique across all consoles).
In the constructor the console specifies which group, id, display title, and description to use.

The `doCallText` and `doCallJson` methods is responsible for gathering the information the console should output.

If the console does not support either text or json output, then the methods can return `null`,
and override the `supportMediaType` method and return `true` for the media-type that are supported.

=== Supported Media Types

A console can support any of, or all of the following types:

- TEXT
- JSON

The intention for `TEXT` is to be plain/text based that can be outputted in CLI and other low-level tools.

For `JSON` then the intention is the console outputs a json dataset with key/value pairs that
holds the information, which can be displayed in a custom fashion such as in a web browser, or IDE tool such as VSCode.

=== Maven Configuration

To make Camel able to discover custom dev consoles, then the xref:camel-component-maven-plugin.adoc[came-component-maven-plugin]
must be used, such as:

[source,xml]
----
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.camel</groupId>
            <artifactId>camel-component-maven-plugin</artifactId>
            <version>${camel-version}</version>
            <executions>
                <execution>
                    <id>generate</id>
                    <goals>
                        <goal>generate</goal>
                    </goals>
                    <phase>process-classes</phase>
                </execution>
                <execution>
                    <id>generate-postcompile</id>
                    <goals>
                        <goal>generate-postcompile</goal>
                    </goals>
                    <phase>prepare-package</phase>
                </execution>
            </executions>
        </plugin>
        <plugin>
            <groupId>org.codehaus.mojo</groupId>
            <artifactId>build-helper-maven-plugin</artifactId>
            <executions>
                <execution>
                    <phase>generate-sources</phase>
                    <goals>
                        <goal>add-source</goal>
                        <goal>add-resource</goal>
                    </goals>
                    <configuration>
                        <sources>
                            <source>src/generated/java</source>
                        </sources>
                        <resources>
                            <resource>
                                <directory>src/generated/resources</directory>
                            </resource>
                        </resources>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----

= Camel Kubernetes plugin

This plugin helps you to get started with running Camel applications on Kubernetes.
Please make sure to meet these prerequisites for running Camel integrations on Kubernetes:

* Install a Kubernetes command line tooling (https://kubernetes.io/docs/tasks/tools/#kubectl[kubectl])
* Connect to a running Kubernetes cluster where you want to run the Camel integration

You can connect to a remote Kubernetes cluster or set up a local cluster.
To set up a local Kubernetes cluster, you have a variety of options.

* https://kind.sigs.k8s.io/docs/user/quick-start/[Kind]
* https://minikube.sigs.k8s.io/docs/start/[Minikube]

Camel JBang is able to interact with any of these Kubernetes platforms (remote or local).

Running Camel routes on Kubernetes is quite simple with Camel JBang.
In fact, you can develop and test your Camel route locally with Camel JBang and then promote the same source to running it as an integration on Kubernetes.

The Camel JBang Kubernetes functionality is provided as a command plugin.
This means you need to enable the `kubernetes` plugin first to use the subcommands in Camel JBang.

[source,bash]
----
camel plugin add kubernetes
----

You should see the `kubernetes` plugin listed as an installed plugin.

[source,bash]
----
camel plugin get
----

[source,bash]
----
 NAME        COMMAND     DEPENDENCY                                      DESCRIPTION
 kubernetes  kubernetes  org.apache.camel:camel-jbang-plugin-kubernetes  Run Camel applications on Kubernetes
----

Now Camel JBang is able to run the subcommands offered by the plugin.
You can inspect the help page to see the list of available plugin subcommands.

[source,bash]
----
camel kubernetes --help
----

== Kubernetes export

The Kubernetes plugin works with the Camel JBang export functionality.
The project export generates a proper Maven/Gradle project following one of the available runtime types Quarkus, SpringBoot or camel-main.

In case you export the project with the Kubernetes plugin the exported project holds all information (e.g. sources, properties, dependencies, etc.) and is ready to build, push and deploy the application to Kubernetes, too.
The export generates a Kubernetes manifest (kubernetes.yml) that holds all resources (e.g. Deployment, Service, ConfigMap) required to run the application on Kubernetes.

You can create a project export with the following command.

[source,bash]
----
camel kubernetes export route.yaml --dir some/path/to/project
----

The command receives one or more source files (e.g. Camel routes), and performs the export.
As a result, you will find the Maven/Gradle project sources generated into the given project path.

The default runtime of the project is Quarkus.
You can adjust the runtime with an additional command option `--runtime=quarkus`.

If you want to run this application on Kubernetes, you need to build the container image, push it to a registry and deploy the application to Kubernetes.

TIP: The Camel JBang Kubernetes plugin provides a `run` command that combines these steps (export, container image build, push, deploy) into a single command.

You can now navigate to the generated project folder and build the project artifacts for instance with this Maven command.

[source,bash]
----
./mvnw package -Dquarkus.container-image.build=true
----

According to the runtime type (e.g., quarkus) defined for the export this builds and creates a Quarkus application artifact JAR in the Maven build output folder (e.g. `target/route-1.0-SNAPSHOT.jar`).

The option `-Dquarkus.container-image.build=true` also builds a container image that is ready for deployment to Kubernetes.
More precisely, the exported project uses the very same tooling and options as an arbitrary Quarkus/SpringBoot application would do.
This means you can easily customize the container image and all settings provided by the runtime provider (e.g., Quarkus or SpringBoot) after the export.

The Kubernetes deployment resources are automatically generated with the export, too.

You can find the Kubernetes manifest in `src/main/kubernetes/kubernetes.yml`.

For instance with the option `-Dquarkus.kubernetes.deploy=true` uses this manifest to trigger the Kubernetes deployment as part of the Maven build.

[source,bash]
----
./mvnw package -Dquarkus.kubernetes.deploy=true
----

You will see the Deployment on Kubernetes shortly after this command has finished.

The Camel JBang Kubernetes export command provides several options to customize the exported project.

[width="100%",cols="1m,3",options="header",]
|=======================================================================
|Option |Description

|--trait-profile
|The trait profile to use for the deployment.

|--service-account
|The service account used to run the application.

|--dependency
|Adds dependency that should be included, use "camel:" prefix for a Camel component, "mvn:org.my:app:1.0" for a Maven dependency.

|--build-property
|Maven/Gradle build properties (syntax: --build-property=prop1=foo)

|--property
|Add a runtime property or properties file from a path, a config map or a secret (syntax: [my-key=my-value,file:/path/to/my-conf.properties,[configmap,secret]:name]).

|--config
|Add a runtime configuration from a ConfigMap or a Secret (syntax: [configmap,secret]:name[/key], where name represents the configmap/secret name and key optionally represents the configmap/secret key to be filtered).

|--resource
|Add a runtime resource from a Configmap or a Secret (syntax: [configmap,secret]:name[/key][@path], where name represents the configmap/secret name, key optionally represents the configmap/secret key to be filtered and path represents the destination path).

|--open-api
|Add an OpenAPI spec (syntax: [configmap,file]:name).

|--env
|Set an environment variable in the integration container, for instance "-e MY_VAR=my-value".

|--volume
|Mount a volume into the integration container, for instance "-v pvcname:/container/path".

|--connect
|A Service that the integration should bind to, specified as [[apigroup/]version:]kind:[namespace/]name.

|--source
|Add the source file to your integration, this is added to the list of files listed as arguments of the command.

|--annotation
|Add an annotation to the integration. Use name values pairs like "--annotation my.company=hello".

|--label
|Add a label to the integration. Use name values pairs like "--label my.company=hello".

|--trait
|Add a trait configuration to the integration. Use name values pairs like "--trait trait.name.config=hello".

|--image
|An image built externally (for instance via CI/CD). Enabling it will skip the integration build phase.

|--image-registry
|The image registry to hold the app container image.

|--image-group
|The image registry group used to push images to.

|--image-builder
|The image builder used to build the container image (e.g. docker, jib, podman, s2i).

|--image-platform
|List of target platforms. Each platform is defined using os and architecture (e.g. linux/amd64).

|--base-image
|The base image that is used to build the container image from (default is eclipse-temurin:<java-version>).

|--registry-mirror
|Optional Docker registry mirror where to pull images from when building the container image.

|--cluster-type
|The target cluster type. Special configurations may be applied to different cluster types such as Kind or Minikube.

|--profile
|The developer xref:manual::camel-jbang.adoc#_using_profiles[profile] to use a specific configuration in configuration files using the naming style `application-<profile>.properties`.
|=======================================================================

The Kubernetes plugin export command also inherits all options from the arbitrary Camel JBang export command.

TIP: See the possible options by running: `camel kubernetes export --help` for more details.

=== Kubernetes Container Health Probes

The Observability Services component is set by default in the project created by the export command, then the health path probes are prefixed with the `/observe` endpoint, regardless if they are Quarkus or Spring Boot.

These are the HTTP Container probe endpoints.

For Quarkus.
[source]
----
/observe/health/live
/observe/health/ready
/observe/health/started
----

For Spring Boot (there is no startup probe)
[source]
----
/observe/health/liveness
/observe/health/readiness
----

Note that these container probes are generated by jkube plugin, when you run the `k8s:resource` to generate the manifests in the `target/kubernetes/kubernetes.yml`.

You can export to a project and manually remove the `camel-observability-services` artifact from the `pom.xml`.

== Kubernetes manifest options

The Kubernetes manifest (kubernetes.yml) describes all resources to successfully run the application on Kubernetes.
The manifest usually holds the deployment, a service definition, config maps and much more.

You can use several options on the `export` command to customize this manifest with the traits.
The trait concept was born out of Camel K, and the Camel K operator uses the traits to configure the Kubernetes resources that are managed by an integration.
You can use the same options to also customize the Kubernetes manifest that is generated as part of the project export.

The configuration of the traits is used by the given order:

1. Use the `--trait` command options values
2. Any annotation starting with the prefix `trait.camel.apache.org/*`
3. Any properties from the specific configuration `application-<profile>.properties` for the profile defined by the command option `--profile` with the prefix `camel.jbang.trait.*`
4. Any properties from the default configuration `application.properties` with the prefix `camel.jbang.trait.*`

=== Container trait options

The container specification is part of the Kubernetes Deployment resource and describes the application container image, exposed ports and health probes, for example.

The container trait is able to customize the container specification with the following options:

[cols="2m,1m,5a"]
|===
|Property | Type | Description

| container.port
| int
| To configure a different port exposed by the container (default `8080`).

| container.port-name
| string
| To configure a different port name for the port exposed by the container. It defaults to `http` only when the `expose` parameter is true.

| container.service-port
| int
| To configure under which service port the container port is to be exposed (default `80`).

| container.service-port-name
| string
| To configure under which service port name the container port is to be exposed (default `http`).

| container.name
| string
| The application container name.

| container.image
| string
| The application container image to use for the Deployment.

| container.image-pull-policy
| PullPolicy
| The pull policy: Always\|Never\|IfNotPresent

| container.image-pull-secrets
| string[]
| The pull secrets for private registries

| container.request-cpu
| string
| The minimum amount of CPU required.

| container.request-memory
| string
| The minimum amount of memory required.

| container.limit-cpu
| string
| The maximum amount of CPU required.

| container.limit-memory
| string
| The maximum amount of memory required.

|===

The syntax to specify container trait options is as follows:

[source,bash]
----
camel kubernetes export Sample.java --trait container.[key]=[value]
----

You may specify these options with the export command to customize the container specification.

[source,bash]
----
camel kubernetes export Sample.java --trait container.name=my-container --trait container.port=8088 --trait container.imagePullPolicy=IfNotPresent --trait container.request-cpu=0.005 --trait container.request-memory=100Mi
----

This results in the following container specification in the Deployment resource.

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    camel.apache.org/integration: sample
  name: sample
spec:
  selector:
    matchLabels:
      camel.apache.org/integration: sample
  template:
    metadata:
      labels:
        camel.apache.org/integration: sample
    spec:
      containers:
      - image: quay.io/sample:1.0-SNAPSHOT #<1>
        imagePullPolicy: IfNotPresent #<2>
        name: my-container #<3>
        ports:
        - containerPort: 8088 #<4>
          name: http
          protocol: TCP
        resources:
          requests:
            memory: 100Mi
            cpu: '0.005'
----
<1> Container image running the application
<2> Customized image pull policy
<3> Custom container name
<4> Custom container port exposed

=== Labels and annotations

You may need to add labels or annotations to the generated Kubernetes resources.
By default, the generated resources will have the label `camel.apache.org/integration` set to the exported project name.

You can add labels and annotations with these options on the export command:

[source,bash]
----
camel kubernetes export Sample.java --annotation [key]=[value] --label [key]=[value]
----

.Example

[source,bash]
----
camel kubernetes export Sample.java --annotation project.team=camel-experts
----

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    project.team: camel-experts #<1>
  labels:
    camel.apache.org/integration: sample
  name: sample
spec:
  selector:
    matchLabels:
      camel.apache.org/integration: sample
  template:
    metadata:
      labels:
        camel.apache.org/integration: sample
    spec:
      containers:
      - image: quay.io/sample:1.0-SNAPSHOT
        name: sample
----
<1> Custom deployment annotation

=== Environment variables

The environment trait is there to set environment variables on the container specification.

The environment trait provides the following configuration options:

[cols="2m,1m,5a"]
|===
|Property | Type | Description

| environment.vars
| []string
| A list of environment variables to be added to the integration container.
The syntax is KEY=VALUE, e.g., `MY_VAR="my value"`.
These take precedence over the previously defined environment variables.

|===

The syntax to specify environment trait options is as follows:

[source,bash]
----
camel kubernetes export Sample.java --trait environment.[key]=[value]
----

There is also a shortcut option `--env` that you can use.

[source,bash]
----
camel kubernetes export Sample.java --env [key]=[value]
----

.Example
[source,bash]
----
camel kubernetes export Sample.java --trait environment.vars=MY_ENV=foo --env FOO_ENV=bar
----

This results in the following container specification in the Deployment resource.

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    camel.apache.org/integration: sample
  name: sample
spec:
  selector:
    matchLabels:
      camel.apache.org/integration: sample
  template:
    metadata:
      labels:
        camel.apache.org/integration: sample
    spec:
      containers:
      - image: quay.io/sample:1.0-SNAPSHOT
        name: sample
        env: #<1>
          - name: MY_ENV
            value: foo
          - name: FOO_ENV
            value: bar
----
<1> Environment variables set in the container specification

=== Service trait options

The Service trait enhances the Kubernetes manifest with a Service resource so that the application can be accessed by other components in the same namespace.
The service resource exposes the application with a protocol (e.g., TCP/IP) on a given port and uses either `ClusterIP`, `NodePort` or `LoadBalancer` type.

The Camel JBang plugin automatically inspects the Camel routes for exposed Http services and adds the service resource when applicable.
This means when one of the Camel routes exposes a Http service (for instance by using the `platform-http` component) the Kubernetes manifest also creates a Kubernetes Service resource besides the arbitrary Deployment.

You can customize the generated Kubernetes service resource with trait options:

[cols="2m,1m,5a"]
|===
|Property | Type | Description

| service.type
| string
| The type of service to be used, either 'ClusterIP', 'NodePort' or 'LoadBalancer'.

| container.service-port
| int
| To configure under which service port the container port is to be exposed (default `80`).

| container.service-port-name
| string
| To configure under which service port name the container port is to be exposed (default `http`).

|===

=== Knative service trait options

https://knative.dev/docs/serving/[Knative serving] defines a set of resources on Kubernetes to handle Serverless workloads with automatic scaling and scale-to-zero functionality.

When Knative serving is available on the target Kubernetes cluster, you may want to use the Knative service resource instead of an arbitrary Kubernetes service resource.
The Knative service trait will create such a resource as part of the Kubernetes manifest.

NOTE: The `knative-service` trait is disabled by default, you need to enable the Knative service trait with `--trait knative-service.enabled=true` option. Otherwise, the Camel JBang export will always create an arbitrary Kubernetes service resource.

NOTE: If you enable the knative-service trait and deploys to minikube and uses the docker builder to build the container image in the minikube registry addon, it's likely the container image published won't contain the digest value, and https://knative.dev/docs/serving/configuration/deployment/#skipping-tag-resolution[knative-serving has a verification to check the image digest], so the pod will fail to start with the error message `failed to resolve image to digest`, so for development purposes the kubernetes plugin will skip this validation by adding the property `registries-skipping-tag-resolving: localhost:5000` to the `configmap/config-deployment` in `knative-serving` namespace, if you want to disable this automatic setting, you can set the `--disable-auto` parameter to disable the automatic cluster configuration, however disabling it won't set other automatic configuration for the cluster. You may also want to manually set that property, so this plugin won't set it even with the automatic cluster detection.

WARN: Currently knative-service doesn't work in OpenShift, work is underway to fix it.


The trait offers following options for customization:

[cols="2m,1m,5a"]
|===
|Property | Type | Description

| knative-service.enabled
| bool
| Can be used to enable or disable a trait. All traits share this common property.

| knative-service.annotations
| map[string]string
| The annotations added to route.
This can be used to set knative service-specific annotations
CLI usage example: -t "knative-service.annotations.'haproxy.router.openshift.io/balance'=true"

| knative-service.class
| string
| Configures the Knative autoscaling class property (e.g., to set `hpa.autoscaling.knative.dev` or `kpa.autoscaling.knative.dev` autoscaling).

Refer to the Knative documentation for more information.

| knative-service.autoscaling-metric
| string
| Configures the Knative autoscaling metric property (e.g., to set `concurrency` based or `cpu` based autoscaling).

Refer to the Knative documentation for more information.

| knative-service.autoscaling-target
| int
| Sets the allowed concurrency level or CPU percentage (depending on the autoscaling metric) for each Pod.

Refer to the Knative documentation for more information.

| knative-service.min-scale
| int
| The minimum number of Pods that should be running at any time for the integration. It's **zero** by default, meaning that
the integration is scaled down to zero when not used for a configured amount of time.

Refer to the Knative documentation for more information.

| knative-service.max-scale
| int
| An upper bound for the number of Pods that can be running in parallel for the integration.
Knative has its own cap value that depends on the installation.

Refer to the Knative documentation for more information.

| knative-service.rollout-duration
| string
| Enables to gradually shift traffic to the latest Revision and sets the rollout duration.
It's disabled by default and must be expressed as a Golang `time.Duration` string representation,
rounded to a second precision.

| knative-service.visibility
| string
| Setting `cluster-local`, Knative service becomes a private service.
Specifically, this option applies the `networking.knative.dev/visibility` label to Knative service.

Refer to the Knative documentation for more information.

| knative-service.timeout-seconds
| int
| The maximum duration in seconds that the request instance is allowed to respond to a request. This field propagates to the integration Pod’s terminationGracePeriodSeconds.

Refer to the Knative documentation for more information.

|===

=== Connecting to Knative

The previous section described how the exported Apache Camel application can leverage the Knative service resource with auto-scaling as part of the deployment to Kubernetes.

Apache Camel also provides a Knative component that makes you easily interact with https://knative.dev/docs/eventing/[Knative eventing] and https://knative.dev/docs/serving/[Knative serving].

The Knative component enables you to exchange data with the Knative eventing broker and other Knative services deployed on Kubernetes.
The Camel JBang Kubernetes plugin provides some autoconfiguration options when connecting with the Knative component.
The export command assists you in configuring both the Knative component and the Kubernetes manifest for connecting to Knative resources on the Kubernetes cluster.

You can configure the Knative component with the Knative trait.

NOTE: The `knative` trait is disabled by default, you need to enable the Knative trait with `--trait knative.enabled=true` option.

The trait offers the following options for customization:

[cols="2m,1m,5a"]
|===
|Property | Type | Description

| knative.enabled
| bool
| Can be used to enable or disable a trait. (default: true)

| knative.configuration
| string
| Can be used to inject a Knative complete configuration in JSON format

| knative.channel-sinks
| []string
| List of channels used as destination of camel routes. Can contain simple channel names or full Camel URIs.

Refer to the Knative documentation for more information.

| knative.channel-sources
| []string
| List of channels used as the source of camel routes. Can contain simple channel names or full Camel URIs.

| knative.endpoint-sinks
| []string
| List of endpoints used as destination of camel routes. Can contain simple endpoint names or full Camel URIs.

| knative.endpoint-sources
| []string
| List of endpoints used as sources of camel routes. Can contain simple endpoint names or full Camel URIs.

| knative.event-sinks
| []string
| List of endpoints used as destination of integration routes. Can contain simple endpoint names or full Camel URIs.

| knative.event-sources
| []string
| List of event types that the integration will be subscribed to. Can contain simple event types or full Camel URIs (to use a specific broker different from "default").

| knative.sink-binding
| bool
| Allows binding the integration to a sink via a Knative SinkBinding resource. This can be used when the integration targets a single sink. It’s enabled by default when the integration targets a single sink (except when the integration is owned by a Knative source).

| knative.filters
| []string
| Sets filter attributes on the event stream (such as event type, source, subject and so on). A list of key-value pairs that represent filter attributes and its values. The syntax is KEY=VALUE, e.g., source="my.source". Filter attributes get set on the Knative trigger that is being created as part of this integration.

| knative.filter-event-type
| bool
| Enables the default filtering for the Knative trigger using the event type If this is true, the created Knative trigger uses the event type as a filter on the event stream when no other filter criteria is given. (default: true)

|===


=== Knative trigger

The concept of a Knative trigger allows you to consume events from the https://knative.dev/docs/eventing/[Knative eventing] broker.
In case your Camel route uses the Knative component as a consumer you may need to create a trigger in Kubernetes
to connect your Camel application with the Knative broker.

The Camel JBang Kubernetes plugin is able to automatically create this trigger for you.

NOTE: The `knative` trait is disabled by default, you need to enable the Knative trait with `--trait knative.enabled=true` option.

The following Camel route uses the Knative event component and references a Knative broker by its name.
The plugin inspects the code and automatically generates the Knative trigger as part of the Kubernetes manifest that is used
to run the Camel application on Kubernetes.

[source,yaml]
----
- from:
    uri: knative:event/camel.evt.type?name=my-broker
    steps:
      - to: log:info
----

The route consumes Knative events of type `camel.evt.type`.
If you export this route with the Camel JBang Kubernetes plugin, you will see a Knative trigger being generated as part of the Kubernetes manifest (kubernetes.yml).

[source,bash]
----
camel kubernetes export knative-route.yaml
----

The generated export project can be deployed to Kubernetes, and as part of the deployment, the trigger is automatically created so the application can start consuming events.

The generated trigger looks as follows:

[source,yaml]
----
apiVersion: eventing.knative.dev/v1
kind: Trigger
metadata:
  name: my-broker-knative-route-camel-evt-type
spec:
  broker: my-broker
  filter:
    attributes:
      type: camel.evt.type
  subscriber:
    ref:
      apiVersion: v1
      kind: Service
      name: knative-route
    uri: /events/camel-evt-type
----

The trigger uses a default filter on the event type CloudEvents attribute and calls the Camel application via the exposed Kubernetes service resource.

The Camel application is automatically configured to expose an Http service so incoming events are handed over to the Camel route.
You can review the Knative service resource configuration that makes Camel configure the Knative component.
The configuration has been automatically created in `src/main/resources/knative.json` in the exported project.

Here is an example of the generated `knative.json` file:

[source,json]
----
{
  "resources" : [ {
    "name" : "camel-event",
    "type" : "event",
    "endpointKind" : "source",
    "path" : "/events/camel-event",
    "objectApiVersion" : "eventing.knative.dev/v1",
    "objectKind" : "Broker",
    "objectName" : "my-broker",
    "reply" : false
  } ]
}
----

The exported project has everything configured to run the application on Kubernetes.
Of course, you need Knative eventing installed on your target cluster, and you need to have a Knative broker named `my-broker` available in the target namespace.

Now you can just deploy the application using the Kubernetes manifest and see the Camel route consuming events from the broker.

=== Knative channel subscription

Knative channels represent another form of producing and consuming events from the Knative broker.
Instead of using a trigger, you can create a subscription for a Knative channel to consume events.

NOTE: The `knative` trait is disabled by default, you need to enable the Knative trait with `--trait knative.enabled=true` option.

The Camel route that connects to a Knative channel in order to receive events looks like this:

[source,yaml]
----
- from:
    uri: knative:channel/my-channel
    steps:
      - to: log:info
----

The Knative channel is referenced by its name.
The Camel JBang Kubernetes plugin will inspect your code to automatically create a channel subscription as part of the Kubernetes manifest.
You just need to export the Camel route as usual.

[source,bash]
----
camel kubernetes export knative-route.yaml
----

The code inspection recognizes the Knative component that references the Knative channel, and the subscription automatically becomes part of the exported Kubernetes manifest.

Here is an example subscription that has been generated during the export:

[source,yaml]
----
apiVersion: messaging.knative.dev/v1
kind: Subscription
metadata:
  name: my-channel-knative-route
spec:
  channel:
    apiVersion: messaging.knative.dev/v1
    kind: Channel
    name: my-channel
  subscriber:
    ref:
      apiVersion: v1
      kind: Service
      name: knative-route
    uri: /channels/my-channel
----

The subscription connects the Camel application with the channel, so each event on the channel is sent to the Kubernetes service resource that also has been created as part of the Kubernetes manifest.

The Camel Knative component uses a service resource configuration internally to create the proper Http service.
You can review the Knative service resource configuration that makes Camel configure the Knative component.
The configuration has been automatically created in `src/main/resources/knative.json` in the exported project.

Here is an example of the generated `knative.json` file:

[source,json]
----
{
  "resources" : [ {
    "name" : "my-channel",
    "type" : "channel",
    "endpointKind" : "source",
    "path" : "/channels/my-channel",
    "objectApiVersion" : "messaging.knative.dev/v1",
    "objectKind" : "Channel",
    "objectName" : "my-channel",
    "reply" : false
  } ]
}
----

Assuming that you have Knative eventing installed on your cluster and that you have set up the Knative channel `my-channel` you can start consuming events right away.
The deployment of the exported project uses the Kubernetes manifest to create all required resources, including the Knative subscription.

=== Knative sink binding

When connecting to a Knative resource (Broker, Channel, Service) in order to produce events for Knative eventing you probably want to use a `SinkBinding` that resolves the URL to the Knative resource for you.
The sink binding is a Kubernetes resource that makes Knative eventing automatically inject the resource URL into your Camel application on startup.
The Knative URL injection uses environment variables (`K_SINK`, `K_CE_OVERRIDES`) on your deployment.
The Knative eventing operator will automatically resolve the Knative resource (e.g. a Knative broker URL) and inject the value so your application does not need to know the actual URL when deploying.

The Camel JBang Kubernetes plugin leverages the sink binding concept for all routes that use the Knative component as an output.

NOTE: The `knative` trait is disabled by default, you need to enable the Knative trait with `--trait knative.enabled=true` option.

The following route produces events on a Knative broker:

[source, yaml]
----
- from:
    uri: timer:tick
    steps:
      - setBody:
          constant: Hello Camel !!!
      - to: knative:event/camel.evt.type?name=my-broker
----

The route produces events of type `camel.evt.type` and pushes the events to the broker named `my-broker`.
At this point, the actual Knative broker URL is unknown.
The sink binding is going to resolve the URL and inject its value at deployment time using the `K_SINK` environment variable.

The Camel JBang Kubernetes plugin export automatically inspects such a route and automatically creates the sink binding resource for us.
The sink binding is part of the exported Kubernetes manifest and is created on the cluster as part of the deployment.

A sink binding resource created by the export command looks like follows:

[source,bash]
----
camel kubernetes export knative-route.yaml
----

[source,yaml]
----
apiVersion: sources.knative.dev/v1
kind: SinkBinding
metadata:
  finalizers:
    - sinkbindings.sources.knative.dev
  name: knative-route
spec:
  sink:
    ref:
      apiVersion: eventing.knative.dev/v1
      kind: Broker
      name: my-broker
  subject:
    apiVersion: apps/v1
    kind: Deployment
    name: knative-route
----

In addition to creating the sink binding, the Camel JBang plugin also takes care of configuring the Knative Camel component.
The Knative component uses a configuration file that you can find in `src/main/resources/knative.json`.
As you can see the configuration uses the `K_SINK` injected property placeholder as a broker URL.

[source,json]
----
{
  "resources" : [ {
    "name" : "camel-evt-type",
    "type" : "event",
    "endpointKind" : "sink",
    "url" : "{{k.sink}}",
    "objectApiVersion" : "eventing.knative.dev/v1",
    "objectKind" : "Broker",
    "objectName" : "my-broker",
    "reply" : false
  } ]
}
----

As soon as the Kubernetes deployment for the exported project has started the sink binding will inject the `K_SINK` environment variable so that the Camel applicaiton is ready to send events to the Knative broker.

The sink binding concept works for Knative Broker, Channel and Service resources.
You just reference the resource by its name in your Camel route when sending data to the Knative component as an output of the route (`to("knative:event|channel|endpoint/<resource-name>")`).

=== Mount trait options

The mount trait is able to configure volume mounts on the Deployment resource in order to inject data from Kubernetes resources such as config maps or secrets.

There are also shortcut options like `--volume`, `--config` and `--resource` for the mount trait.
These options are described in more detail in the next section.
For now let's have a look into the pure mount trait configuration options.

The mount trait provides the following configuration options:

[cols="2m,1m,5a"]
|===
|Property | Type | Description

| mount.configs
| []string
| A list of configuration pointing to configmap/secret.
The configurations are expected to be UTF-8 resources as they are processed by runtime Camel Context and tried to be parsed as property files.
They are also made available on the classpath to ease their usage directly from the Route.
Syntax: [configmap\|secret]:name[/key], where name represents the resource name and key optionally represents the resource key to be filtered

| mount.resources
| []string
| A list of resources (text or binary content) pointing to a configmap/secret.
The resources are expected to be any resource type (text or binary content).
The destination path can be either a default location or any path specified by the user.
Syntax: [configmap\|secret]:name[/key][@path], where name represents the resource name, key optionally represents the resource key to be filtered and path represents the destination path

| mount.volumes
| []string
| A list of Persistent Volume Claims to be mounted. Syntax: [pvcname:/container/path]

|===

The syntax to specify mount trait options is as follows:

[source,bash]
----
camel kubernetes export Sample.java --trait mount.[key]=[value]
----

.Example
[source,bash]
----
camel kubernetes export Sample.java --trait mount.configs=configmap:my-data --trait mount.volumes=my-pvc:/container/path
----

This results in the following container specification in the Deployment resource.

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    camel.apache.org/integration: sample
  name: sample
spec:
  selector:
    matchLabels:
      camel.apache.org/integration: sample
  template:
    metadata:
      labels:
        camel.apache.org/integration: sample
    spec:
      containers:
        - image: quay.io/sample:1.0-SNAPSHOT
          name: sample
          volumeMounts:
            - mountPath: /etc/camel/conf.d/_configmaps/my-data #<1>
              name: my-data
              readOnly: true
            - mountPath: /container/path #<2>
              name: my-pvc
              readOnly: false
      volumes:
        - name: my-data #<3>
          configMap:
            name: my-data
        - name: my-pvc #<4>
          persistentVolumeClaim:
            claimName: my-pvc
----
<1> The config map `my-data` mounted into the container with default mount path for configurations
<2> The volume mounted into the container with given path
<3> The config map reference as volume spec
<4> The persistent volume claim `my-pvc`

=== ConfigMaps, volumes and secrets

In the previous section, we have seen how to mount volumes, configs, and resources into the container.

The Kubernetes export command provides some shortcut options for adding configmaps and secrets as volume mounts.
The syntax is as follows:

[source,bash]
----
camel kubernetes export Sample.java --config [key]=[value] --resource [key]=[value] --volume [key]=[value]
----

The options expect the following syntax:

[cols="2m,5a"]
|===
|Option | Syntax

| config
| Add a runtime configuration from a ConfigMap or a Secret (syntax: [configmap\|secret]:name[/key], where name represents the configmap or secret name and key optionally represents the configmap or secret key to be filtered).

| resource
| Add a runtime resource from a Configmap or a Secret (syntax: [configmap\|secret]:name[/key][@path], where name represents the configmap or secret name, key optionally represents the configmap or secret key to be filtered and the path represents the destination path).

| volume
| Mount a volume into the integration container, for instance "--volume pvcname:/container/path".

|===

.Example
[source,bash]
----
camel kubernetes export Sample.java --config secret:my-credentials  --resource configmap:my-data --volume my-pvc:/container/path
----

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    camel.apache.org/integration: sample
  name: sample
spec:
  selector:
    matchLabels:
      camel.apache.org/integration: sample
  template:
    metadata:
      labels:
        camel.apache.org/integration: sample
    spec:
      containers:
        - image: quay.io/sample:1.0-SNAPSHOT
          name: sample
          volumeMounts:
            - mountPath: /etc/camel/conf.d/_secrets/my-credentials
              name: my-credentials #<1>
              readOnly: true
            - mountPath: /etc/camel/resources.d/_configmaps/my-data
              name: my-data #<2>
              readOnly: true
            - mountPath: /container/path
              name: my-pvc #<3>
              readOnly: false
      volumes:
        - name: my-credentials #<4>
          secret:
            secretName: my-credentials
        - name: my-data #<5>
          configMap:
            name: my-data
        - name: my-pvc #<6>
          persistentVolumeClaim:
            claimName: my-pvc
----
<1> The secret configuration volume mount
<2> The config map resource volume mount
<3> The volume mount
<4> The secret configuration volume
<5> The config map resource volume
<6> The persistent volume claim volume

The trait volume mounts follow some best practices in specifying the mount paths in the container. Configurations and resources, secrets, and configmaps do use different paths in the container. The Camel application is automatically configured to read these paths as resource folders, so you can use the mounted data in the Camel routes via classpath reference, for instance.

=== Ingress trait options

The ingress trait enhances the Kubernetes manifest with an Ingress resource to expose the application to the outside world. This requires the presence in the Kubernetes manifest of a Service Resource.

The ingress trait provides the following configuration options:

[cols="2m,1m,5a"]
|===
|Property | Type | Description

| ingress.enabled
| bool
| Can be used to enable or disable a trait. All traits share this common property (default `false`).

| ingress.annotations
| map[string]string
| The annotations added to the ingress. This can be used to set controller-specific annotations, e.g., when using the https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md[NGINX Ingress controller].

| ingress.host
| string
| To configure the host exposed by the ingress.

| ingress.path
| string
| To configure the path exposed by the ingress (default `/`).

| ingress.pathType
| string
| To configure the https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types[path type] exposed by the ingress. One of Exact, Prefix, ImplementationSpecific (default to Prefix).

| ingress.auto
| bool
| To automatically add an Ingress Resource whenever the route uses an HTTP endpoint consumer (default `true`).

| ingress.tls-hosts
| []string
| To configure specific hosts exposed through SNI TLS extension by the ingess.

| ingress.tls-secret-name
| string
| To indicate the secret containing the TLS private key and certificate to use for TLS.

|===

The syntax to specify container trait options is as follows:

[source,bash]
----
camel kubernetes export Sample.java --trait ingress.[key]=[value]
----

You may specify these options with the export command to customize the Ingress Resource specification.

[source,bash]
----
camel kubernetes export Sample.java --trait ingress.enabled=true --trait ingress.host=example.com --trait ingress.path=/sample(/|$)(.*) --trait ingress.pathType=ImplementationSpecific --trait ingress.annotations=nginx.ingress.kubernetes.io/rewrite-target=/\$2 --trait ingress.annotations=nginx.ingress.kubernetes.io/use-regex=true
----


This results in the following container specification in the Ingress resource.

[source,yaml]
----
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  annotations: #<1>
    nginx.ingress.kubernetes.io/rewrite-target: /$2
    nginx.ingress.kubernetes.io/use-regex: "true"
  labels:
    app.kubernetes.io/name: sample
  name: sample
spec:
  ingressClassName: nginx
  rules:
  - host: example.com
    http:
      paths:
      - backend:
          service:
            name: route-service
            port:
              name: http #<2>
        path: /sample(/|$)(.*) #<3>
        pathType: ImplementationSpecific #<4>


----
<1> Custom annotations configuration for ingress behavior
<2> Service port name
<3> Custom ingress backend path
<4> Custom ingress backend path type

=== Route trait options

The Route trait enhances the Kubernetes manifest with a Route resource to expose the application to the outside world. This requires the presence in the Kubernetes manifest of a Service Resource.

NOTE: You need to enable the OpenShift profile trait with `--trait-profile=openshift` option.

The Route trait provides the following configuration options:

[cols="2m,1m,5a"]
|===
|Property | Type | Description

| route.enabled
| bool
| Can be used to enable or disable a trait. All traits share this common property (default `false`).

| route.annotations
| map[string]string
| The annotations added to the route. This can be used to set https://docs.openshift.com/container-platform/4.16/networking/routes/route-configuration.html#nw-route-specific-annotations_route-configuration[openshift route specific annotations] options.

| route.host
| string
| To configure the host exposed by the route.

| route.tls-termination
| string
| The TLS termination type, like `edge`, `passthrough` or `reencrypt`. Refer to the OpenShift route documentation for additional information.

| route.tls-certificate
| string
| The TLS certificate contents or file (`file:absolute.path`). Refer to the OpenShift route documentation for additional information.

| route.tls-key
| string
| The TLS certificate key contents or file (`file:absolute.path`). Refer to the OpenShift route documentation for additional information.

| route.tls-ca-certificate
| string
| The TLS CA certificate contents or file (`file:absolute.path`). Refer to the OpenShift route documentation for additional information.

| route.tls-destination-ca-certificate
| string
| The destination CA contents or file (`file:absolute.path`). The destination CA certificate provides the contents of the CA certificate of the final destination. When using reencrypt termination, this file should be provided to have routers use it for health checks on the secure connection. If this field is not specified, the router may provide its own destination CA and perform hostname validation using the short service name (service.namespace.svc), which allows infrastructure generated certificates to automatically verify. Refer to the OpenShift route documentation for additional information.


| route.tls-insecure-edge-termination-policy
| string
| To configure how to deal with insecure traffic, e.g. `Allow`, `Disable` or `Redirect` traffic. Refer to the OpenShift route documentation for additional information.

|===

The syntax to specify container trait options is as follows:

[source,bash]
----
camel kubernetes export Sample.java --trait route.[key]=[value]
----

You may specify these options with the export command to customize the Route Resource specification.

[source,bash]
----
camel kubernetes export Sample.java --trait-profile=openshift -t route.enabled=true --trait route.host=example.com -t route.tls-termination=edge -t route.tls-certificate=file:/tmp/tls.crt -t route.tls-key=file:/tmp/tls.key
----


This results in the following container specification in the Route resource.

[source,yaml]
----
apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: route-service
spec:
  host: example.com #<1>
  port:
    targetPort: http #<2>
  tls:
    certificate: | #<3>
      ...
    key: | #<4>
      ...
    termination: edge #<5>
  to: #<6>
    kind: Service
    name: route-service
----
<1> Custom route host
<2> Service port name
<3> Custom route TLS certificate content
<4> Custom route TLS certificate key content
<5> Custom route TLS termination
<6> Service Resource reference


=== OpenApi specifications

You can mount OpenAPI specifications to the application container with this trait.

The openapi trait provides the following configuration options:

[cols="2m,1m,5a"]
|===
|Property | Type | Description

| openapi.configmaps
| []string
| The configmaps holding the spec of the OpenAPI

|===

The syntax to specify openapi trait options is as follows:

[source,bash]
----
camel kubernetes export Sample.java --trait openapi.[key]=[value]
----

.Example
[source,bash]
----
camel kubernetes export Sample.java --trait openapi.configmaps=configmap:my-spec
----

TIP: There is also a shortcut option `--open-api=configmap:my-configmap`.

[source,bash]
----
camel kubernetes export Sample.java --open-api configmap:[name-of-configmap]
----

This results in the following container specification in the Deployment resource.

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    camel.apache.org/integration: sample
  name: sample
spec:
  selector:
    matchLabels:
      camel.apache.org/integration: sample
  template:
    metadata:
      labels:
        camel.apache.org/integration: sample
    spec:
      containers:
      - image: quay.io/sample:1.0-SNAPSHOT
        name: sample
        volumeMounts:
            - mountPath: /etc/camel/resources.d/_configmaps/my-spec
              name: my-spec #<1>
              readOnly: true
      volumes:
        - name: my-spec #<2>
          configMap:
            name: my-spec
----
<1> OpenAPI specification volume mount
<2> Volume referencing the config map holding the OpenAPI specification

== Deploy to OpenShift

By default, the Kubernetes manifest is suited for plain Kubernetes platforms.
In case you are targeting OpenShift as a platform you may want to leverage special resources such as Route, ImageStream or BuildConfig.

You can set the `cluster-type=openshift` option on the export command to tell the Kubernetes plugin to create a Kubernetes manifest specifically suited for OpenShift.

Also, the default image builder is S2I for OpenShift clusters.
This means by setting the cluster type, you will automatically switch from default Jib to S2I.
Of course, you can tell the plugin to use Jib with `--image-builder=jib` option.
The image may then get pushed to an external registry (docker.io or quay.io) so OpenShift can pull as part of the deployment in the cluster.

TIP: When using S2I, you may need to explicitly set the `--image-group` option to the project/namespace name in the OpenShift cluster.
This is because S2I will push the container image to an image repository that uses the OpenShift project/namespace name as part of the image coordinates in the registry: `image-registry.openshift-image-registry.svc:5000/<project name>/<name>:<tag>`

When using S2I as an image build option, the Kubernetes manifest also contains an ImageStream and BuildConfig resource.
Both resources are automatically added/removed when creating/deleting the deployment with the Camel Kubernetes JBang plugin.

== Kubernetes run

The run command combines several steps into one single command.
The command performs a project export to a temporary folder, builds the project artifacts as well as the container images, pushes the image to an image registry and finally performs the deployment to Kubernetes using the generated Kubernetes manifest (`kubernetes.yml`).

[source,bash]
----
camel kubernetes run route.yaml --image-registry=kind
----

When connecting to a local Kubernetes cluster, you may need to specify the image registry where the application container image gets pushed to.
The run command is able to automatically configure the local registry when using predefined names such as `kind` or `minikube`, there is a detection mechanism to set some properties accordingly to the cluster type, currently it can auto detect Openshift and Minikube. If you want to disable the cluster detection, you have to set the `--disable-auto` cli parameter.

NOTE: When running minikube, the easiest way to push the image to the minikube container registry, is to enable the registry addon in minikube and to run `eval $(minikube docker-env)`.

Use the `--image-group` or the `--image` option to customize the container image.

[source,bash]
----
camel kubernetes run route.yaml --image-registry=kind --image-group camel-experts
----

The command above builds and pushes the container image: `localhost:5001/camel-experts/route:1.0-SNAPSHOT`.

[source,bash]
----
camel kubernetes run route.yaml --image quay.io/camel-experts/demo-app:1.0
----

The `--image` option forces the container image group, name, version as well as the image registry.

=== Customize the Kubernetes manifest

The `run` command provides the same options to customize the Kubernetes manifest as the `export` command.
You may want to add environment variables, mount secrets and configmaps, adjust the exposed service and many other things with trait options as described in the export command section.

=== Auto reload with `--dev` option

The `--dev` option runs the application on Kubernetes and automatically adds a file watcher to listen for changes on the Camel route source files.
In case the sources get changed, the process will automatically perform a rebuild and redeployment.
The command constantly prints the logs to the output, so you may see the changes directly being applied to the Kubernetes deployment.

[source,bash]
----
camel kubernetes run route.yaml --image-registry=kind --dev
----

You need to terminate the process to stop the dev mode.
This automatically removes the Kubernetes deployment from the cluster on shutdown.

NOTE: On macOS hosts, the file watch mechanism is known to be much slower and less stable compared to using the `--dev` option on other operating systems like Linux.
This is due to limited native file operations on macOS for Java processes.

== Show logs

To inspect the log output of a running deployment call:

[source,bash]
----
camel kubernetes logs --name=route
----

The command connects to the running integration Pod on the cluster and streams the log output.
Just terminate the process to stop printing the logs.

The `--name` option should point to a previously exported project (either via `run` or `export` command).

== Delete deployments

Of course, you may also delete a deployment from the cluster.

[source,bash]
----
camel kubernetes delete --name=route
----

Use the `--name` option to select a previously exported project (either via `run` or `export` command).
The delete operation will remove all resources defined in the Kubernetes manifest.

If you used the `--cluster-type` option to create your project (either via `run` or `export` command) you will need to use it as well for the delete operation.

[source,bash]
----
camel kubernetes delete --name=route --cluster-type=openshift
----

== Minikube deployment tips and troubleshooting

To run a local Kubernetes cluster with Minikube for development purposes.
Here are some tips from users that have been using this.

The following steps have been known to be working with Camel 4.8.1+:

1. `minikube start --addons registry --driver=docker`
2. `eval $(minikube -p minikube docker-env)`
3. `camel kubernetes run demo.camel.yaml --cluster-type=minikube --build-property=quarkus.kubernetes.image-pull-policy=Never`

Most important `--build-property=quarkus.kubernetes.image-pull-policy=Never` without that it is not working, which is not clear from the current Minikube docs.

The following steps have been known to be working with Camel 4.9+:

1. `minikube start --addons registry --driver=docker`
2. `eval $(minikube -p minikube docker-env)`
3. `camel kubernetes run demo.camel.yaml --cluster-type=minikube --build-property=quarkus.kubernetes.image-pull-policy=Never --trait container.image-push=true --image-registry '$(kubectl -n kube-system get service registry -o jsonpath='{.spec.clusterIP}')' --image-builder=docker`

The following steps have been known to be working with Camel 4.10+:

1. `minikube start --addons registry --driver=docker`
2. `eval $(minikube -p minikube docker-env)`
3. `camel kubernetes run demo.camel.yaml --cluster-type=minikube --build-property=quarkus.kubernetes.image-pull-policy=Never --image-registry "$(kubectl -n kube-system get service registry -o jsonpath='{.spec.clusterIP}')" --image-builder=docker`

Note that Docker multi-platform build is used. It requires to have followed these https://docs.docker.com/build/building/multi-platform/#build-multi-platform-images[Docker requirements].

= Camel JBang

A JBang-based Camel app for easily running Camel routes.

== Installation

First, you must install https://www.jbang.dev/[JBang], which is used for launching Camel.
See instructions on https://www.jbang.dev/download/[JBang] how to download and install.

After JBang is installed, you can verify JBang is working by executing the following command from a command shell:

[source,bash]
----
jbang version
----

Which should output the version of JBang.

To make it easier to use Camel JBang, then install the following:

[source,bash]
----
jbang app install camel@apache/camel
----

This will install Apache Camel as the `camel` command within JBang, meaning that you can run Camel from the command line
by just executing `camel` (see more next).

Note: It requires access to the internet, in case of using a proxy, please ensure that the proxy is configured for your system.
If Camel JBang is not working with your current configuration,
please look to https://www.jbang.dev/documentation/guide/latest/configuration.html#proxy-configuration[Proxy configuration in JBang documentation].

== Container Image

There is also a container image available in https://hub.docker.com/r/apache/camel-jbang/[Dockerhub]

[source,bash]
----
docker pull apache/camel-jbang:4.4.0
----

or

[source,bash]
----
podman pull apache/camel-jbang:4.4.0
----

Once you have the image in your local registry, you can run all the commands listed below by simple doing:

[source,bash]
----
docker run apache/camel-jbang:4.4.0 version
----

or

[source,bash]
----
podman run apache/camel-jbang:4.4.0 version
----

This will print the following result:

[source,bash]
----
Camel JBang version: 4.4.0
----

So running a simple route will be as easy as doing the following:

[source,bash]
----
docker run -v .:/integrations apache/camel-jbang:4.4.0 run /integrations/example.yaml
----

or

[source,bash]
----
podman run -v .:/integrations apache/camel-jbang:4.4.0 run /integrations/example.yaml
----

== Using Camel JBang

The Camel JBang supports multiple commands. Running the command below will print all of them:

[source,bash]
----
camel --help
----

TIP: The first time you run this command, it may cause dependencies to be cached, therefore taking a few extra seconds to run. If you are already using JBang and you get first time to run errors such as `Exception in thread "main" java.lang.NoClassDefFoundError: "org/apache/camel/dsl/jbang/core/commands/CamelJBangMain"` you may try clearing the JBang cache and re-install again.

All the commands support the `--help` and will display the appropriate help if that flag is provided.

=== Enable shell completion

Camel JBang provides shell completion for bash and zsh out of the box. To enable shell completion for Camel JBang, run:

[source,bash]
----
source <(camel completion)
----

To make it permanent, run:

[source,bash]
----
echo 'source <(camel completion)' >> ~/.bashrc
----

== REPL loop

A simple read-eval-print loop is available, you can launch it with:

[source, bash]
----
camel shell
----

== Creating and running Camel routes

You can create a new basic routes with the `init` command.

For example, to create an XML route, you can run:

[source,bash]
----
camel init cheese.xml
----

Which creates the file `cheese.xml` (in the current directory) with a sample route.

To run the file, you do:

[source,bash]
----
camel run cheese.xml
----

NOTE: You can create and run any of the supported xref:dsl.adoc[DSLs] in Camel such as YAML, XML, Java, Groovy.

To create a new .java route, you simply do:

[source,bash]
----
camel init foo.java
----

When using the init command, then Camel will by default create the file in the current directory.
However, you can use
the `--directory` option to create the file in the specified directory.
For example, to create in a folder
named `_foobar_` you can do:

[source,bash]
----
camel init foo.java --directory=foobar
----

=== Running Routes from multiple files

You can run more than one file, for example, to run two YAML files you can do:

[source,bash]
----
camel run one.yaml two.yaml
----

You can also mix different xref:dsl.adoc[DSLs] such as YAML and Java:

[source,bash]
----
camel run one.yaml hello.java
----

You can also use wildcards (i.e. `*`) to match multiple files, such as running all the YAML files:

[source,bash]
----
camel run *.yaml
----

Or you can run all files starting with foo*

[source,bash]
----
camel run foo*
----

And to run everything

[source,bash]
----
camel run *
----

TIP: The run goal can also detect files that are `properties`, such as `application.properties`.

=== Running a Maven or Gradle based project

Camel JBang is intended for flat-file-based projects, where you run small integrations.
However, Camel JBang may be used as a tool for migrating existing Maven or Gradle based projects.
To make the migration easier, then JBang can do _best effort_ to run, export, or transform these projects.

For example, if you have a Maven-based project, you can execute

[source,bash]
----
camel run pom.xml
----

or for a Gradle project

[source,bash]
----
camel run build.gradle
----

Camel JBang will then scan in `src/main/java` and `src/main/resources` for files to include (recursive).

NOTE: Using `camel run pom.xml` is not intended as a fully compatible way of running an existing Maven-based project. It cannot start Quarkus or Spring Boot applications; instead, use the proper plugins/commands. The command is mainly used to migrate from old projects.

=== Running Route with user interactive prompt for placeholder values

You can create Camel integrations that makes it possible for the user to quickly enter placeholder values from command prompt.

For example, given the following route:

[source,java]
----
import org.apache.camel.builder.RouteBuilder;

public class foo extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        from("timer:java?period={{time:1000}}")
            .setBody()
                .simple("Hello Camel from {{you}}")
            .log("${body}");
    }
}
----

Then if you run this with:

[source,bash]
----
camel run foo.java
----

You will have an exception on startup about the missing value
[source,text]
----
Caused by: java.lang.IllegalArgumentException: Property with key [you] not found in properties from text: Hello Camel from {{you}}`
----

However, you can then run in prompt mode as follows:

[source,bash]
----
camel run foo.java --prompt
----

And Camel will now prompt in the terminal for you to enter values for the placeholders:

[source,bash]
----
2023-12-15 21:46:44.218  INFO 15033 --- [           main] org.apache.camel.main.MainSupport   : Apache Camel (JBang) 4.7.0 is starting
2023-12-15 21:46:44.331  INFO 15033 --- [           main] org.apache.camel.main.MainSupport   : Using Java 17.0.5 with PID 15033. Started by davsclaus in /Users/davsclaus/workspace/deleteme/prompt
2023-12-15 21:46:45.360  INFO 15033 --- [           main] mel.cli.connector.LocalCliConnector : Management from Camel JBang enabled
Enter optional value for time (1000):
Enter required value for you: Jack
2023-12-15 21:46:55.239  INFO 15033 --- [           main] el.impl.engine.AbstractCamelContext : Apache Camel 4.7.0 (foo) is starting
2023-12-15 21:46:55.323  INFO 15033 --- [           main] g.apache.camel.main.BaseMainSupport : Property-placeholders summary
2023-12-15 21:46:55.323  INFO 15033 --- [           main] g.apache.camel.main.BaseMainSupport :     [prompt]                       you=Jack
2023-12-15 21:46:55.341  INFO 15033 --- [           main] el.impl.engine.AbstractCamelContext : Routes startup (started:1)
----

From the snippet above, Camel JBang had two prompts. First for the `time` which has a default value of `1000` so you can just press ENTER to accept the default value.
And for `you` a value must be entered, and we entered `Jack` in this example.

You may want to use this for Camel prototypes where you want the user to be able to enter custom values quickly.
Those values can of course be pre-configured in `application.properties` as well.

=== Running Route from input parameter

For very small Java routes then it is possible to provide the route as CLI argument, as shown below:

[source,bash]
----
camel run --code='from("kamelet:beer-source").to("log:beer")'
----

This is very limited as the CLI argument is a bit cumbersome to use than files.

- Java DSL code is only supported
- Code wrapped in single quote, so you can use double quote in Java DSL
- Code limited to what literal values possible to provide from the terminal and JBang.
- All route(s) must be defined in a single `--code` parameter.

NOTE: Using `--code` is only usable for very quick and small prototypes.

From *Camel 4.7* onwards the `--code` parameter can also refer to a `.java` source file,
that are not wrapped in a `public class` which makes it possible to quickly try a prototype
with some Camel java based routes such as the following stored in a file named `quick.java`:

[source,java]
----
from("timer:java?period=1000")
    .setBody()
        .simple("Hello Quick Camel from ${routeId}")
    .log("${body}");
----

Then you can run this route via:

[source,bash]
----
camel run --code=quick.java
----

NOTE: You cannot use `--dev` to hot-reload this on code changes.

=== Running Routes from source directory

You can also run dev mode when running Camel with `--source-dir`, such as:

[source,bash]
----
camel run --source-dir=mycode
----

This starts Camel where it will load the files from the _source dir_ (also subfolders).

=== Stub components that should not be active

Sometimes you need to troubleshoot an existing integration and is given some Camel code (routes).
These routes may use different components, and those components may be tricky to run as they are configured
in a custom way, or need connection to servers you may not have access to.

You can run Camel JBang by stubbing those components (or all of them).

For example, suppose you need access to a JMS broker in the given route below.

[source,java]
----
from("jms:inbox")
  .log("Incoming order")
  .to("bean:transform")
  .log("After transformation")
  .to("jms:process");
----

Then you can run this by stub the `jms` component by:

[source,bash]
----
camel run syncToDatabase.java --stub=jms
----

Then Camel will not start up the JMS component but replace it with the `stub` component, but keep the actual endpoint URIs.

You can then simulate sending messages to Camel with the `cmd send` command:

[source,bash]
----
camel cmd send --body='Something here'
----

Which then will send the message to the incoming endpoint in the route, i.e. `jms:inbox` which has been stubbed.

You can also stub a specific endpoint by providing the full uri, such as:

[source,bash]
----
camel run syncToDatabase.java --stub=jms:inbox
----

Then only the `jms:inbox` endpoint is stubbed.

TIP: You can stub multiple components separated by comma, such as `--stub=jms,sql`

Camel JBang comes with the `camel cmd stub` command that allows to list all endpoints that
has been stubbed, and also browse any messages that are currently present in their internal queues.
A stub endpoint is based on the `seda` component.

[source,bash]
----
camel cmd stub
----

And to browse the messages:

[source,bash]
----
camel cmd stub --browse
----

=== Dev mode with live reload

You can enable dev mode that comes with live reload of the route(s) when the source file is updated (saved),
using the `--dev` options as shown:

[source,bash]
----
camel run foo.yaml --dev
----

Then, while the Camel integration is running, you can update the YAML route and update when saving.

This works for all DSLs, even java, so you can do:

[source,bash]
----
camel run hello.java --dev
----

NOTE: The live reload is meant for development purposes, and if you encounter problems with reloading
such as JVM class loading issues, then you may need to restart the integration. Java files cannot
be supported in Spring Boot runtime since they have to be recompiled to trigger a restart.

You can also run dev mode when running Camel with `--source-dir`, such as:

[source,bash]
----
camel run --source-dir=mycode --dev
----

This starts Camel where it will load the files from the _source dir_ (also subfolders).
And in _dev mode_ then you can add new files, update existing files, and delete files, and Camel
will automatically hot-reload on the fly.

Using _source dir_ is more flexible than having to specify the files in the CLI as shown below:

[source,bash]
----
camel run mycode/foo.java mycode/bar.java --dev
----

In this situation, then Camel will only watch and reload these two files (foo.java and bar.java).
So, for example, if you add a new file cheese.xml, then this file is not reloaded. On the other hand,
if you use `--source-dir` then any files in this directory (and subfolders) are automatic detected
and reloaded. You can also delete files to remove routes.

NOTE: You cannot use both files and source dir together.
The following is not allowed: `camel run abc.java --source-dir=mycode`.

==== Uploading files to source directory via HTTP

When running Camel JBang with `--source-dir`, `--console` and `--dev` (reloading) then you can
change the source files on-the-fly by copying, modifying or deleting the files in the source directory.

This can also be done via HTTP using the `q/upload/:filename` HTTP endpoint using PUT and DELETE verbs.

Suppose that you run Camel JBang with:

[source,bash]
----
camel run --source-dir=mycode --console --dev
----

Then you can upload or modify a source file named `bar.java` you can send a PUT request via curl:

[source,bash]
----
curl -X PUT http://0.0.0.0:8080/q/upload/bar.java --data-binary "@bar.java"
----

Or via:

[source,bash]
----
curl -T bar.java http://0.0.0.0:8080/q/upload/bar.java
----

To send the data via PUT, then the file body can be included when using `Content-Type: application/x-www-form-urlencoded`:

For example, from a CURL `--trace-ascii log.txt`:

[source,text]
----
0000: PUT /q/upload/bar.java HTTP/1.1
0021: Host: 0.0.0.0:8080
0035: User-Agent: curl/7.87.0
004e: Accept: */*
005b: Content-Length: 385
0070: Content-Type: application/x-www-form-urlencoded
00a1:
=> Send data, 385 bytes (0x181)
0000: // camel-k: language=java..import org.apache.camel.builder.Route
0040: Builder;..public class bar extends RouteBuilder {..    @Override
0080: .    public void configure() throws Exception {..        // Writ
00c0: e your routes here, for example:.        from("timer:java?period
0100: ={{time:1000}}").            .setBody().                .simple(
0140: "XXXCamel from ${routeId}").            .log("${body}");.    }.}
0180: .
== Info: Mark bundle as not supporting multiuse
<= Recv header, 17 bytes (0x11)
0000: HTTP/1.1 200 OK
<= Recv header, 19 bytes (0x13)
0000: content-length: 0
<= Recv header, 2 bytes (0x2)
0000:
== Info: Connection #0 to host 0.0.0.0 left intact
----

To delete one or more files, you use the DELETE verb, such as:

[source,bash]
----
curl -X DELETE http://0.0.0.0:8080/q/upload/bar.java
----

You can also use wildcards ('*') to delete all .java files:

[source,bash]
----
curl -X DELETE http://0.0.0.0:8080/q/upload/*.java
----

Or to delete everything

[source,bash]
----
curl -X DELETE http://0.0.0.0:8080/q/upload/*
----

=== Developer Console

You can enable the developer console, which presents a variety of information to the developer.

[source,bash]
----
camel run hello.java --console
----

The console is then accessible from a web browser at: http://localhost:8080/q/dev (by default).
The link is also shown in the log when Camel is starting up.

The console can give you insights into your running Camel integration, such as reporting the top
routes that takes the longest time to process messages. You can then drill down to pinpoint exactly
which individual EIPs in these routes are the slowest.

The developer console can also output the data in JSON format, which, for example, can be used by 3rd-party tooling
to scrape the information.

For example, to output the top routes via curl, you can execute:

[source,bash]
----
curl -s -H "Accept: application/json"  http://0.0.0.0:8080/q/dev/top/
----

And if you have `jq` installed which can format and output the JSON data in color, then do:

[source,bash]
----
curl -s -H "Accept: application/json"  http://0.0.0.0:8080/q/dev/top/ | jq
----

[#_using_profiles]
=== Using profiles

*Available from Camel 4.5*

Camel JBang comes with three sets of profiles

- `dev`:for development (default)
- `test`:for testing (currently same as production)
- `prod`:for production

The developer profile will pre-configure Camel JBang with a number of developer assisted features when
running Camel. For example, tracing messages during routing, additional metrics collected, and more.
This is useful during development and also enhanced the Camel JBang CLI tool.

However, you may want to run Camel JBang in a production-like scenario, which you can do with:

[source,bash]
----
camel run hello.java --profile=prod
----

You can have profile-specific configuration in configuration files using the naming style `application-<profile>.properties`,
such as in the following:

- `application.properties`: common configuration that is always in use (default).
- `application-dev.properties`: developer specific configuration for  the `dev` profile.
- `application-prod.properties`: developer specific configuration for  the `prod` profile.

The profile-specific configuration will override values in the common configuration.

=== Downloading JARs over the internet

By default, Camel JBang will automatically resolve dependencies needed to run Camel, which is done
by JBang and Camel respectively. Camel itself detects at runtime if a component has a need for JARs that
are not currently available on the classpath, and can then automatically download the JARs (incl transitive).

Camel will download these JARs in the following order:

1. from local disk in `~/.m2/repository`
2. from the internet in Maven Central
3. from the internet from custom third-party Maven repositories
4. from all the repositories found in active profiles of `~/.m2/settings.xml` or a settings file specified using
`--maven-settings` option.

If you do not want Camel JBang to download over the internet, you can turn this off with `--download`, as shown below:

[source,bash]
----
camel run foo.java --download=false
----

If you do not want Camel JBang to use your existing Maven settings file, you can use:

[source,bash]
----
camel run foo.java --maven-settings=false
----

[#_adding_custom_jars]
=== Adding custom JARs

Camel JBang will automatically detect dependencies for Camel components, languages, data formats, etc. that
from its own release. This means you often do not have to specify which JARs to use.

However, if you need to add 3rd-party custom JARs, then you can specify these with `--dep` as CLI argument in Maven
GAV syntax (`groupId:artifactId:version`), such as:

[source,bash]
----
camel run foo.java --dep=com.foo:acme:1.0
----

In case you need to explicit add a Camel dependency you can use a shorthand syntax (starting with `camel:` or `camel-`)
such as:

[source,bash]
----
camel run foo.java --dep=camel-saxon
----

You can specify multiple dependencies separated by comma:

[source,bash]
----
camel run foo.java --dep=camel-saxon,com.foo:acme:1.0
----

=== Using 3rd-party Maven repositories

Camel JBang will download from local repository first, and then online from Maven Central.
To be able to download from 3rd-party Maven repositories then you need to specify this as CLI argument,
]or in `application.properties`

[source,bash]
----
camel run foo.java --repos=https://packages.atlassian.com/maven-external
----

TIP: Multiple repositories can be separated by comma

The configuration for the 3rd-party Maven repositories can also be configured in `application.properties`
with the key `camel.jbang.repos` as shown:

[source,properties]
----
camel.jbang.repos=https://packages.atlassian.com/maven-external
----

And when running Camel then `application.properties` is automatically loaded:

[source,bash]
----
camel run foo.java
----

However, you can also explicitly specify the properties file to use:

[source,bash]
----
camel run foo.java application.properties
----

And even better if you specify this as a profile:

[source,bash]
----
camel run foo.java --profile=application
----

Where the profile id is the name of the properties file.


=== Configuration of Maven usage

By default, existing `~/.m2/settings.xml` file is loaded, so it is possible to alter the behaviour of Maven resolution
process. Maven settings file can provide information about Maven mirrors, credential configuration (potentially
encrypted) or active profiles, and additional repositories.

Maven repositories can use authentication and the Maven-way to configure credentials is through `<server>` elements,
like this:

[source,xml]
----
<server>
    <id>external-repository</id>
    <username>camel</username>
    <password>{SSVqy/PexxQHvubrWhdguYuG7HnTvHlaNr6g3dJn7nk=}</password>
</server>
----

While the password may be specified using plain text, it's better to configure maven master password first and then
use it to configure repository password:

[source,bash]
----
$ mvn -emp
Master password: camel
{hqXUuec2RowH8dA8vdqkF6jn4NU9ybOsDjuTmWvYj4U=}
----

The above password should be added to `~/.m2/settings-security.xml` file like this:

[source,xml]
----
<settingsSecurity>
  <master>{hqXUuec2RowH8dA8vdqkF6jn4NU9ybOsDjuTmWvYj4U=}</master>
</settingsSecurity>
----

Then a normal password can be configured like this:

[source,bash]
----
$ mvn -ep
Password: camel
{SSVqy/PexxQHvubrWhdguYuG7HnTvHlaNr6g3dJn7nk=}
----

Finally, such passwords can be used in `<server>/<password>` configuration.

By default, Maven reads the master password from `~/.m2/settings-security.xml` file, but we can override it.
The location of the `settings.xml` file itself can be specified as well:

[source,bash]
----
camel run foo.java --maven-settings=/path/to/settings.xml --maven-settings-security=/path/to/settings-security.xml
----

If you want to run Camel application without assuming any location (even `~/.m2/settings.xml`), use this option:

[source,bash]
----
camel run foo.java --maven-settings=false
----


=== Running routes hosted on GitHub

You can run a route hosted on GitHub using Camels xref:components:others:resourceresolver-github.adoc[GitHub] resource loader.

For example, to run one of the Camel Kamelets examples, you can do:

[source,bash]
----
camel run github:apache:camel-kamelets-examples:jbang/hello-java/Hey.java
----

You can also use the `https` URL for GitHub. For example, you can browse the examples from a web-browser and
then copy the URL from the browser window and run the example with Camel JBang:

[source,bash]
----
camel run https://github.com/apache/camel-kamelets-examples/tree/main/jbang/hello-java
----

You can also use wildcards (i.e. `*`) to match multiple files, such as running all the groovy files:

[source,bash]
----
camel run https://github.com/apache/camel-kamelets-examples/tree/main/jbang/languages/*.groovy
----

Or you can run all files starting with rou*

[source,bash]
----
camel run https://github.com/apache/camel-kamelets-examples/tree/main/jbang/languages/rou*
----

==== Running routes from GitHub gists

Using gists from GitHub is a quick way to share small Camel routes that you can easily run.

For example, to run a gist, you can execute:

[source,bash]
----
camel run https://gist.github.com/davsclaus/477ddff5cdeb1ae03619aa544ce47e92
----

A gist can contain one or more files, and Camel JBang will gather all relevant files, so a gist
can contain multiple routes, properties files, Java beans, etc.

=== Downloading routes hosted on GitHub

We have made it easy for Camel JBang to download existing examples from GitHub to local disk,
which allows for modifying the example and to run locally.

All you need to do is to copy the https link from the web browser.
For example, you can download the _dependency injection_ example by:

[source,bash]
----
camel init https://github.com/apache/camel-kamelets-examples/tree/main/jbang/dependency-injection
----

Then the files (not subfolders) are downloaded to the current directory.
The example can then be run locally with:

[source,bash]
----
camel run *
----

You can also download to a new folder using the `--directory` option, for example, to download to a folder named _myproject_,
you would do:

[source,bash]
----
camel init https://github.com/apache/camel-kamelets-examples/tree/main/jbang/dependency-injection --directory=myproject
----

You can also run in dev mode, to hot-deploy on source code changes.

[source,bash]
----
camel run * --dev
----

You can also download a single file, such as one of the Camel Kamelets examples:

[source,bash]
----
camel init https://github.com/apache/camel-kamelets-examples/blob/main/jbang/hello-yaml/hello.camel.yaml
----

This is a groovy route, which you can run with (or use `*`):

[source,bash]
----
camel run simple.groovy
----

==== Downloading routes form GitHub gists

You can also download files from gists easily as shown:

[source,bash]
----
camel init https://gist.github.com/davsclaus/477ddff5cdeb1ae03619aa544ce47e92
----

This will then download the files to local disk, which you can run afterward:

[source,bash]
----
camel run *
----

You can also download to a new folder using the `--directory` option, for example, to download to a folder named _foobar_,
you would do:

[source,bash]
----
camel init https://gist.github.com/davsclaus/477ddff5cdeb1ae03619aa544ce47e92 --directory=foobar
----

=== Using a specific Camel version

You can specify which Camel version to run as shown:

[source,bash]
----
jbang -Dcamel.jbang.version=3.18.4 camel@apache/camel [command]
----

NOTE: Older versions of Camel may not work as well with Camel JBang as the newest versions.
Starting from Camel 3.20 onwards are the versions that are recommended to be used onwards.

TIP: In Camel *3.20.3* onwards there is a `version` command, see the following section for more details.

In *Camel 3.20.2* onwards the `run` command has built-in support, using `--camel-version`,
for specifying the Camel version to use for the running Camel integration.

[source,bash]
----
camel run * --camel-version=3.18.4
----

TIP: This makes it easy to try different Camel versions, for example, when you need to reproduce an issue,
and find out how it works in a different Camel version.

You can also try bleeding-edge development by using SNAPSHOT such as:

[source,bash]
----
jbang --fresh -Dcamel.jbang.version=3.21.0-SNAPSHOT camel@apache/camel [command]
----

=== Using the version command

In *Camel 3.20.3* onwards the `version` command makes it possible to configure a specific version
of Camel to use when running or exporting. This makes it possible to use the latest Camel JBang CLI
and run integrations using an older Camel version.

[source,bash]
----
camel version
Camel JBang version: 3.20.3
----

Here Camel JBang is using version 3.20.3. Now suppose we want to run Camel integrations with version 3.18.2.

[source,bash]
----
camel version set 3.18.2
----

And you can see what Camel version has been set by:

[source,bash]
----
camel version
Camel JBang version: 3.20.3
User configuration:
    camel-version = 3.18.2
----

And when running an integration, then Camel JBang will show you the _overridden version_ when starting.

[source,bash]
----
camel run foo.java
Running integration with the following configuration:
    --camel-version=3.18.2
2023-03-17 13:35:13.876  INFO 28451 --- [           main] org.apache.camel.main.MainSupport        : Apache Camel (JBang) 3.18.2 is starting
...
----

IMPORTANT: You cannot use both a set version via `camel version set` and also a version specified via `--camel-version` option,
i.e., the following is not possible:

[source,bash]
----
camel version set 4.0.1
camel run * --camel-version=4.3.0
----

If you want to unset the version, you can use the `--reset` option:

[source,bash]
----
camel version set --reset
----

Then the Camel version in use will be the same version as Camel JBang.

==== Listing available Camel releases

The `version` command can also show available Camel releases by checking the Maven central repository.

[source,bash]
----
camel version list
 CAMEL VERSION   JDK   KIND     RELEASED     SUPPORTED UNTIL
    3.14.0       8,11  LTS    December 2021    December 2023
    3.14.1       8,11  LTS     January 2022    December 2023
    3.14.2       8,11  LTS       March 2022    December 2023
    3.14.3       8,11  LTS         May 2022    December 2023
    3.14.4       8,11  LTS        June 2022    December 2023
    3.14.5       8,11  LTS      August 2022    December 2023
    3.14.6       8,11  LTS    November 2022    December 2023
    3.14.7       8,11  LTS    December 2022    December 2023
    3.15.0         11         February 2022
    3.16.0         11            March 2022
    3.17.0      11,17              May 2022
    3.18.0      11,17  LTS        July 2022        July 2023
    3.18.1      11,17  LTS      August 2022        July 2023
    3.18.2      11,17  LTS   September 2022        July 2023
    3.18.3      11,17  LTS     October 2022        July 2023
    3.18.4      11,17  LTS    December 2022        July 2023
    3.18.5      11,17  LTS     January 2023        July 2023
    3.19.0      11,17          October 2022
    3.20.0      11,17  LTS    December 2022    December 2023
    3.20.1      11,17  LTS     January 2023    December 2023
    3.20.2      11,17  LTS    February 2023    December 2023
   4.0.0-M1        17   RC    February 2023
   4.0.0-M2        17   RC       March 2023
----

NOTE: The `version list` shows the latest releases going back a few versions, at this time of writing the minimum version
is Camel 3.14. To show all Camel 3.x releases, you can specify `--from-version=3.0` and the list is longer.
The list can only go back to Camel 2.18, as we do not have all release meta-data for older releases.

You can also show Camel releases for either Spring Boot or Quarkus using the `--runtime` option, such as:

[source,bash]
----
camel version list --runtime=quarkus
 CAMEL VERSION  QUARKUS   JDK  KIND     RELEASED     SUPPORTED UNTIL
    3.14.0       2.6.0     11         December 2021
    3.14.1       2.7.0     11  LTS    February 2022      August 2022
    3.14.2       2.7.1     11  LTS       April 2022      August 2022
    3.14.4       2.7.2     11  LTS        July 2022      August 2022
    3.15.0      2.8.0-M1   11            March 2022
    3.16.0       2.8.0     11            April 2022
    3.16.0       2.9.0     11              May 2022
    3.17.0       2.10.0    11             June 2022
    3.18.0       2.11.0    11             July 2022
    3.18.1       2.12.0    11        September 2022
    3.18.2       2.13.0    11  LTS   September 2022       March 2023
    3.18.3       2.13.1    11  LTS    November 2022       March 2023
    3.18.3       2.13.2    11  LTS    December 2022       March 2023
    3.19.0       2.14.0    11         November 2022
    3.19.0       2.15.0    11         December 2022
    3.20.1       2.16.0    11          January 2023
----

TIP: See more options with `camel version list --help`.

=== Manage plugins

Camel JBang uses a plugin concept for some of the subcommands so users can add functionality on demand.
Each provided plugin adds a list of commands to the Camel JBang command line tool.

You can list the supported plugins with

[source,bash]
----
camel plugin get --all
----

[source,text]
----
Supported plugins:

 NAME        COMMAND     DEPENDENCY                                      DESCRIPTION
 kubernetes  kubernetes  org.apache.camel:camel-jbang-plugin-kubernetes  Run Camel applications on Kubernetes
 generate    generate    org.apache.camel:camel-jbang-plugin-generate    Generate code such as DTOs
----

In case you want to enable a plugin and its functionality, you can add it as follows:

[source,bash]
----
camel plugin add <plugin-name>
----

For example to install `generate` you execute:

[source,bash]
----
camel plugin add generate
----

This adds the plugin, and all subcommands are now available for execution.

You can list the currently installed plugins with:

[source,bash]
----
camel plugin get
----

To remove a plugin from the current Camel JBang command line tooling, you can use the `plugin delete` command.

[source,bash]
----
camel plugin delete <plugin-name>
----

=== Running Pipes

Camel also supports running pipes, which represent Kubernetes custom resources following a specific CRD format (Kubernetes Custom Resource Definitions).

For example, a pipe file named `joke.yaml`:

[source,yaml]
----
#!/usr/bin/env jbang camel@apache/camel run
apiVersion: camel.apache.org/v1
kind: Pipe
metadata:
  name: joke
spec:
  source:
    ref:
      kind: Kamelet
      apiVersion: camel.apache.org/v1
      name: chuck-norris-source
    properties:
      period: 2000
  sink:
    ref:
      kind: Kamelet
      apiVersion: camel.apache.org/v1
      name: log-sink
    properties:
      show-headers: false
----

Can be run with camel:

[source,bash]
----
camel run joke.yaml
----

==== Binding Kamelets in a pipe

Camel JBang is able to create the Pipe custom resource for you.
You can use the `bind` command to specify a source and a sink that should be set in the pipe.
As a result, Camel JBang will create a proper Pipe custom resource for you.

The command expects a file name as command argument and provides several options to define the source and the sink that should be used in the pipe.

[source,bash]
----
camel bind joke.yaml --source chuck-norris-source --sink log-sink
----

This creates the `joke.yaml` file that represents the Pipe resource.

[source,yaml]
----
apiVersion: camel.apache.org/v1
kind: Pipe
metadata:
  name: joke
spec:
  source:
    ref:
      kind: Kamelet
      apiVersion: camel.apache.org/v1
      name: chuck-norris-source
    properties:
      period: 5000
  sink:
    ref:
      kind: Kamelet
      apiVersion: camel.apache.org/v1
      name: log-sink
----

NOTE: The bind command is able to inspect the Kamelets being used as a source and sink in order to automatically set all required properties.
In case the Kamelet defines a required property, and the user has not specified such, the command will automatically set this property with an example value.
Once the pipe resource file is generated, you can review and set the properties as you wish.

The bind command supports the following options:

[width="100%",cols="1m,3",options="header",]
|=======================================================================
|Option |Description

|--source
|Source (from) such as a Kamelet or Camel endpoint uri that provides data.

|--sink
|Sink (to) such as a Kamelet or Camel endpoint uri where data should be sent to.

|--step
|Add optional 1-n steps to the pipe processing. Each step represents a reference to a Kamelet of type action.

|--property
|Add a pipe property in the form of `[source,sink,error-handler,step-<n>].<key>=<value>` where `<n>` is the step number starting from 1.

|--error-handler
|Add error handler (none,log,sink:<endpoint>). Sink endpoints are expected in the format [[apigroup/]version:]kind:[namespace/]name, plain Camel URIs or Kamelet name.

|--output
|Output format generated by this command (supports: file, YAML or JSON). Default is "file".
|=======================================================================

==== Binding explicit Camel URIs

Usually, the source and sink reference a Kamelet by its name as shown in the previous section.
As an alternative, you can also just use an arbitrary Camel endpoint URI that acts as a source or sink in the pipe.

[source,bash]
----
camel bind joke.yaml --source chuck-norris-source --sink https://mycompany.com/the-service
----

As a result, the Pipe resource uses the Camel endpoints as source and sink.

[source,yaml]
----
apiVersion: camel.apache.org/v1
kind: Pipe
metadata:
  name: my-pipe
spec:
  source:
# ...
  sink:
    uri: https://mycompany.com/the-service # <1>
----
<1> Pipe with explicit Camel endpoint URI as sink where the data gets pushed to

=== Creating a new Kamelet

You can create a new kamelet with the `init` command by using kamelet naming convention.

For example, to create a new kamelet source, you can do:

[source,bash]
----
camel init cheese-source.kamelet.yaml
----

This will create a basic kamelet (based on the timer source).

And to use the kamelet, you could create the following route:

[source,yaml]
----
- from:
    uri: "kamelet:cheese-source"
    parameters:
      period: "2000"
      message: "Hello World"
    steps:
      - log: "${body}"
----

If you want to create a sink kamelet, then you just name it with sink as follows (based on log sink):

[source,bash]
----
camel init wine-sink.kamelet.yaml
----

You can then change the route to use the wine kamelet as follows:

[source,yaml]
----
- from:
    uri: "kamelet:cheese-source"
    parameters:
      period: "2000"
      message: "Hello World"
    steps:
      - to: "kamelet:wine-sink"
----

If you want to create a new Kamelet based on an existing Kamelet, for example, to create a new sink based on the existing MySQL:

[source,bash]
----
camel init orderdb-sink.kamelet.yaml --from-kamelet=mysql-sink
----

=== Run from clipboard

You can also run Camel routes directly from the OS clipboard. This allows copying some code,
and then quickly run this.

The syntax is

[source,bash]
----
camel run clipboard.<extension>
----

Where `<extension>` is what kind of file the content of the clipboard is, such as `java`, `xml`, or `yaml` etc.

For example, you can copy this to your clipboard and then run it afterward:

[source,xml]
----
<route>
  <from uri="timer:foo"/>
  <log message="Hello World"/>
</route>
----

[source,bash]
----
camel run clipboard.xml
----

==== Run and reload from clipboard

*Available since Camel 4.2*

It is also possible to run from clipboard in _reload_ mode as shown:

[source,bash]
----
camel run clipboard.xml --dev
----

Then you can quickly make changes and copy to clipboard, and Camel JBang will update while running.

=== Sending messages via Camel

*Available since Camel 4*

When building integrations with Camel JBang, you may find yourself in need of being able
to send messages into Camel, to test your Camel routes. This can be challenging when the
Camel routes are connected to external systems using different protocols.

The best approach is to send messages into these external systems using standard tools provided
by these systems, which often can be done using CLI tools. However, in some situations, where you
may not be familiar with these tools, you can try to let Camel send the message. Note that this
can only be possible in some scenarios, and should only be used as a _quick way_.

Suppose you have a Camel route that consumes messages from an external MQTT broker:

[source,yaml]
----
- route:
    from:
      uri: kamelet:mqtt5-source
      parameters:
        topic: temperature
        brokerUrl: tcp://mybroker:1883
      steps:
        - transform:
            expression:
              jq:
                expression: .value
        - log:
            message: The temperature is ${body}
----

In the example above the MQTT broker is running on hostname `mybroker` port 1883.

The idea with the `camel cmd send` command is to _tap into_ an existing running Camel integration,
and reuse an existing endpoint (if possible). In this example, we want to use the existing configuration
to avoid having to configure this again.

By executing the following from a shell

[source,bash]
----
$ camel cmd send --body=file:payload.json mqtt
----

We can send a message where the payload is loaded from a file (`_payload.json_`). You can also specify the payload in the CLI
argument, but it's cumbersome to specify JSON structure so often it's better to refer to a local file.

[source,json]
----
{
  "value": 21
}
----

The `mqtt` argument is the name of the existing running Camel integration. You can also specify the PID instead.
So what happens is that Camel will let the existing integration send the message.

Because the existing integration only has one route, then the `send` command will automatically pick
the `_from_` endpoint, i.e. `kamelet:mqtt5-source` with all its configuration. If there are multiple routes,
then you can filter which route/endpoint by the `--endpoint` option:

For example, to pick the first route by _route id_:

[source,bash]
----
$ camel cmd send --body=file:payload.json --endpoint=route1 mqtt
----

Or to pick the first route that uses mqtt component:

[source,bash]
----
$ camel cmd send --body=file:payload.json --endpoint=mqtt mqtt
----

We are fortunate in this situation as the endpoint can be used as both a _consumer_ and _producer_ in Camel,
and therefore we are able to send the message to the MQTT broker via `tcp://mybroker:1883` on topic _temperate_.

TIP: See more options with `camel cmd send --help`.

The source for this example is provided on GitHub at https://github.com/apache/camel-kamelets-examples/tree/main/jbang/mqtt)[camel-jbang MQTT example].

==== Poll messages via Camel

*Available since Camel 4.8*

The `camel cmd send` command has been improved to also _poll_ messages from Camel. This is needed
if you want to poll the latest messages from a Kafka topic, JMS queue, or download a file from FTP etc.

The poll uses Camel consumer to poll the message (timeout if no message received) instead of producer.

For example to poll a message from a ActiveMQ queue named cheese you can do:

[source,bash]
----
$ camel cmd send --poll --endpoint='activemq:cheese'
----

When you poll then you do not send any payload (body or headers).

=== Receiving messages via Camel

*Available since Camel 4.9*

When building a prototype integration with Camel JBang, you may route messages to external systems.
To know whether messages are being routed correctly, you may use system consoles to look inside these systems
which messages have arrived, such as SQL prompts, web consoles, CLI tools etc.

The Camel JBang now comes with a new command to receive messages from remote endpoints.
This can be used to quickly look or tail in terminal the messages that an external systems has received.
Camel does this by consuming the messages (if the component has support for consumer) and then let Camel JBang dump the messages from the CLI.

For example to start dumping all messages from ActiveMQ in one command, you can do:

[source,bash]
----
$ camel cmd receive --endpoint='activemq:cheese'
----

You can also use pattern syntax for the endpoint, so suppose you have the following route:

[source,java]
----
from("ftp:myserver:1234/foo")
  .to("log:order")
  .to("activemq:orders");
----

Then you can tell Camel to automatic start receiving messages with:

[source,bash]
----
$ camel cmd receive --action=start
----

TIP: You can enable and disable this mode with `--action=start` and `--action-stop`.

Then Camel will automatically discover from the running integration, all the _producers_ and
find the first _producer_ that is remote and also has consumer support. In the example above,
that is the `activemq` component, and thus Camel will start receive from `activemq:orders`.

You can see the status via:

[source,bash]
----
$ camel cmd receive
 PID   NAME   AGE   STATUS    TOTAL  SINCE  ENDPOINT
  4364  foo   1m33s  Enabled     18     2s  activemq://orders
----

You can then dump all the received messages with:

[source,bash]
----
$ camel cmd receive --action=dump
----

This will dump all the messages, and continue to dump new incoming messages. Use (ctrl + c) to break and exit.
You can turn follow off with `--follow=false`.

TIP: Use `camel cmd receive --help` to see all the various options for this command.


=== Controlling local Camel integrations

To list the currently running Camel integrations, you use the `ps` command:

[source,bash]
----
camel ps
  PID   NAME                             READY  STATUS    AGE
 61818  sample.camel.MyCamelApplica...   1/1   Running  26m38s
 62506  dude                             1/1   Running   4m34s
----

This lists the PID, the name and age of the integration.

You can use the `stop` command to stop any of these running Camel integrations.
For example, to stop dude, you can do

[source,bash]
----
camel stop dude
Stopping running Camel integration (pid: 62506)
----

You can also stop by the PID:

[source,bash]
----
camel stop 62506
Stopping running Camel integration (pid: 62506)
----

NOTE: You do not have to type the full name, as the stop command will match using integrations
that start with the input, for example, you can do `camel stop d` to stop all integrations
starting with d. If you have multiple integrations running with similar name such as `dude`, `dude2`, then
if you type `camel stop dude` then Camel will stop both integrations. However, if you want to only
stop a single integration then either stop via PID or use `camel stop dude!` with the `!` at the end.

To stop all integrations, then execute without any pid:

[source,bash]
----
camel stop
Stopping running Camel integration (pid: 61818)
Stopping running Camel integration (pid: 62506)
----

==== Watching local Camel integrations

Most of the management commands can run in _watch_ mode, which repetitively output the status in full-screen mode.
This is done using the `--watch` parameter as follows:

[source,bash]
----
camel ps --watch
  PID   NAME                             READY  STATUS    AGE
 61818  sample.camel.MyCamelApplica...   1/1   Running  26m38s
 62506  dude                             1/1   Running   4m34s
----

==== Controlling Spring Boot and Quarkus integrations

The Camel JBang CLI will by default only control Camel integrations that are running using the CLI, eg `camel run foo.java`.

For the CLI to be able to control and manage Spring Boot or Quarkus applications, then you need to add a dependency
to these projects to integrate with Camel CLI.

In Spring Boot, you add the following dependency:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.springboot</groupId>
    <artifactId>camel-cli-connector-starter</artifactId>
</dependency>
----

In Quarkus, you need to add the following dependency:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-cli-connector</artifactId>
</dependency>
----

==== Getting status of Camel integrations

The `get` command in Camel JBang is used for getting Camel specific status for one
or all of the running Camel integrations.

To display the status of the running Camel integrations:

[source,bash]
----
camel get
  PID   NAME      CAMEL   PLATFORM            READY  STATUS    AGE    TOTAL  FAILED  INFLIGHT  SINCE-LAST
 61818  MyCamel   3.20.0  Spring Boot v2.7.3   1/1   Running  28m34s    854       0         0     0s/0s/-
 63051  dude      3.20.0  JBang                1/1   Running     18s     14       0         0     0s/0s/-
 63068  mygroovy  3.20.0  JBang                1/1   Running      5s      2       0         0     0s/0s/-
----

The `camel get` command will default display Camel application (context), which is equivalent to
typing `camel get context`.

This displays overall information for every Camel integration, where you can see
the total number of messages processed. The column _Since Last_
shows how long time ago the last processed message for 3 stages (started/completed/failed).

The value of `0s/0s/-` means that the last started and completed message just happened (0 seconds ago),
and  that there has not been any failed message yet. And this example `9s/9s/1h3m` means that last started and
completed message is 9 seconds ago, and last failed were 1 hour and 3 minutes ago.

TIP: You can run in _watch_ mode using: `camel get --watch`

===== Total in Camel 4.7 and 4.8

From *Camel 4.7* onwards, two numbers will be displayed for _TOTAL_, _FAILED_, and _INFLIGHT_ columns.
The first number is messages received from external systems (databases, cloud systems), and the second
number is the total number (as in earlier versions).

[source,bash]
----
camel get
  PID   NAME    CAMEL  PLATFORM        PROFILE  READY  STATUS   RELOAD  AGE   ROUTE  MSG/S  TOTAL  FAIL  INFLIGHT  LAST  DELTA  SINCE-LAST
 42240  cheese  4.7.0  JBang v0.116.0  dev       1/1   Running       0  1m8s    2/2   1.01   1/65   0/0       0/0     0     -1     1s/1s/-
----

The _TOTAL_ column above shows `1/65` which mean that 1 message was from an external source, and 65 in total; which means that
64 are from internal sources (such as timer, seda).

===== Total in Camel 4.9 onwards

The TOTAL column is total number of messages processed. This is all messages both started internally (such as from a timer)
and received from external systems (databases, cloud systems). In *Camel 4.9* we made the TOTAL column a single digit again
to not confuse, and we added a new `REMOTE` column to show total for remote systems only. So the example above would be:

[source,bash]
----
camel get
  PID   NAME    CAMEL  PLATFORM        PROFILE  READY  STATUS   RELOAD  AGE   ROUTE  MSG/S  TOTAL  REMOTE  FAIL  INFLIGHT  LAST  DELTA  SINCE-LAST
 42240  cheese  4.9.0  JBang v0.118.0  dev       1/1   Running       0  1m8s    2/2   1.01     65       1   0/0       0/0     0     -1     1s/1s/-
----

==== Route status

You can also see the status of every route, from all the local Camel integrations with `camel get route`:

[source,bash]
----
camel get route
  PID   NAME      ID      FROM                        STATUS    AGE   TOTAL  FAILED  INFLIGHT  MEAN  MIN  MAX  SINCE-LAST
 61818  MyCamel   hello   timer://hello?period=2000   Running  29m2s    870       0         0     0    0   14     0s/0s/-
 63051  dude      java    timer://java?period=1000    Running    46s     46       0         0     0    0    9     0s/0s/-
 63068  mygroovy  groovy  timer://groovy?period=1000  Running    34s     34       0         0     0    0    5     0s/0s/-
----

TIP: Use `camel get --help` to display all the available commands as additional will be added in upcoming releases.

==== Top status of Camel integrations

The `camel top` command is intended for getting top utilization statistics (highest to lowest heap used memory)
of the running Camel integrations.

[source,bash]
----
camel top
  PID   NAME     JAVA     CAMEL   PLATFORM            STATUS    AGE         HEAP        NON-HEAP     GC     THREADS   CLASSES
 22104  chuck    11.0.13  3.20.0  JBang               Running   2m10s  131/322/4294 MB  70/73 MB  17ms (6)      7/8  7456/7456
 14242  MyCamel  11.0.13  3.20.0  Spring Boot v2.7.3  Running  33m40s  115/332/4294 MB  62/66 MB  37ms (6)    16/16  8428/8428
 22116  bar      11.0.13  3.20.0  JBang               Running    2m7s   33/268/4294 MB  54/58 MB  20ms (4)      7/8  6104/6104
----

The _HEAP_ column shows the heap memory (used/committed/max) and the non-heap (used/committed).
The _GC_ column shows garbage collection information (time and total runs).
The _CLASSES_ column shows the number of classes (loaded/total).

You can also see the top performing routes (highest to lowest mean processing time)
of every route, from all the local Camel integrations with `camel top route`:

[source,bash]
----
camel top route
  PID   NAME     ID                     FROM                                 STATUS    AGE    TOTAL  FAILED  INFLIGHT  MEAN  MIN  MAX  SINCE-LAST
 22104  chuck    chuck-norris-source-1  timer://chuck?period=10000           Started     10s      1       0         0   163  163  163          9s
 22116  bar      route1                 timer://yaml2?period=1000            Started      7s      7       0         0     1    0   11          0s
 22104  chuck    chuck                  kamelet://chuck-norris-source        Started     10s      1       0         0     0    0    0          9s
 22104  chuck    log-sink-2             kamelet://source?routeId=log-sink-2  Started     10s      1       0         0     0    0    0          9s
 14242  MyCamel  hello                  timer://hello?period=2000            Started  31m41s    948       0         0     0    0    4          0s
----

TIP: Use `camel top --help` to display all the available commands as additional will be added in upcoming releases.

==== Tailing logs

When you run Camel integrations, then they will by default run in the foreground and output logs.

NOTE: The `camel log` command is **not** supported when running in Spring Boot or Quarkus runtimes.

You can from another terminal access the logs from any Camel integration with the `log` command, as follows:

[source,bash]
----
camel log chuck
chuck     | 2023-01-04 17:59:19.288  INFO 44619 --- [           main] org.apache.camel.main.MainSupport   : Apache Camel (JBang) 3.21.0 is starting
chuck     | 2023-01-04 17:59:19.395  INFO 44619 --- [           main] org.apache.camel.main.MainSupport   : Using Java 17.0.5 with PID 44619. Started by davsclaus in /Users/davsclaus/workspace/
...
----

You can also watch logs for all Camel integrations by `camel log`, or you can specify by name/pids (separate by comma) `camel log bar,chuck`.

It is also possible to find and highlight keywords from the log using `--find`, such as:

[source,bash]
----
camel log chuck --find=invoice
----

You can find multiple items by repeating the option, i.e.:

[source,bash]
----
camel log chuck --find=invoice --find=order
----

There is also a _grep_ option that will filter the logs to only show lines that matches text (ignore case).

[source,bash]
----
camel log chuck --grep=error
----

The log command will by default tail the logs for new lines. If you want to exit the command immediately, you
can turn off the following as shown:

[source,bash]
----
camel log chuck --grep=error --follow=false
----

This will grep the logs for log lines with matches text `error` and output only these logs, and exit.

==== Tracing messages

The `trace` command is used for showing how messages are routed in Camel. The command has similar output as the `log`
command but only display message tracing information. This allows you to see every _step_ a message is routed in Camel.

The `trace` command has many options and can be used to _filter_, _grep_ or output on different detail _levels`.
The _exchange id_ is logged (and grouped by colour), so you can use that to correlate the events when traces are interleaved.

The trace command will by default list the status of whether tracing is enabled or not in the integrations:

[source,bash]
----
camel trace
 PID   NAME   AGE  STATUS   TOTAL  QUEUE  FILTER  PATTERN
 6911  chuck   5s  Standby      0      0
----

Here we can see that the tracer is in standby mode, and you need to start the tracer before Camel will capture messages:

TIP: Camel 4.8 onwards has tracing in standby mode (when using dev profile). You can enable tracing on startup by setting the configuration `camel.trace.enabled=true` in `application.properties`.

[source,bash]
----
camel trace --action=start
----

And if you run `camel trace` again you can see the tracer is started:

[source,bash]
----
camel trace
PID   NAME   AGE   STATUS   TOTAL  QUEUE  FILTER  PATTERN
6911  chuck  1m5s  Started     16      4
----

And to show the traces you need to use the `dump` action as follows:

[source,bash]
----
camel trace chuck --action=dump
----

You can also dump traces from all running integrations:

[source,bash]
----
camel trace --action=dump
----

To stop tracing use `--action=stop`.

And you can also clear the already traced messages with `--action=clear`.

==== Running Camel integrations in background

The `run` command allows running Camel in the background with the `--background` option.
Therefore, to see and understand what happens then the management commands
cane be used, such as `camel ps`, `camel get`, and `camel log`.

NOTE: Only Camel Main is supported to run in background

[source,bash]
----
$ camel run chuck.yaml --background --runtime=main
Running Camel integration: chuck in background with PID: 80093

$ camel ps
  PID   NAME    READY  STATUS   AGE
 80093  chuck    1/1   Running  33s
----

To see the log use `camel log`
[source,bash]
----
$ camel log
chuck     | 2023-01-04 17:59:19.288  INFO 44619 --- [           main] org.apache.camel.main.MainSupport   : Apache Camel (JBang) 3.21.0 is starting
chuck     | 2023-01-04 17:59:19.395  INFO 44619 --- [           main] org.apache.camel.main.MainSupport   : Using Java 17.0.5 with PID 44619. Started by davsclaus in /Users/davsclaus/workspace/
...
----

To stop the integration you can use `camel stop`

[source,bash]
----
$ camel stop chuck
Shutting down Camel integration (pid: 80093)
----

When running in background, then Camel JBang (**4.10 onwards**) will now automatic wait for the integration
to startup before returning from the CLI command. This ensures that if there are any startup
errors such as compilation errors or DSL errors etc. then these are captured and printed in the shell.
You can use the option `--background-wait=false` to turn this off.

==== Starting and Stopping routes

The `camel cmd` is intended for executing miscellaneous commands in the running Camel integrations.
For example, there are commands to start and stop routes.

To stop all the routes in the chuck integration, you execute:

[source,bash]
----
camel cmd stop-route chuck
----

And the status will then report the status as _Stopped_ for the chuck integration:

[source,bash]
----
camel get route
  PID   NAME     ID                     FROM                                 STATUS    AGE   TOTAL  FAILED  INFLIGHT  MEAN  MIN  MAX  SINCE-LAST
 81663  chuck    chuck                  kamelet://chuck-norris-source        Stopped           600       0         0     0    0    1          4s
 81663  chuck    chuck-norris-source-1  timer://chuck?period=10000           Stopped           600       0         0    65   52  290          4s
 81663  chuck    log-sink-2             kamelet://source?routeId=log-sink-2  Stopped           600       0         0     0    0    1          4s
 83415  bar      route1                 timer://yaml2?period=1000            Started  5m30s    329       0         0     0    0   10          0s
 83695  MyCamel  hello                  timer://hello?period=2000            Started  3m52s    116       0         0     0    0    9          1s
----

To start the routes, you can do:

[source,bash]
----
camel cmd start-route chuck
----

To stop _all_ routes in every Camel integration:

[source,bash]
----
camel cmd stop-route
----

And you can start _all_ routes using:

[source,bash]
----
camel cmd start-route
----

To start a specific route, you need to use `--id` parameter such as the following,
which will start routes named `route1` in all running integrations:

[source,bash]
----
camel cmd start-route --id=route1
----

If you want to do this in a specific integration, you must include the name or pid:

[source,bash]
----
camel cmd start-route bar --id=route1
----

TIP: You can stop one or more route by their ids by separating using
comma such as `camel cmd start-route --id=route1,hello`.
Use `camel cmd start-route --help` for more details.

==== Running Camel integrations on Kubernetes

After developing the Camel routes locally with JBang, you may want to run these also on the Kubernetes platform at some point.

Camel JBang provides a plugin for managing and easily running Camel applications on Kubernetes.
The plugin uses the project export functionality to build and deploy the application on Kubernetes with Quarkus or SpringBoot.

Read about it in the xref:camel-jbang-kubernetes.adoc[Camel Kubernetes plugin] documentation.

==== Configuring logging levels

You can see the current logging levels of the running Camel integrations by:

[source,bash]
----
camel cmd logger
  PID   NAME   AGE   LOGGER  LEVEL
 90857  bar   2m48s  root    INFO
 91103  foo     20s  root    INFO
----

The logging level can be changed at runtime, for example, to change foo to DEBUG you execute:

[source,bash]
----
camel cmd logger --logging-level=DEBUG foo
----

TIP: You can use `--all` to change logging levels for all running integrations.

===== Configuring individual logging levels

From *Camel 4.6* onwards you can easily configure different logging levels from CLI and `application.properties`.

For example from CLI, you can specify using the `--logging-category` option.
For example, to enable DEBUG logging if using Kafka:

[source,bash]
----
$ camel run myapp.yaml --logging-category=org.apache.kafka=DEBUG
----

You can specify multiple categories by repeating the CLI option as shown:

[source,bash]
----
$ camel run myapp.yaml --logging-category=org.apache.kafka=DEBUG --logging-category=com.foo.something=TRACE
----

You can also configure logging levels in `application.properties` using two styles

- `logging.level.` it is the default style used by Camel and Spring Boot
- `quarkus.log.category.` is used by Quarkus

For example, you can declare as follows:

[source,properties]
----

# make it easy to configure individual logging levels
logging.level.org.apache.kafka = DEBUG
logging.level.com.foo.something = TRACE

# you can also use quarkus style naming
quarkus.log.category."org.apache.kafka".level = DEBUG
quarkus.log.category."com.foo.something".level = TRACE
----

==== Listing services

Some Camel integrations may host a service which clients can call, such as REST, or SOAP-WS, or socket-level services using TCP protocols.

You can list the available services as shown in the example below:

[source,bash]
----
camel get service
 PID   NAME       COMPONENT      PROTOCOL  SERVICE
 1912  netty      netty          tcp       tcp:localhost:4444
 2023  greetings  platform-http  rest      http://0.0.0.0:7777/camel/greetings/{name} (GET)
 2023  greetings  platform-http  http      http://0.0.0.0:7777/q/dev
----

Here you can see 2 Camel integrations. The netty integration hosts a TCP service that is available on port 4444.
The other Camel integration hosts a REST service that can be called via GET only.
And finally the integration comes with embedded web console (started with the `--console` option).

NOTE: For a service to be listed then Camel components must be able to advertise the services using xref:camel-console.adoc[].

==== Observability with metrics

Camel JBang comes with support for using Micrometer for metrics that easily can be made available.

You simply either run with `--metrics` option, or enable and have more control of the configuration in the `application.properties` file as shown below:

[source,properties]
----
# enable HTTP server with metrics
camel.server.enabled=true
camel.server.metricsEnabled=true

# turn on micrometer metrics
camel.metrics.enabled=true
# include more camel details
camel.metrics.enableMessageHistory=true
# include additional out-of-the-box micrometer metrics for cpu, jvm and used file descriptors
camel.metrics.binders=processor,jvm-info,file-descriptor
----

Then you can access metrics from the web browser at: http://localhost:8080/q/metrics[http://localhost:8080/q/metrics]

You can also see metrics from the CLI as shown below:

[source,bash]
----
$ camel get metric
  PID   NAME         TYPE   METRIC                         ROUTE                  VALUE  MEAN  MAX  TOTAL
 11562  MyCoolCamel  timer  camel.exchange.event.notifier                             3    12   27     35
 11562  MyCoolCamel  timer  camel.exchange.event.notifier                             3     1    2      3
 11562  MyCoolCamel  gauge  camel.routes.added                                        3
 11562  MyCoolCamel  gauge  camel.routes.running                                      3
 11562  MyCoolCamel  gauge  jvm.info                                                  1
 11562  MyCoolCamel  gauge  process.cpu.usage                     0.0045185067010171795
 11562  MyCoolCamel  gauge  process.files.max                                     10240
 11562  MyCoolCamel  gauge  process.files.open                                      288
 11562  MyCoolCamel  gauge  system.cpu.count                                          8
 11562  MyCoolCamel  gauge  system.cpu.usage                        0.15222772277227722
 11562  MyCoolCamel  gauge  system.load.average.1m                        3.58935546875
----

==== Listing state of Circuit Breakers

If your Camel integration uses xref:components:eips:circuitBreaker-eip.adoc[Circuit Breaker],
then you can output the status of the breakers with Camel JBang as follows:

[source,bash]
----
camel get circuit-breaker
  PID   NAME  COMPONENT     ROUTE   ID               STATE      PENDING  SUCCESS  FAIL  REJECT
 56033  mycb  resilience4j  route1  circuitBreaker1  HALF_OPEN        5        2     3       0
----

Here we can see the circuit breaker is in _half-open_ state, i.e., a state where the breaker is attempting
to transition back to closed if the failures start to drop.

TIP: You can run the command with watch to keep showing the latest state `watch camel get circuit-breaker`.

=== Using Jolokia and Hawtio

The https://hawt.io/[Hawtio] web console allows inspecting running Camel integrations, such
as all the JMX management information, and not but least to visualize the Camel routes
with live performance metrics. Hawtio is a handy tool for many years, and we have made it
easy to use Hawtio with Camel JBang.

To let Hawtio able to inspect the Camel integrations, then the Jolokia JVM Agent
must be installed in the running integration, this can be done, either explicit as follows:

[source,bash]
----
camel ps
  PID   NAME                             READY  STATUS    AGE
 61818  sample.camel.MyCamelApplica...   1/1   Running  26m38s
 62506  dude.java                        1/1   Running   4m34s
----

With the PID you can then attach Jolokia:

[source,bash]
----
camel jolokia 62506
Started Jolokia for PID 62506
http://127.0.0.1:8778/jolokia/
----

Instead of using PID, you can also attach by name pattern.
In this example, because the
two Camel integrations have unique names (foo and dude), then you can also attach Jolokia
without knowing the PID as follows:

[source,bash]
----
camel jolokia du
Started Jolokia for PID 62506
http://127.0.0.1:8778/jolokia/
----

Then you can launch https://hawt.io/[Hawtio] using Camel JBang:

[source,bash]
----
camel hawtio
----

This will automatically download and start Hawtio, and open in web browser.

TIP: See `camel hawtio --help` for options.

And when Hawtio launches in the web browser, click the _Discover_ tab which should
list all the local available Jolokia Agents (yes you can use `camel jolokia PID` to connect
to multiple different Camel integrations and from this list select which to load).

Click the green _lightning_ icon to connect to running Camel integration (of choice).

You can uninstall the Jolokia JVM Agent in a running Camel integration when no longer needed:

[source,bash]
----
camel jolokia 62506 --stop
Stopped Jolokia for PID 62506
----

It is also possible to do this with only one command, as follows:

[source,bash]
----
camel hawtio dude
----

Where _dude_ is the name of the running Camel integration. When you stop Hawtio (using `ctrl` + `c`)
then Camel will attempt to uninstall the Jolokia JVM Agent. However, this may not be
able to do this always, because the JVM is being terminated which can prevent camel-jbang
from doing JVM process communication to the running Camel integration.

=== Scripting from terminal using pipes

You can also execute a Camel JBang file as a script that can be used for terminal scripting with pipes and filters.

NOTE: Every time the script is executed, a JVM is started with Camel.
This is not very fast or low on memory usage,
so use Camel JBang terminal scripting where using Camel makes sense.
For example, to use
many Camel components or Kamelets, to more easily send or receive data from disparate IT systems.

This requires adding the following line in top of the file, for example, as in the `UpperCase.java` file below:

[source,text]
----
///usr/bin/env jbang --quiet camel@apache/camel script "$0" "$@" ; exit $?

import org.apache.camel.builder.RouteBuilder;

//Will upper-case the input
public class UpperCase extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        from("stream:in")
                .setBody()
                .simple("${body.toUpperCase()}")
                .to("stream:out");
    }
}
----

To be able to execute this as a script, you need to set execute file permission:

[source,bash]
----
chmod +x UpperCase.java
----

Then you can then execute this as a script:

[source,bash]
----
echo "Hello\nWorld" | ./UpperCase.java
----

Which should output:

[source,text]
----
HELLO
WORLD
----

Logging can be turned on using `--logging=true` which then logs to `.camel-jbang/camel-pipe.log` file.
The name of the logging file cannot be configured.

[source,bash]
----
echo "Hello\nWorld" | ./UpperCase.java --logging=true
----

==== Using stream:in with line vs. raw mode

When using `stream:in` to read data from _System in_ then the xref:components::stream-component.adoc[Stream component]
works in two modes:

- line mode (default): reads input as single lines (separated by line breaks).
  Message body is a `String`.
- raw mode: reads the entire stream until the _end of stream_.
  Message body is a `byte[]`.

IMPORTANT: The default mode is due to historically how the stream component was created.
Therefore, you may want to set `stream:in?readLine=false` to use raw mode.

=== Running local Kamelets

You can also use Camel JBang to try local Kamelets, without the need to publish them on GitHub or package them in a jar.

[source,bash]
----
camel run --local-kamelet-dir=/path/to/local/kamelets earthquake.yaml
----

TIP: When the kamelets are from local file system, then they can be live reloaded if they are updated, when you run
Camel JBang in `--dev` mode.

You can also point to a folder in a GitHub repository. For example, we have provided some custom Kamelets
at https://github.com/apache/camel-kamelets-examples/tree/main/custom-kamelets, which can be used easily:

[source,bash]
----
camel run --local-kamelet-dir=https://github.com/apache/camel-kamelets-examples/tree/main/custom-kamelets user.java
----

NOTE: If a kamelet is loaded from GitHub, then they cannot be live reloaded.

=== Using the platform-http component

NOTE: Camel JBang is only intended for working with `platform-http` as HTTP server component for rest-dsl,
and for HTTP serer in general. It is not intended to work with `camel-servlet` or `camel-jetty`. If you find a need for using Jetty,
then Camel JBang will not support seamless rest-dsl support and exporting.

When a route is started from `platform-http` then Camel JBang will automatically include a VertX HTTP server
running on port 8080. For example, the following route in a file named `server.yaml`:

[source,yaml]
----
- from:
    uri: "platform-http:/hello"
    steps:
      - set-body:
          constant: "Hello World"
----

Can be run with

[source,bash]
----
camel run server.yaml
----

And you can call the HTTP service with:

[source,bash]
----
$ curl http://localhost:8080/hello
Hello World%
----

=== Using Java beans and processors

There is basic support for including regular Java source files together with Camel routes,
and let Camel JBang runtime compile the Java source. This means you can include smaller utility
classes, POJOs, Camel Processors and whatnot that the application needs.

=== Dependency Injection in Java classes

When running Camel integrations with camel-jbang, then the runtime is `camel-main` based. This means
there is no Spring Boot or Quarkus available.
However, we have added support for using annotation-based dependency injection in Java classes.

==== Using Camel dependency injection

You can use the following Camel annotations on Camel standalone:

- `@org.apache.camel.BindToRegistry` on class level (for custom beans, processors, etc.) to create an instance of the class and register in the xref:registry.adoc[Registry].
- `@org.apache.camel.Configuration` on class level for `CamelConfiguation` classes, which is used during Camel startup (only Camel Main runtime) to allow custom setup that requires some coding.

And these annotations should work on all runtimes
(if target runtime is either Quarkus or Spring Boot then favour using their annotations):

- `@org.apache.camel.BeanInject` to dependency inject a bean on a class field.
- `@org.apache.camel.PropertyInject` to inject a xref:using-propertyplaceholder.adoc[property placeholder]. Such as a property defined in `application.properties`.
- `@org.apache.camel.BindToRegistry` on a method to create a bean by invoking the method.
- `@org.apache.camel.Converter` on class level to auto-register the xref:type-converter.adoc[type converters] from the class.

IMPORTANT: You can use `@BeanInject` annotation to refer to existing bean annotated with `@BindToRegistry`, however, this is possible if the dependency is registered before the dependant.

==== Using Spring Boot dependency injection

You can use the following Spring Boot annotations:

- `@org.springframework.stereotype.Component` or `@org.springframework.stereotype.Service` on class level to create an instance of the class and register in the xref:registry.adoc[Registry].
- `@org.springframework.beans.factory.annotation.Autowired` to dependency inject a bean on a class field. `@org.springframework.beans.factory.annotation.Qualifier` can be used to specify the bean id.
- `@org.springframework.beans.factory.annotation.Value` to inject a xref:using-propertyplaceholder.adoc[property placeholder]. Such as a property defined in `application.properties`.
- `@org.springframework.context.annotation.Bean` on a method to create a bean by invoking the method.

==== Using Quarkus injection

You can use the following Quarkus annotations:

- `@javax.enterprise.context.ApplicationScoped` or `@javax.inject.Singleton` on class level to create an instance of the class and register in the xref:registry.adoc[Registry]. `@javax.inject.Named` can be used to specify the bean id.
- `@javax.inject.Inject` to dependency inject a bean on a class field. `@javax.inject.Named` can be used to specify the bean id.
- `@org.eclipse.microprofile.config.inject.ConfigProperty` to inject a xref:using-propertyplaceholder.adoc[property placeholder]. Such as a property defined in `application.properties`.
- `@javax.enterprise.inject.Produces` on a method to create a bean by invoking the method. `@javax.inject.Named` can be used to specify the bean id.

==== Using beans in Camel XML DSL

Since Camel *4.0.0*, when using xref:components:others:java-xml-io-dsl.adoc[XML DSL],
we can declare additional beans in a similar way as in xref:components:others:yaml-dsl.adoc[YAML DSL].
Such beans will be added to the xref:registry.adoc[Registry] and can be referred to, for example, from routes.

[source,xml]
----
<camel>

	<bean name="beanFromMap" type="com.acme.MyBean">
		<properties>
			<property key="foo" value="bar" />
		</properties>
	</bean>

</camel>
----

The properties of the bean can be defined using either nested `<property>` and `<properties>` elements or using dotted properties style, as shown in the example below:

[source,xml]
----
<camel>

    <!-- nested properties style -->
	<bean name="beanFromMap" type="com.acme.MyBean">
		<properties>
			<property key="field1" value="f1_p" />
			<property key="field2" value="f2_p" />
			<property key="nested">
				<properties>
					<property key="field1" value="nf1_p" />
					<property key="field2" value="nf2_p" />
				</properties>
			</property>
		</properties>
	</bean>

    <!-- dotted properties style -->
	<bean name="beanFromProps" type="com.acme.MyBean">
		<properties>
			<property key="field1" value="f1_p" />
			<property key="field2" value="f2_p" />
			<property key="nested.field1" value="nf1_p" />
			<property key="nested.field2" value="nf2_p" />
		</properties>
	</bean>

</camel>
----

==== Using Spring beans in Camel XML DSL

Since Camel *4.0.0*, when using xref:components:others:java-xml-io-dsl.adoc[XML DSL], we can also declare _beans_ using Spring Beans XML namespace.
All these beans will be added to the xref:registry.adoc[Registry].

This will not make the application managed by Spring Framework / Spring Boot. Simply Camel will leverage existing support for generic bean definition including:

* dependency injection
* constructor injection
* dependency cycles
* wiring existing Camel objects (like `org.apache.camel.CamelContext`)

xref:components:others:java-xml-io-dsl.adoc[XML DSL] allows using XML documents that define routes, rests and route templates. Since Camel *4.0.0* these documents may use a new root XML element (either `<camel>` or `<beans>` to resemble Spring XML DSL), where other Camel elements (like `<routes>`) are contained.

Here's an example `camel.xml` file, which defines both the routes and beans used (referred to) by the route definition:

.camel.xml
[source,xml]
----
<camel>

    <beans xmlns="http://www.springframework.org/schema/beans">
        <bean id="messageString" class="java.lang.String">
            <constructor-arg index="0" value="Hello"/>
        </bean>

        <bean id="greeter" class="org.apache.camel.main.app.Greeter">
            <description>Spring Bean</description>
            <property name="message">
                <bean class="org.apache.camel.main.app.GreeterMessage">
                    <property name="msg" ref="messageString"/>
                </bean>
            </property>
        </bean>
    </beans>

    <route id="my-route">
        <from uri="direct:start"/>
        <bean ref="greeter"/>
        <to uri="mock:finish"/>
    </route>

</camel>
----

This document contains embedded `<beans>` element using Spring Beans XML namespace (`http://www.springframework.org/schema/beans`) - Camel passes this element directly to Spring `org.springframework.beans.factory.xml.XmlBeanDefinitionReader` and all read beans are used to populate xref:registry.adoc[Camel Registry].

The beans declared this way may use references to some predefined Camel beans.
Currently, these are handled:

* `_CamelContext_`: an instance of current `org.apache.camel.CamelContext`
* `_MainConfiguration_`: an instance of `org.apache.camel.main.MainConfigurationProperties` used for `org.apache.camel.main.KameletMain`

So we can use this XML fragment without actually defining what `CamelContext` is.

[source,xml]
----
<camel>

    <beans xmlns="http://www.springframework.org/schema/beans">
        <bean id="greeter" class="org.apache.camel.main.app.Greeter">
            <property name="camelContext" ref="CamelContext"/>
            <!-- ... -->
        </bean>
    </beans>

    <route id="my-route">
        <from uri="direct:start"/>
        <bean ref="greeter"/>
        <to uri="mock:finish"/>
    </route>

</camel>
----

What's more, we can declare some additional beans that can affect internal mechanics of `CamelContext` being run. `org.apache.camel.main.DefaultConfigurationConfigurer` is used by xref:components:others:main.adoc[Camel Main] to configure `CamelContext` using beans found in xref:registry.adoc[Camel Registry].

For example, we can customize used `org.apache.camel.spi.UuidGenerator` with this XML fragment to replace UUID generator used by Camel (which defaults to `org.apache.camel.support.DefaultUuidGenerator`):

[source,xml]
----
<camel>

    <beans xmlns="http://www.springframework.org/schema/beans">
        <bean id="customUUIDGenerator" class="org.apache.camel.support.ShortUuidGenerator" />
    </beans>

</camel>
----

That's it - Camel context will then look up for the instances of `org.apache.camel.spi.UuidGenerator` and if one is found, it'll be used by Camel.

=== Configuring JDBC DataSources

When using SQL databases, then you would often need to configure a JDBC connection pool. You can do this:

- Manually by adding 3rd party JAR dependency for the data source (and connection pool), and configure this from Java or XML/YAML DSL.
- *Camel 4.6* Spring Boot style with `spring.datasource.` configuration in `application.properties` (uses Hikari connection-pool)

==== Defining datasource in YAML DSL as a bean

Here is a snippet how you can declare a bean as the `DataSource` for a Postgres database in YAML DSL:

[source,yaml]
----
- beans:
    - name: PostgresqlDataSource
      properties:
        databaseName: "postgres"
        password: "postgres"
        portNumber: "5432"
        serverName: localhost
        user: postgres
      type: org.postgresql.ds.PGSimpleDataSource
----

You would then also need to add the JAR dependency with Maven coordinates: `org.postgresql:postgresql:42.7.3`.

==== Using a Spring Boot JDBC data source

In `application.properties` you can set up the datasource such as:

[source,properties]
----
spring.datasource.url= jdbc:sqlserver://db.example.net:1433;databaseName=test_db
spring.datasource.username=user
spring.datasource.password=password
spring.datasource.driverClassName=com.microsoft.sqlserver.jdbc.SQLServerDriver
----

The name of the `DataSource` will be registered with `springDataSource`, however you can configure the name via:

[source,properties]
----
spring.datasource.name=myDataSourceNameHere
----

TIP: Some JDBC drivers are automatic detected by camel-jbang.
If not, then you need to add the JAR dependency manually.

And you can configure the Hikari connection-pool (if needed), such as:

[source,properties]
----
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.pool-name=collection-pool
----

And you can set logging to DEBUG on hikari to see the actual configuration:

[source,properties]
----
logging.level.com.zaxxer.hikari = DEBUG
----

=== Debugging

There are two kinds of debugging:

* _Java debugging_: Java code debugging (Standard Java)
* _Camel route debugging_: Debugging Camel routes (requires Camel tooling plugins)

==== Java debugging

Camel JBang makes it easy to do _Java debugging_ when you run your integration with the `--jvm-debug` option as shown below:

[source,bash]
----
camel run hello.yaml --jvm-debug
Listening for transport dt_socket at address: 4004
----

As you can see the default listening port is 4004 but can be configured as described in https://www.jbang.dev/documentation/guide/latest/debugging.html[JBang Debugging].

This is a standard Java debug socket. You can then use the IDE of your choice. For instance, see the generic documentation for https://www.jetbrains.com/help/idea/attaching-to-local-process.html#create-rc[IntelliJ], https://code.visualstudio.com/docs/java/java-debugging#_attach[VS Code] and https://www.vogella.com/tutorials/EclipseDebugging/article.html#remote-debugging[Eclipse Desktop]. You will surely want to add `Processor` to be able to put breakpoints hit during route execution (as opposed to route definition creation).

===== Standard JBang debugging

You can debug your integration scripts by making use of the `--debug` flag provided by JBang.

[source,bash]
----
jbang --debug  camel@apache/camel run hello.yaml
Listening for transport dt_socket at address: 4004
----

This makes it possible to debug any of the Camel JBang commands, not only the `run` command as shown above.

==== Camel route debugging

With *Camel 4.2* onwards you can now easily debug Camel routes from the command shell with the `debug` command as shown below:

[source,bash]
----
camel debug hello.yaml
----

This will run the integration (in background), and the current shell running in foreground will act as a CLI based debugger.
You can see snippets from the log (in the top), the middle section shown the current breakpoint.
And in the bottom you can see content of the message (similar to the `camel trace` command)

[source,text]
----
2023-11-03 18:15:06.715  INFO 33384 --- [           main] g.apache.camel.main.BaseMainSupport :     [Command Line]                 camel.debug.loggingLevel=DEBUG
2023-11-03 18:15:06.715  INFO 33384 --- [           main] g.apache.camel.main.BaseMainSupport :     [Command Line]                 camel.debug.singleStepIncludeStartEnd=true
2023-11-03 18:15:06.787  INFO 33384 --- [           main] mel.cli.connector.LocalCliConnector : Camel CLI enabled (local)
2023-11-03 18:15:06.833  INFO 33384 --- [           main] el.impl.engine.AbstractCamelContext : Apache Camel 4.7.0 (foo) is starting
2023-11-03 18:15:06.906  INFO 33384 --- [           main] g.apache.camel.main.BaseMainSupport : Property-placeholders summary
2023-11-03 18:15:06.906  INFO 33384 --- [           main] g.apache.camel.main.BaseMainSupport :     [application.properties]       my-name=Donald Duck
2023-11-03 18:15:06.924  INFO 33384 --- [           main] el.impl.engine.AbstractCamelContext : Routes startup (started:1)
2023-11-03 18:15:06.924  INFO 33384 --- [           main] el.impl.engine.AbstractCamelContext :     Started route-07a6 (timer://yaml)
2023-11-03 18:15:06.924  INFO 33384 --- [           main] el.impl.engine.AbstractCamelContext : Apache Camel 4.7.0 (foo) started in 91ms (build:0ms init:0ms start:91ms)
2023-11-03 18:15:11.951  INFO 33384 --- [ - timer://yaml] foo.camel.yaml:10                   : Before:

Source: foo.camel.yaml:13                                                         History
--------------------------------------------------------------------------------  ------------------------------------------------------------------------------------------
  10:              - log:                                                         route-07a6/from-c041           (0ms)    4:       uri: timer
  11:                  message: 'Before: ${body}'                                 route-07a6/log1                (1ms)   10:         - log:
  12:                  id: log1
  13: --->         - setProperty:
  14:                  name: myProp
  15:                  expression:
  16:                    constant:
  17:                      expression: '123'
  18:                      id: constant-4004


2023-11-03 18:15:11.951  33384 --- [ thread #4 - timer://yaml]              route-07a6/setProperty-321c :     3 - Breakpoint (4ms)
 Exchange  (DefaultExchange)  InOnly  D48642E54410AF9-0000000000000000
 Message   (DefaultMessage)
 Body      (null)


    Breakpoint suspended. Press ENTER to continue.
----

This is _basic_ but yet powerful, as you have this debugger always readily available, without having to start up VSCode or IDEA tooling.

TIP: The `camel debug` can debug almost all the DSLs (there is a problem with groovy).

===== Configuring breakpoints

When using `camel debug` then breakpoints are by default added to every route.
However, you can specify which breakpoints to use instead with the `--breakpoint` option.
This parameter is able to match the Camel routes using a pattern style:

1. Exact match by node ids
2. Match node ids by pattern (wildcard and regular expression)
3. Match by EIP kind (setHeader, setBody, choice, split, etc.)
4. Match by source and line number
5. Match by line number

Multiple breakpoints can be separated by comma.

For example, to set a breakpoint at the setHeader EIP, you do:

[source,bash]
----
camel debug hello.yaml --breakpoint=setHeader
----

To set a breakpoint at line 18:

[source,bash]
----
camel debug hello.yaml --breakpoint=18
----

To set a breakpoint at line 18 and 34

[source,bash]
----
camel debug hello.yaml --breakpoint=18,34
----

==== Editing code using VSCode or IDEA editors

You can use JBang to edit the source code by using the `jbang` CLI to download dependencies,
and set up a project for being ready to load into an IDE of choice, such as IDEA, VSCode, or Eclipse.

This is typically in use when you use Java DSL and have Camel routes in .java source code.
To let JBang understand which dependencies are in use, then you need to use JBang style for specifying
dependencies by using `//DEPS` code comments in Java code.

Given the following source file in `foo.java` file:

[source,java]
----
//DEPS org.apache.camel:camel-bom:4.3.0@pom
//DEPS org.apache.camel:camel-endpointdsl
//DEPS org.apache.camel:camel-netty-http
//DEPS org.apache.camel:camel-stream

// add more dependencies here

import org.apache.camel.builder.endpoint.EndpointRouteBuilder;
import org.apache.camel.component.netty.http.NettyHttpMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class foo extends EndpointRouteBuilder {

    private static final Logger LOG = LoggerFactory.getLogger(foo.class);

    @Override
    public void configure() {
        from(timer("trigger").period(5000).repeatCount(3))
                .to(nettyHttp("https://random-data-api.com/api/v2/banks").keepAlive(true))
                .process(e -> {
                    // use classes from camel-netty-http dependency in the source code
                    // and have jbang able to generate project with the dependencies ready
                    // to use in your IDE of choice
                    NettyHttpMessage msg = e.getMessage(NettyHttpMessage.class);
                    LOG.info("Netty HTTP response:\n\n\n{}\n\n\n", msg.getHttpResponse());
                })
                .log("Found bank:")
          .to(stream("out"));
    }
}
----

TIP: You can use `camel dependency update foo.java` to update the dependencies.

Notice how we specify https://www.jbang.dev/documentation/guide/latest/dependencies.html[JBang dependencies] at the top of the file.
We want JBang to know and prepare for the IDE of choice.
The first `//DEPS` is the `@pom` which set up the Camel version to use.
The following `//DEPS` declares the Camel component we use.

You can now open this source file for editing in your IDE of choice by using jbang CLI as follows:

[source,bash]
----
$ jbang edit -b foo.java
----

You can find this example at: https://github.com/apache/camel-kamelets-examples/tree/main/jbang/jbang-edit

==== Updating dependencies in source code

When working with Java source code, then you can keep the JBang dependencies up to date using the following command:

[source,bash]
----
$ camel dependency update foo.java
----

TIP: You can use `--clean` to not keep any existing dependencies and generate a clean fresh list.

This will then automatic insert or update the JBang dependencies (`//DEPS`) in the top of the source file.

You may want to use this for making it easier to load the source into an IDE editor to do coding.
See the previous section for more details.

===== Updating dependencies in Maven projects

Camel JBang can also help with keeping Camel Maven dependencies up-to-date for Maven based projects.

For example if start using new Camel components, in your Camel routes. Then you would have to
add the corresponding Camel JAR dependencies to the pom.xml file.

You can use the `camel dependency update` command to automate this, by executing from the project folder:

[source,bash]
----
$ camel dependency update pom.xml
----

Notice, that only adding new Camel dependencies is supported. If you remove a component,
then you need to remove the dependency from the pom.xml manually.
Also, this is only intended for production code from `src/main` folder.

==== Camel route debugging using VSCode or IDEA editors

The Camel route debugger is available by default (the `camel-debug` component is automatically added to the classpath). By default, it can be reached through JMX at the URL `service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi/camel`.

You can then use the Integrated Development Environment (IDE) of your choice. For instance, https://plugins.jetbrains.com/plugin/9371-apache-camel[IntelliJ], https://marketplace.visualstudio.com/items?itemName=redhat.vscode-debug-adapter-apache-camel[VS Code] or https://marketplace.eclipse.org/content/textual-debugging-apache-camel[Eclipse Desktop].

A specific how-to is available for VS Code, see this https://youtu.be/owNhWxf42qk[video].

TIP: When exporting to Maven projects, then you can use the maven profile `camel.debug` that will include the `camel-debug` JAR
to make it possible for Camel IDE tools to do Camel route debugging.

==== Health Checks

The status of health checks can be accessed via Camel JBang from the CLI as follows:

[source,bash]
----
camel get health
  PID   NAME    AGE  ID             RL  STATE  RATE    SINCE   MESSAGE
 61005  mybind   8s  camel/context   R   UP    2/2/-  1s/3s/-
----

Here we can see the Camel is _UP_. The application has just been running for 8 seconds, and there
 have been two health checks invoked.

The output is showing the _default_ level of checks as:

- `CamelContext` health check
- Component-specific health checks (such as from `camel-kafka` or `camel-aws`, ...)
- Custom health checks
- Any check that are not UP

The _RATE_ column shows 3 numbers separated by `/`. So `2/2/-` means two checks in total, two successes, and no failures.
The two last columns will reset when a health check changes state as this number is the number of consecutive
checks that was successful or failure. So if the health check starts to fail, then the numbers could be:

[source,bash]
----
camel get health
  PID   NAME     AGE   ID             RL  STATE   RATE    SINCE    MESSAGE
 61005  mybind   3m2s  camel/context   R   UP    77/-/3  1s/-/17s  some kind of error
----

Here we can see the numbers are changed to `77/-/3`. This means the total is 77. There is no success, but
the check has been failing three times in a row. The _SINCE_ column corresponds to the _RATE_. So in this
 case, we can see the last check was 1 second ago, and that the check has been failing for 17 seconds in a row.

You can use `--level=full` to output every health check, that will include consumer and route level checks
as well.

A health check may often be failed due to an exception was thrown which can be shown via `--trace` flag:

[source,bash]
----
camel get health --trace
  PID   NAME      AGE   ID                                        RL  STATE    RATE       SINCE     MESSAGE
 61038  mykafka  6m19s  camel/context                             R   UP    187/187/-  1s/6m16s/-
 61038  mykafka  6m19s  camel/kafka-consumer-kafka-not-secure...  R  DOWN   187/-/187  1s/-/6m16s  KafkaConsumer is not ready - Error: Invalid url in bootstrap.servers: value


------------------------------------------------------------------------------------------------------------------------
                                                       STACK-TRACE
------------------------------------------------------------------------------------------------------------------------
	PID: 61038
	NAME: mykafka
	AGE: 6m19s
	CHECK-ID: camel/kafka-consumer-kafka-not-secured-source-1
	STATE: DOWN
	RATE: 187
	SINCE: 6m16s
	METADATA:
		bootstrap.servers = value
		group.id = 7d8117be-41b4-4c81-b4df-cf26b928d38a
		route.id = kafka-not-secured-source-1
		topic = value
	MESSAGE: KafkaConsumer is not ready - Error: Invalid url in bootstrap.servers: value
	org.apache.kafka.common.KafkaException: Failed to construct kafka consumer
		at org.apache.kafka.clients.consumer.KafkaConsumer.<init>(KafkaConsumer.java:823)
		at org.apache.kafka.clients.consumer.KafkaConsumer.<init>(KafkaConsumer.java:664)
		at org.apache.kafka.clients.consumer.KafkaConsumer.<init>(KafkaConsumer.java:645)
		at org.apache.kafka.clients.consumer.KafkaConsumer.<init>(KafkaConsumer.java:625)
		at org.apache.camel.component.kafka.DefaultKafkaClientFactory.getConsumer(DefaultKafkaClientFactory.java:34)
		at org.apache.camel.component.kafka.KafkaFetchRecords.createConsumer(KafkaFetchRecords.java:241)
		at org.apache.camel.component.kafka.KafkaFetchRecords.createConsumerTask(KafkaFetchRecords.java:201)
		at org.apache.camel.support.task.ForegroundTask.run(ForegroundTask.java:123)
		at org.apache.camel.component.kafka.KafkaFetchRecords.run(KafkaFetchRecords.java:125)
		at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
		at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
		at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
		at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
		at java.base/java.lang.Thread.run(Thread.java:829)
	Caused by: org.apache.kafka.common.config.ConfigException: Invalid url in bootstrap.servers: value
		at org.apache.kafka.clients.ClientUtils.parseAndValidateAddresses(ClientUtils.java:59)
		at org.apache.kafka.clients.ClientUtils.parseAndValidateAddresses(ClientUtils.java:48)
		at org.apache.kafka.clients.consumer.KafkaConsumer.<init>(KafkaConsumer.java:730)
		... 13 more
----

Here we can easily see that the health check is failing because of the `org.apache.kafka.common.config.ConfigException`
which is due to invalid configuration: `Invalid url in bootstrap.servers: value`.

TIP: Use `camel get health --help` to see all the various options.


== Running with Spring Boot or Quarkus

Camel JBang is __primary__ intended to be Camel standalone only. In *Camel 4.6* onwards, we added limited
support for running with Spring Boot or Quarkus, but there are some limitations.

You use the `--runtime` option to specify which platform to use, as shown below:

[source,bash]
----
camel run foo.camel.yaml --runtime=spring-boot
----

And for Quarkus:

[source,bash]
----
camel run foo.camel.yaml --runtime=quarkus
----

When running this way, then Camel JBang is _essentially_ doing an _export_ to a temporary folder,
and then running Spring Boot or Quarkus using Maven.

You can do changes to the source file and have Quarkus and Spring Boot reload the routes, just as `camel run --dev` can do,
but uses the natural Spring Boot _dev-tools_ and Quarkus _dev mode_ functionality.

There are several limitations, one would be that Spring Boot and Quarkus cannot automatically detect new components and download JARs.
(you can stop and run again to update dependencies).

When using Quarkus, then you can only select the Quarkus version to run. That is locked to a specific Camel version.
You can see the versions by `camel version list --runtime=quarkus`. On the other hand Spring Boot is more flexible
where you can choose different Spring Boot and Camel versions (within reasonable range).

For example:

[source,bash]
----
camel run foo.camel.yaml --runtime=spring-boot --spring-boot-version=3.2.3 --camel-version=4.4.1
----

And for Quarkus:

[source,bash]
----
camel run foo.camel.yaml --runtime=quarkus --quarkus-version=3.9.4
----


== Transforming message (data mapping)

When integrating a system, you often need to transform messages from one system to another. Camel has a rich set
of capabilities for this such as various data formats, templating languages, and much more. However, for basic
data mapping such as taking an existing incoming JSON document and transforming this to a smaller JSON document,
you may want to do this quickly with Camel.

The `camel transform message` command can be used for such tasks, where it can take an existing source file as input,
and then a template that defines how to transform the data, and then show the output (in real time).

For example, given this JSon document (in a file named `random.json`), we want to combine the name, and select a few fields:

[source,json]
----
{
  "id": 9914,
  "uid": "eb5fa603-1db6-45f9-912a-431a6ed59b18",
  "password": "ei7gvYKdnN",
  "first_name": "Khalilah",
  "last_name": "Monahan",
  "username": "khalilah.monahan",
  "email": "khalilah.monahan@email.com",
  "avatar": "https://robohash.org/utnumquamexcepturi.png?size=300x300&set=set1",
  "gender": "Agender",
  "phone_number": "+54 (421) 591-5640 x333",
  "social_insurance_number": "268418308",
  "date_of_birth": "1975-03-11",
  "employment": {
    "title": "Product Design Director",
    "key_skill": "Work under pressure"
  },
  "address": {
    "city": "New Fritzchester",
    "street_name": "Patrick Common",
    "street_address": "4538 Reggie Inlet",
    "zip_code": "16282-7045",
    "state": "New York",
    "country": "United States",
    "coordinates": {
      "lat": -1.9868753435474673,
      "lng": 39.09763956726292
    }
  },
  "credit_card": {
    "cc_number": "4493983042212"
  },
  "subscription": {
    "plan": "Student",
    "status": "Active",
    "payment_method": "Debit card",
    "term": "Monthly"
  }
}
----

Then we can have a `transform.json` file as the beginning of the template, with the structure of the desired output:

[source,json]
----
{
    "sid": 123,
	"name": "TODO",
	"country": "TODO",
	"phone": "TODO",
	"student": false
}
----

We can then run `camel transform message` and have it update (in real time) the output every time we change the template.

[source,bash]
----
$ camel transform message --body=file:random.json --language=simple --template=file:transform.json --pretty --watch
----

What happens is then Camel will output on the console as you go:

[source,bash]
----
 Exchange  (DefaultExchange)  InOut   23F5DD4CE6C260B-0000000000000002
 Message   (DefaultMessage)
 Body      (String) (bytes: 118)
 {
   "sid": 123,
   "name": "TODO",
   "country": "TODO",
   "phone": "TODO",
   "student": false
 }
----

Then you can update the `transform.json` file and save it and see the generated output:

[source,json]
----
{
   "sid": ${jq(.id)},
   "name": "${jq(.first_name)} ${jq(.last_name)}",
   "country": "TODO",
   "phone": "TODO",
   "student": false
}
----

And the output:

[source,bash]
----
 Exchange  (DefaultExchange)  InOut   23F5DD4CE6C260B-0000000000000018
 Message   (DefaultMessage)
 Body      (String) (bytes: 158)
 {
   "sid": 9914,
   "name": "Khalilah Monahan",
   "country": "TODO",
   "phone": "TODO",
   "student": false
 }
----

Then you can continue to update the `transform.json` until you have the desired result.
And if you make a mistake, then you see an error (in red) with stacktrace that hopefully can help you out how to fix this.

=== Transforming directly from the Camel DSL source

In the example above we externalize the transformation into a template file named `transform.json`.
However, it's possible to transform directly in the Camel DSL route.

NOTE: Currently Java DSL is not working in --watch mode (reload on change)

In the following, we cover the json-transform example from: https://github.com/apache/camel-kamelets-examples/tree/main/jbang/json-transform

In this example, a random beer is fetched via the beer-source kamelet. The beer data is as follows:

[source,json]
----
 {
   "id": 2104,
   "uid": "cefb36e1-e42f-4083-8f97-fc4ff85e56fb",
   "brand": "Pabst Blue Ribbon",
   "name": "St. Bernardus Abt 12",
   "style": "Belgian Strong Ale",
   "hop": "Amarillo",
   "yeast": "1388 - Belgian Strong Ale",
   "malts": "Caramel",
   "ibu": "43 IBU",
   "alcohol": "3.8%",
   "blg": "16.0°Blg"
 }
----

We save this beer into a file named `sample.json` as we want to use this as source for message transformation.

Now suppose we want to transform this to a smaller JSON document with only a few elements, then we can do this
directly in the route:

[source,yaml]
----
- route:
    nodePrefixId: route-c38
    id: route-66b0
    from:
      uri: kamelet:beer-source
      id: from-3996
      steps:
        - setBody:
            expression:
              simple:
                expression: >-
                  TODO
                id: simple-b320
            id: setBody-fa01
        - log:
            message: ${body}
            id: log-0c79
----

As we can see the route has a `setBody` where we want to transform the message, which we can do with the simple
language combined with JQ (or JSonPath). At first, we just write TODO to get started:

[source,bash]
----
camel transform message --body=file:sample.json --source=beer-jq.yaml  --watch --pretty
----

And the output from the transformation is:

[source,text]
----
 Exchange  (DefaultExchange)  InOut   D9F909701338607-0000000000000004
 Message   (DefaultMessage)
 Body      (String) (bytes: 4)
 TODO
----

We can now do live updates in the Camel route, and when we save the file, the transform command will output the changes in the terminal.
So we modify the DSL to grab the details we want, such as:

[source,yaml]
----
    expression: >-
      {
        "kind": "${jq(.brand)}",
        "beer": "${jq(.name)}"
      }
    id: simple-b320
----

Notice how we use inlined JQ expressions to grab the desired data from the sample, and when saving the file, we have
the result shown in the terminal:

[source,text]
----
 Exchange  (DefaultExchange)  InOut   D9F909701338607-000000000000003E
 Message   (DefaultMessage)
 Body      (String) (bytes: 78)
 {
   "kind": "Pabst Blue Ribbon",
   "beer": "St. Bernardus Abt 12"
 }
----

And when we are done with the transformation we can stop by `ctrl + c` to exit the command.

When transforming messages directly from the DSL (using the `--source` option), then by default
Camel will pick the last expression in the route. If you only have one expression like in this example,
then that is easy. But when you have many, then you need to tell which one to use.

You can do this either by referring to the line number in the source code of the EIP / expression, or
by its id (if specified).

So suppose the example had many expressions, and the one we want to use is on line 11, then we can do as follows:

[source,bash]
----
camel transform message --body=file:sample.json --source=beer-jq.yaml:11  --watch --pretty
----

Notice how we specify the line number in the source file name, by prefixing with `:line-number`.
The line number does not have to be 100% accurate, as long the number is within range of the EIP, until
the next EIP in the route. In the example, this means you can pick number in range 8-17.

If we want to use the id of the expression/EIP, we can do the same as shown below:

[source,bash]
----
camel transform message --body=file:sample.json --source=beer-jq.yaml:setBody-fa01  --watch --pretty
----

You can also transform the message from JSON to XML as shown (or any other kind of fixed structure):

[source,yaml]
----
- setBody:
    expression:
      simple:
        expression: >-
          <beer id="${jq(.id)}">
            <name>${jq(.name)}</name>
            <kind>${jq(.brand)}</kind>
          </beer>
        id: simple-b320
    id: setBody-fa01
----

You can configure options that the language format should use, such as shown below:

[source,bash]
----
$ camel transform message --body=file:sample.json --language=jsonpath --template="beer.unknown" --option=suppressExceptions=true
----

TIP: You can specify multiple options by repeating the `--option` argument.

Pay attention that we now use JSONPath as the language, and the template is a tiny JSON path expression.
Because the sample does not have a `beer.unknown` path, then JSonPath would normally throw an exception.
This can be suppressed by setting the option `suppressExceptions` to `true` as shown above. Then the output is as follows:

[source,text]
----
2023-12-04 13:02:50.923  66291 --- Message transformed (success) (239ms)
 Exchange  (DefaultExchange)  InOut   6118686CA3995FF-0000000000000000
 Message   (DefaultMessage)
 Body      (null) (bytes: 14)
 [Body is null]
----

=== Transforming the message using Components

Some components can also be used for message transformation such as FlatPack, Velocity, FreeMarker, Thymeleaf, and good old XSLT.

TIP: You can use `camel catalog component --filter=transform` to see which components can be transformation.

Given the below XML in the `sample.xml` file:

[source,xml]
----
<hash>
  <id type="integer">1369</id>
  <uid>8c946e1a-fdc5-40d3-9098-44271bdfad65</uid>
  <account-number>8673088731</account-number>
  <iban>GB38EFUA27474531363797</iban>
  <bank-name>ABN AMRO MEZZANINE (UK) LIMITED</bank-name>
  <routing-number>053228004</routing-number>
  <swift-bic>AACCGB21</swift-bic>
</hash>
----

Then you can transform this using an XSLT named `mystyle.xsl`:

[source,xml]
----
<?xml version = "1.0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:template match="/">
    <bank>
    	<name><xsl:value-of select="/hash/bank-name/text()"/></name>
    	<bic><xsl:value-of select="/hash/swift-bic/text()"/></bic>
    </bank>
  </xsl:template>

</xsl:stylesheet>
----

Then you can do live changes to the stylesheet and see the output in real-time with Camel JBang by running:

[source,bash]
----
$ camel transform message --body=file:sample.xml --component=xslt --template=file:mystyle.xsl --pretty --watch
----

You can then edit the `mystyle.xsl` file, and save the file, and watch the terminal for the updated result.

You can find this example at: https://github.com/apache/camel-kamelets-examples/tree/main/jbang/xslt-transform

You can configure options that the XSLT component format should use, such as shown below:

[source,bash]
----
$ camel transform message --body=file:sample.xml --component=xslt --template=file:mystyle.xsl --option=output=bytes --pretty --watch
----

TIP: You can specify multiple options by repeating the `--option` argument.

NOTE: The transform message with the component is limited as some components require configuring complex options that cannot be set from command line.

=== Transforming a message using Data Formats

Some data formats can also be used for message transformation such as Base64, Csv, FlatPack.

TIP: You can use `camel catalog dataformat --filter=transform` to see which components can be transformation.

Given the below CSV file in the `daltons.csv`:

[source,text]
----
Jack Dalton, 115, mad at Averell
Joe Dalton, 105, calming Joe
William Dalton, 105, keeping Joe from killing Averell
Averell Dalton, 80, playing with Rantanplan
Lucky Luke, 120, capturing the Daltons
----

Then you can transform this via Camel CSV dataformat from its form into Java objects (unmarshal).
This will NOT transform the CSV into another format such as XML, but allows you to quickly try out the dataformat,
and be able to inspect the Java object inside Camel.

[source,bash]
----
$ camel transform message --body=file:daltons.csv --dataformat=csv
----

This will then output:

[source,text]
----
2023-12-04 10:53:45.578  55793 --- Message transformed (success) (176ms)
 Exchange  (DefaultExchange)  InOut   6673987D34F3B54-0000000000000000
 Message   (DefaultMessage)
 Body      (ArrayList) (size: 5 bytes: 224)
 [[Jack Dalton,  115,  mad at Averell], [Joe Dalton,  105,  calming Joe], [William Dalton,  105,  keeping Joe from killing Averell], [Averell Dalton,  80,
 playing with Rantanplan], [Lucky Luke,  120,  capturing the Daltons]]
----

As you can see Camel CSV dataformat will then unmarshal the input (from CSV file) to a `java.util.ArrayList` object
with 5 elements (one per row), and each row is another List of the columns.

You can configure options that the CSV data format should use, such as shown below:

[source,bash]
----
$ camel transform message --body=file:daltons.csv --dataformat=csv --option=captureHeaderRecord=true
----

TIP: You can specify multiple options by repeating the `--option` argument.

NOTE: The transform message with dataformat is limited as some dataformat requires configuring complex options that cannot be set from the command line.

== Transforming routes DSL

Camel offers different DSLs, such as Java, XML, YAML, and more. Many graphical editors and code generators use XML and YAML Camel DSL, therefore, for some use cases it may be required to use one DSL or the other.
The `camel transform route` command can be used to transform a YAML route into an XML and vice versa, the command takes a list of files as input and transforms the DSL.

For example, given the following YAML content, in a file named route.yaml

[source:yaml]
----
- route:
    id: route-b785
    nodePrefixId: route-14b
    from:
      id: from-959e
      uri: direct
      parameters:
        name: start
      steps:
        - choice:
            id: choice-52fe
            when:
              - id: when-b126
                expression:
                  simple:
                    id: simple-576d
                    expression: ${header.foo} == 'bar'
                steps:
                  - to:
                      id: to-65f9
                      uri: jms
                      parameters:
                        destinationName: queue
            otherwise:
              id: otherwise-c07f
              steps:
                - to:
                    id: to-dc76
                    uri: log
                    parameters:
                      loggerName: default
----

The following command

[source:bash]
----
camel transform route --format=xml /path/to/route.yaml
----

Automatically transform the route in XML DSL (Camel XML IO DSL)

[source:xml]
----
<camel>
    <route id="route-b785" nodePrefixId="route-14b">
        <from id="from-959e" uri="direct:start"/>
        <choice id="choice-52fe">
            <when id="when-b126">
                <simple>${header.foo} == 'bar'</simple>
                <to id="to-65f9" uri="jms:queue"/>
            </when>
            <otherwise id="otherwise-c07f">
                <to id="to-dc76" uri="log:default"/>
            </otherwise>
        </choice>
    </route>
</camel>
----

TIP: If all the input files have the same extension and are written with the same DSL, for example, `.yaml`, the transformation will default to the XML DSL and vice versa.

== Listing what Camel components are available

Camel comes with a lot of artifacts out of the box which comes as:

- components
- data formats
- expression languages
- miscellaneous components
- kamelets

You can use the Camel CLI to list what Camel provides via the `camel catalog` command.
For example, to list all the components

[source,bash]
----
camel catalog component
----

And to see which Kamelets are available:

[source,bash]
----
camel catalog kamelet
----

TIP: Use `camel catalog --help` to see all possible commands.

=== Displaying component documentation

The `doc` goal can show quick documentation for every component, dataformat, kamelets etc.
For example, to see the kafka component you run:

[source,bash]
----
camel doc kafka
----

NOTE: The documentation is not the full documentation as shown on the website, as the Camel CLI does not have direct
access to this information and can only show a basic description of the component, but include tables for every
configuration option.

To see the documentation for jackson dataformat:

[source,bash]
----
camel doc jackson
----

In some rare cases then there may be a component and dataformat with the same name, and the `doc` goal prioritizes
components. In such a situation you can prefix the name with dataformat, i.e.:

[source,bash]
----
camel doc dataformat:thrift
----

You can also see the kamelet documentation such as shown:

[source,bash]
----
camel doc aws-kinesis-sink
----

==== Browsing online documentation from the Camel website

You can use the `doc` command to quickly open the url in the web browser for the online documentation.
For example, to browse the kafka component, you use `--open-url`:

[source,bash]
----
camel doc kafka --open-url
----

This also works for data formats, languages, kamelets etc.

[source,bash]
----
camel doc aws-kinesis-sink --open-url
----

TIP: To just get the link to the online documentation, then use `camel doc kafka --url`.

==== Filtering options listed in the tables

Some components may have many options, and in such cases you may use `--filter` to only list options that match the filter
in either name, description, or the group (producer, security, advanced, etc).

For example, to list only security related options:

[source,bash]
----
camel doc kafka --filter=security
----

And to list only something about _timeout_:

[source,bash]
----
camel doc kafka --filter=timeout
----

== Open API

Camel JBang allows quickly exposing an Open API service using _contract-first_ approach,
where you have an existing OpenAPI specification file.

Then Camel JBang is able to bridge each API endpoint from the OpenAPI specification to
a Camel route with the naming convention `direct:<operationId>`.

This make it quick to implement a Camel route for a given operation.

See the https://github.com/apache/camel-kamelets-examples/tree/main/jbang/open-api[open-api example] for more details.

== Gathering list of dependencies

When working with Camel JBang, then dependencies are automatically resolved. This means that
you do not have to use a build system like Maven or Gradle to add every Camel component
as a dependency.

However, you may want to know what dependencies are required to run the Camel integration.
To see this, you can use the `dependency` command. The command output does not output a detailed
tree, such as `mvn dependencies:tree`, as the output is intended to list which Camel components,
and other JARs needed (when using Kamelets).

The dependency output by default is _vanilla_ Apache Camel with the camel-main as runtime, as shown below:

[source,bash]
----
camel dependency list
org.apache.camel:camel-dsl-modeline:3.20.0
org.apache.camel:camel-health:3.20.0
org.apache.camel:camel-kamelet:3.20.0
org.apache.camel:camel-log:3.20.0
org.apache.camel:camel-rest:3.20.0
org.apache.camel:camel-stream:3.20.0
org.apache.camel:camel-timer:3.20.0
org.apache.camel:camel-yaml-dsl:3.20.0
org.apache.camel.kamelets:camel-kamelets:0.9.3
----

The output is by default a line per maven dependency in GAV format (_groupId:artifactId:version_).

You can also specify the output should be in _Maven format_ as shown:

[source,bash]
----
camel dependency list --output=maven
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-main</artifactId>
    <version>3.20.0</version>
</dependency>
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-dsl-modeline</artifactId>
    <version>3.20.0</version>
</dependency>
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-health</artifactId>
    <version>3.20.0</version>
</dependency>
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-kamelet</artifactId>
    <version>3.20.0</version>
</dependency>
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-log</artifactId>
    <version>3.20.0</version>
</dependency>
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-rest</artifactId>
    <version>3.20.0</version>
</dependency>
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-stream</artifactId>
    <version>3.20.0</version>
</dependency>
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-timer</artifactId>
    <version>3.20.0</version>
</dependency>
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-yaml-dsl</artifactId>
    <version>3.20.0</version>
</dependency>
<dependency>
    <groupId>org.apache.camel.kamelets</groupId>
    <artifactId>camel-kamelets</artifactId>
    <version>0.9.3</version>
</dependency>
----

You can also choose the target runtime as either _quarkus_ or _spring-boot_ as shown:

[source,bash]
----
camel dependency --runtime=spring-boot
org.springframework.boot:spring-boot-starter-actuator:2.7.5
org.springframework.boot:spring-boot-starter-web:2.7.5
org.apache.camel.springboot:camel-spring-boot-engine-starter:3.20.0
org.apache.camel.springboot:camel-dsl-modeline-starter:3.20.0
org.apache.camel.springboot:camel-kamelet-starter:3.20.0
org.apache.camel.springboot:camel-log-starter:3.20.0
org.apache.camel.springboot:camel-rest-starter:3.20.0
org.apache.camel.springboot:camel-stream-starter:3.20.0
org.apache.camel.springboot:camel-timer-starter:3.20.0
org.apache.camel.springboot:camel-yaml-dsl-starter:3.20
org.apache.camel.kamelets:camel-kamelets:0.9.3
----

== Generating SBOM report

[source,bash]

You can generate a SBOM report of your integration by running the following command

----
camel sbom
----

By default, it will generate a file named `sbom.json` in `cyclonedx` format.

You can also choose to use an `spdx` format with the following command

----
camel sbom --sbom-format=spdx
----

You can also choose the target runtime as either _quarkus_ or _spring-boot_ as shown:

----
camel sbom --runtime=quarkus
----

or

----
camel sbom --runtime=spring-boot
----

by default `camel-main` will be used

=== Copying dependency JARs to a specific directory

You can use the `camel dependency copy` command to copy the required JARs to a specific folder.

IMPORTANT: The `camel dependency copy` and `camel dependency list` uses Apache Maven,
This requires having Apache Maven installed, and `mvn` command in PATH environment, so Camel JBang
can invoke `mvn` command.

By default, the JARs are copied to `lib` folder:

[source,bash]
----
camel dependency copy
ls lib
camel-api-3.21.0.jar                    camel-health-3.21.0.jar                 camel-yaml-dsl-3.21.0.jar
camel-base-3.21.0.jar                   camel-main-3.21.0.jar                   camel-yaml-dsl-common-3.21.0.jar
camel-base-engine-3.21.0.jar            camel-management-api-3.21.0.jar         camel-yaml-dsl-deserializers-3.21.0.jar
camel-core-engine-3.21.0.jar            camel-rest-3.21.0.jar                   jakarta.activation-api-1.2.2.jar
camel-core-languages-3.21.0.jar         camel-support-3.21.0.jar                jakarta.xml.bind-api-2.3.3.jar
camel-core-model-3.21.0.jar             camel-timer-3.21.0.jar                  slf4j-api-1.7.36.jar
camel-core-processor-3.21.0.jar         camel-tooling-model-3.21.0.jar          snakeyaml-engine-2.3.jar
camel-core-reifier-3.21.0.jar           camel-util-3.21.0.jar
camel-dsl-support-3.21.0.jar            camel-util-json-3.21.0.jar
----

== Creating Projects

You can _export_ your Camel JBang integration to a traditional Java-based project such as Spring Boot or Quarkus.

You may want to do this after you have built a prototype using Camel JBang, and are in need
of a traditional Java-based project with more need for Java coding, or wanting to use the powerful
runtimes of Spring Boot, Quarkus or vanilla Camel Main.

=== Exporting to Camel Spring Boot

The command `export --runtime=spring-boot` will export your current Camel JBang file(s) to a Maven-based
Spring Boot project with files organized in `src/main/` folder structure.

For example, to export to Spring Boot using the Maven groupId `_com.foo_` and the artifactId _acme_
and with version _1.0-SNAPSHOT_ you execute:

[source,bash]
----
camel export --runtime=spring-boot --gav=com.foo:acme:1.0-SNAPSHOT
----

NOTE: This will export to the _current_ directory, meaning that files are moved into the needed folder structure.

To export to another directory (copies the files), you execute:

[source,bash]
----
camel export --runtime=spring-boot --gav=com.foo:acme:1.0-SNAPSHOT --directory=../myproject
----

When exporting to Spring Boot then the Camel version defined in the `pom.xml` or `build.gradle` is
the same version as Camel JBang uses. However, you can specify the Camel version as shown below:

[source,bash]
----
camel export --runtime=spring-boot --gav=com.foo:acme:1.0-SNAPSHOT --directory=../myproject --camel-spring-boot-version=3.18.3
----

TIP: See the possible options by running: `camel export --help` for more details.

=== Exporting to Camel Quarkus

The command `export --runtime=quarkus` will export your current Camel JBang file(s) to a Maven-based
Quarkus project with files organized in `src/main/` folder structure.

For example, to export to Quarkus using the Maven groupId `_com.foo_` and the artifactId _acme_
and with version _1.0-SNAPSHOT_ you simply execute:

[source,bash]
----
camel export --runtime=quarkus --gav=com.foo:acme:1.0-SNAPSHOT
----

NOTE: This will export to the _current_ directory, meaning that files are moved into the necessary folder structure.

To export to another directory (copies the files) you execute:

[source,bash]
----
camel export --runtime=quarkus --gav=com.foo:acme:1.0-SNAPSHOT --directory=../myproject
----

TIP: See the possible options by running: `camel export --help` for more details.

NOTE: You cannot use `--profile` option when exporting to Camel Quarkus.

=== Exporting to Camel Main

The command `export --runtime=camel-main` will export your current Camel JBang file(s) to a Maven-based
vanilla Camel Main project with files organized in `src/main/` folder structure.

For example, to export to Camel Main using the Maven groupId _com.foo_ and the artifactId _acme_
and with version _1.0-SNAPSHOT_ you simply execute:

[source,bash]
----
camel export --runtime=camel-main --gav=com.foo:acme:1.0-SNAPSHOT
----

NOTE: This will export to the _current_ directory, meaning that files are moved into the needed folder structure.

To export to another directory (copies the files), you execute:

[source,bash]
----
camel export --runtime=camel-main --gav=com.foo:acme:1.0-SNAPSHOT --directory=../myproject
----

TIP: See the possible options by running: `camel export --help` for more details.

==== Exporting with Java Agent included

The Camel Main runtime allows exporting with Java Agents that makes it easier to run your Camel integration
with Java Agents such as OpenTelemetry Agent.

NOTE: Only `camel-main` as runtime supports exporting with Java Agents included.

This requires specifying the agent as a dependency with `agent:` as prefix as shown below in `application.properties`:

[source,properties]
----
camel.jbang.dependencies=camel:opentelemetry,agent:io.opentelemetry.javaagent:opentelemetry-javaagent:1.31.0
camel.opentelemetry.enabled=true
----

Then you can export to `--runtime=camel-main` as follows:

[source,bash]
----
camel export --runtime=camel-main --gav=com.foo:acme:1.0-SNAPSHOT --directory=../myproject
----

Then Camel JBang will detect the `agent:` dependency and download this from Maven and save to a `../myproject/agent` folder.
You can then start the Camel integration from Java via:

[source,bash]
----
cd ../myproject
mvn clean package
java -javaagent:agent/opentelemetry-javaagent-1.31.0.jar -jar target/acme-1.0-SNAPSHOT.jar
----

=== Exporting with selected files

By default, Camel will export what was last run, or all files from the current directory.
You can also explicitly specify which files should be exported.

For example, you may have 3 files in a folder:

- Foo.java
- bar.xml
- cheese.yaml

These are 3 Camel routes, and you want to export them into 2 different applications:

[source,bash]
----
camel export Foo.java --runtime=quarkus --gav=com.foo:acme:1.0-SNAPSHOT --directory=../export1
camel export bar.xml cheese.yaml --runtime=spring-boot --gav=com.foo:cheese:1.0-SNAPSHOT --directory=../export2
----

As you can see the first export command will only include `Foo.java`, and then 2nd export includes both `bar.xml` and `cheese.yaml`.

NOTE: If you have `application.properties` in the folder as well, then this will be included in both exports.

=== Exporting as Gradle Project

Camel JBang exports by default as a Maven-based project. To use Gradle instead, you can
specify the `--build-tool=gradle` when exporting, such as:

[source,bash]
----
camel export --build-tool=gradle --runtime=spring-boot --gav=com.foo:acme:1.0-SNAPSHOT --directory=../myproject
----

=== Exporting with JMX management included

Usually when exporting to Spring Boot, Quarkus or Camel Main, then JMX management is not included out of the box.
To include JMX, you need to add `camel:management` in the `--dep` option, as shown below:

[source,bash]
----
camel export --runtime=quarkus --gav=com.foo:acme:1.0-SNAPSHOT --dep=camel:management --directory=../myproject
----

=== Exporting with Camel CLI included

Usually when exporting to Spring Boot, Quarkus or Camel Main, then Camel JBang CLI is not included out of the box.
To be able to continue to use Camel CLI (i.e. `camel`), you need to add `camel:cli-connector` in the `--dep` option, as shown below:

[source,bash]
----
camel export --runtime=quarkus --gav=com.foo:acme:1.0-SNAPSHOT --dep=camel:cli-connector --directory=../myproject
----

=== Troubleshooting exporting

When exporting then Camel CLI performs a set of tasks which can go wrong.
To see more activity during exporting you can turn on both `--verbose` and `--logging` that
prints more information to the console. You can also set `--logging-level=DEBUG` to output even more details.

If your Camel application cannot be exported, for example due to some custom Java code, you can
try to export with `--ignore-loading-error`.

TIP: Camel will by default store export logs to `<user home>/.camel/camel-export.log` file of the last export run (unless you turn on `--logging` that logs only to console).

=== Configuring exporting

The export command will by default load configuration from `application.properties`
which also can be used to specific parameters for export such as selecting the runtime and java version.

The follow options related to _exporting_, can be configured in `application.properties`:

|===
|Option | Description

|`camel.jbang.runtime`
|Runtime (spring-boot, quarkus, or camel-main)

|`camel.jbang.gav`
|The Maven group:artifact:version

|`camel.jbang.dependencies`
|Additional dependencies (Use commas to separate multiple dependencies). See more details at xref:_adding_custom_jars[].

|`camel.jbang.excludes`
|Exclude files by name or pattern. Multiple names can be separated by comma.

|`camel.jbang.classpathFiles`
|Additional files to add to classpath (Use commas to separate multiple files). See more details at xref:_adding_custom_jars[].

|`camel.jbang.jkubeFiles`
|Resource fragments for Kubernetes (Use commas to separate multiple files).

|`camel.jbang.javaVersion`
|Java version (17 or 21). Java 17 is default.

|`camel.jbang.kameletsVersion`
|Apache Camel Kamelets version

|`camel.jbang.localKameletDir`
|Local directory for loading Kamelets

|`camel.jbang.camelSpringBootVersion`
|Camel version to use with Spring Boot

|`camel.jbang.springBootVersion`
|Spring Boot version

|`camel.jbang.quarkusGroupId`
|Quarkus Platform Maven groupId

|`camel.jbang.quarkusArtifactId`
|Quarkus Platform Maven artifactId

|`camel.jbang.quarkusVersion`
|Quarkus Platform version

|`camel.jbang.mavenWrapper`
|Include Maven Wrapper files in the exported project

|`camel.jbang.gradleWrapper`
|Include Gradle Wrapper files in the exported project

|`camel.jbang.buildTool`
|Build tool to use (Maven or Gradle)

|`camel.jbang.repos`
|Additional maven repositories for download on-demand (Use commas to separate multiple repositories)

|`camel.jbang.mavenSettings`
|Optional location of Maven settings.xml file to configure servers, repositories, mirrors, and proxies. If set to false, not even the default ~/.m2/settings.xml will be used.

|`camel.jbang.mavenSettingsSecurity`
|Optional location of Maven settings-security.xml file to decrypt settings.xml

|`camel.jbang.mavenCentralEnabled`
|Whether downloading JARs from Maven Central repository is enabled

|`camel.jbang.mavenApacheSnapshotEnabled`
|Whether downloading JARs from ASF Maven Snapshot repository is enabled

|`camel.jbang.exportDir`
|Directory where the project will be exported

|`camel.jbang.platform-http.port`
| HTTP server port to use when running standalone Camel, such as when `--console` is enabled (port 8080 by default).

|`camel.jbang.console`
| Developer console at /q/dev on local HTTP server (port 8080 by default) when running standalone Camel

|`camel.jbang.info`
| Info console at /q/info on local HTTP server (port 8080 by default) when running standalone Camel

|`camel.jbang.health`
| Health check at /q/health on local HTTP server (port 8080 by default) when running standalone Camel

|`camel.jbang.metrics`
| Metrics (Micrometer and Prometheus) at /q/metrics on local HTTP server (port 8080 by default) when running standalone Camel

|`camel.jbang.open-api`
| File name of open-api spec file (JSON or YAML) that are used when using `--open-api` to generate routes from the swagger/openapi API spec file.

|`camel.jbang.ignoreLoadingError`
| Whether to ignore route loading and compilation errors (use this with care!)

|`camel.jbang.jib-maven-plugin-version`
| Version to use for jib-maven-plugin if exporting to camel-main and have Kubernetes enabled (jkube.xxx options).

|===

NOTE: These are options from the export command, so you can see more details and default values using `camel export --help`.

== Configuration

Camel JBang `config` command is used to store and use the user configuration. This eliminates the need to specify CLI options each time. For example, to run a different Camel version, instead of executing

[source,bash]
----
camel run * --camel-version=3.18.4
----

the camel-version can be added to the user configuration such as:

[source,bash]
----
camel config set camel-version=3.18.4
----

Now, the run command picks the user configuration:

[source,bash]
----
camel run *
----

=== Configuration Locations

Camel JBang uses two possible configuration files:

- Global configuration: ~/.camel-jbang-user.properties
- Local configuration: ./camel-jbang-user.properties

=== Configuration Precedence

When both files exist, the local configuration takes precedence over the global configuration.

=== Using Configuration Commands

All camel config commands target the global configuration by default. To work with the local configuration instead, add the `--global=false` flag:
[source,bash]
----
camel config <command> --global=false
----
This directs all configuration changes to the local ./camel-jbang-user.properties file.

IMPORTANT: You cannot use both a set version via `camel config set` and also a version specified via `--camel-version` option,
i.e., the following is not possible:

[source,bash]
----
camel config set camel-version=4.0.1
camel run * --camel-version=4.3.0
----

=== Set and unset configuration

Every Camel JBang option is added to the user configuration. For example, to export a simple project such as

[source,bash]
----
camel init foo.yaml
camel config set gav=com.foo:acme:1.0-SNAPSHOT
camel config set runtime=spring-boot
camel config set deps=org.apache.camel.springboot:camel-timer-starter
camel config set camel-spring-boot-version=3.20.1

camel export
----

User configuration keys are unset using the following:

[source,bash]
----
camel config unset camel-spring-boot-version
----

=== List and get configurations

User configuration keys are listed using the following:

[source,bash]
----
camel config list
----

Following is the output for the above-mentioned configuration.

[source,bash]
----
runtime = spring-boot
deps = org.apache.camel.springboot:camel-timer-starter
gav = com.foo:acme:1.0-SNAPSHOT
----

To obtain a value for the given key, use the `get` command.

[source,bash]
----
camel config get gav

com.foo:acme:1.0-SNAPSHOT
----

=== Placeholders' substitutes

User configuration values can be used as placeholder substitutes with command line properties, for example:

[source,bash]
----
camel config set repos=https://maven.repository.my.repo.com/ga

camel run 'Test.java' --logging-level=info --repos=#repos,https://packages.atlassian.com/maven-external
----

In this example, since `repos` is set in the user configuration (`config set`) and the `camel run` command declares the placeholder `#repos`, `camel run` will replace the placeholder so that both repositories will be used during the execution.
Notice, that to refer to the configuration value the syntax is `#optionName` eg `#repos`.

NOTE: The placeholder substitution only works for every option that a given Camel command has.
You can see all the options a command has via the help, eg `camel run --help`.


== Troubleshooting

When using https://www.jbang.dev/[JBang] then JBang stores state in `~/.jbang` directory.
This is also the location where JBang stores downloaded JARs.

Camel JBang also downloads needed dependencies while running. However, these dependencies
are downloaded to your local Maven repository `~/.m2`.

So if you find problems with running Camel JBang using what is seems like an outdated JAR, then you can
try to delete these directories or parts of it.

== Infrastructure

Camel JBang `infra` command can be used to `list`, `run` and `stop` external services that can be used for fast prototyping and testing.
Apache Camel test-infra Services are exposed via the `infra` command, in this way, the same infrastructure that is used to test
Apache Camel itself, is exposed via Camel JBang, and services that are already proved to work with Apache Camel can be easily used.

=== List Services

Supported external services can be listed with the following command:

[source,bash]
----
camel infra list
----

Following is the output for the above-mentioned configuration.

[source,bash]
----
ALIAS                   IMPLEMENTATION
 ignite
 azure                   storage-queue
 openldap
 event-bridge
 xmpp
 kinesis
 redis
 ...
----

=== Run Service

Supported external services can be run with the following command (Docker or Podman is required for most of the service):

[source,bash]
----
camel infra run $SERVICE ($OPTIONAL_SERVICE_IMPLEMENTATION)
----

Once the service is up and running, information about the service are printed as json that can be easily used in the Camel Routes,
for example:

[source,bash]
----
$ camel infra run ftp

Starting service ftp
{
  "getPort" : 52472,
  "getFtpRootDir" : "file://path/to/current/directory/target/ftp/camel-test-infra-test-directory/camel-test-infra-configuration-test-directory"
}
----

[source,bash]
----
$ camel infra run kafka redpanda

Starting service kafka with implementation redpanda
{
  "getBootstrapServers" : "localhost:32771"
}
----

[source,bash]
----
$ camel infra run openldap

Starting service openldap
{
  "getPort" : 32774,
  "getSslPort" : 32775,
  "getHost" : "localhost"
}
----

=== Stop Service

Stop a running infrastructure service:

[source,bash]
----
$ camel infra run arangodb
...

$ camel infra ps
 ALIAS             IMPLEMENTATION  DESCRIPTION
 arangodb                          ArangoDB is a multi-model database for high-performance applications.

$ camel infra stop arangodb
Shutting down service arangodb (PID: {pidNumber})
----

=== List running services

Display running services, useful to retrieve the service ALIAS

[source,bash]
----
$ camel infra run arangodb
...

$ camel infra ps
 ALIAS             IMPLEMENTATION  DESCRIPTION
 arangodb                          ArangoDB is a multi-model database for high-performance applications.
---

=== Get running service

Display running service information, the command will print the json containing information about the running service (ex. host, port, username)

[source,bash]
----
$ camel infra run openldap
...

$ camel infra get openldap
{
  "getPort" : 32774,
  "getSslPort" : 32775,
  "getHost" : "localhost"
}
---

=== Get running services logs

The command `camel infra log` gathers and displays the log of all running services (similar to tail command)

[source,bash]
----
$ camel infra log
[service1] ...
[service2] ...
[service1] ...
[service2] ...
[service2] ...
[service2] ...
[service1] ...
[service2] ...
[service1] ...
[service1] ...
[service1] ...
---

In order to retrieve the log of a specific service the service alias can be provided

[source,bash]
----
$ camel infra log service
[service] ...
[service] ...
[service] ...
---

== Update

Apache Camel applications can be automatically updated using Camel JBang. The update command provides two main operations:

- `list`: Shows available Apache Camel versions for updating
- `run`: Executes the actual update process 

The update process leverages the https://github.com/apache/camel-upgrade-recipes[Apache Camel Open Rewrite recipes] and supports three application types:

- Plain Camel (camel-main)
- Camel Quarkus
- Camel Spring Boot

While Camel and Camel Spring Boot updates primarily use camel-upgrade-recipes, 
Camel Quarkus updates involve both the Quarkus runtime (via https://github.com/openrewrite/rewrite-quarkus[Rewrite Quarkus]) and Apache Camel recipes.

=== Listing Available Updates

To see which versions are available for updating, use:

[source,bash]
----
$ camel update list

 VERSION                       RUNTIME            RUNTIME VERSION  DESCRIPTION                                                                    
 4.4.4                         Camel Quarkus      3.8.x            Migrates `camel 4.0` quarkus application to `camel 4.4`.                       
 4.8.0                         Camel                               Migrates Apache Camel 4 application to Apache Camel 4.8.0                      
 4.8.3                         Camel Quarkus      3.15.x           Migrates `camel 4.4` quarkus application to `camel 4.8`.                       
 4.9.0                         Camel                               Migrates Apache Camel 4 application to Apache Camel 4.9.0                      
 4.9.0                         Camel Spring Boot  3.4.0            Migrates Apache Camel Spring Boot 4 application to Apache Camel Spring Boot 4.9.0
----

=== Running Updates

To perform an update to a specific version:

[source,bash]
----
$ camel update run $VERSION
----

NOTE: The update commands must be executed in the project directory containing the pom.xml file.

==== Configuration Options

The update process can be customized with several options:
`--runtime`: Specifies the application type:

- `camel-main` - Plain Camel applications
- `spring-boot` - Camel Spring Boot applications
- `quarkus` - Camel Quarkus applications

`--repos`: Additional Maven repositories to use during the update
`--dry-run`: Preview the changes without applying them
`--extraActiveRecipes`: Comma-separated list of additional recipe names to apply
`--extraRecipeArtifactCoordinates`: Comma-separated list of Maven coordinates for extra recipes (format: groupId:artifactId:version)
Use `--help` to see all available options.

==== Examples

Update a Camel Quarkus application

[source,bash]
----
$ camel update run 4.8.3 --runtime=quarkus --dryRun
----

Update a plain Camel application

[source,bash]
----
$ camel update run 4.9.0 --runtime=camel-main --repos=https://myMaven/repo --extraActiveRecipes=my.first.Recipe,my.second.Recipe --extraRecipeArtifactCoordinates=ex.my.org:recipes:1.0.0
----

Update a Spring Boot application with and extra Spring Boot 3.3 upgrade recipe

[source,bash]
----
$ camel update run 4.9.0 --runtime=spring-boot --extraActiveRecipes=org.openrewrite.java.spring.boot3.UpgradeSpringBoot_3_3 --extraRecipeArtifactCoordinates=org.openrewrite.recipe:rewrite-spring:6.0.2
----= Camel Maven Archetypes

Camel is distributed with the following archetypes for Maven end users.

== Archetype Supported

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Archetype |Description

|camel-archetype-api-component |This archetype is used for creating a new
Maven project for Camel xref:components::index.adoc[Components]. Use this if
there is an API component missing in Camel that you want to create yourself.

|camel-archetype-component |This archetype is used for creating a new
Maven project for Camel xref:components::index.adoc[Components]. Use this if
there is a component missing in Camel that you want to create yourself.

|camel-archetype-cdi |This archetype is used to create a
new Maven project for Camel routes in the Java Container using CDI to
configure components, endpoints and beans.

|camel-archetype-dataformat |This archetype is used for
creating a new Maven project for Camel xref:data-format.adoc[Data
Format]s. Use this if there is a data format missing in Camel that you
want to create yourself.

|camel-archetype-java |This archetype is used to create a new Maven
project for Camel routes using Java DSL.

|camel-archetype-main |This archetype is used to create a new Maven
project for Camel routes running Camel standalone (camel-main).

|camel-archetype-spring |This archetype is used to
create a new Maven project for XML DSL routes using Spring.

|camel-archetype-spring-boot |This archetype is used to
create a new Maven project for Camel routes using Spring Boot.

|camel-archetype-endpointdsl |This archetype is used to
create a new Maven project for Camel routes using Endpoint DSL.

|=======================================================================

The maven coordinates for these archetypes is the following:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel.archetypes</groupId>
  <artifactId>${archetype-name}</artifactId>
  <version>${camel-version}</version>
</dependency>
----

=== Snapshot Archetypes

If you would like to use an archetype from an unreleased version of
Camel, you just need to let the maven-archetype-plugin know where to
look for it. For example, say someone wanted to create a Java based
project based on Camel 3.21.0-SNAPSHOT. He'd need to use the following command

[source,bash]
----
mvn archetype:generate \
  -DarchetypeGroupId=org.apache.camel.archetypes \
  -DarchetypeArtifactId=camel-archetype-java \
  -DarchetypeVersion=3.21.0-SNAPSHOT
----

When the project is created, you may need to add another repository to
the pom.xml file. This is to load a SNAPSHOT version of the
camel-maven-plugin

[source,xml]
----
<pluginRepositories>
  <pluginRepository>
    <releases>
      <enabled>false</enabled>
    </releases>
    <snapshots/>
    <id>Apache Snapshot Repository</id>
    <url>http://repository.apache.org/snapshots</url>
  </pluginRepository>
</pluginRepositories>
----

= Camel Maven Plugin

The Camel Maven Plugin supports the following goals

 - camel:run - To run your Camel application
 - camel:dev - To run your Camel application in developer mode
 - camel:debug - To run your Camel application in debug mode
 - camel:prepare-fatjar - To prepare your Camel application for being packaged as a fat-jar (such as by maven-assembly-plugin)

== camel:run

The `camel:run` goal of the Camel Maven Plugin is used to run your Camel Spring configurations in a forked JVM from Maven.
A good example application to get you started is the Spring Example.

----
cd examples/camel-example-spring
mvn camel:run
----

This makes it very easy to spin up and test your routing rules without having to write a main(...) method;
it also lets you create multiple jars to host different sets of routing rules and easily test them independently.

How this works is that the plugin will compile the source code in the maven project,
then boot up a Spring ApplicationContext using the XML configuration files on the classpath at `META-INF/spring/*.xml`

If you want to boot up your Camel routes a little faster, you could try the `camel:embedded` instead.

=== Options

The maven plugin *run* goal supports the following options which can be configured from the command line (use `-D` syntax), or defined in the `pom.xml` file in the `<configuration>` tag.

|===
| Parameter | Default Value | Description
| duration | -1 | Sets the time duration (seconds) that the application will run for before terminating. A value <= 0 will run forever.
| durationIdle | -1 | Sets the idle time duration (seconds) duration that the application can be idle before terminating. A value <= 0 will run forever.
| durationMaxMessages | -1 | Sets the duration of maximum number of messages that the application will process before terminating.
| logClasspath | false | Whether to log the classpath when starting
| loggingLevel | OFF | Whether to use built-in console logging (uses log4j), which does not require to add any logging dependency to your project. However, the logging is fixed to log to the console, with a color style that is similar to Spring Boot. You can change the root logging level to: FATAL, ERROR, WARN, INFO, DEBUG, TRACE, OFF
| profile |  | To run with a specific Camel Main profile (dev,test,prod)
|===



=== Logging the classpath

You can configure whether the classpath should be logged when `camel:run` executes.
You can enable this in the configuration using:

[source,xml]
----
<plugin>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-maven-plugin</artifactId>
  <configuration>
    <logClasspath>true</logClasspath>
  </configuration>
</plugin>
----

=== Using built-in logging

If you want quickly to have logging to console, you can use the built-in logging by setting the logging level as shown:

[source,xml]
----
<plugin>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-maven-plugin</artifactId>
  <configuration>
    <loggingLevel>INFO</loggingLevel>
  </configuration>
</plugin>
----

This runs the application with console logging, in color that is similar to Spring Boot logging.
This is default turned off, to use the configured logging system in the project.

The idea with the built-in logging is that you sometimes want to avoid messing with setting
up logging, and just want a quick and easy log to console that looks good.


== camel:dev

The `camel:dev` is an extension to `camel:run` to run the Camel application in developer mode.
In this mode, among others, Camel will use hot-reloading of DSL routes (xml, yaml and java) that are located from
the `src/main/resources` directory.

=== Options

The maven plugin *dev* goal supports the following options which can be configured from the command line (use `-D` syntax), or defined in the `pom.xml` file in the `<configuration>` tag.

|===
| Parameter | Default Value | Description
| routesDirectory | src/main/resources | To watch the directory for file changes which triggers a live reload of the Camel routes on-the-fly.
| duration | -1 | Sets the time duration (seconds) that the application will run for before terminating. A value <= 0 will run forever.
| durationIdle | -1 | Sets the idle time duration (seconds) duration that the application can be idle before terminating. A value <= 0 will run forever.
| durationMaxMessages | -1 | Sets the duration of maximum number of messages that the application will process before terminating.
| logClasspath | false | Whether to log the classpath when starting
| loggingLevel | OFF | Whether to use built-in console logging (uses log4j), which does not require to add any logging dependency to your project. However, the logging is fixed to log to the console, with a color style that is similar to Spring Boot. You can change the root logging level to: FATAL, ERROR, WARN, INFO, DEBUG, TRACE, OFF
| profile | dev | To run with a specific Camel Main profile (dev,test,prod)
|===

== camel:debug

The `camel:debug` is an extension to `camel:dev` to run the Camel application in debug mode which allows to debug the Camel routes thanks to the Camel textual route debugger.

=== Options

The maven plugin *debug* goal supports the following options which can be configured from the command line (use `-D` syntax), or defined in the `pom.xml` file in the `<configuration>` tag.

|===
| Parameter | Default Value | Description
| suspend | true | Indicates whether the message processing done by Camel should be suspended as long as a debugger is not attached.
|===

== camel:prepare-fatjar

The `camel:prepare-fatjar` goal of the Camel Maven Plugin is used to prepare your Camel application
for being packaged as a _fat jar_. The goal scans the Maven dependencies to discover Camel JARs and
extract if they have type converters, which gets merged together into a single _uber_ file stored
in `target/classes/META-INF/services/org/apache/camel/UberTypeConverterLoader`.

This _uber_ loader file contains all the combined type converters the Camel application uses at runtime.
They are merged together into this single file.

This is needed as otherwise the _fat jar_ maven plugins (such as maven-assembly-plugin, or maven-shade-plugin)
causes the `TypeConverterLoader` files to be overwritten in the assembled JAR which causes not all type converters
to be loaded by Camel.

The `UberTypeConverterLoader` ensures they all type converters gets loaded as this file contains all the known
type converter files.

To use this goal, you can add the following to your Camel application `pom.xml` file:

[source,xml]
----
  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.camel</groupId>
        <artifactId>camel-maven-plugin</artifactId>
        <version>${camel.version}</version>
        <executions>
          <execution>
            <goals>
              <goal>prepare-fatjar</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
----

For example to use this with the `maven-assembly-plugin` you can do as below.
Remember to specify the class name of *your* main class where it says `com.foo.NameOfMainClass`:

[source,xml]
----
  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.camel</groupId>
        <artifactId>camel-maven-plugin</artifactId>
        <version>${camel.version}</version>
        <executions>
          <execution>
            <goals>
              <goal>prepare-fatjar</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-assembly-plugin</artifactId>
        <configuration>
          <archive>
            <manifest>
              <mainClass>com.foo.NameOfMainClass</mainClass>
            </manifest>
          </archive>
        </configuration>
      </plugin>
    </plugins>
  </build>
----
= Camel Report Maven Plugin

The Camel Report Maven Plugin supports the following goals

 - camel-report:validate - To validate your source code for invalid Camel endpoint uris
 - camel-report:route-coverage - To report the coverage of your Camel routes after unit testing

== camel-report:validate

For validating the source code for mis-configured Camel:

- endpoint uris
- simple expressions or predicates
- duplicate route ids
- seda/direct endpoint pairs
- configuration in properties files

Then you can run the `validate` goal from the command line or from within your Java editor such as IDEA or Eclipse.

----
mvn camel-report:validate
----

You can also enable the plugin to run automatically as part of the build to catch these errors.

[source,xml]
----
<plugin>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-report-maven-plugin</artifactId>
  <executions>
    <execution>
      <phase>process-classes</phase>
      <goals>
        <goal>validate</goal>
      </goals>
    </execution>
  </executions>
</plugin>
----

The phase determines when the plugin runs. In the sample above the phase is `process-classes` which runs after
the compilation of the main source code.

The maven plugin can also be configured to validate the test source code , which means that the phase should be
changed accordingly to `process-test-classes` as shown below:

[source,xml]
----
<plugin>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-report-maven-plugin</artifactId>
  <executions>
    <execution>
      <configuration>
        <includeTest>true</includeTest>
      </configuration>
      <phase>process-test-classes</phase>
      <goals>
        <goal>validate</goal>
      </goals>
    </execution>
  </executions>
</plugin>
----

=== Running the goal on any Maven project

You can also run the validate goal on any Maven project without having to add the plugin to the `pom.xml` file.
Doing so requires to specify the plugin using its fully qualified name. For example to run the goal on
the `camel-example-cdi` from Apache Camel you can run

----
$cd camel-example-cdi
$mvn org.apache.camel:camel-report-maven-plugin:2.20.0:validate
----

which then runs and outputs the following:

----
[INFO] ------------------------------------------------------------------------
[INFO] Building Camel :: Example :: CDI 3.0.0
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- camel-report-maven-plugin:3.0.0:validate (default-cli) @ camel-example-cdi ---
[INFO] Endpoint validation success: (4 = passed, 0 = invalid, 0 = incapable, 0 = unknown components)
[INFO] Simple validation success: (0 = passed, 0 = invalid)
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
----

The validation passed, and 4 endpoints was validated. Now suppose we made a typo in one of the Camel endpoint uris in the source code, such as:

[source,java]
----
@Uri("timer:foo?period=5000")
----


is changed to include a typo error in the `period` option

[source,java]
----
@Uri("timer:foo?perid=5000")
----

And when running the `validate` goal again reports the following:

----
[INFO] ------------------------------------------------------------------------
[INFO] Building Camel :: Example :: CDI 3.0.0
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- camel-report-maven-plugin:3.0.0:validate (default-cli) @ camel-example-cdi ---
[WARNING] Endpoint validation error at: org.apache.camel.example.cdi.MyRoutes(MyRoutes.java:32)

	timer:foo?perid=5000

	                   perid    Unknown option. Did you mean: [period]


[WARNING] Endpoint validation error: (3 = passed, 1 = invalid, 0 = incapable, 0 = unknown components)
[INFO] Simple validation success: (0 = passed, 0 = invalid)
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
----

=== Options

The maven plugin *validate* goal supports the following options which can be configured from the command line (use `-D` syntax), or defined in the `pom.xml` file in the `<configuration>` tag.

|===
| Parameter | Default Value | Description
| downloadVersion | true | Whether to allow downloading Camel catalog version from the internet. This is needed if the project uses a different Camel version than this plugin is using by default.
| failOnError | false | Whether to fail if invalid Camel endpoints was found. By default the plugin logs the errors at WARN level.
| coverageThreshold | 100 | The minimum route coverage in percent when using failOnError.
| overallCoverageThreshold | 0 | The minimum coverage across all routes in percent when using failOnError.
| logUnparseable | false | Whether to log endpoint URIs which was un-parsable and therefore not possible to validate.
| includeJava | true | Whether to include Java files to be validated for invalid Camel endpoints.
| includeXml | true | Whether to include XML files to be validated for invalid Camel endpoints.
| includeTest | false | Whether to include test source code.
| includes | | To filter the names of java and xml files to only include files matching any of the given list of patterns (wildcard and regular expression). Multiple values can be separated by comma.
| excludes | | To filter the names of java and xml files to exclude files matching any of the given list of patterns (wildcard and regular expression). Multiple values can be separated by comma.
| ignoreUnknownComponent | true | Whether to ignore unknown components.
| ignoreIncapable | true | Whether to ignore incapable of parsing the endpoint uri or simple expression.
| ignoreLenientProperties | true | Whether to ignore components that uses lenient properties. When this is true, then the uri validation is stricter but would fail on properties that are not part of the component but in the uri because of using lenient properties. For example using the HTTP components to provide query parameters in the endpoint uri.
| ignoreDeprecated | true |Whether to ignore deprecated options being used in the endpoint uri.
| duplicateRouteId | true |Whether to validate for duplicate route ids. Route ids should be unique and if there are duplicates then Camel will fail to startup.
| directOrSedaPairCheck | true |Whether to validate direct/seda endpoints sending to non existing consumers.
| configurationFiles | application.properties | Location of configuration files to validate. The default is application.properties. Multiple values can be separated by comma and use wildcard pattern matching.
| showAll | false | Whether to show all endpoints and simple expressions (both invalid and valid).
| downloadTransitiveArtifacts | false | When sourcesArtifacts are declared, this flag can be used to download transitive dependencies, carefully enable this flag since it will try to download the whole dependency tree.
| sourcesArtifacts | | List of sources transitive dependencies that contain camel routes, this option can be used to download extra dependencies that contain camel route that your project may depend on.
| extraMavenRepositories | | List of extra maven repositories.
|===

For example to turn on ignoring usage of deprecated options from the command line, you can run:

----
$mvn camel-report:validate -Dcamel.ignoreDeprecated=true
----

Notice that you must prefix the `-D` command argument with `camel.`, eg `camel.ignoreDeprecated` as the option name.

=== Validating include test

If you have a Maven project then you can run the plugin to validate the endpoints in the unit test source code as well.
You can pass in the options using `-D` style as shown:

----
$cd myproject
$mvn org.apache.camel:camel-report-maven-plugin:3.0.0:validate -Dcamel.includeTest=true
----

=== Validate Apache Camel routes in transitive dependencies

If your routes use `direct` or `seda` endpoints that are not present in the current project, but the routes are declared into a dependency of your project, you can edit the plugin configuration accordingly so that these routes can be taken into account by the Camel validate plugin.
In particular, in order to use the validate plugin with transitive dependencies, *sources jars are needed*, for example:

* Given the following Camel route `from("direct:in").to("direct:out")` defined in the current project
* The route `from("direct:out")` is declared into a dependency of your project, for example `my.company:routes-dependency:1.0`
* If `routes-dependency` sources are released into a maven repository, the following plugin configuration can be used:

```xml
<plugin>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-report-maven-plugin</artifactId>
  <executions>
    <execution>
      <phase>package</phase>
      <goals>
        <goal>validate</goal>
      </goals>
      <configuration>
        <sourcesArtifacts>
          <sourcesArtifact>my.company:routes-dependency:jar:sources:1.0</sourcesArtifact>
        </sourcesArtifacts>
        <extraMavenRepositories>
          <extraMavenRepository>http://internal.repo:8080/maven</extraMavenRepository>
        </extraMavenRepositories>
      </configuration>
    </execution>
  </executions>
</plugin>
```

== camel-report:route-coverage

For generating a report of the coverage of your Camel routes from unit testing.
In the same manner you can generate Java code coverage reports, then this is the same but for Camel routes.
You can therefore use this to know which parts of your Camel routes have been used or not.

Camel uses JMX to capture metrics during tests which are used for calculating route coverage.
You must have `camel-management` JAR on the classpath (can be test scoped)
such as by declaring the following Maven dependency in your pom.xml file:

[source,xml]
----
<!-- JMX is needed for route coverage testing -->
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-management</artifactId>
    <scope>test</scope>
</dependency>
----

=== Enabling route coverage

You can enable route coverage while running unit tests either by:

- setting global JVM system property enabling for all test classes
- using `@EnableRouteCoverage` annotation per test class if using `camel-test-spring-junit5` module
- overriding `isDumpRouteCoverage` method per test class if using `camel-test` module

==== Enabling via JVM system property

You can turn on the JVM system property `CamelTestRouteCoverage` to enable route coverage for all tests cases.
This can be done either in the configuration of the `maven-surefire-plugin`:

[source,xml]
----
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-surefire-plugin</artifactId>
  <configuration>
    <systemPropertyVariables>
      <CamelTestRouteCoverage>true</CamelTestRouteCoverage>
    </systemPropertyVariables>
  </configuration>
</plugin>
----

Or from the command line when running tests:

----
mvn clean test -DCamelTestRouteCoverage=true
----

==== Enabling via @EnableRouteCoverage annotation

You need to enable route coverage in the unit tests classes. You can do this by adding the `@EnableRouteCoverage`
annotation to the test class if you are testing using `camel-test-spring-junit5`:

[source,java]
----
@CamelSpringBootTest
@SpringBootTest(classes = SampleCamelApplication.class)
@EnableRouteCoverage
public class FooApplicationTest {
----

==== Enabling via isDumpRouteCoverage method

However if you are using `camel-test` and your unit tests are extending `CamelTestSupport` then you can
turn on route coverage as shown:

[source,java]
----
@Override
public boolean isDumpRouteCoverage() {
    return true;
}
----

IMPORTANT: Routes that can be route coveraged **MUST** have a unique id assigned, in other words you cannot use anonymous routes.

You do this using `routeId` in Java DSL:

[source,java]
----
from("jms:queue:cheese").routeId("cheesy")
  .to("log:foo")
  ...
----

And in XML DSL you just assign the route id via the id attribute

[source,xml]
----
<route id="cheesy">
  <from uri="jms:queue:cheese"/>
  <to uri="log:foo"/>
  ...
</route>
----

=== Generating route coverage report

After unit testing with:

----
mvn test
----

You can then run the goal to report the route coverage

----
mvn camel-report:route-coverage
----

Which then reports which routes has missing route coverage with precise source code line reporting:

----
[INFO] --- camel-camel-report-plugin:3.0.0:route-coverage (default-cli) @ camel-example-spring-boot-xml ---
[INFO] Discovered 1 routes
[INFO] Route coverage summary:

File:	src/main/resources/my-camel.xml
RouteId:	hello

  Line #      Count   Route
  ------      -----   -----
      28          1   from
      29          1     transform
      32          1     filter
      34          0       to
      36          1     to

Coverage: 4 out of 5 (80.0%)
----

Here we can see that the 2nd last line with `to` has `0` in the count column, and therefore is not covered.
We can also see that this is one line 34 in the source code file, which is in the `my-camel.xml` XML file.

=== Options

The maven plugin *coverage* goal supports the following options which can be configured from the command line (use `-D` syntax),
 or defined in the `pom.xml` file in the `<configuration>` tag.

|===
| Parameter | Default Value | Description
| failOnError | false | Whether to fail if any of the routes has not 100% coverage.
| includeTest | false | Whether to include test source code.
| includes | | To filter the names of java and xml files to only include files matching any of the given list of
 patterns (wildcard and regular expression). Multiple values can be separated by comma.
| excludes | | To filter the names of java and xml files to exclude files matching any of the given list of
 patterns (wildcard and regular expression). Multiple values can be separated by comma.
| anonymousRoutes | false | **Deprecated** Whether to allow anonymous routes (routes without any route id assigned).
 By using route id's then it is safer to match the route cover data with the route source code.
 Anonymous routes are less safe to use for route coverage as its harder to know exactly which route
 that was tested corresponds to which of the routes from the source code.
| generateJacocoXmlReport | false | Whether to generate a coverage-report in Jacoco XML format. When enabled it will generate the file: `target/site/jacoco/xmlJacoco.xml`
| generateHtmlReport | false | Whether to generate a coverage-report in HTML format. When enabled it will generate the file: `target/site/route-coverage/html/index.html`
|===

= CamelContext Auto Configuration

The xref:camelcontext.adoc[CamelContext] is autoconfigured when running Camel with either
xref:components:others:main.adoc[Camel Main], Camel Spring Boot, Camel Quarkus.

== Camel Autoconfiguration

Under these runtimes then the autoconfiguration is performed by shared code from the `camel-main` JAR
to ensure the configuration is similar on these runtimes.

The autoconfiguration is executed in several steps:

1. Configure `CamelContext` (and more such as components) from xref:components::properties-component.adoc[properties] from external sources like `application.properties|yaml`
2. Configure optional services that have been registered in the xref:registry.adoc[Registry]

=== Autoconfiguration of Properties

This is used for configuring the standard set of more than 100 options which are listed in the _Camel Main Options_ table at xref:components:others:main.adoc[Camel Main].

NOTE: When using Camel on Spring Boot, then these options are prefixed with `camel.springboot`, and not `camel.main`.

=== Autoconfiguration of Optional Services

After configuring the standard options, then Camel will look in the xref:registry.adoc[Registry] for custom
services to be used.
For example, to plug in a custom `UnitOfWorkFactory`.

The services can be anything that can be plugged into Camel (typically services that implement an SPI interface `org.apache.camel.spi`).

The following SPI services can only a single instance (singleton) be in the xref:registry.adoc[Registry].

[width="100%",cols="2m,8",options="header",]
|=======================================================================
|SPI |Description
| AsyncProcessorAwaitManager | To use a custom async processor await manager
| BacklogTracer | To use a custom backlog tracer
| ClassResolver | To use a custom class resolver. This is only necessary if you run Camel on a special application server to deal with classloading.
| Debugger | To use a custom xref:debugger.adoc[debugger]
| EventFactory | To use a custom event notifier factory
| ExchangeFactory | To use a custom xref:exchange-pooling.adoc[exchange factory]
| ExecutorServiceManager | To use a custom xref:threading-model.adoc[thread pool manager]
| FactoryFinderResolver | To use a custom factory finder resolver. This is only necessary if you run Camel on a special application server to deal with classloading.
| HealthCheckRegistry | To use a custom xref:health-check.adoc[health check registry]
| InflightRepository | To use a custom in flight repository
| ManagementObjectNameStrategy | To use a custom JMX MBean object naming
| ManagementStrategy | To use a custom JMX management strategy
| MessageHistoryFactory | To use a custom factory for xref:components:eips:message-history.adoc[message history]
| ModelJAXBContextFactory | To use a custom `JAXBContext` factory (only needed if you run Camel on a special application server to deal with JAXB classloading)
| NodeIdFactory | To use a custom factory for creating auto generated node ids
| ProcessorFactory | To use a custom factory for creating xref:components:eips:enterprise-integration-patterns.adoc[EIP] processors
| PropertiesComponent | To use a custom properties component
| ReactiveExecutor | To use a custom reactive engine in the Camel routing engine
| RouteController | To use a custom xref:route-controller.adoc[route controller]
| RuntimeEndpointRegistry | To use a custom runtime xref:endpoint.adoc[endpoint] registry
| ShutdownStrategy | To use a custom xref:graceful-shutdown.adoc[shutdown strategy]
| StartupStepRecorder | To use a custom startup recorder
| ThreadPoolFactory | To use a custom xref:threading-model.adoc[thread pool factory]
| UnitOfWorkFactory | To use a custom unit of work factory
| UuidGenerator | To use a custom xref:uuidgenerator.adoc[uuid generator]
|=======================================================================

For the following SPI services, there can be multiple (one or more) implementations in the xref:registry.adoc[Registry].

[width="100%",cols="2m,8",options="header",]
|=======================================================================
|SPIs |Description
| CamelClusterService | Adds all the custom xref:clustering.adoc[camel-cluster services]
| EndpointStrategy | Adds all the custom xref:endpoint.adoc[endpoint strategies]
| EventNotifier | Adds all the custom event notifiers
| GlobalSSLContextParametersSupplier | To use a custom supplier for xref:camel-configuration-utilities.adoc[JSSE (Java Security)]
| InterceptStrategy | Adds all the custom intercept strategies
| LifecycleStrategy | Adds all the custom lifecycle strategies
| LogListener | Adds all the log listeners
| ModelLifecycleStrategy | Adds all the custom model lifecycle strategies
| RoutePolicyFactory | Adds all the custom xref:route-policy.adoc[route policy factories]
| ServiceRegistry | Adds all the custom camel-cloud service registries
| ThreadPoolProfile | Adds all the xref:threading-model.adoc[thread pool profiles]
| TypeConverters | Adds all the custom xref:type-converter.adoc[type converters]
|=======================================================================
= CamelContext

The https://www.javadoc.io/doc/org.apache.camel/camel-api/latest/org/apache/camel/CamelContext.html[`CamelContext`] is the runtime system, which holds together all the fundamental concepts of Apache Camel (routes, endpoints, components, etc).

This context object represents the Camel runtime system. Typically, you have one `CamelContext` instance in an application.

image::images/camel-context.png[image]

The `CamelContext` provides access to many features and services, the most notable being components, type converters, a registry, endpoints, routes, data formats, and languages.

The following table lists the most common services provided by the `CamelContext`:

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Service |Description
|xref:component.adoc[Components] | Contains the components used.
|xref:endpoint.adoc[Endpoints] | Contains the endpoints that have been used.
|xref:routes.adoc[Routes] | The routes in use.
|xref:data-format.adoc[Data formats] | Contains the loaded data formats.
|xref:languages.adoc[Languages] | Contains the loaded languages.
|xref:type-converter.adoc[Type converters] | Contains the loaded type converters. Camel has a mechanism that allows you to manually or automatically convert from one type to another.
|xref:registry.adoc[Registry] | Contains a registry that allows you to look up beans.
|=======================================================================

== CamelContext 101

To give you a better understanding of Apache Camel, we'll discuss what is inside the `CamelContext`.

=== Routing Engine

Camel's routing engine moves messages under the hood and does all the heavy lifting to ensure that messages are routed properly. It is not exposed to the developer, but you should be aware that it's there.

=== Routes

xref:routes.adoc[Routes] are a core abstraction for Camel. The simplest way to define a route is as a chain of xref:processor.adoc[Processors]. There are many reasons for using routers in messaging applications.
By decoupling clients from servers, and producers from consumers, routes can, for example, do the following:

* Decide dynamically what server a client will invoke
* Provide a flexible way to add extra processing
* Allow independent development for clients and servers
* Foster better design practices by connecting disparate systems that do one thing well
* Allow for clients of servers to be stubbed out (using xref:components::mock-component.adoc[mocks]) for testing purposes

Each route in Camel has a unique identifier. You can use the identifier to log, debug, monitor, and start and stop routes.

Routes have one and only one input source for messages. They are effectively tied to an input endpoint.

=== Domain Specific Language (DSL)

To wire processors and endpoints together to form routes, Camel defines a xref:dsl.adoc[DSL].

In Camel with Java, DSL means a fluent Java API that contains methods named for EIP terms.

Consider this example:

[source,java]
----
from("file:data/inbox")
    .filter().xpath("/order[not(@test)]")
        .to("jms:queue:order");
----

Here, in a single Java statement, you define a route that consumes files from a xref:components::file-component.adoc[file] endpoint.
Camel uses the xref:components:eips:filter-eip.adoc[Filter EIP] to route the messages using an XPath predicate to test whether the message is not a test order. If a message passes the test, Camel forwards it to the xref:components::jms-component.adoc[JMS] endpoint. Messages failing the filter test are skipped.

Camel provides multiple DSL languages. You could define the same route using the XML DSL:

[source,xml]
----
<route>
    <from uri="file:data/inbox"/>
    <filter>
        <xpath>/order[not(@test)]</xpath>
        <to uri="jms:queue:order"/>
    </filter>
</route>
----

And in YAML:

[source,yaml]
----
- from:
    uri: "file:data/inbox"
    steps:
      - filter:
          xpath: "/order[not(@test)]"
          steps:
            - to: "jms:queue:order"
----

The DSLs provide a nice abstraction for Camel users to build applications. Under the hood, though, a route is composed of a graph of processors.

=== Processors

The xref:processor.adoc[processor] is a core Camel concept that represents a node capable of using, creating,
or modifying an incoming xref:exchange.adoc[exchange].

During routing, exchanges flow from one processor to another; as such, you can think of a route as a graph having specialized processors
as the nodes, and lines that connect the output of one processor to the input of another.
Processors could be implementations of EIPs, producers for specific components, or
your own custom code. The figure below shows the flow between processors.

image::images/message_flow_in_route.png[image]

A route starts with a consumer (i.e., `from` in the DSL) that populates the initial xref:exchange.adoc[exchange]. At each processor step, the output (out) message
from the previous step is the input (in) message of the next. In many cases, processors don’t set an out message, so in this case the in message
is reused. The xref:exchange-pattern.adoc[exchange pattern] of the exchange determines, at the end of a route, whether a reply needs to be sent back to the caller of the route.
If the exchange pattern (MEP) is `InOnly`, no reply will be sent back. If it’s `InOut`, Camel will take the out message from the last step and return it.

=== Component

xref:components::index.adoc[Components] are the main extension point in Camel.

From a programming point of view, components are fairly simple: they’re associated
with a name that’s used in a xref:uris.adoc[URI], and they act as a factory of xref:endpoint.adoc[endpoints].

For example, `FileComponent` is referred to by file in a URI, and it creates `FileEndpoint`. The endpoint
is perhaps an even more fundamental concept in Camel.

=== Endpoint

An xref:endpoint.adoc[endpoint] is the Camel abstraction that models the end of a channel through which a
system can send or receive messages.

image::images/MessageEndpointSolution.gif[image]

In Camel, you configure endpoints by using URIs, such as `file:data/inbox?delay=5000`,
and you also refer to endpoints this way. At runtime, Camel looks up an endpoint based
on the URI notation. The figure below shows how this works.

image::images/endpoint-uri-syntax.png[image]

The scheme (1) denotes which Camel component handles that type of endpoint. In
this case, the scheme of `file` selects `FileComponent`. `FileComponent` then works as a
factory, creating `FileEndpoint` based on the remaining parts of the URI. The context
path `data/inbox` (2) tells `FileComponent` that the starting folder is `data/inbox`. The
option, `delay=5000` (3) indicates that files should be polled at a 5-second interval.

The next figure shows how an endpoint works together with an exchange, producers, and consumers.

image::images/endpoint-factory.png[image]

An endpoint acts as a factory for creating consumers and producers that are capable of
receiving and sending messages to a particular endpoint.

=== Producer

A producer is the Camel abstraction that refers to an entity capable of sending a message to
an endpoint. When a message is sent to an endpoint, the producer handles the details of getting
the message data compatible with that particular endpoint. For example, `FileProducer`
will write the message body to a `java.io.File`. `JmsProducer`, on the other hand, will map
the Camel message to `javax.jms.Message` before sending it to a JMS destination. This
is an important feature in Camel, because it hides the complexity of interacting with
particular transports. All you need to do is route a message to an endpoint, and the producer
does the heavy lifting.

=== Consumer

A consumer is the service that receives messages produced by some external system,
wraps them in an xref:exchange.adoc[exchange], and sends them to be processed.
Consumers are the source of the exchanges being routed in Apache Camel.
To create a new exchange, a consumer will use the endpoint that wraps
the payload being consumed. A xref:processor.adoc[processor] is then used to initiate the routing of the
exchange in Camel via the routing engine.

Camel has two kinds of consumers: event-driven consumers, and polling consumers (or scheduled polling consumers).
The differences between these consumers are important, because they help solve different
problems.

==== Event Driven Consumer

The most familiar consumer is the event-driven consumer, as illustrated:

image::images/EventDrivenConsumerSolution.gif[image]

This kind of consumer is mostly associated with client-server architectures and web
services. It’s also referred to as an asynchronous receiver in the EIP world. An event-driven
consumer listens on a particular messaging channel, such as a TCP/IP port, JMS
queue, Twitter handle, Amazon SQS queue, WebSocket, and so on. It then waits for a
client to send messages to it. When a message arrives, the consumer wakes up and takes
the message for processing.

==== Polling Consumer / Scheduled Polling Consumer

In contrast to the event-driven consumer, the polling consumer actively goes and
fetches messages from a particular source, such as an FTP server. The polling consumer
is also known as a synchronous receiver in EIP lingo, because it won’t poll for more
messages until it’s finished processing the current message. A common flavor of the
polling consumer is the scheduled polling consumer, which polls at scheduled intervals.
File, FTP, and email components all use scheduled polling consumers.

NOTE: In the Camel components, its only either the event driven or scheduled polling consumers that
are in use. The polling consumer (non-scheduled) is only used to poll on-demand, such as
when using the xref:components:eips:pollEnrich-eip.adoc[Poll Enrich] EIP, or from Java by
creating a `PollingConsumer` instance via the `createPollingConsumer()` method from `Endpoint`.


== See Also

See the following for high-level xref:architecture.adoc[architecture] of Apache Camel.

See xref:lifecycle.adoc[Lifecycle] to understand the overall lifecycle of the `CamelContext`.
= Clustering

Camel offers the following cluster related SPI:

- *Cluster Service*
+
A regular Camel service that manages cluster resources such as _views_ (see below)

- *Cluster View*
+
Represent a view of the cluster with its own set of isolated resources. As today views provide supports for:
+
    * Leader Election
    * Topology events like members joining/leaving the cluster

- *Cluster Member*
+
Represent a member of the cluster.


== Cluster SPI Setup

A _Cluster Service_ is just like any other camel service so set it up you only need to register your implementations
to the `CamelContext`:

[source,java]
----
MyClusterServiceImpl service = new MyClusterServiceImpl();
context.addService(service);
----

The configuration of the _Cluster Service_ depends on the implementation you have chose.
Out of the box camel provides the following implementations:

[cols="1,1,2", options="header"]
|====
|Type       |Module           | Class
|consul     |camel-consul     | org.apache.camel.component.consul.cluster.ConsulClusterService
|file       |camel-file       | org.apache.camel.component.file.cluster.FileLockClusterService
|infinispan |camel-infinispan | org.apache.camel.component.infinispan.cluster.InfinispanClusterService
|jgroups |camel-jgroups | org.apache.camel.component.jgroups.cluster.JGroupsLockClusterService
|jgroups-raft |camel-jgroups-raft | org.apache.camel.component.jgroups.raft.cluster.JGroupsRaftClusterService
|kubernetes |camel-kubernetes | org.apache.camel.component.kubernetes.cluster.KubernetesClusterService
|zookeeper  |camel-zookeeper  | org.apache.camel.component.zookeeper.cluster.ZooKeeperClusterService
|====

Configuration examples:

- *Spring Boot*
+
[source,properties]
----
camel.cluster.file.enabled = true
camel.cluster.file.id = ${random.uuid}
camel.cluster.file.root = ${java.io.tmpdir}
----


- *Spring XML*
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
         http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://camel.apache.org/schema/spring
         http://camel.apache.org/schema/spring/camel-spring.xsd">

  <bean id="zx" class="org.apache.camel.component.zookeeper.cluster.ZooKeeperClusterService">
    <property name="id" value="node-1"/>
    <property name="basePath" value="/camel/cluster"/>
    <property name="nodes" value="localhost:2181"/>
  </bean>

  <camelContext xmlns="http://camel.apache.org/schema/spring" autoStartup="false">
    ...
  </camelContext>

</beans>
----

== Cluster SPI Usage

The _Cluster SPI_ is leveraged by the following new implementations:

- *ClusteredRoutePolicy*
+
This is an implementation of a RoutePolicy that starts the routes it is associated to when the Cluster View it uses takes the leadership
+
[source,java]
----
context.addRoutes(new RouteBuilder {
    @Override
    public void configure() throws Exception {
        // Create the route policy
        RoutePolicy policy = ClusteredRoutePolicy.forNamespace("my-ns");

        // bind the policy to one or more routes
        from("timer:clustered?delay=1000&period=1000")
            .routePolicy(policy)
            .log("Route ${routeId} is running ...");
    }
});
----
+
To apply the same policy to all the routes a dedicated  _RoutePolicyFactory_ can be used:
+
[source,java]
----
// add the clustered route policy factory to context
context.addRoutePolicyFactory(ClusteredRoutePolicyFactory.forNamespace("my-ns"));

context.addRoutes(new RouteBuilder {
    @Override
    public void configure() throws Exception {
        // bind the policy to one or more routes
        from("timer:clustered?delay=1000&period=1000")
            .log("Route ${routeId} is running ...");
    }
});
----

- *ClusteredRouteController*
+
This is an implementation of the _RouteController SPI_ that lets the camel context start then starts/stops the routes when the leadership is taken/lost. This is well integrated with spring-boot apps so assuming you have your routes set-up like:
+
[source,java]
----
@Bean
public RouteBuilder routeBuilder() {
    return new RouteBuilder() {
        @Override
        public void configure() throws Exception {
            from("timer:heartbeat?period=10000")
                .routeId("heartbeat")
                .log("HeartBeat route (timer) ...");
            from("timer:clustered?period=5000")
                .routeId("clustered")
                .log("Clustered route (timer) ...");
        }
    };
}
----
+
You can then leverage Spring Boot configuration to make them clustered:
+
[source,properties]
----
# enable the route controller
camel.clustered.controller.enabled = true

# define the default namespace for routes
camel.clustered.controller.namespace = my-ns

# exclude the route with id 'heartbeat' from the clustered ones
camel.clustered.controller.routes[heartbeat].clustered = false
----

- *Master Component*
+
The master component is similar to a _ClusteredRoutePolicy_ but it works on consumer level so it ensures the only a single endpoint in a cluster is consuming resources at any point in time. Set it up is very easy and all you need is to prefix singleton endpoints according to the master component syntax:
+
[source,text]
----
master:namespace:delegateUri
----
+
A concrete example:
+
[source,java]
----
@Bean
public RouteBuilder routeBuilder() {
    return new RouteBuilder() {
        @Override
        public void configure() throws Exception {
            from("timer:heartbeat?period=10000")
                .routeId("heartbeat")
                .log("HeartBeat route (timer) ...");

            from("master:my-ns:timer:clustered?period=5000")
                .routeId("clustered")
                .log("Clustered route (timer) ...");
        }
    };
}
----

= Commercial Camel Offerings

Apache Camel is a widely used project. As such, several companies have
built products and services around Camel. This page is dedicated to
providing descriptions of those offerings and links to more information.
Companies are definitely encouraged to update this page directly or
link:/community/mailing-list/[send a mail] to the Camel PMC with a description
of your offerings and we can update the page. The products and services
listed on this page are provided for information use only to our users.
The Camel PMC does not endorse or recommend any of the products or
services on this page. See below for information about what is
appropriate to add to the page.


== http://www.cyberlogic.ch[Cyberlogic Consulting]

http://www.cyberlogic.ch[Cyberlogic Consulting] is a Swiss based
consultancy. We pride ourselves in providing Swiss quality services
including enterprise consulting, coding, systems integration, training
and support for Apache Camel and the related Apache Open Source
Software. We specialize in helping our clients to realize new projects
and support the delivery of the project from end to end.


== https://integrationmadeeasy.com[Dovetail]

https://integrationmadeeasy.com[Dovetail] is a company based in the Netherlands.
It offers a low-code integration platform based on Apache Camel, Apache ActiveMQ and
https://assimbly.org[Assimbly]. The aim is to make integration as easy as possible.
We provide cloud services, support and training.


== http://ibm.biz/OSSupport[IBM]

http://ibm.biz/OSSupport[IBM] provides cross-platform support and consulting for
https://www.ibm.com/downloads/cas/KOAB4E9V[Apache Camel and many other open source packages].


== https://linuxpolska.com/[Linux Polska]

https://linuxpolska.com/[Linux Polska] provides consulting,
implementation and maintenance services in the areas of middleware, especially for Apache Camel and related projects based on Apache.
The company also designs and creates its own open source solutions.


== http://www.openlogic.com/[OpenLogic]

http://www.openlogic.com/[OpenLogic] by Perforce has a team of Camel experts ready to help you.
We provide 24/7 support for troubleshooting issues and outages, consulting on architecture and design, and instructor-led, hands-on training.
https://www.openlogic.com/solutions/support-activemq-apache-camel-kafka#apache-camel[Learn more about OpenLogic's Camel support].


== https://www.redhat.com[Red Hat]

https://www.redhat.com[Red Hat] offers a https://developers.redhat.com/products/redhat-build-of-camel/overview[supported build of Camel] as part of 
https://www.redhat.com/en/products/integration[Red Hat Integration] and https://www.redhat.com/en/products/application-foundations[Red Hat Application Foundations].
It contains an enterprise integration platform based on Apache Camel and other
open source integration projects, with developer and production support.
In addition to enterprise support, Red Hat provides
https://www.redhat.com/en/training/skills-path-finder/red-hat-certified-specialist-camel-development[training],
https://www.redhat.com/en/services/consulting[consulting], and
https://developers.redhat.com/products/redhat-build-of-camel/overview[a developer community].

== https://www.randoli.io[Randoli]
We provide consulting and implementation of Microservices as well as modernization support for legacy applications using Springboot + Camel or Quarkus + Camel.
https://randoli.io/services/
https://randoli.io/case-studies/case-study-postal-tech-company-modernization
https://www.redhat.com/rhdc/managed-files/cl-randoli-partner-case-study-f31836pr-202211-en_0.pdf

== https://riverlog.com/systemintegration/esb-model-and-camel-based-systems-integration[RiverLog]

https://www.riverlog.com[RiverLog Software] engages with systems integrators and implementers to deploy Camel based, ESB model integration within enterprises.
RiverLog's custom scripts and generic modules help in reducing Apache Camel integration efforts across the enterprise. 


== https://www.routeblaze.io[RouteBLAZE]

https://www.routeblaze.io[RouteBLAZE] allows you to design, develop and deploy business processes at Enterprise scale. 
It comes bundled with a suite of tools and services that support every step of the journey, from project inception through to production support.
We also provide bespoke development and consultancy. 


== http://www.savoirtech.com[Savoir Technologies, Inc]

http://www.savoirtech.com[Savoir Technologies, Inc] provides enterprise
consulting, training and support for Camel and a host of other Apache
service containers. Savoir can provide best practice mentoring for
developing with Camel, as well as architectural/design reviews,
troubleshooting and SOA infrastructure implementations.


== https://skintegrationsolutions.com[SK Integration Solutions Private Limited]

https://skintegrationsolutions.com[SK Integration Solutions Private Limited] is a company based in India that offers the best practices for using Apache Camel in all phases of the SDLC.


== http://www.talend.com[Talend, Inc]

http://www.talend.com[Talend, Inc] provides enterprise level services,
training and support for Apache Camel and their
http://www.talend.com/products/esb-standard-edition.php[Talend ESB]
product which is a repackaging of Apache Camel including a full,
pre-configured OSGi runtime container.


== https://talismanplatform.com[Talisman Platform]

The https://talismanplatform.com[Talisman Platform] is a production-ready data integration platform designed for business-critical integrations. 
Designed to facilitate integration driven by the robust capabilities of Apache Camel, 
building on top of https://github.com/apache/camel-karavan[Apache Camel Karavan], the Talisman Platform offers exclusive additional features to enhance your integration experience. 
These include Authentication and Authorization mechanisms, advanced Monitoring and Observability tools, and a comprehensive API Gateway.


== http://touk.pl[TouK]

http://touk.pl[TouK] provides enterprise integration consulting and
system integration services as well as support for Apache Camel and
Apache Servicemix.


== https://www.yupiik.com[Yupiik]

https://www.yupiik.com[Yupiik] contributes and commits to the Apache Camel project. Provides consulting,
training and support for Apache Camel and related projects like Apache Karaf, Apache ActiveMQ, Apache Kafka,
Apache Unomi.


== Policy for additions to this page

Companies are free to add information about their products and services
to this page (please keep entries in alphabetical order). The
information must be factual and informational in nature and not be a
marketing statement. Statements that promote your products and services
over other offerings on the page will not be tolerated and will be
removed. Such marketing statements can be added to your own pages on
your own site, but not here.

When in doubt, email the Camel dev list (see
link:/community/mailing-list/[Mailing Lists]) and ask. We'd be happy to help.
= Component DSL

Component-DSL is a builder API that allows using type-safe construction of Camel xref:component.adoc[Components] and injecting them directly to the xref:camelcontext.adoc[Camel Context] instead of initializing through a constructor.

The Component DSL is exclusively available as part of the Java DSL.

== Using Component DSL

The following is an example of a Kafka component that is constructed using the typical constructor initialization:

[source,java]
----
KafkaComponent kafka = new KafkaComponent();
kafka.setBrokers("localhost:9090");

camelContext.addComponent("kafka", kafka);
----

The same Java statement can be rewritten in the following more readable way using the new `ComponentsBuilderFactory` that allows the access to all component DSLs in Camel:

[source,java]
----
ComponentsBuilderFactory.kafka()
                        .brokers("{{kafka.host}}:{{kafka.port}}")
                        .register(camelContext, "kafka");
----

In order to explain it better, we can break down the above Java statement into 3 parts:

. `ComponentsBuilderFactory.kafka()`: This will initialize the DSL for `camel-kafka` component.
. `.brokers("{{kafka.host}}:{{kafka.port}}")`: This is the equivalent setter of `kafka.setBrokers("localhost:9090")` using DSL fluent builder.
. `.register(camelContext, "kafka")`: Here we register directly the component under name `kafka` into Camel context, of course you can use any component name you like, just like `addComponent` API. 

=== Type Safety

Similar to the xref:Endpoint-dsl.adoc[Endpoint DSL], uses the meta-model, which is extracted from the source and
written in various JSON files, to generate a fluent DSL for each component. This fluent DSL provides type safety for parameters.


== Dependency

In order to use this feature, Maven users will need to add the following dependency to their `pom.xml` for this component:

[source,xml]
.pom.xml
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-componentdsl</artifactId>
    <version>x.x.x</version>
</dependency>
----

And then use it just like how we demonstrated it earlier in this page.
= Components

Components are a fundamental building block of Apache Camel and are used to connect routes to a wide variety of external systems and services. Camel comes with a large number of built-in components that provide connectivity to a wide range of technologies and protocols, such as HTTP, JMS, file, and many others. You can also create a custom components if the built-in components do not meet your needs.

== Components: the basics

A Component is essentially a factory of Endpoint instances. Typically, applications shouldn't need to interact directly with a component. However, there are some circumstances where manipulating the component may be beneficial for the performance, operation, or scalability of the application. In such cases, these applications may use the context to get access to an instance of the endpoint they need to manipulate. The applications can do so by using the method `CamelContext.getEndpoint()`. This method returns an implementation of the `Component` interface that is appropriate for the component requested. For instance, consider the following code:

[source,java]
----
myCamelContext.getEndpoint("pop3://john.smith@mailserv.example.com?password=myPassword");
----

For the URI given in the above example, the `CamelContext` object would map the `pop3` prefix to an instance of the `MailComponent` class.

The parameter to `getEndpoint()` is a URI. The URI _scheme_ (that is,
the part before `:`) specifies the name of a component. Internally, the `CamelContext` object maintains a mapping from the names of components to `Component` objects.

[NOTE]
====
Our documentation contains an in-depth overview of the xref:manual::component.adoc[Component] if you want to learn more about it, including important details necessary to write your own.
====

== Configuring Component Options

Camel components are configured on two separate levels:

- component level
- endpoint level

The component level is the highest level which holds general and common configurations that are inherited by the endpoints.
For example, a component may have security settings, credentials for authentication, urls for network connection and so forth.

Some components only have a few options, and others may have many. Because components typically have pre-configured defaults
that are commonly used, then you may often only need to configure a few options on a component; or none at all.

Configuring components can be done with the xref:component-dsl.adoc[Component DSL], in a configuration file (application.properties|yaml), or directly with Java code.

== Configuring Endpoint Options

Typically, you want to configure endpoints, as endpoints often have many options, which allows you to configure what you need the endpoint to do. These endpoint options are also categorized according to the type of endpoint:

* consumer (_from_)
* producer (_to_)
* or both.

Configuring endpoints is most often done directly in the endpoint URI as path and query parameters. You can also use
the xref:Endpoint-dsl.adoc[Endpoint DSL] as a _type safe_ way of configuring endpoints.

A good practice when configuring options is to use xref:using-propertyplaceholder.adoc[Property Placeholders],
which allow us to avoid using hardcoded urls, port numbers, sensitive information, and other settings.
In other words, with placeholders you can externalize the configuration from your code, thus obtaining more flexibility and reuse.

=== How Camel maps names to components

In the getting started guide, we explained that Camel maintains a map of names to components. This raises the question of how Camel populates this map with named `Component` objects.

[NOTE]
====
Normally, application developers don't need to worry about this. However, this information is fundamental if you are writing a custom component.
====

There are two ways of populating the map.

* Programmatically, using the context
* Via lazy-initialization

=== Programmatically

The programmatic way is for application-level code to invoke `CamelContext.addComponent(String componentName, Component component)`.

The example below shows a single `MailComponent` object being registered in the map under 3 different names.

[source,java]
----
Component mailComponent = new org.apache.camel.component.mail.MailComponent();
myCamelContext.addComponent("pop3", mailComponent);
myCamelContext.addComponent("imap", mailComponent);
myCamelContext.addComponent("smtp", mailComponent);
----

=== Lazy-initialization

The second (and preferred) way to populate the map of named `Component` objects in the `CamelContext` object is to let the `CamelContext` object perform lazy initialization.

This approach relies on developers following a convention when they write a class that implements the `Component` interface. For instance, let's assume you write a class called `com.example.myproject.FooComponent` and you want Camel to automatically recognize this by the name `foo`. To do this, you write a properties file called `META-INF/services/org/apache/camel/component/foo` (without a `.properties` file extension) that has a single entry in it called `class`, the value of which is the fully-scoped name of your class. For instance:

.META-INF/services/org/apache/camel/component/foo
[source]
----
class=com.example.myproject.FooComponent
----

If you want Camel to also recognize the class by the name `bar` then you write another properties file in the same directory called `bar` that has the same contents. Once you have written the properties file(s), you create a JAR file that contains the `com.example.myproject.FooComponent` class and the properties file(s), and you add this jar file to your CLASSPATH. Then, when application-level code invokes `createEndpoint("foo:...")` on a `CamelContext` object, Camel will find the "foo"" properties file on the CLASSPATH, get the value of the `class` property from that properties file, and use reflection APIs to create an instance of the specified class.

Camel provides out-of-the-box support for various communication technologies. This support consists of classes that implement the `Component` interface plus properties files that enable a `CamelContext` object to populate its map of named `Component`
objects.

Earlier in this guide, we provided the following example of calling `CamelContext.getEndpoint()`:

[source,java]
----
myCamelContext.getEndpoint("pop3://john.smith@mailserv.example.com?password=myPassword");
----

We originally referred to the parameter as a URI because the online Camel documentation and the Camel source code both claim the parameter is a URI. In reality, the parameter is restricted to being a URL. This is because when Camel extracts the component name from the parameter, it looks for the first ":", which is a simplistic algorithm.

[NOTE]
====
Remember that in the xref:camel-core:getting-started:index.adoc[Getting Started With Camel] we explained that a URI could be a URL or a URN.
====

Now consider the following calls to `getEndpoint`:

[source,java]
----
myCamelContext.getEndpoint("pop3:...");
myCamelContext.getEndpoint("jms:...");
myCamelContext.getEndpoint("urn:foo:...");
myCamelContext.getEndpoint("urn:bar:...");
----

Camel identifies the components in the above example as `pop3`, `jms`, `urn`, and `urn`. It would be more useful if the latter components were identified as `urn:foo` and `urn:bar` or as `foo` and `bar` (that is, by skipping over the `urn:` prefix). So, in practice, you must identify an endpoint with a URL (a string of the form `<scheme>:...`) rather than with a URN (a string of the form `urn:<scheme>:...`). This lack of proper support for URNs means that you should consider the parameter to the method `getEndpoint()` as being a URL rather than (as claimed) a URI.

[NOTE]
====
Make sure to read xref:faq:how-do-i-configure-endpoints.adoc[How do I configure endpoints?]
to learn more about configuring endpoints. For example, how to refer to beans in the xref:registry.adoc[Registry] or how
to use raw values for password options, and using xref:using-propertyplaceholder.adoc[property placeholders] etc.
====

== Component DSL

Component-DSL is a builder API that allows using type-safe construction of Camel Components and injecting them directly to the xref:camelcontext.adoc[Camel Context] instead of initializing through a constructor.

** xref:manual::component-dsl.adoc[Component DSL]

== Writing Components

This is an advanced topic and described in more detail in the xref:writing-components.adoc[Writing Components Guide].

== See Also

- List of all Camel xref:components::index.adoc[Components]
= Configuring Routes Startup Ordering and Auto-startup

Camel supports configuring two aspects:

* auto-startup
* order of starting routes

== Auto-startup

The `autoStartup` option allows is to configure
Camel to *not* auto start routes when Camel starts.

The auto startup can be configured on two levels:

- Camel context: _Globally_
- Route: _Individually per route_

For example, the xref:camelcontext.adoc[CamelContext] below we have configured `autoStartup=false` to
prevent Camel starting all the routes on startup.

[source,xml]
----
<camelContext id="myCamel" xmlns="http://camel.apache.org/schema/spring"
              autoStartup="false">
    <route>
        <from uri="direct:foo"/>
        <to uri="mock:foo"/>
    </route>
    <route>
        <from uri="direct:bar"/>
        <to uri="mock:bar"/>
    </route>
</camelContext>
----

So how do you start the routes?

The `autoStartup` option on the `<camelContext>` is only used once, so you
can manually start Camel later by invoking its `start` method in Java as shown
below.

For example, when using Spring, you can get hold of the `CamelContext` via
the Spring `ApplicationContext`:

[source,java]
----
ApplicationContext ac = ...
CamelContext camel = ac.getBean("myCamel", CamelContext.class);

// now start all the routes
camel.getRouteController().startAllRoutes();
----

TIP: The routes can also be started via JMX (requires `camel-management` JAR to be on the classpath) by invoking the `startAllRoutes` operation on the CamelContext MBean.

=== Auto-startup per route level

You can also use the `autoStartup` option to configure if a given route
should be started when Camel starts. By default, a route is auto started.

In XML DSL, you disable auto startup as follows:

[source,xml]
----
<route autoStartup="false">
   <from uri="activemq:queue:special"/>
   <to uri="file://backup"/>
</route>
----

And to explicit state it should be started:

[source,xml]
----
<route autoStartup="true">
   <from uri="activemq:queue:special"/>
   <to uri="file://backup"/>
</route>
----

And in Java DSL you can configure auto startup on `CamelContext` as follows:

[source,java]
----
camelContext.setAutoStartup(false);
----

And on route level you can disable it via `noAutoStartup`:

[source,java]
----
from("activemq:queue:special").noAutoStartup()
    .to("file://backup");
----

To startup based on a boolean, String or
xref:components::properties-component.adoc[Property], do one of the following:

[source,java]
----
// using a boolean
from("activemq:queue:special").autoStartup(false)
    .to("file://backup");

// using a string
from("activemq:queue:special").autoStartup("false")
    .to("file://backup");

// using property placeholders
from("activemq:queue:special").autoStartup("{{startupRouteProperty}}")
    .to("file://backup");
----

== Configuring starting order for routes

You can also configure the order in which routes are started.
Previously,
Camel started the routes in a non-deterministic order.
Now you have
fine-grained control in which order the routes should be started.
There is a
new attribute `startupOrder` which is an `Integer` that states the order.
Camel then sorts the routes before starting time.
The routes with the lowest `startupOrder` are started first, and the ones with the highest are
started last.

IMPORTANT: All `startupOrder` defined must be unique among all routes in your
xref:camelcontext.adoc[CamelContext]. Otherwise, if there are clashes in
`startupOrder` numbers among routes, the routes will fail to start up throwing
`org.apache.camel.FailedToStartRouteException`.

Normally you should also use numbers that are lower than 1000, as routes without
an explicit `startupOrder` definition will have a number starting from 1000
auto assigned. So view numbers from 1000 upwards as reserved internally
for Camel itself.

However, you can also use higher numbers than 1000
(to avoid collisions with those auto assigned numbers) to specify the last routes
to start up. Normally, the usage of numbers starting from 10000 should be safe
for the purpose.

In terms of the `startupOrder` there are no strict rules that it must
start from 1 and increment by 1.
You can, for example, use: 100, 200, 205, 89 if you like.
The only rule of thumb is that the numbers must be unique.

=== Why do you want to control the starting order?

It can help in cases where routes are inter-dependent on each other and
also help with graceful shutting down Camel as Camel can stop the routes
in the correct order as well.

Apache Camel will stop the routes in the *reverse* order that they were started.

Let's try a couple of examples.

=== Startup ordering example

[source,java]
----
from("seda:foo").startupOrder(1)
    .to("mock:result");

from("direct:start").startupOrder(2)
    .to("seda:foo");
----

And the same example with XML DSL:

[source,xml]
----
<routes>
    <route startupOrder="1">
        <from uri="seda:foo"/>
        <to uri="mock:result"/>
    </route>

    <route startupOrder="2">
        <from uri="direct:start"/>
        <to uri="seda:foo"/>
    </route>
</routes>
----

In this example, we have two routes in which we have started that the
direct:start route should be started *after* the seda:foo route.
Because direct:start is considered the input, and we want seda:foo
route to be up and running beforehand.

=== Using startOrder together with non startOrder

You can also mix and match routes with and without `startupOrder` defined.
The first two routes below have start order defined, and the last route has not.

[source,java]
----
from("seda:foo").startupOrder(1)
    .to("mock:result");

from("direct:start").startupOrder(2)
    .to("seda:foo");

from("direct:bar")
    .to("seda:bar");
----

And the same example with XML DSL:

[source,xml]
----
<routes>
    <route startupOrder="1">
        <from uri="seda:foo"/>
        <to uri="mock:result"/>
    </route>

    <route startupOrder="2">
        <from uri="direct:start"/>
        <to uri="seda:foo"/>
    </route>

    <route>
        <from uri="direct:bar"/>
        <to uri="seda:bar"/>
    </route>
</routes>
----

In the route above we have *not* defined a `startupOrder` on the last
route direct:bar in which Camel will auto assign a number for it, in
which this case will be 1000.
Therefore, the route will be started last.

So you can use this to your advantage to only assign a `startupOrder` on
the routes which really needs it.

=== Configuring routes to start up last

You can use a high number in `startupOrder` to have a specific route startup last as shown below:

[source,java]
----
// use auto assigned startup ordering
from("direct:start").to("seda:foo");

// should start first
from("seda:foo").startupOrder(1).to("mock:result");

// should start last after the default routes
from("direct:bar").startupOrder(12345).to("seda:bar");

// use auto assigned startup ordering
from("seda:bar").to("mock:other");
----

In the example above, the order of route startups should be:

1. `_seda:foo_`
2. `_direct:start_`
3. `_seda:bar_`
4. `_direct:bar_`

=== Shutting down routes

Apache Camel will shut down the routes in the *reverse* order that they were started.

See more at xref:graceful-shutdown.adoc[Graceful Shutdown].

= ConsumerTemplate

The `ConsumerTemplate` interface allows you to receive message exchanges from
endpoints in a variety of different ways to make it easy to work with
Camel xref:endpoint.adoc[Endpoint] instances from Java code.

It can be configured with a default endpoint if you just want to receive
lots of messages to the same endpoint; or you can specify an
xref:endpoint.adoc[Endpoint] or uri as the first parameter.

The `receiveBody()` method allows you to receive any object to an endpoint
easily as shown:

[source,java]
----
ConsumerTemplate template = exchange.getContext().createConsumerTemplate();

// recieve from default endpoint
Object body = template.receiveBody();

// receive from a specific queue
body = template.receiveBody("activemq:MyQueue");
----

== Receive modes

The consumer template operates in three modes:

- **receive** - Consumes from the endpoint, waiting until there is a message (can potentially wait for a long time!).
- **receiveNoWait** - Consumes from endpoint, not waiting for a message if none exists.
- **receiveTimeout** - Consumes from the endpoint, waiting until there is a response, or the timeout occurs.

In the previous examples then it was the first mode we used (`receiveBody`).
For example if there are no messages on the `activemq:MyQueue` then Camel would wait until a message is sent to this queue.

Often you dont want to wait _forever_ so its often a good idea to use a timeout value, such as 5 seconds:

[source,java]
----
ConsumerTemplate template = exchange.getContext().createConsumerTemplate();

// receive from a specific queue
body = template.receiveBody("activemq:MyQueue", 5000);
----

Here we wait at most 5 seconds for a message to be consumed, if there was no message, then `null` is returned as response.

== See Also

See xref:producertemplate.adoc[ProducerTemplate]= Context Reload

The context reload functionality in Camel is capable of reloading all existing routes and property placeholders
upon an external triggered event.

For example, if you are using xref:components::aws-secrets-manager-component.adoc[AWS Secrets], then
enabling context-reload would then reload Camel routes upon a secret is updated in AWS.

The context reload is limited to refresh the following on reload:

- xref:using-propertyplaceholder.adoc[property placeholders]
- all existing xref:routes.adoc[routes] (no changes to structure of routes; see xref:route-reload.adoc[]])

General services in xref:camelcontext.adoc[CamelContext] and java beans or Camel xref:processor.adoc[] is not updated.

== Using context reloading

The context reloading can be configured in Java or with Spring Boot, Quarkus in the following way:

[source,java]
----
CamelContext context = ...

ContextReloadStrategy reload = new DefaultContextReloadStrategy();
context.addService(reload);
----

And with Camel Quarkus / Camel Main you can configure this in `application.properties:`

[source,properties]
----
# turn on context reloading
camel.main.context-reload-enabled = true
----

And in Spring Boot:

[source,properties]
----
# turn on context reloading
camel.springboot.context-reload-enabled = true
----

== Triggering context reloading

Any custom code can trigger context reloading. This is done by ensuring the context reload is enabled (see the note above), and
then from Java you can get hold of `ContextReloadStrategy` as follows:

[source,java]
----
ContextReloadStrategy reload = context.hasService(ContextReloadStrategy.class);
if (reload != null) {
    // trigger reload
    reload.onReload(this);
}
----

The method `onReload` will then reload all the xref:using-propertyplaceholder.adoc[property placeholders] and
then afterward reload all existing xref:routes.adoc[routes].


== See Also

See related xref:route-reload.adoc[].

= CronScheduledRoutePolicy

`CronScheduledRoutePolicy` is a
xref:scheduledroutepolicy.adoc[ScheduledRoutePolicy] that facilitates
route activation, deactivation, suspension and resumption of routes
based on a xref:components::quartz-component.adoc[Quartz] cron trigger.

[TIP]
====
.Relationship to the Quartz component

All Scheduled route policies share the scheduler created by the xref:components::quartz-component.adoc[Quartz]
component. In this way, scheduler, jobs and triggers can be managed in a
common and consistent way.
====

== Using cron scheduled route policy

To use a `CronScheduledRoutePolicy` it is
necessary to instantiate an object of the type
`org.apache.camel.routepolicy.quartz.CronScheduledRoutePolicy`.

To perform a route operation at a given time, the following
information must be provided.

=== Starting a route

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter Name |Type |Default Value |Description
|routeStartTime |String |  |the initial scheduled date and time as a
Cron Expression for route start
|=======================================================================

=== Stopping a route

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter Name |Type |Default Value |Description
|routeStopTime |String |  |the initial scheduled date and time as a Cron
Expression for route stop

|routeStopGracePeriod |int |10000 |the time period to wait before
initiating graceful route stop

|routeStopTimeUnit |long |TimeUnit.MILLISECONDS |the time unit for the
grace period expressed as `java.util.concurrent.TimeUnit`
|=======================================================================

=== Suspending a route

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter Name |Type |Default Value |Description
|routeSuspendTime |String |  |the initial scheduled date and time as a
Cron Expression for route suspension
|=======================================================================

=== Resuming a route

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter Name |Type |Default Value |Description
|routeResumeTime |String |  |the initial scheduled date and time as a
Cron Expression for route resumption
|=======================================================================

== Configuring the route policy

Once the `org.apache.camel.routepolicy.quartz.CronScheduledRoutePolicy`
is created it can be wired into the Camel route as follows:

In Java:

[source,java]
----
CronScheduledRoutePolicy startPolicy = new CronScheduledRoutePolicy();
startPolicy.setRouteStartTime("*/3 * * * * ?");
                
from("direct:start")
    .routeId("testRoute").routePolicy(startPolicy).noAutoStartup()
    .to("mock:success");
----

And with Spring XML:

[source,xml]
----
<bean id="startPolicy" class="org.apache.camel.routepolicy.quartz.CronScheduledRoutePolicy">
    <property name="routeStartTime" value="*/3 * * * * ?"/>
</bean>
    
<camelContext xmlns="http://camel.apache.org/schema/spring">
    <route id="testRoute" routePolicyRef="startPolicy" autoStartup="false">
        <from uri="direct:start"/>
        <to uri="mock:success"/>
    </route>
</camelContext>
----

IMPORTANT: Notice how the route to be scheduled *MUST* be configured to not
xref:configuring-route-startup-ordering-and-autostartup.adoc[auto-startup], to let
the route scheduler take control of starting and stopping the route accordingly.

=== Dependency

Maven users will need to add a camel-quartz dependency to their
`pom.xml` to avail this capability.

[source,xml]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-quartz</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----
= Data Format

Camel supports a pluggable `DataFormat` to allow messages to be marshalled
to and from binary or text formats to support a kind of
xref:components:eips:message-translator.adoc[Message Translator].

image::images/MessageTranslator.gif[image]

Camel has support for message transformation using several techniques.
One such technique is data formats, where marshal and unmarshal comes from.

So in other words, the xref:components:eips:marshal-eip.adoc[Marshal] and
xref:components:eips:unmarshal-eip.adoc[Unmarshal] EIPs
are used data formats.

- _Marshal_ - Transforms the message body (such as Java object) into a binary or textual format, ready to be wired over the network.
- _Unmarshal_ - Transforms data in some binary or textual format (such as received over the network)
into a Java object; or some other representation according to the data format being used.

== Supported data formats

There are more than 40 different data formats that
support formats such as XML, CSV, JSON, YAML, Avro, Protobuf, and many more.

== Example

See xref:components:eips:marshal-eip.adoc[Marshal] for more information and examples.

== See Also

** xref:manual::dataformat-dsl.adoc[Data Format DSL]
= Data Format DSL

The Data Format DSL is a builder API that allows using type safe construction of
Camel xref:data-format.adoc[Data Formats].

The Data Format DSL is exclusively available as part of the Java DSL.

The DSL can be accessed directly from the `RouteBuilder` thanks to the method `dataFormat()`.

== Using Data Format DSL

In the following example, a `CsvDataFormat` is created using the legacy approach where the data format is instantiated explicitly and configured using setters:

[source,java]
----
public class MyRoutes extends RouteBuilder {
    @Override
    public void configure() {
        CsvDataFormat dataFormat = new CsvDataFormat(); // <1>
        dataFormat.setDelimiter("|"); // <2>
        from("direct:format")
            .setBody(constant(Map.of("foo", "abc", "bar", 123)))
            .marshal(dataFormat); // <3>
    }
}
----
<1> Instantiate the expected data format
<2> Configure the data format according to the needs
<3> Affect the data format with the expected configuration

The previous code could be simplified using the utility methods available directly from the `DataFormatClause` corresponding to the type returned by the `marshal()` and `unmarshal()` methods:

[source,java]
----
public class MyRoutes extends RouteBuilder {
    @Override
    public void configure() {
        from("direct:format")
            .setBody(constant(Map.of("foo", "abc", "bar", 123)))
            .marshal()
            .csv(); // <1>
    }
}
----
<1> Select the `csv` data format with the default delimiter

This approach is suitable for very basic configuration, but as there are only limited utility methods for each supported data format, for more complex configuration, we can quickly face situations where the utility method for our expected configuration doesn't exist. In this situation, you can either use the legacy approach or the data format DSL like in the next code snippet:

[source,java]
----
public class MyRoutes extends RouteBuilder {
    @Override
    public void configure() {
        from("direct:format")
            .setBody(constant(Map.of("foo", "abc", "bar", 123)))
            .marshal(
                dataFormat() // <1>
                    .csv() // <2>
                        .delimiter(",") // <3>
                    .end() // <4>
            );
    }
}
----
<1> Give access to all the supported data formats
<2> Select the `csv` data format
<3> Configure the data format according to the needs
<4> Build the data format with the expected configuration
= Debugger

The Camel Debugger is intended for third party tooling to make it possible to
debug routes, trace messages and to use breakpoints with the EIP patterns in the Camel routes.

The Debugger allows tooling or the likes to attach breakpoints which are
being invoked when xref:exchange.adoc[Exchanges] are routed.

== Java Debugging Camel routes in unit tests

If you are developing unit tests using the `camel-test-junit5` component, then
the Debugger is available if you turn it on via overriding the `isUseDebugger()`
method and return `true`.

In this unit test

[source,java]
-----------------------------------------------
public class DebugTest extends CamelTestSupport
-----------------------------------------------

We want to debug the following route

[source,java]
-----------------------------------------------
@Override
protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder() {
        @Override
        public void configure() throws Exception {
            // this is the route we want to debug
            from("direct:start")
                .to("mock:a")
                .transform(body().prepend("Hello "))
                .to("mock:b");
        }
    };
}
-----------------------------------------------

Which can easily done by overriding the `debugBefore` method as shown

[source,java]
-----------------------------------------------
@Override
public boolean isUseDebugger() {
    // must enable debugger
    return true;
}
 
@Override
protected void debugBefore(Exchange exchange, Processor processor,
                           ProcessorDefinition<?> definition, String id, String shortName) {
    // this method is invoked before we are about to enter the given processor
    // from your Java editor you can just add a breakpoint in the code line below
    log.info("Before " + definition + " with body " + exchange.getIn().getBody());
}
-----------------------------------------------

Then from your Java editor just add a breakpoint inside the
`debugBefore` method. Then fire up the unit test and wait for the Java
editor to hit the breakpoint. Then you can inspect the
Exchange during debugging while it advances during
routing. The `ProcessorDefinition` and the `id` and `shortName`
parameters is all information which tells you where in the route the
breakpoint was hit. 

TIP: There is also a `debugAfter` method which is invoked after the processor
has been invoked. This allows you to _see_ what happens to the
Exchange right after it has invoked a processor in the route.

The screenshot below shows the Debugger in action.
The IDE (IDEA) has hit the breakpoint, and we can inspect the
parameters. Notice how we can see that the message is to be sent to the mock:a
endpoint.

image::images/debug.png[image]

=== Java debugging of Camel routes written with Java DSL

A trick to debug a Camel route written with Java DSL is to modify the route to insert a `processor` and then to set the breakpoint in it.

For instance:

[source,java]
-----------------------------------------------
public class MyRouteBuilder extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        from("timer:demo").routeId("foo")
        	.bean("myBean", "hello")
			.process(new Processor() {
				@Override
				public void process(Exchange exchange) throws Exception {
					System.out.println("put a breakpoint here");
				}
			})
        	.log("${body}")
        	.bean("myBean", "bye")
        	.log("${body}");
    }
}
-----------------------------------------------

=== Implementing a custom debugger

The debugger API is defined in `org.apache.camel.spi.Debugger`.
This API has methods to attach and remove breakpoints.

And to suspend/resume all breakpoints etc.
You can also attach a condition to the breakpoint, so it only reacts if
the condition matches.

Camel provides a base implementation `org.apache.camel.impl.DefaultDebugger`,
which can be used to extend for custom implementations.

=== Camel Route debugger through JMX

There is also a xref:backlog-debugger.adoc[Backlog Debugger] that allows debugging from JMX.
It is automatically provided when `camel-debug` is on the classpath (since 3.16) or when
using the `camel:debug` Maven goal (since 3.18).

To be able to have enough time to add your breakpoints, since 3.18, you could need to suspend the message processing of Camel to make sure
that you won't miss any messages. For this kind of need, you have to set either the environment variable `CAMEL_DEBUGGER_SUSPEND` or the system property `org.apache.camel.debugger.suspend` to `true` within the context of your application, then the `Backlog Debugger` suspends the message processing until the JMX operation `attach` is called. Calling the JMX operation `detach` suspends again the message processing.

In case the environment variable and the system property are both set, the value of the environment variable is used.

Several third-party tools are using it:

* https://hawt.io/[hawtio] uses this for its web-based debugging functionality
* https://marketplace.visualstudio.com/items?itemName=redhat.vscode-debug-adapter-apache-camel[VS Code Debug Adapter for Camel]
* http://marketplace.eclipse.org/content/textual-debugging-apache-camel[Eclipse Desktop Debug Adapter for Camel]
* https://plugins.jetbrains.com/plugin/9371-apache-camel[IntelliJ Camel plugin]
* https://github.com/camel-tooling/camel-debug-adapter[Debug Adapter Server for Camel]

Camel requires to have `camel-management` JAR on the classpath for having JMX enabled.

= DefaultErrorHandler

This is the default xref:error-handler.adoc[Error Handler] in Camel.

The default xref:error-handler.adoc[Error Handler] has the same power
as the xref:components:eips:dead-letter-channel.adoc[Dead Letter Channel.]
However, it does *not* support a _dead letter queue_, which is
the only difference between the two of them.

The `DefaultErrorHandler` is configured differently from
xref:components:eips:dead-letter-channel.adoc[Dead Letter Channel] as
it is configured to:

* not redeliver
* not handled
* no dead letter queue (because it is not possible)

By default, any exception thrown during routing will be propagated back
to the caller and the xref:exchange.adoc[Exchange] ends immediately.
However, you can use the xref:exception-clause.adoc[Exception Clause] to
catch a given exception and lower the exception by marking it as
handled. If so, the exception will *not* be sent back to the caller, and
the xref:exchange.adoc[Exchange] will succeed, but *not continue* being routed.
See the _difference_ between `handled` and `continued` in the
xref:exception-clause.adoc[Exception Clause] documentation.

== Example

In this route below, any exception thrown in, such as the `validateOrder`
bean, will be propagated back to the caller via the jetty endpoint, which
then returns an HTTP error message back to the client.

[source,java]
----
from("jetty:http://localhost/myservice/order")
  .to("bean:validateOrder")
  .to("jms:queue:order");
----

We can add an `onException` in case we want to catch certain exceptions
and route them differently, for instance to catch a
`ValidationException` and return a fixed response to the caller.

[source,java]
----
onException(ValidationException.class)
  .handled(true)
  .transform(body(constant("INVALID ORDER")));

from("jetty:http://localhost/myservice/order")
  .to("bean:validateOrder")
  .to("jms:queue:order");
----

When the `ValidationException` is thrown from the `validateOrder` bean,
it is intercepted by Camel error handler which lets the
`onException(ValidationException.class)` handle the exception.
The xref:exchange.adoc[Exchange] is routed to this onException route, and
since we use `handled(true)`, then the original exception is cleared,
and we transform the message into a fixed response that is returned to
jetty endpoint that returns it to the original caller.

= Delayer

The Delayer is used for slowing processing of messages.

This allows you to set a fixed amount of delay between each step a message passes in
the route.
It can be used to better show how things are happening nicely and slowly, so you
are not bombarded with a zillion lines of logging output.

== Using Delayer

The delayer can be configured on two levels:

- Camel context: _Globally_
- Route: _Individually per route_

=== Configuring using XML DSL

Set the `delayer` attribute of the `<camelContext>` tag as shown below:

[source,xml]
--------------------------------------------------------------------------------------------------
<camelContext id="camel" delayer="500" xmlns="http://activemq.apache.org/camel/schema/spring">
    <route>
        <from uri="direct:start"/>
        <to uri="mock:result"/>
    </route>
</camelContext>
--------------------------------------------------------------------------------------------------

=== Configuring using Java

You can enable delaying messages by setting the delay value on the `CamelContext` as shown:

[source,java]
-----------------------------
camelContext.setDelayer(200);
-----------------------------

=== Configuring on route level

You can also configure it on both camel context and per route
as you like. Per route will override the camel context setting.

For example, the route below is only the first route that has a delayer with 200 milliseconds.

[source,xml]
----
<camelContext>
   <route delayer="200">
     ...
   </route>

   <route>
     ...
   </route>
</camelContext>
----

And in Java DSL:

[source,java]
----
from("direct:start").delayer(200)
    .to("mock:result")
----

= DSL

Camel uses a Java _Domain Specific Language_ or DSL for creating
xref:components:eips:enterprise-integration-patterns.adoc[Enterprise Integration
Patterns] or xref:routes.adoc[Routes] in a variety of domain-specific
languages (DSL) as listed below:

* xref:java-dsl.adoc[Java DSL]: a Java-based DSL using the fluent builder style.
* xref:components:others:java-xml-io-dsl.adoc[XML DSL]: an XML-based DSL in Camel XML files only.
* xref:components::spring-summary.adoc[Spring XML]: an XML-based DSL in classic Spring XML files.
* xref:components:others:yaml-dsl.adoc[YAML DSL]: for creating routes using YAML format.
* xref:rest-dsl.adoc[Rest DSL]: a DSL to define REST services using REST verbs.
** xref:rest-dsl-openapi.adoc[Rest DSL contract first]: rest DSL using _contract-first_ when OpenAPI specs.
* xref:bean-integration.adoc[Annotation DSL]: Use annotations in Java beans.

== See Also

* xref:camelcontext.adoc[CamelContext] the main entry for Camel is the `CamelContext`
* xref:routes.adoc[Routes] for general information about a Camel route
* xref:route-builder.adoc[RouteBuilder] for creating routes using the Java DSL style.
* xref:lambda-route-builder.adoc[LambdaRouteBuilder] for creating routes using Java lambda style.
* xref:Endpoint-dsl.adoc[Endpoint DSL] for creating routes using type-safe Camel endpoints in Java.
* xref:dataformat-dsl.adoc[DataFormat DSL] for type-safe Camel data formats in Java.
* xref:route-template.adoc[Route Template] for creating reusable route templates.
* xref:route-reload.adoc[Route Reload] for hot-reloading routes in a running Camel application.
= Component Endpoint Annotations

You can annotate xref:endpoint.adoc[Endpoint] and xref:component.adoc[Component]
classes, so that their configuration documentation can be
automatically generated by Maven tooling via the
xref:camel-component-maven-plugin.adoc[Camel Component Maven Plugin]
into the `src/main/generated` folder.

The documentation is then included into the jar as JSON schema files.

The Camel project uses this to automatic keep the website documentation up-to-date
with all the latest options on the Camel xref:components::index.adoc[Components].

== Supported Annotations

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Annotation |Description
|`@UriEndpoint` |Specifies that an endpoint is annotated with `@UriParam`
and/or `@UriParams` annotations. Also specifies the default scheme to use
in the generated documentation, and other information.

|`@UriParam` |Used to annotate a parameter value; usually specified via
?foo=bar syntax in the URI strings in Camel. Used currently only on
field declarations but in the future could be used on setter methods
too. If no name is specified then the name of the field/setter property
is used.

|`@UriParams` |Specifies that a field is a nested object of one or more
configuration parameters; then the class of this field should be
annotated with one or more `@UriParam` or `@UriParams` annotations

|`@Metadata` | Used for special situations to provide additional information.
|=======================================================================

For example see the `TimerEndpoint` from the `camel-timer` component and
notice how it is using these annotations.

The annotations are not only useful for automatically generating the
documentation; we can use them to refine the validation of the code
during configuration and can be useful for tooling providers, so they
can more easily introspect the configuration options.

= Endpoint DSL

Endpoint-DSL is a builder API that allows using type-safe endpoint xref:uris.adoc[URL] configurations.

The Endpoint DSL is exclusively available as part of the Java DSL.

The DSL can be accessed in several ways, but the main one is to switch to using an `EndpointRouteBuilder` instead of the usual
`RouteBuilder`. This builder provides access to all of Camel endpoint builders which are defined through inheritance on the `org.apache.camel.builder.endpoint.EndpointRouteBuilder`.

== Using Endpoint DSL

The following is an example of an FTP route using the standard `RouteBuilder` Java DSL:

[source,java]
----
public class MyRoutes extends RouteBuilder {
    @Override
    public void configure() {
        from("ftp://foo@myserver?password=secret&recursive=true&" +
                "ftpClient.dataTimeout=30000&" +
                "ftpClientConfig.serverLanguageCode=fr")
                .to("bean:doSomething");
    }
}
----

The same Java statement can be rewritten in the following more type-safe and readable way using
the new `EndpointRouteBuilder` that allows using the Endpoint-DSL:

[source,java]
----
public class MyRoutes extends EndpointRouteBuilder {
    @Override
    public void configure() throws Exception {
        from(ftp("myserver").account("foo").password("secret").recursive(true)
            .advanced()
                .ftpClientParameters(Collections.singletonMap("dataTimeout", 30000))
                .ftpClientConfig(Collections.singletonMap("serverLanguageCode", "fr")))
            .to(bean("something"));
    }
}
----

=== Type Safety

Similar to the xref:component-dsl.adoc[Component DSL], uses the meta-model, which is extracted from the source and
written in various JSON files, to generate a fluent DSL for each component. This fluent DSL provides type safety for parameters.

=== Using custom component names

The Endpoint-DSL uses the default name of the xref:component.adoc[Component], so in the example above the name is `ftp`.
There can be use-cases where you may have multiple Camel xref:components::index.adoc[components] of the same type registered with different names.
An example is if you have two JMS broker systems (for example ActiveMQ and WebSphereMQ).

Then you can set up two Camel JMS components with unique names such as: `myAMQ` and `myWMQ`

The Endpoint-DSL can use these names with the `jms` fluent builder as shown:

[source,java]
----
from(jms("myWMQ", "cheese").concurrentConsumers(5))
    .to(jms("myAMQ", "smelly"));
----

Notice how we can refer to their names as the first parameter in the `jms` fluent builder.
The example would then consume messages from WebSphereMQ queue named cheese and route to ActiveMQ on a queue named smelly.

=== Headers' name

The endpoint-dsl can also be used to be assisted when selecting the name of a header to set or to get. The headers' name builder
is accessible directly from the method of the class `EndpointRouteBuilder` without argument whose name is the scheme of
the target component.

In the example below the method `file()` available from `EndpointRouteBuilder`, gives access to the methods corresponding to the name of the headers of the file component. Here the method `fileName()` is called to get the name of the header for the name of the file.

[source,java]
----
public class MyRoutes extends EndpointRouteBuilder {
    @Override
    public void configure() {
        from(/*some endpoint*/)
            // Some route start
            .setHeader(file().fileName(), constant("foo.txt"))
            // Some route end
            ;
    }
}
----

=== Using Endpoint-DSL outside route builders

You can use the type-safe endpoint-dsl outside route builders with:

* With the `FluentProducerTemplate` to send messages
* Creating an `Endpoint`

For example to send a message to Kafka you can use the `FluentProducerTemplate`

[source,java]
----
import static org.apache.camel.builder.endpoint.StaticEndpointBuilders.kafka;

context.createFluentProducerTemplate()
    .to(kafka("start").clientId("myClient").brokers("{{myBrokers}}").partitionKey("myKey"))
    .withBody("Hello World")
    .send();
----

To use the endpoint-dsl with kafka you need to static import `kafka` from the class:
`org.apache.camel.builder.endpoint.StaticEndpointBuilders` which has all the Camel components.

An endpoint can also be created in Java code via the endpoint-dsl as shown:

[source,java]
----
import static org.apache.camel.builder.endpoint.StaticEndpointBuilders.paho;

Endpoint mqtt = paho("sensor").clientId("myClient").userName("scott").password("tiger")
    .resolve(context);
----

You can then set all the options via the type-safe DSL and then the endpoint can be resolved (created)
by calling `resolve` with `CamelContext` as parameter.

If you want to inject an endpoint into your POJO or `RouteBuilder` class using endpoint-dsl, then
this can be done similar to the previous example, but with one important difference:

[source,java]
----
import org.apache.camel.BindToRegistry;
import org.apache.camel.EndpointInject;
import org.apache.camel.Produce;
import org.apache.camel.builder.EndpointProducerBuilder;
import static org.apache.camel.builder.endpoint.StaticEndpointBuilders.paho;

@BindToRegistry
public class MyPojo {

    @Produce
    private FluentProducerTemplate producer;

    private final EndpointProducerBuilder mqtt = paho("sensor").clientId("myClient").userName("scott").password("tiger");

    public void sendToSensor(String data) {
        producer.withBody(data).to(mqtt).send();
    }

}
----

The `MyPojo` is a class that with standalone Camel can be discovered and registered with the `@BindToRegistry` annotation.
If you use Spring Boot, or Quarkus etc then you should use their kind of annotations for this.

That's not the point of this example, it is the Endpoint DSL to configure the MQTT endpoint (camel-paho).
The endpoint is configured the same way as before by the type-safe endpoint-dsl by static importing the `paho`,
and then use its fluent builder methods to configure. Notice how the returned type is `EndpointProducerBuilder`.
That type is not an `Endpoint` instance as it's not resolved (i.e. it's only a builder for an endpoint).
This means that the builder can be code and compiled before `CamelContext` is created and started.

At runtime, we want to use this endpoint to send messages to MQTT server; this is done in the `sendToSensor`
method where we are using `FluentProducerTemplate` that is capable of using the `EndpointProducerBuilder` as
the endpoint in shown with: `.to(mqtt)`.


== Dependency

Maven users will need to add the following dependency to their `pom.xml` for this component:

[source,xml]
.pom.xml
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-endpointdsl</artifactId>
    <version>x.x.x</version>
</dependency>
----
= Endpoints

Camel supports the xref:components:eips:message-endpoint.adoc[Message Endpoint] pattern
using the https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Endpoint.html[Endpoint]
interface.

Endpoints are created by a xref:component.adoc[Component] and these endpoints are referred
to in the xref:dsl.adoc[DSL] via their endpoint xref:uris.adoc[URIs].

== Example

The following example route demonstrates the use of a xref:components::file-component.adoc[File]
consumer endpoint and a * xref:components::jms-component.adoc[JMS] producer endpoint,
by their xref:manual::uris.adoc[URIs]:

[source,java]
----
from("file:messages/foo")
    .to("jms:queue:foo");
----

And in XML:

[source,xml]
----
<route>
    <from uri="file:messages/foo"/>
    <to uri="jms:queue:foo"/>
</route>
----

== Endpoint API

You will almost never have the need for creating endpoints manually via Java API.

From an `Endpoint` you can use the following Java API methods to create producers or consumers to the endpoint:

* https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Endpoint.html#createProducer--[`createProducer()`]
will create a
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Producer.html[Producer]
for sending message exchanges to the endpoint.

* https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Endpoint.html#createConsumer-org.apache.camel.Processor[`createConsumer()`]
implements the xref:components:eips:eventDrivenConsumer-eip.adoc[Event Driven Consumer]
pattern for consuming message exchanges from the endpoint via a
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Processor.html[Processor]
when creating a
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Consumer.html[Consumer].

* https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Endpoint.html#createPollingConsumer[`createPollingConsumer()`]
implements the xref:components:eips:polling-consumer.adoc[Polling Consumer] pattern for
consuming message exchanges from the endpoint via a
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/PollingConsumer.html[PollingConsumer].

= Error Handler

Camel supports pluggable
https://www.javadoc.io/doc/org.apache.camel/camel-base/current/org/apache/camel/processor/ErrorHandler.html[ErrorHandler]
strategies to deal with errors processing an xref:components:eips:eventDrivenConsumer-eip.adoc[Event Driven Consumer].

An alternative is to specify the error handling directly in the xref:dsl.adoc[DSL]
using the xref:exception-clause.adoc[Exception Clause].

== Exception Clause

Using Error Handler combined with
Exception Clause is a very powerful
combination. We encourage end-users to use this combination in your
error handling strategies. See samples and
Exception Clause.

== Using try ... catch ... finally

Related to error handling is the xref:try-catch-finally.adoc[Try Catch
Finally] as DSL you can use directly in your route. Its basically a
mimic of the regular try catch finally in the Java language but with
more power.

The current implementations Camel provides out of the box are:

== Non transacted

* DefaultErrorHandler is the default
error handler in Camel. This error handler does not support a dead
letter queue, it will propagate exceptions back to the caller, as if
there were no error handler at all. It has a limited set of features.
* Dead Letter Channel which supports
attempting to redeliver the message exchange a number of times before
sending it to a dead letter endpoint
* NoErrorHandler for no error handling

== Transacted

* TransactionErrorHandler is the
default error handler in Camel for transacted routes. See the
Transactional Client EIP pattern.

These error handlers can be applied in the DSL to an
entire set of rules or a specific routing rule as we show in the next
examples. Error handling rules are inherited on each routing rule within
a single RouteBuilder

== Short Summary of the provided Error Handlers

=== DefaultErrorHandler

The DefaultErrorHandler is the default
error handler in Camel. Unlike xref:components:eips:dead-letter-channel.adoc[Dead Letter
Channel] it does not have any dead letter queue, and do *not* handle
exceptions by default.

=== Dead Letter Channel

The Dead Letter Channel will redeliver at
most 6 times using 1 second delay, and if the exchange failed it will be
logged at ERROR level.

You can configure the default dead letter endpoint to use:
or in XML DSL:

[source,xml]
--------------------------------------------------------------------------------------------------
<camel:errorHandler id="deadLetterErrorHandler" type="DeadLetterChannel" deadLetterUri="log:dead">

<camel:camelContext errorHandlerRef="deadLetterErrorHandler">
  ...
</camel:camelContext>
--------------------------------------------------------------------------------------------------

=== No Error Handler

The no error handler is to be used for disabling error handling.

[source,java]
-------------------------------
errorHandler(noErrorHandler());
-------------------------------

or in XML DSL:

[source,xml]
---------------------------------------------------------------
<camel:errorHandler id="noErrorHandler" type="NoErrorHandler"/>

<camel:camelContext errorHandlerRef="noErrorHandler">
  ...
</camel:camelContext>
---------------------------------------------------------------

=== TransactionErrorHandler

The TransactionErrorHandler is the
default error handler in Camel for transacted routes.

TIP: If you have marked a route as transacted using the *transacted* DSL then
Camel will automatically use a
TransactionErrorHandler. It will try
to lookup the global/per route configured error handler and use it if
it is a `TransactionErrorHandlerBuilder` instance. If not Camel will
automatically create a temporary
TransactionErrorHandler that
overrules the default error handler. This is convention over
configuration.

== Features support by various Error Handlers

Here is a breakdown of which features are supported by the
Error Handler(s):

[width="100%",cols="20%,80%",options="header",]
|=======================================================================
|Feature |Supported by the following Error Handler

|all scopes |DefaultErrorHandler,
TransactionErrorHandler,
Dead Letter Channel

|onException |DefaultErrorHandler,
TransactionErrorHandler,
Dead Letter Channel

|onWhen |DefaultErrorHandler,
TransactionErrorHandler,
Dead Letter Channel

|continued |DefaultErrorHandler,
TransactionErrorHandler,
Dead Letter Channel

|handled |DefaultErrorHandler,
TransactionErrorHandler,
Dead Letter Channel

|Custom ExceptionPolicy |DefaultErrorHandler,
TransactionErrorHandler,
Dead Letter Channel

|useOriginalBody |DefaultErrorHandler,
TransactionErrorHandler,
Dead Letter Channel

|retryWhile |DefaultErrorHandler,
TransactionErrorHandler,
Dead Letter Channel

|onRedelivery |DefaultErrorHandler,
TransactionErrorHandler,
Dead Letter Channel

|RedeliveryPolicy |DefaultErrorHandler,
TransactionErrorHandler,
Dead Letter Channel

|asyncDelayedRedelivery |DefaultErrorHandler,
TransactionErrorHandler,
Dead Letter Channel

|redeliverWhileStopping |DefaultErrorHandler,
TransactionErrorHandler,
Dead Letter Channel

|dead letter queue |Dead Letter Channel

|onPrepareFailure |DefaultErrorHandler,
Dead Letter Channel

|=======================================================================

See xref:exception-clause.adoc[Exception Clause] documentation for
additional documentation of the features above.

== Scopes

The error handler is scoped as either:

- CamelContext - _Globally_ in XML or _globally only_ within the same `RouteBuilder` in Java DSL
- Route - _Individually per route_

The following example shows how you can register a global error handler for the `RouteBuilder`:

[source,java]
---------------------------------------------------------------
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
        errorHandler(deadLetterChannel("seda:error"));

        // here is our regular route
        from("seda:a").to("seda:b");
    }
};
---------------------------------------------------------------

The following example shows how you can register a route specific error
handler

[source,java]
---------------------------------------------------------------
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
        // this route is using a nested error handler
        from("seda:a")
            // here we configure the error handler
            .errorHandler(deadLetterChannel("seda:error"))
            // and we continue with the routing here
            .to("seda:b");

        // this route will use the default error handler
        from("seda:b").to("seda:c");
    }
};
---------------------------------------------------------------

== Spring based configuration

*Java DSL vs. Spring DSL*
The error handler is configured a bit differently in Java DSL and Spring
DSL. Spring DSL relies more on standard Spring bean configuration
whereas Java DSL uses fluent builders.

The error handler can be configured as a spring bean and scoped in:

* global (the `<camelContext>` tag)
* per route (the `<route>` tag)
* or per policy (the `<policy>`/`<transacted>` tag)

The error handler is configured with the `errorHandlerRef` attribute.

TIP: *Error Handler Hierarchy* +
The error handlers are inherited, so if you only have set a global error
handler, then it is used everywhere. But you can override this in a route
and use another error handler.

=== Spring-based configuration sample

In this sample, we configure a xref:components:eips:dead-letter-channel.adoc[Dead Letter
Channel] on the route that should redeliver at most 3 times and use a
little delay before retrying. First we configure the reference to *myDeadLetterErrorHandler* using
the `errorHandlerRef` attribute on the `route` tag.

[source,xml]
----
    <camelContext xmlns="http://camel.apache.org/schema/spring">
        <!-- set the errorHandlerRef to our DeadLetterChannel, this applies for this route only -->
        <route errorHandlerRef="myDeadLetterErrorHandler">
            <from uri="direct:in"/>
            <process ref="myFailureProcessor"/>
            <to uri="mock:result"/>
        </route>
    </camelContext>
----

Then we configure *myDeadLetterErrorHandler* that is our
Dead Letter Channel. This configuration
is standard Spring using the bean element.
And finally we have another spring bean for the redelivery policy where
we can configure the options for how many times to redeliver, delays
etc.

[source,xml]
----
    <!-- here we configure our DeadLetterChannel -->
    <bean id="myDeadLetterErrorHandler" class="org.apache.camel.builder.DeadLetterChannelBuilder">
	    <!-- exchanges is routed to mock:dead in cased redelivery failed -->
        <property name="deadLetterUri" value="mock:dead"/>
		<!-- reference the redelivery policy to use -->
        <property name="redeliveryPolicy" ref="myRedeliveryPolicyConfig"/>
    </bean>

    <!-- here we set the redelivery settings -->
    <bean id="myRedeliveryPolicyConfig" class="org.apache.camel.processor.errorhandler.RedeliveryPolicy">
	    <!-- try redelivery at most 3 times, after that the exchange is dead and its routed to the mock:dead endpoint -->
        <property name="maximumRedeliveries" value="3"/>
		<!-- delay 250ms before redelivery -->
        <property name="redeliveryDelay" value="250"/>
    </bean>
----

In *Camel 4.6* you can now inline `<errorHandler>` directly in the routes. The example above can be done as follows:

[source,xml]
----
    <camelContext xmlns="http://camel.apache.org/schema/spring">
        <route>
            <errorHandler>
                <deadLetterChannel deadLetterUri="mock:dead">
                    <redeliveryPolicy maximumRedeliveries="3" redeliveryDelay="250"/>
                </deadLetterChannel>
            </errorHandler>
            <from uri="direct:in"/>
            <process ref="myFailureProcessor"/>
            <to uri="mock:result"/>
        </route>
    </camelContext>
----


== Using the transactional error handler

The transactional error handler is based on spring transaction. This
requires the usage of the camel-spring or camel-jta component.

See xref:components:eips:transactional-client.adoc[Transactional Client] that has many
samples for how to use and transactional behavior and configuration with
this error handler.

= EventNotifier

The event notifier `org.apache.camel.spi.EventNotifier` is used to get notified about events within the CamelContext. For example, when a route is started or stopped.
The events are collected independently from the CamelContext (routes, services, exchanges, and so on). This means that the notifier doesn't interfere with the rest of Camel, and
the events can be processed independently for logging, data offloading or other type of actions.

== Type of Events

The following CamelEvents are available:

* CamelEvent
** CamelContextEvent
***	CamelContextInitializedEvent
***	CamelContextInitializingEvent
***	CamelContextReloadedEvent
***	CamelContextReloadFailureEvent
***	CamelContextReloadingEvent
***	CamelContextResumedEvent
***	CamelContextResumeFailureEvent
***	CamelContextResumingEvent
***	CamelContextRoutesStartedEvent
***	CamelContextRoutesStartingEvent
***	CamelContextRoutesStoppedEvent
***	CamelContextRoutesStoppingEvent
***	CamelContextStartedEvent
***	CamelContextStartingEvent
***	CamelContextStartupFailureEvent
***	CamelContextStopFailureEvent
***	CamelContextStoppedEvent
***	CamelContextStoppingEvent
***	CamelContextSuspendedEvent
***	CamelContextSuspendingEvent
** ExchangeEvent
***	ExchangeAsyncProcessingStartedEvent
***	ExchangeCompletedEvent
***	ExchangeCreatedEvent
***	ExchangeFailedEvent
***	ExchangeFailureEvent
***	ExchangeFailureHandledEvent
***	ExchangeFailureHandlingEvent
***	ExchangeRedeliveryEvent
***	ExchangeSendingEvent
***	ExchangeSentEvent
**	FailureEvent
**	RouteEvent
***	RouteAddedEvent
***	RouteReloadedEvent
***	RouteRemovedEvent
***	RouteStartedEvent
***	RouteStartingEvent
***	RouteStoppedEvent
***	RouteStoppingEvent
** ServiceEvent
***	ServiceStartupFailureEvent
***	ServiceStopFailureEvent
**	StepEvent
***	StepCompletedEvent
***	StepFailedEvent
***	StepStartedEvent

See the Javadoc of the `org.apache.camel.spi.CamelEvent` for more details.

== Collect Events

To collect events a class is needed that extends the EventNotifierSupport class.

[source,java]
----
public class MyCollector extends EventNotifierSupport {
    
    protected Logger log = LoggerFactory.getLogger(getClass());

    @Override
    public void notify(CamelEvent event) throws Exception {

        log.info("Event: " event.getType().name());

    }

}
----

Then you can enable the notifier:

[source,java]
----
context.getManagementStrategy().addEventNotifier(new MyCollector());
----


== Collect Specific Events

By default you get notified by all events. It's however possible to exclude certain groups of events to get
only the group of event you are interest in.

In the following example we collect only StepEvents:

[source,java]
----
public class StepCollector extends EventNotifierSupport {
    protected Logger log = LoggerFactory.getLogger(getClass());

    @Override
    public void notify(CamelEvent event) throws Exception {

        // Cast CamelEvent to StepEvent
        CamelEvent.StepEvent stepEvent = (CamelEvent.StepEvent) event;

        // Get detailed information from the StepEvent
        String eventType = stepEvent.getType().name();
        String stepId = stepEvent.getStepId();
        String body = stepEvent.getExchange().getMessage().getBody(String.class);

        log.info("Event Type:\t\t" + eventType);
        log.info("Step ID:\t\t\t" + stepId);
        log.info("Message Body:\t\t " + body);

    }

}
----

Then you can enable the notifier for steps by excluding other groups:

[source,java]
----
//Create eventNotifier that only collects stepEvents
StepCollector stepCollector = new StepCollector();
stepCollector.setIgnoreCamelContextEvents(true);
stepCollector.setIgnoreCamelContextInitEvents(true);
stepCollector.setIgnoreExchangeEvents(true);
stepCollector.setIgnoreRouteEvents(true);
stepCollector.setIgnoreServiceEvents(true);
stepCollector.setIgnoreStepEvents(false);

//Add the Event Notifier to the Camel Context
context.getManagementStrategy().addEventNotifier(stepCollector);
----

== Event Timestamps

By default, event timestamps are not included and the getTimestamp() method returns 0. 

Timestamps can be enabled from the CamelContext as follows:

[source,java]
----
context.getManagementStrategy().getEventFactory().setTimestampEnabled(true);
----
= Examples

Once you have read about xref:getting-started.adoc[Getting Started] and
looked at the xref:components:eips:enterprise-integration-patterns.adoc[Enterprise
Integration Patterns], you might want to try out some examples.

[NOTE]
====
The examples listed below are hosted at Apache. We also offer the
link:/community/articles/[Articles] page as a collection of 3rd-party Camel
material - such as tutorials, blog posts, published articles, videos,
podcasts, presentations, and so forth.

If you have written a Camel-related article, then we are happy to
provide a link to it. You can contact the Camel link:/community/team/[Team] via
our link:/community/mailing-list/[Mailing Lists], or simply post a tweet with
the words "Apache Camel".
====

== Examples

Browse the https://github.com/apache/camel-examples/tree/main#welcome-to-the-apache-camel-examples[camel-examples]
from github where each example is documented with instructions how to run, and are up-to-date.


= Exception Clause

You can use the _Exception Clause_ in the Java xref:dsl.adoc[DSL] to
specify the error handling you require on a per exception type basis
using the *`onException()`* method. To get started we give quick sample
before digging into how it works.

For example if you want to perform a specific piece of processing if a
certain exception is raised you can do this simply via:

[source,java]
----
onException(ValidationException.class)
    .to("activemq:validationFailed");

from("seda:inputA")
    .to("validation:foo/bar.xsd", "activemq:someQueue");

from("seda:inputB")
    .to("direct:foo")
    .to("rnc:mySchema.rnc", "activemq:anotherQueue");
----

Here if the processing of *`seda:inputA`* or *`seda:inputB`* cause
a *`ValidationException`* to be thrown (such as due to the XSD
validation of the xref:components::validator-component.adoc[Validation] component),
then the message will be sent to the
*`activemq:validationFailed`* queue.

You can define multiple *`onException`* clauses for different behavior:

[source,java]
----
onException(ValidationException.class)
    .to("activemq:validationFailed");

onException(ShipOrderException.class)
    .to("activemq:shipFailed");

from("seda:order")
    .to("bean:processOrder");
----

== Scopes

Exception clauses is scoped as either:

* global (for Java DSL that is per *`RouteBuilder`* instances, to reuse,
see note below)
* or route specific

Where the *global* are the simplest and most easy to understand. In the
advanced section we dig into the route specific and even combining them.
However

Global scope for Java DSL is per *`RouteBuilder`* instance, so if you
want to share among multiple *`RouteBuilder`* classes, then create a
base abstract *`RouteBuilder`* class and put the error handling logic in
its *`configure`* method. And then extend this class, and make sure to
class *`super.configure()`*. We are just using the Java inheritance
technique.

== How Does Camel Select Which Clause Should Handle a Given Thrown Exception?

Camel uses *`DefaultExceptionPolicyStrategy`* to determine a strategy
how an exception being thrown should be handled by which *`onException`*
clause. The strategy is:

* the order in which the *`onException`* is configured takes precedence.
Camel will test from first...last defined.
* Camel will start from the bottom (nested caused by) and recursive up
in the exception hierarchy to find the first matching *`onException`*
clause.
* *`instanceof`* test is used for testing the given exception with the
*`onException`* clause defined exception list. An exact *`instanceof`*
match will always be used, otherwise the *`onException`* clause that has
an exception that is the closets super of the thrown exception is
selected (recurring up the exception hierarchy).

This is best illustrated with an exception:

[source,java]
----
onException(IOException.class)
    .maximumRedeliveries(3);

onException(OrderFailedException.class)
    .maximumRedeliveries(2);
----

In the sample above we have defined two exceptions in
which *`IOException`* is first, so Camel will pickup this exception if
there is a match. *`IOException`* that is more general is selected then.

So if an exception is thrown with this hierarchy:

....
+ RuntimeCamelException (wrapper exception by Camel)
    + OrderFailedException
        + IOException
            + FileNotFoundException
....

Then Camel will try testing the exception in this order:
*`FileNotFoundException`*, *`IOException`*, *`OrderFailedException`* and
*`RuntimeCamelException`*.
As we have defined a *`onException(IOException.class)`* Camel will
select this as it's the *closest* match.

If we add a third *`onException`* clause with the
*`FileNotFoundException`*

[source,java]
----
onException(IOException.class)
    .maximumRedeliveries(3);

onException(OrderFailedException.class)
    .maximumRedeliveries(2);

onException(FileNotFoundException.class)
    .handled(true)
    .to("log:nofile");
----

Then with the previous example Camel will now use the last
*`onException(FileNotFoundException.class)`* as its an *exact* match.
Since this is an exact match it will override the
general *`IOException`* that was used before to handle the same
exception thrown.

Now a new situation if this exception was thrown instead:

....
+ RuntimeCamelException (wrapper exception by Camel)
    + OrderFailedException
        + OrderNotFoundException
....

Then the *`onException(OrderFailedException.class)`* will be selected -
no surprise here.

And this last sample demonstrates the *`instanceof`* test aspect in
which Camel will select an exception if it's an instance of the defined
exception in the *`onException`* clause. Illustrated as:

....
+ RuntimeCamelException (wrapper exception by Camel)
    + SocketException
....

Since *`SocketException`* is an *`instanceof IOException`*, Camel will
select the *`onException(IOException.class)`* clause.

== Configuring RedeliveryPolicy (redeliver options)

https://www.javadoc.io/doc/org.apache.camel/camel-base/current/org/apache/camel/processor/errorhandler/RedeliveryPolicy.html[RedeliveryPolicy]
requires to use the xref:components:eips:dead-letter-channel.adoc[Dead Letter Channel]
as the xref:error-handler.adoc[Error Handler]. Dead Letter Channel
supports attempting to redeliver the message exchange a number of times
before sending it to a dead letter endpoint. See
xref:components:eips:dead-letter-channel.adoc[Dead Letter Channel] for further
information about redeliver and which redeliver options exists.

=== No redelivery is default for onException

By default, any xref:exception-clause.adoc[Exception Clause] will *not*
redeliver! (as it sets the `maximumRedeliveries` option to 0).

Sometimes you want to configure the redelivery policy on a per exception
type basis. By default in the top examples, if an
*`org.apache.camel.ValidationException`* occurs then the message will
not be redelivered; however if some other exception occurs, e.g.,
*`IOException`* or whatever, the route will be retried according to the
settings from the xref:components:eips:dead-letter-channel.adoc[Dead Letter Channel].

However if you want to customize any methods on the
https://www.javadoc.io/doc/org.apache.camel/camel-base/current/org/apache/camel/processor/errorhandler/RedeliveryPolicy.html[RedeliveryPolicy]
object, you can do this via the fluent API. So lets retry in case
of *`org.apache.camel.ValidationException`* up till two times.

*Java DSL*:

[source,java]
----
onException(ValidationException.class)
    .maximumRedeliveries(2);
----

*XML DSL*:

[source,xml]
----
<onException>
    <exception>com.mycompany.ValidationException</exception>
    <redeliveryPolicy maximumRedeliveries="2"/>
</onException>
----

You can customize any of the
https://www.javadoc.io/doc/org.apache.camel/camel-base/current/org/apache/camel/processor/errorhandler/RedeliveryPolicy.html[RedeliveryPolicy]
so we can for instance set a different delay of *`5000`* millis:

[source,xml]
----
<onException>
    <exception>com.mycompany.ValidationException</exception>
    <redeliveryPolicy maximumRedeliveries="2" delay="5000"/>
</onException>
----

== Point of Entry for Redelivery Attempts

All redelivery attempts start at the point of the failure. So the route:

[source,java]
----
onException(ConnectException.class)
    .from("direct:start")
    .process("processor1")
    .process("processor2") // <--- throws a ConnectException
    .to("mock:theEnd")
----

Will retry from *`processor2`* - not the complete route.

== Reusing RedeliveryPolicy

You can reference a *`RedeliveryPolicy`* so you can reuse existing
configurations and use standard spring bean style configuration that
supports property placeholders.

[source,xml]
----
<bean id="myRedeliveryPolicy" class="org.apache.camel.processor.RedeliveryPolicy">
    <property name="maximumRedeliveries" value="${myprop.max}"/>
</bean>

<!-- here we reference our redelivery policy defined above -->
<onException redeliveryPolicyRef="myRedeliveryPolicy">
    <!-- you can define multiple exceptions just adding more exception elements as show below -->
    <exception>com.mycompany.MyFirstException</exception>
    <exception>com.mycompany.MySecondException</exception>
</onException>
----

== Asynchronous Delayed Redelivery

Camel has a feature to _not block_ while waiting for a
delayed redelivery to occur. However if you use transacted routes then
Camel will block as its mandated by the transaction manager to execute
all the work in the same thread context. You can enable the non blocking
asynchronous behavior by the *`asyncDelayedRedelivery`* option. This
option can be set on the *`errorHandler`*, *`onException`* or the
redelivery policies.

By default, the error handler will create and use a scheduled thread pool
to trigger redelivery in the future. You can also configure
the *`executorServiceRef`* on the xref:error-handler.adoc[Error Handler]
to indicate a reference to either a shared thread pool you can enlist in
the registry, or a thread pool profile in case you want to be able to
control pool settings.

== Catching Multiple Exceptions

Multiple exception can be caught as shown:

[source,java]
----
onException(MyBusinessException.class, MyOtherBusinessException.class)
    .maximumRedeliveries(2)
    .to("activemq:businessFailed");
----

And in XML DSL you just add another exception element:

[source,xml]
----
<onException>
    <exception>com.mycompany.MyBusinessException</exception>
    <exception>com.mycompany.MyOtherBusinessException</exception>
    <redeliveryPolicy maximumRedeliveries="2"/>
    <to uri="activemq:businessFailed"/>
</onException>
----

== Using a Processor as a Failure Handler

We want to handle certain exceptions in a specific way, so we add
a *`onException`* clause for the particular exception.

[source,java]
----
// here we register exception cause for MyFunctionException
// when this exception occurs we want it to be processed by our
// processor
onException(MyFunctionalException.class)
  .process(new MyFunctionFailureHandler())
  .stop();
----


So what happens is that whenever a *`MyFunctionalException`* is thrown it
is being routed to our processor *`MyFunctionFailureHandler`*. So you
can say that the exchange is diverted when a *`MyFunctionalException`*
is thrown during processing. It's important to distinct this as perfectly
valid. The default redelivery policy from the
xref:components:eips:dead-letter-channel.adoc[Dead Letter Channel] will not kick in, so
our processor receives the Exchange directly, without any redeliver
attempted. In our processor we need to determine what to do. Camel
regards the Exchange as *failure handled*. So our processor is the end
of the route. So lets look the code for our processor.

[source,java]
----
    public static class MyFunctionFailureHandler implements Processor {

        @Override
        public void process(Exchange exchange) throws Exception {
            // the caused by exception is stored in a property on the exchange
            Throwable caused = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Throwable.class);
            assertNotNull(caused);
            // here you can do what you want, but Camel regards this exception as
            // handled, and this processor as a failure handler, so it won't do redeliveries.
            // So this is the end of this route.
        }
    }
----

Notice how we get the *caused by* exception using a property on the Exchange.
This is where Camel stores any caught exception during processing. So
you can fetch this property and check what the exception message and do
what you want.

== Marking Exceptions as Handled

See also the section <<Handle and Continue Exceptions>> below.

Using *`onException`* to handle known exceptions is a very powerful
feature in Camel. You can mark the exception as being handled with the *handle* DSL,
so the caller will not receive the caused exception as a response. The handle is a
xref:predicate.adoc[Predicate] that is overloaded to accept three types
of parameters:

* Boolean
* xref:predicate.adoc[Predicate]
* xref:expression.adoc[Expression] that will be evaluated as a
xref:predicate.adoc[Predicate] using this rule set: If the expression
returns a Boolean, it is used directly. For any other response, it is regarded
as `true` if the response is `not null`.

For instance to mark all *`ValidationException`* as being handled we can
do this:

[source,java]
----
onException(ValidationException)
    .handled(true);
----

== Example Using Handled

In this route below we want to do special handling of
all *`OrderFailedException`* as we want to return a customized response
to the caller. First we setup our routing as:

[source,java]
----
    // we do special error handling for when OrderFailedException is
    // thrown
    onException(OrderFailedException.class)
        // we mark the exchange as handled so the caller doesn't
        // receive the
        // OrderFailedException but whatever we want to return
        // instead
        .handled(true)
        // this bean handles the error handling where we can
        // customize the error
        // response using java code
        .bean(OrderService.class, "orderFailed")
        // and since this is an unit test we use mocks for testing
        .to("mock:error");

    // this is just the generic error handler where we set the
    // destination
    // and the number of redeliveries we want to try
    errorHandler(deadLetterChannel("mock:error").maximumRedeliveries(1));

    // this is our route where we handle orders
    from("direct:start")
        // this bean is our order service
        .bean(OrderService.class, "handleOrder")
        // this is the destination if the order is OK
        .to("mock:result");
----

Then we have our service bean that is just a plain POJO demonstrating how you
can use xref:bean-integration.adoc[Bean Integration] in Camel to avoid
being tied to the Camel API:

[source,java]
----
    /**
     * Order service as a plain POJO class
     */
    public static class OrderService {

        /**
         * This method handle our order input and return the order
         */
        public Object handleOrder(@Headers Map headers, @Body String payload) throws OrderFailedException {
            headers.put("customerid", headers.get("customerid"));
            if ("Order: kaboom".equals(payload)) {
                throw new OrderFailedException("Cannot order: kaboom");
            } else {
                headers.put("orderid", "123");
                return "Order OK";
            }
        }

        /**
         * This method creates the response to the caller if the order could not
         * be processed
         */
        public Object orderFailed(@Headers Map headers, @Body String payload) {
            headers.put("customerid", headers.get("customerid"));
            headers.put("orderid", "failed");
            return "Order ERROR";
        }
    }
----

And finally the exception that is being thrown is just a regular exception:

[source,java]
----
    public static class OrderFailedException extends Exception {

        private static final long serialVersionUID = 1L;

        public OrderFailedException(String message) {
            super(message);
        }

    }
----

So what happens?

If we sent an order that is being processed OK then the caller will
receive an Exchange as reply containing *`Order OK`* as the payload and
*`orderid=123`* in a header.

If the order could *not* be processed and thus
an *`OrderFailedException`* was thrown the caller will *not* receive
this exception but our customized response that we have
fabricated in the *`orderFailed`* method in our *`OrderService`*. So the
caller receives an Exchange with the payload *`Order ERROR`* and a
*`orderid=failed`* in a header.

== Using Handled with Spring XML DSL

The same route as above in Spring XML DSL:

[source,xml]
----
 <!-- setup our error handler as the deal letter channel -->
<bean id="errorHandler" class="org.apache.camel.builder.DeadLetterChannelBuilder">
    <property name="deadLetterUri" value="mock:error"/>
</bean>

<!-- this is our POJO bean with our business logic defined as a plain spring bean -->
<bean id="orderService" class="org.apache.camel.spring.processor.onexception.OrderService" />

<!-- this is the camel context where we define the routes -->
<!-- define our error handler as a global error handler -->
<camelContext errorHandlerRef="errorHandler" xmlns="http://camel.apache.org/schema/spring">

  <onException>
    <!-- the exception is full qualified names as plain strings -->
    <!-- there can be more just add a 2nd, 3rd exception element (unbounded) -->
    <exception>org.apache.camel.spring.processor.onexception.OrderFailedException</exception>
    <!-- we can set the redelivery policy here as well -->
    <redeliveryPolicy maximumRedeliveries="1" />
    <!-- mark this as handled -->
    <handled>
      <constant>true</constant>
    </handled>
    <!-- let our order service handle this exception, call the orderFailed method -->
    <bean ref="orderService" method="orderFailed" />
    <!-- and since this is a unit test we use mock for assertions -->
    <to uri="mock:error" />
  </onException>

  <route>
    <!-- the route -->
    <from uri="direct:start" />
    <!-- in the normal route then route to our order service and call handleOrder method -->
    <bean ref="orderService" method="handleOrder" />
    <!-- and since this is a unit test we use mock for assertions -->
    <to uri="mock:result" />
  </route>

</camelContext>
----

== Handling and Sending a Fixed Response Back to the Client

In the route above we handled the exception but routed it to a different
endpoint. What if you need to alter the response and send a fixed
response back to the original caller (the client). No secret here just
do as you do in normal Camel routing, use
xref:components:eips:message-translator.adoc[transform] to set the response, as shown in
the sample below:

[source,java]
----
// we catch MyFunctionalException and want to mark it as handled
// (= no failure returned to client)
// but we want to return a fixed text response, so we transform
// OUT body as Sorry.
onException(MyFunctionalException.class)
  .handled(true)
  .transform().constant("Sorry");
----

We modify the sample slightly to return the original caused exception
message instead of the fixed text `Sorry`:

[source,java]
----
// we catch MyFunctionalException and want to mark it as handled
// (= no failure returned to client)
// but we want to return a fixed text response, so we transform
// OUT body and return the exception message
onException(MyFunctionalException.class)
  .handled(true)
  .transform(exceptionMessage());
----

And we can use the xref:components:languages:simple-language.adoc[Simple] language to set a readable error
message with the caused exception message:

[source,java]
----
// we catch MyFunctionalException and want to mark it as handled
// (= no failure returned to client)
// but we want to return a fixed text response, so we transform
// OUT body and return a nice message
// using the simple language where we want insert the exception
// message
onException(MyFunctionalException.class)
  .handled(true)
  .transform().simple("Error reported: ${exception.message} - cannot process this message.");
----

== Handle and Continue Exceptions

The option `continued` allows you to
both *`handle`* and *`continue`* routing in the original route as if the
exception did not occur.

For example: to ignore and continue when the *`IDontCareException`* was
thrown we can do this:

[source,java]
----
onException(IDontCareException.class)
    .continued(true);
----

You can maybe compare continued with a having a *`try ... catch`* block
around each step and then just ignore the exception. Using continued
makes it easier in Camel as you otherwise had to use
xref:try-catch-finally.adoc[Try Catch Finally] style for this kind of
use case.

=== Example Using continued

In this route below we want to do special handling of
all *`IllegalArgumentException`* as we just want to continue routing.

[source,java]
----
onException(IllegalArgumentException.class).continued(true);

from("direct:start")
  .to("mock:start")
  .throwException(new IllegalArgumentException("Forced"))
  .to("mock:result");
----

And the same example in Spring XML DSL:

[source,xml]
----
 <camelContext xmlns="http://camel.apache.org/schema/spring">

        <onException>
            <exception>java.lang.IllegalArgumentException</exception>
            <!-- tell Camel to handle and continue when this exception was thrown -->
            <continued><constant>true</constant></continued>
        </onException>

        <route>
            <from uri="direct:start"/>
            <to uri="mock:start"/>
            <throwException message="Forced" exceptionType="java.lang.IllegalArgumentException"/>
            <to uri="mock:result"/>
        </route>

    </camelContext>
----

== What is the Difference Between Handled and Continued?

If handled is true, then the thrown exception will be _handled_ and
Camel will *not* continue routing in the original route, but break out.
However you can configure a route in the *`onException`* which will be
used instead. You use this route if you need to create some custom
response message back to the caller, or do any other processing because
that exception was thrown.

If continued is true, then Camel will catch the exception and in fact
just ignore it and continue routing in the original route. However if
you have a route configured in the *`onException`* it will route that
route first, before it will continue routing in the original route.


== Using `useOriginalMessage`

The option *`useOriginalMessage`* is used for routing the original input
message instead of the current message that potential is modified during routing.

For example: if you have this route:

[source,java]
----
from("jms:queue:order:input")
    .to("bean:validateOrder");
    .to("bean:transformOrder")
    .to("bean:handleOrder");
----

The route listen for JMS messages and validates, transforms and handle
it. During this the xref:exchange.adoc[Exchange] payload is
transformed/modified. So in case something goes wrong and we want to
move the message to another JMS destination, then we can add an
*`onException`*. But when we move the xref:exchange.adoc[Exchange] to
this destination we do not know in which state the message is in. Did
the error happen in before the *`transformOrder`* or after? So to be
sure we want to move the original input message we received from
`jms:queue:order:input`. So we can do this by enabling the
*`useOriginalMessage`* option as shown below:

[source,java]
----
// will use original input message (body and headers)
onException(MyOrderException.class)
    .useOriginalMessage()
    .handled(true)
    .to("jms:queue:order:failed");
----

Then the messages routed to the *`jms:queue:order:failed`* is the
original input. If we want to manually retry we can move the JMS message
from the failed to the input queue, with no problem as the message is
the same as the original we received.

== `useOriginalMessage` with Spring DSL

The *`useOriginalMessage`* option is defined as a boolean attribute on
the *`<onException>`* XML tag in Spring DSL. So the definition above
would be:

[source,xml]
----
<onException useOriginalMessage="true">
    <exception>com.mycompany.MyOrderException</exception>
    <handled><constant>true</constant></handled>
    <to uri="jms:queue:order:failed"/>
</onException>
----

== Boundary of original message

The original input means the input message that are bounded by the current unit of work. An unit of work typically spans one route, or multiple routes if they are connected 
using internal endpoints such as direct or seda. When messages are passed via external
endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the
message it received as input as the original input. Also, some EIP patterns such as splitter,
multicast, will create a new unit of work boundary for the messages in their sub-route
(i.e. the split message); however these EIPs have an option named shareUnitOfWork which
allows combining with the parent unit of work in regard to error handling and therefore use
the parent original message.

== Using `useOriginalBody`

The useOriginalBody is similar to useOriginalMessage as documented above. You may want to use useOriginalBody when you want to be able to enrich the message with custom headers and preserve the original message body before sending to an error handler or dead letter channel.

For example: if you have this route:

[source,java]
----
// will use original input body
onException(MyOrderException.class)
    .useOriginalBody()
    .handled(true)
    .to("jms:queue:order:failed");

from("jms:queue:order:input")
    .setHeader("application", constant("OrderApp"))
    .to("bean:validateOrder");
    .to("bean:transformOrder")
    .to("bean:handleOrder");
----

Then the message has been enriched with a header named application after the original message was received by the JMS endpoint. And in case of an error `onException`
will handle the exception and use the original message body and the headers from the current message as-is, which means the headers will include the application header.

== Advanced Usage of Exception Clause

Camel supports advanced configuration of exception clauses.

=== Using Global and Per Route Exception Clauses

You can define exception clauses either as:

* global
* or route specific

We start off with the sample that we change over time. First off
we use only global exception clauses:

[source,java]
----
// default should errors go to mock:error
errorHandler(deadLetterChannel("mock:error").redeliveryDelay(0));

// if a MyTechnicalException is thrown we will not try to
// redeliver and we mark it as handled
// so the caller does not get a failure
// since we have no to then the exchange will continue to be
// routed to the normal error handler
// destination that is mock:error as defined above
onException(MyTechnicalException.class).maximumRedeliveries(0).handled(true);

// if a MyFunctionalException is thrown we do not want Camel to
// redelivery but handle it our self using
// our bean myOwnHandler, then the exchange is not routed to the
// default error (mock:error)
onException(MyFunctionalException.class).maximumRedeliveries(0).handled(true).to("bean:myOwnHandler");

// here we route message to our service bean
from("direct:start").choice().when().xpath("//type = 'myType'").to("bean:myServiceBean").end().to("mock:result");
----

In the next sample we change the global exception policies to be pure route
specific.

=== Must use `.end()` for route specific exception policies

[IMPORTANT] This requires to end the *`onException`* route with
*`.end()`* to indicate where it stops and when the regular route
continues.

[source,java]
----
// default should errors go to mock:error
errorHandler(deadLetterChannel("mock:error"));

// here we start the routing with the consumer
from("direct:start")

    // if a MyTechnicalException is thrown we will not try to
    // redeliver and we mark it as handled
    // so the caller does not get a failure
    // since we have no to then the exchange will continue to be
    // routed to the normal error handler
    // destination that is mock:error as defined above
    // we MUST use .end() to indicate that this sub block is
    // ended
    .onException(MyTechnicalException.class).maximumRedeliveries(0).handled(true).end()

    // if a MyFunctionalException is thrown we do not want Camel
    // to redelivery but handle it our self using
    // our bean myOwnHandler, then the exchange is not routed to
    // the default error (mock:error)
    // we MUST use .end() to indicate that this sub block is
    // ended
    .onException(MyFunctionalException.class).maximumRedeliveries(0).handled(true).to("bean:myOwnHandler").end()

    // here we have the regular routing
    .choice().when().xpath("//type = 'myType'").to("bean:myServiceBean").end().to("mock:result");
----

And now it gets complex as we combine global and route specific exception
policies as we introduce a second route in the sample:

[source,java]
----
// global error handler
// as its based on a unit test we do not have any delays between
// and do not log the stack trace
errorHandler(deadLetterChannel("mock:error").redeliveryDelay(0).logStackTrace(false));

// shared for both routes
onException(MyTechnicalException.class).handled(true).maximumRedeliveries(2).to("mock:tech.error");

from("direct:start")
    // route specific on exception for MyFunctionalException
    // we MUST use .end() to indicate that this sub block is
    // ended
    .onException(MyFunctionalException.class).maximumRedeliveries(0).end().to("bean:myServiceBean").to("mock:result");

from("direct:start2")
    // route specific on exception for MyFunctionalException
    // that is different than the previous route
    // here we marked it as handled and send it to a different
    // destination mock:handled
    // we MUST use .end() to indicate that this sub block is
    // ended
    .onException(MyFunctionalException.class).handled(true).maximumRedeliveries(0).to("mock:handled").end().to("bean:myServiceBean").to("mock:result");
----

Notice that we can define the same exception *`MyFunctionalException`* in both
routes, but they are configured differently and thus is handled
different depending on the route. You can of course also add a
new *`onException`* to one of the routes so it has an additional
exception policy.

And finally we top this by throwing in a nested error handler as well,
as we add the 3rd route shown below:

[source,java]
----
from("direct:start3")
    // route specific error handler that is different than the
    // global error handler
    // here we do not redeliver and send errors to mock:error3
    // instead of the global endpoint
    .errorHandler(deadLetterChannel("mock:error3").maximumRedeliveries(0))

    // route specific on exception to mark MyFunctionalException
    // as being handled
    .onException(MyFunctionalException.class).handled(true).end()
    // however we want the IO exceptions to redeliver at most 3
    // times
    .onException(IOException.class).maximumRedeliveries(3).end().to("bean:myServiceBean").to("mock:result");
----

=== Global exception policies and nested error handlers

The sample above with both nested error handlers and both global and per
route exception clauses is a bit advanced. It's important to get the
fact straight that the *global* exception clauses is really global so
they also applies for nested error handlers. So if a
*`MyTechnicalException`* is thrown then it's the global exception policy
that is selected.

== Using Fine Grained Selection Using `onWhen` Predicate

You can attach an xref:expression.adoc[Expression] to the exception
clause to have fine grained control when a clause should be selected or
not. As it's an xref:expression.adoc[Expression] you can use any kind of
code to perform the test. Here is a sample:

[source,java]
----
errorHandler(deadLetterChannel("mock:error").redeliveryDelay(0).maximumRedeliveries(3));

// here we define our onException to catch MyUserException when
// there is a header[user] on the exchange that is not null
onException(MyUserException.class).onWhen(header("user").isNotNull()).maximumRedeliveries(1)
    // setting delay to zero is just to make unit testing faster
    .redeliveryDelay(0).to(ERROR_USER_QUEUE);

// here we define onException to catch MyUserException as a kind
// of fallback when the above did not match.
// Notice: The order how we have defined these onException is
// important as Camel will resolve in the same order as they
// have been defined
onException(MyUserException.class).maximumRedeliveries(2)
    // setting delay to zero is just to make unit testing faster
    .redeliveryDelay(0).to(ERROR_QUEUE);
----

In the sample above we have two *`onException`*'s defined. The first has
an *`onWhen`* expression attached to only trigger if the message has a
header with the key user that is not null. If so this clause is selected
and is handling the thrown exception. The second clause is a for coarse
gained selection to select the same exception being thrown but when the
expression is evaluated to false.

[NOTE]
====
This is not required, if the second clause is omitted, then the
default error handler will kick in.
====

== Using onRedelivery Processor

xref:components:eips:dead-letter-channel.adoc[Dead Letter Channel] has support
for *`onRedelivery`* to allow custom processing of a Message before its
being redelivered. It can be used to add some customer header or
whatnot. In Camel 2.0 we have added this feature to
xref:exception-clause.adoc[Exception Clause] as well, so you can use per
exception scoped on redelivery. Camel will fallback to use the one
defined on xref:components:eips:dead-letter-channel.adoc[Dead Letter Channel] if any, if
none exists on the xref:exception-clause.adoc[Exception Clause]. See
xref:components:eips:dead-letter-channel.adoc[Dead Letter Channel] for more details on
*`onRedelivery`*.

In the code below we want to do some custom code before redelivering any
*`IOException`*. So we configure an *`onException`* for
the *`IOException`* and set the *`onRedelivery`* to use our custom
processor:

[source,java]
----
// when we redeliver caused by an IOException we want to do some
// special code before the redeliver attempt
onException(IOException.class)
    // try to redeliver at most 3 times
    .maximumRedeliveries(3)
    // setting delay to zero is just to make unit testing faster
    .redeliveryDelay(0).onRedelivery(new MyIORedeliverProcessor());
----

And in our custom processor we set a special timeout header to the message.
You can of course do anything what you like in your code.

[source,java]
----
// This is our processor that is executed before every redelivery attempt
// here we can do what we want in the java code, such as altering the
// message
public static class MyRedeliverProcessor implements Processor {

    @Override
    public void process(Exchange exchange) throws Exception {
        // the message is being redelivered so we can alter it

        // we just append the redelivery counter to the body
        // you can of course do all kind of stuff instead
        String body = exchange.getIn().getBody(String.class);
        int count = exchange.getIn().getHeader("CamelRedeliveryCounter", Integer.class);

        exchange.getIn().setBody(body + count);
    }
}
----

== Using onRedelivery in Spring XML DSL

In Spring DSL you need to use the *`onRedeliveryRef`* attribute to refer
to a spring bean id that is your custom processor:

[source,xml]
----
<onException onRedeliveryRef="myIORedeliverProcessor">
    <exception>java.io.IOException</exception>
</onException>
----

And our processor is just a regular spring bean (we use *`$`* for the inner
class as this code is based on unit testing):

[source,xml]
----
 <bean id="myRedeliveryProcessor"
          class="org.apache.camel.processor.DeadLetterChannelOnExceptionOnRedeliveryTest$MyRedeliverProcessor"/>
----

== Using onExceptionOccurred Processor

xref:components:eips:dead-letter-channel.adoc[Dead Letter Channel] has support
for *`onExceptionOccurred`* to allow custom processing of a Message just
after the exception was thrown. It can be used to do some custom logging
or whatnot. The difference between *`onRedelivery`* processor
and *`onExceptionOccurred`* processor, is that the former is processed
just before a redelivery attempt is being performed, that means it will
not happen right after an exception was thrown. For example if the error
handler has been configured to perform 5 seconds delay between
redelivery attempts, then the redelivery processor is invoked 5 seconds
after the exception was thrown. On the other hand
the *`onExceptionOccurred`* processor is always invoked right after the
exception was thrown, and also if redelivery has been disabled.

[NOTE]
====
Any new exceptions thrown from the *`onExceptionOccurred`*
processor is logged as *`WARN`* and ignored, to not override the
existing exception. 
====

In the code below we want to do some custom logging when an exception
happened. Therefore we configure an *`onExceptionOccurred`* to use our
custom processor:

[source.java]
----
errorHandler(defaultErrorHandler()
    .maximumRedeliveries(3)
    .redeliveryDelay(5000)
    .onExceptionOccurred(myProcessor));
----

=== Using onRedelivery in Spring XML DSL

In Spring DSL you need to use the *`onExceptionOccurredRef`* attribute
to refer to a spring bean id that is your custom processor:

[source,xml]
----
<bean id="myProcessor" class="com.foo.MyExceptionLoggingProcessor"/>

<camelContext errorHandlerRef="eh" xmlns="http://camel.apache.org/schema/spring">
    <errorHandler id="eh" type="DefaultErrorHandler" onExceptionOccurredRef="myProcessor">
        <redeliveryPolicy maximumRedeliveries="3" redeliveryDelay="5000"/>
    </errorHandler>
    ...
</camelContext>
----

== Using Fine Grained Retry Using retryWhile Predicate

When you need fine grained control for determining if an exchange should
be retried or not you can use the *`retryWhile`* predicate. Camel will
redeliver until the predicate returns false.

Example:

[source,java]
----
// we want to use a predicate for retries so we can determine in
// our bean when retry should stop, notice it will overrule the global
// error handler where we defined at most 1 redelivery attempt. Here we will
// continue until the predicate returns false
onException(MyFunctionalException.class).retryWhile(method("myRetryHandler")).handled(true).transform().constant("Sorry");
----

Where the bean *`myRetryHandler`* is computing if we should retry or not:

[source,java]
----
public class MyRetryBean {

    // using bean binding we can bind the information from the exchange to
    // the types we have in our method signature
    public boolean retry(@Header(Exchange.REDELIVERY_COUNTER) Integer counter) {
        // NOTE: counter is the redelivery attempt, will start from 1
        // we can of course do what ever we want to determine the result but
        // this is a unit test so we end after 3 attempts
        return counter < 3;
    }
}
----

== Using Custom ExceptionPolicyStrategy

The default
https://www.javadoc.io/doc/org.apache.camel/camel-core-processor/current/org/apache/camel/processor/errorhandler/ExceptionPolicyStrategy.html[ExceptionPolicyStrategy]
in Camel should be sufficient in nearly all use-cases.
However, if you need to use your own (use only for rare and advanced use-cases) this can be configured as the
sample below illustrates:

[source,java]
----
// configure the error handler to use my policy instead of the default from Camel
errorHandler(deadLetterChannel("mock:error").exceptionPolicyStrategy(new MyPolicy()));
----

Using our own strategy *`MyPolicy`* we can change the default behavior of
Camel with our own code to resolve which exception type
from above should be handling the given thrown exception.

[source,java]
----
public static class MyPolicy implements ExceptionPolicyStrategy {

    @Override
    public ExceptionPolicyKey getExceptionPolicy(Set<ExceptionPolicyKey> exceptionPolicies, Exchange exchange, Throwable exception) {
        // This is just an example that always forces the exception type configured
        // with MyPolicyException to win.
        return new ExceptionPolicyKey(null, MyPolicyException.class, null);
    }
}
----

== Using the Exception Clause in Spring XML DSL

You can use all of the above mentioned exception clause features in the
Spring XML DSL as well. Here are a few examples:

* Global scoped

[source,xml]
----
<!-- setup our error handler as the deal letter channel -->
<bean id="errorHandler" class="org.apache.camel.builder.DeadLetterChannelBuilder">
    <property name="deadLetterUri" value="mock:error"/>
</bean>

<!-- this is our POJO bean with our business logic defined as a plain spring bean -->
<bean id="orderService" class="org.apache.camel.spring.processor.onexception.OrderService" />

<!-- this is the camel context where we define the routes -->
<!-- define our error handler as a global error handler -->
<camelContext errorHandlerRef="errorHandler" xmlns="http://camel.apache.org/schema/spring">

  <onException>
    <!-- the exception is full qualified names as plain strings -->
    <!-- there can be more just add a 2nd, 3rd exception element (unbounded) -->
    <exception>org.apache.camel.spring.processor.onexception.OrderFailedException</exception>
    <!-- we can set the redelivery policy here as well -->
    <redeliveryPolicy maximumRedeliveries="1" />
    <!-- mark this as handled -->
    <handled>
      <constant>true</constant>
    </handled>
    <!-- let our order service handle this exception, call the orderFailed method -->
    <bean ref="orderService" method="orderFailed" />
    <!-- and since this is a unit test we use mock for assertions -->
    <to uri="mock:error" />
  </onException>

  <route>
    <!-- the route -->
    <from uri="direct:start" />
    <!-- in the normal route then route to our order service and call handleOrder method -->
    <bean ref="orderService" method="handleOrder" />
    <!-- and since this is a unit test we use mock for assertions -->
    <to uri="mock:result" />
  </route>

</camelContext>
----

* Route specific scoped

[source,xml]
----
<!-- setup our error handler as the deal letter channel -->
<bean id="deadLetter" class="org.apache.camel.builder.DeadLetterChannelBuilder">
    <property name="deadLetterUri" value="mock:dead"/>
</bean>

<!-- the default error handler used in the 2nd route -->
<bean id="defaultErrorHandler" class="org.apache.camel.builder.DefaultErrorHandlerBuilder"/>

<!-- this is our POJO bean with our business logic defined as a plain spring bean -->
<bean id="orderService" class="org.apache.camel.spring.processor.onexception.OrderService"/>

<!-- this is the camel context where we define the routes -->
<camelContext xmlns="http://camel.apache.org/schema/spring">

    <route errorHandlerRef="deadLetter">
        <from uri="direct:start"/>
        <onException>
            <exception>org.apache.camel.spring.processor.onexception.OrderFailedException</exception>
            <redeliveryPolicy maximumRedeliveries="1"/>
            <handled>
                <constant>true</constant>
            </handled>
            <bean ref="orderService" method="orderFailed"/>
            <to uri="mock:error"/>
        </onException>
        <bean ref="orderService" method="handleOrder"/>
        <to uri="mock:result"/>
    </route>

    <!-- The exception clause specified in the first route will not be used in this route -->
    <route errorHandlerRef="defaultErrorHandler">
        <from uri="direct:start_with_no_handler"/>
        <bean ref="orderService" method="handleOrder"/>
        <to uri="mock:result"/>
    </route>

</camelContext>
----

= Exchange Pattern

There are two _Message Exchange Patterns_ you can use in
messaging.

From there xref:components:eips:enterprise-integration-patterns.adoc[Enterprise
Integration Patterns] they are:

* xref:components:eips:event-message.adoc[Event Message] (or one-way)
* xref:components:eips:requestReply-eip.adoc[Request Reply]

In Camel we have an
`org.apache.camel.ExchangePattern`
enumeration which can be configured on the *exchangePattern* property on
the Message Exchange indicating if a message
exchange is a one way xref:components:eips:event-message.adoc[Event Message] (*InOnly*) or
a xref:components:eips:requestReply-eip.adoc[Request Reply] message exchange (*InOut*).

For example to override the default pattern on a xref:components::jms-component.adoc[JMS]
endpoint you could use the `exchangePattern` parameter in the Endpoint xref:uris.adoc[URI]
as shown:

[source,text]
----
jms:myQueue?exchangePattern=InOut
----
= Exchange Pooling

The routing engine keeps the state of each message, tracking the message flow, and where the messages are going next. The routing engine also handles complex tasks such as error handling, capturing metrics, and many other things. A small number of Java objects are allocated on the heap for each processing step during routing.

Because of this routing bookkeeping and processing, Apache Camel requires a tiny resource overhead when routing messages.

With the advance of cloud computing, where workloads are precisely measured, then Camel has undergone a series of core optimizations to reduce its overhead.

== Pooling objects to reduce object allocations

The most significant object being reused is the `org.apache.camel.Exchange` object. This object is the root object
that holds the message with its payload, headers, metadata, and other content.

Besides pooling exchanges, the internal objects used by the routing engine are also pooled and recycled. This can dramatically reduce the object allocations from Camel core itself.

There will always be object allocations from the actual message content (payload and headers), and also from the Camel components in use and its 3rd party libraries. The footprint of Camel core and its routing engine is close to zero when pooling is enabled.

This all sounds marvelous so what are the negative aspects? The price to pay for object pooling is the complexity of managing the pool (acquiring and returning objects to the pool). However, all of this is taken care of by Camel itself. The object pools are using JDK `ConcurrentMap` instances and take up very little memory. Managing the pool causes a small CPU overhead associated with adding and removing objects from the pools, and resetting the objects before reuse.

In most cases, it may be possible to sacrifice the very tiny CPU cost in exchange for reduced object allocations. This can improve responsiveness and reduce latency by preventing the JVM garbage collection from running more frequently (under some circumstances, the garbage collection overhead can cause your application to halt or delay processing messages due to stop-the-world pauses and other processing overhead associated with it).

== Enabling Exchange Pooling

The _object pooling_ is currently disabled by default. If you are using Camel Main (from Camel Core), Camel Spring Boot, or Camel Quarkus, then you can enable this in the `application.properties`:

[source,properties]
----
camel.main.exchange-factory = pooled
----

=== Enabling Exchange Pooling on Camel 3.x

If you are using a different runtime or want to do that programmatically, you can do so in Camel version 3 (Camel 3.x) using the `setExchangeFactory` method from the `ExtendedCamelContext`. Here's an example of how to do that using Java:

[source,java]
----
// suppose a Camel context object declared in the scope
CamelContext context = ...

context.adapt(ExtendedCamelContext.class).setExchangeFactory(new PooledExchangeFactory());
----

[NOTE]
====
The `ExtendedCamelContext` is an internal API of Camel and, as such, may not offer the same level of backward compatibility as the public APIs. Whenever possible, configure the exchange pooling via application properties.
====

=== Enabling Exchange Pooling on Camel 4.x

If you are using a different runtime or if you want to do that programmatically, you can do so in Camel 4 and newer versions using the `setExchangeFactory` method from the `ExtendedCamelContext`. Here's an example of how to do that using Java:

[source,java]
----
CamelContext context = ...
context.getExchangeExtension().setExchangeFactory(new PooledExchangeFactory());
----

[NOTE]
====
The `ExtendedCamelContext` is an internal API of Camel and, as such, may not offer the same level of backward compatibility as the public APIs. Whenever possible, configure the exchange pooling via application properties.
====

== Configuration Options

You can configure exchange pooling with the following options:

[width="100%",cols="25%,50%,25%",options="header"]
|===
|Option |Description | Default
| exchange-factory | Whether to use pooling or not. Possible values are prototype or pooled | prototype
| exchange-factory-capacity | Maximum number of elements in the pool | 100
| exchange-factory-statistics-enabled | Whether to capture usage statistics | false
|===

== Management

If object pooling is enabled, then Camel provides a JMX MBean which allows us to introspect the pools and their usage via JMX. This requires adding `camel-management` JAR to the classpath.

== Examples

We have provided a few examples which we are using for performance profiling.
You can check the basic https://github.com/apache/camel-performance-tests/tree/main/profiling/timer-log[timer-log] if you need an example.


= Message Exchange

A request message and its corresponding reply or exception message is represented in Camel using the `Exchange` interface.
This interface provides an abstraction for this pattern of communication between systems.
The presence of a reply message is optional and depends on the xref:exchange-pattern.adoc[exchange pattern] used in the integration.
Thanks to this, Apache Camel can support different integration patterns such as:

* xref:components:eips:event-message.adoc[Event Messages]: messages that have only an inbound message
* xref:components:eips:requestReply-eip.adoc[Request and Reply]: messages that have an inbound and an outbound message.

== Learn More About Exchanges

* xref:manual::exchange-pooling.adoc[Exchange Pooling]
* xref:manual::using-exchange-pattern-annotations.adoc[Using Exchange Pattern Annotations]

== Implementation Details

There are concrete classes that implement the `Exchange` interface for each Camel-supported communications technology. For example, the `JmsExchange` class provides a JMS-specific implementation of the `Exchange` interface. The public API of the `Exchange` interface is limited intentionally: we expect that each class that implements this interface will provide its own technology-specific operations.

Application-level programmers rarely access the `Exchange` interface (or classes that implement it) directly. However, many classes in Camel are generic types that are instantiated on (a class that implements) `Exchange`. Because of this, the `Exchange` interface appears a lot in the generic signatures of classes and methods.
= Expressions

Expressions and xref:predicate.adoc[Predicates] can then be used to
create the various xref:components:eips:enterprise-integration-patterns.adoc[Enterprise
Integration Patterns] in the xref:dsl.adoc[DSL] like with the xref:components:eips:recipientList-eip.adoc[Recipient List] EIP.

To support dynamic rules Camel supports pluggable
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Expression.html[Expression]
strategies using a variety of different xref:components:languages:index.adoc[Languages].

== Expression API

If you are outside the DSL and want to create your own
expressions you can either implement the
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Expression.html[Expression
interface], reuse one of the other builders or try the
https://www.javadoc.io/doc/org.apache.camel/camel-support/current/org/apache/camel/support/builder/ExpressionBuilder.html[ExpressionBuilder
class].

=== Expression

The API for a Camel Expression is defined in the
`org.apache.camel.Expression` interface as shown:

[source,java]
-------------------------------------------------------------------------------
public interface Expression {

    /**
     * Returns the value of the expression on the given exchange
     *
     * @param exchange the message exchange on which to evaluate the expression
     * @param type the expected type of the evaluation result
     * @return the value of the expression
     */
    <T> T evaluate(Exchange exchange, Class<T> type);
}
-------------------------------------------------------------------------------

= Getting Started

You can get started with Apache Camel in a variety of ways, such as:

- Using online Project generators
- Using the Camel CLI (command line)
- Using Camel Karavan (visual UI Camel designer)

And some more alternative methods:

- Adding Camel to an existing project
- Using IDE tooling wizards
- Using Maven Archetypes
- Cloning an existing example to modify


== Using online Project generators

You can use https://kameleon.dev/#/standalone[Camel Kameleon] which is Camel's own
online project generator. This generator is Camel focused only, which is recommended
for most Camel users.

You can also use https://start.spring.io/[Spring Boot Initializer] which is the Spring Boot
generator that also has Camel support. However, this generator does not allow users to have fine-grained control over which components, data formats, kamelets etc. they can use.

And there is https://code.quarkus.io/[Code with Quarkus], the Quarkus
generator, which has great support with Camel.


== Getting Started from command line (CLI)

Camel uses https://www.jbang.dev/[JBang] for the Camel CLI.
You can easily get up and running in a few steps.

*Step 1*

Open your favorite terminal and use JBang to install the Camel CLI.
You do not need to have Java installed first.

For Linux, macOS, and Windows (using WSL or bash compatible shell like Cygwin or MinGW)

[source,bash]
----
curl -Ls https://sh.jbang.dev | bash -s - trust add https://github.com/apache/
curl -Ls https://sh.jbang.dev | bash -s - app install --fresh --force camel@apache/camel
----

For Windows using Powershell

[source,shell script]
----
iex "& { $(iwr https://ps.jbang.dev) } trust add https://github.com/apache/"
iex "& { $(iwr https://ps.jbang.dev) } app install --fresh --force camel@apache/camel"
----

If it's your first time to install, you'll need to restart your shell.

*Step 2*

Create your first Camel integration

[source,bash]
----
camel init hello.java
----

*Step 3*

Run the Camel integration

[source,bash]
----
camel run hello.java
----

Bang the Camel integration is now running.
You can use `ctrl` + `c` to stop the integration.

*Step 4*

Camel makes it easy to change your code on the fly.
You can run in live coding mode, as shown:

[source,bash]
----
camel run hello.java --dev
----

While in live coding mode, whenever you save changes to `hello.java`, Camel will automatically load the updated version.

*Step 5*

Make sure to check out the xref:camel-jbang.adoc[Camel JBang] documentation, for more details on the powers
of the Camel CLI. You will also find information how you can _export_ what you have built
with the Camel CLI into a vanilla Camel Spring Boot or Camel Quarkus project.

== Getting started with Camel using Karavan

The https://github.com/apache/camel-karavan[Camel Karavan] is a toolkit for visually
designing Camel integrations, it is fully integrated with xref:camel-jbang.adoc[Camel JBang]
which allows users to easily try Camel while using the designer.

== Alternative ways of getting started with Camel

=== Adding Camel to an existing project

You can add Camel to any Java project, such as adding the necessary Camel dependencies
to the project build files (Maven or Gradle).

=== Using IDE tooling wizards

Some IDEs have wizards for creating new projects, of which, some have support for
Apache Camel via Spring Boot Initializer or Code with Quarkus.

=== Using Maven Archetypes

Apache Camel comes with a set of xref:camel-maven-archetypes.adoc[Camel Maven Archetypes],
you can use to create a new Camel project.

=== Cloning an existing example to modify

There are tons of Camel examples hosted on Github that you can clone and modify,
such as https://github.com/apache/camel-spring-boot-examples[Camel Spring Boot examples].

= Graceful Shutdown

Camel supports a pluggable shutdown strategy using
`org.apache.camel.spi.ShutdownStrategy`. Its responsible for shutting
down routes in a graceful manner. The other resources will still be
handled by xref:camelcontext.adoc[CamelContext] to shutdown. This leaves
the problem at hand with properly shutting down all the routes reliably
to the `ShutdownStrategy`.

Camel provides a default strategy in the
`org.apache.camel.impl.engine.DefaultShutdownStrategy` which is capable of
doing that.

== Default Shutdown Strategy

The default strategy (`DefaultShutdownStrategy`) will gracefully shutdown routes:

* in the reverse order they were started
* let pending and current in flight exchanges run to completion before
shutting down
* using a timeout of 45 seconds which then forces a _hard_ shutdown

The settings are configurable, so you can change the timeout, and
whether in case of timeout to force a _hard_ shutdown or ignore.

When shutting down the strategy will output to log the progress:

[source,log]
---------------------------------
2009-12-20 10:56:53,055 [main ] INFO DefaultCamelContext - Apache Camel (CamelContext:camel-1) is stopping
2009-12-20 10:56:53,056 [main ] INFO DefaultShutdownStrategy - Starting to graceful shutdown routes (timeout 45 seconds)
2009-12-20 10:56:53,059 [1: ShutdownTask] INFO DefaultShutdownStrategy - Waiting as there are still 5 inflight exchanges to complete before we can shutdown
2009-12-20 10:56:54,060 [1: ShutdownTask] INFO DefaultShutdownStrategy - Waiting as there are still 4 inflight exchanges to complete before we can shutdown
2009-12-20 10:56:55,061 [1: ShutdownTask] INFO DefaultShutdownStrategy - Waiting as there are still 3 inflight exchanges to complete before we can shutdown
2009-12-20 10:56:56,065 [1: ShutdownTask] INFO DefaultShutdownStrategy - Waiting as there are still 2 inflight exchanges to complete before we can shutdown
2009-12-20 10:56:57,066 [1: ShutdownTask] INFO DefaultShutdownStrategy - Waiting as there are still 1 inflight exchanges to complete before we can shutdown
2009-12-20 10:56:58,069 [main ] INFO DefaultShutdownStrategy - Graceful shutdown of routes complete in 5 seconds.
2009-12-20 10:56:58,072 [main ] INFO DefaultInflightRepository - Shutting down with no inflight exchanges.
2009-12-20 10:56:58,077 [main ] INFO DefaultCamelContext - Apache Camel (CamelContext:camel-1) stopped
---------------------------------

Notice how the strategy waits while there are inflight exchanges still being
processed before it shutdown the routes and after that Camel itself.

=== Suppressing logging due to timeout not allowing all inflight messages to complete

If a graceful shutdown could not shutdown cleanly within the given
timeout period, then Camel performs a more aggressive shutdown (hard) by
forcing routes and thread pools etc to shut down, and the routing
engine will reject continue processing xref:exchange.adoc[Exchange]s. If
this happens you may see WARN logs about xref:exchange.adoc[Exchange]s
being rejected and other failures due the forced shutdown.

If you do not want to see these logs, you can suppress this by setting
the option suppressLoggingOnTimeout to true.

[source,java]
---------------------------------
context.getShutdownStrategy().setSuppressLoggingOnTimeout(true);
---------------------------------

Notice that suppression is _a best effort_ attempt and there may still be some
logging from 3rd party libraries, which Camel cannot control.

=== Logging inflight exchange information on timeout

If a graceful shutdown could not shutdown cleanly within the given
timeout period, then Camel performs a more aggressive shutdown by
forcing routes and thread pools etc to shut down. When the timeout
happens, then Camel logs information about the current inflight
exchanges, which shows from which route the exchange origins, and where
it currently is being routed. For example the logging below, shows that
there is 1 inflight exchange, that origins from route1, and currently is
still in route1 at the "delay1" node. The elapsed is time in millis how
long at the current node (eg delay1) and duration is total time in
mills.

If you enable DEBUG logging level
on `org.apache.camel.impl.engine.DefaultShutdownStrategy` then it logs the same
inflight exchange information during graceful shutdown

[source,log]
---------------------------------
2015-01-12 13:23:23,656 [ - ShutdownTask] INFO DefaultShutdownStrategy -
There are 1 inflight exchanges: InflightExchange:
[exchangeId=ID-davsclaus-air-62213-1421065401253-0-3,
fromRouteId=route1, routeId=route1, nodeId=delay1, elapsed=2007,
duration=2017]
---------------------------------

If you do not want to see these logs, you can turn this off by setting
the option logInflightExchangesOnTimeout to false.

[source,java]
---------------------------------
context.getShutdownStrategy().setLogInflightExchangesOnTimeout(false);
---------------------------------

=== JMX managed

The `ShutdownStrategy` is JMX aware, so you can manage it from a
JMX console. This allows to adjust the strategy at runtime.

TIP: The timeout settings can also be changed on the `CamelContextMBean`.

== Controlling ordering of routes

You can configure the order in which routes should be started, and thus
also the same order they are being shutdown.
 See more at
xref:configuring-route-startup-ordering-and-autostartup.adoc[Configuring
route startup ordering and autostartup].

== Fine grained configuration

You can control two areas that influence graceful shutdown in the Camel
routing:

* `ShutdownRoute`
* `ShutdownRunningTask`

These options can be configured on two levels: _context_ and _route_.
The route level take precedence over context, meaning that if not
explicit configured on the route level, then the context level is used.

=== ShutdownRoute

This option can control how a given route should act during graceful
shutdown. It has two values `Default` and `Defer`. The `Default` is
obviously the default option which lets Camel shutdown the route as
early as possible. The `Defer` is used to defer shutting down this route
to a later stage. This is useful when other routes are dependent upon
it. For example an internal route which other routes reuse.

NOTE: It is best to only defer shutting down internal routes only. Public
routes should shut down as quickly as possible otherwise it will just
keep intake new messages which will delay the shutdown processor. Or
even have it timeout if a lot of new messages keep coming in.

=== ShutdownRunningTask

This option control how a given route consumer acts during shutdown.
Most route consumer will only operate on a single task (message),
however the xref:batch-consumer.adoc[Batch Consumer] can operate on many
messages (in a batch). This option is for batch consumers.

The default value is `CompleteCurrentTaskOnly` which mean that the
current _in progress_ task (message) will be completed and then the
consumer will shut down. The other option `CompleteAllTasks` allows the
consumer to complete all the tasks (messages) before shutting down. For
example a xref:components::file-component.adoc[File] consumer will process all the pending
files it has picked up before shutting down.

== Stop individual routes

It is possible to stop (will do a gracefully shut down) an individual route using
`stopRoute(routeId)` method as shown:

[source,java]
----
camelContext.getRouteController().stopRoute(routeId);
----

Routes can also be stopped via JMX.

=== Stopping and marking routes as failed due to an exception

It is possible to stop and fail (will do a gracefully shut down) an individual route using
`stopRoute(routeId, cause)` method as shown:

[source,java]
----
Exception cause = ...
camelContext.getRouteController().stopRoute(routeId, cause);
----

This will stop the route and then mark the route as failed with the caused exception.

NOTE: The Camel xref:health-check.adoc[Health Check] detect the route as failed and report it as DOWN.
If the route is manually stopped, then the route is not marked as failed,
and the xref:health-check.adoc[Health Check] will report the status as UNKNOWN.

Routes can also be stopped and failed via JMX.

== Implementing custom component or ShutdownStrategy

If you develop your own Camel component or want to implement your own
shutdown strategy then read this section for details.

=== ShutdownStrategy

You can implement your own strategy to control the shutdown by
implementing the `org.apache.camel.spi.ShutdownStrategy` and the set it
on the `CamelContext` using the `setShutdownStrategy` method.

=== ShutdownAware

The interface `org.apache.camel.spi.ShutdownAware` is an optional
interface consumers can implement to have fine grained control during
shutdown. The `ShutdownStrategy` must be able to deal with consumers
which implement this interface. This interface was introduced to cater
for in memory consumers such as xref:components::seda-component.adoc[SEDA] which potentially
have a number of pending messages on its internal in memory queues. What
this allows is to let it control the shutdown process to let it complete
its pending messages.

The method `getPendingExchangesSize` should return the number of pending
messages which reside on the in memory queues.
The method `deferShutdown` should return `true` to defer the shutdown
to a later stage, when there are no more pending and inflight messages.

xref:batch-consumer.adoc[Batch Consumer] should implement
`ShutdownAware` so they properly support the `ShutdownRunningTask`
option. See `GenericFileConsumer` for an example.


= Health Checks

Camel provides support to probe the state of an integration via a pluggable Health Check strategy based on the following concepts:

- *HealthCheck:* represents a health check and defines its basic contract.
- *HealthCheckResponse:* represents a health check invocation response.
- *HealthCheckConfiguration:* a basic configuration object that holds some basic settings like the minimum delay between calls, the number of times a service may be reported as unhealthy before marking the check as failed; besides these simple options, the check implementation is responsible for implementing further limitations where needed.
- *HealthCheckRegistry:* a registry for health checks. There is a single default implementation and end users should really not implement their own.
- *HealthCheckRepository:* a simple interface to define health check providers. By default there is one that grabs all the checks available in the registry so you can add your own check i.e. instantiating your bean in spring/spring-boot; components can provide their own repository.

== Health checks out of the box

Camel provides the following health checks out of the box:

- _context_ - A `HealthCheck` which performs check whether the `CamelContext` is started. This can be used for readiness checks; to know when Camel is fully started and ready to handle traffic.
- _routes_ - A `HealthCheckRegistry` which discovers all the available routes in `CamelContext` and checks whether they are all started.
This can be used for readiness checks; to know when Camel is fully started and ready to handle traffic.
Combining with the supervised `RouteController` this allows to perform readiness check for routes that are under supervising,
such as troublesome routes that may not start up the first time, and are retried to be started in the background with backoff delays.
- _consumers_ A `HealthCheckRegistry` which discovers all the consumers from all the routes in `CamelContext`
enabling fine-grained checks for the route input. This means if the consumer is failing to poll new messages
then the health check can detect this and report as un-healthy. Note that the consumer will be DOWN during its initialization and until at least
one poll run has been executed, to know whether that poll was a success or not. And if the poll was a success
then the consumer is UP. This is on purpose to avoid having the health check to be initially UP
and then after first poll run then DOWN again because the consumer cannot poll from external system;
which causes the health check to be _flaky_.
- _producers_ A `HealthCheckRegistry` which are for producer based health-checks. There are a few components
which comes with producer health checks such as `camel-kafka` and many of the `AWS` components.
However, producer health checks are by default disabled. See further below for how to enable producer health checks.
- _registry_ - A `HealthCheckRegistry` which discovers all the available custom `HealthCheck` instances in the `Registry`.

== IDs

A `HealthCheck` and `HealthCheckRegistry` has an ID. The ID has the name syntax `*name*-health-check`, or `*name*-health-check-repository`.
With the suffix `-health-check` or `-health-check-repository`. When looking up or resolving by IDs then the shorthand name can be used.

For example `context-health-check` is the ID but can also be used by its shorthand `context`.

The ID of the consumer health checks is the route id with `consumer:` as prefix, i.e. if the route
is named foo, then the ID is `consumer:foo`.

== Readiness and Liveness

Readiness and Liveness probes serve distinct purposes. Readiness indicates whether the application is ready to serve requests or traffic.
Liveness probes indicates whether the application is alive and functioning. A health check is by default usable for both readiness and liveness checks.

To check wether a health check is usable for readiness or livesness:

[source,java]
----
HealthCheck healthCheck = HealthCheckHelper.getHealthCheck(camelContext, healthCheckId);

System.out.println("Readiness=" + healthCheck.isReadiness());
System.out.println("Live=" + healthCheck.isLiveness());
----

To specify a custom health check as only usable for liveness checks,
you would need to turn off readiness, by overriding the `isReadiness` method and return `false`.

[source,java]
----
@Override
public boolean isReadiness() {
    return false;
}
----

== Configuring health-check

Camel supports via `camel-main` to configure health-checks from configuration files. This is possible for runtimes that leverage `camel-main`
such as Camel on Spring Boot, or Camel K.

Camel will automatically enable `context`, `routes`, `consumers`, `producers` and `registry` health-checks if `camel-health` is detected on the classpath.
They are all enabled by default (except for `producers` which is disabled).

However, you can configure them, for example to turn them off:

[source,properties]
----
# global option to turn health-check off (will not install health-check)
### camel.health.enabled=false

# allows to enable or disable health-checks from startup
# for example to only use context health-check
camel.health.routesEnabled=false
camel.health.consumersEnabled=false
camel.health.registryEnabled=false
----

The same can also be done programmatically using the Camel health api:

[source,java]
----
HealthCheckRepository consumersHealthCheckRepository = HealthCheckHelper.getHealthCheckRepository(context, "consumers");

if (consumersHealthCheckRepository != null) {
    consumersHealthCheckRepository.setEnabled(false);
}
----

=== How to consume the health check

Once you have the health check exposed as a service and the application is up and running, you can check it by accessing the related endpoint:

```
$ curl http://localhost:8080/q/health
{
    "status": "UP"
,
    "checks": [
        {
            "name": "context",
            "status": "UP"        },
        {
            "name": "route:route1",
            "status": "UP"        },
        {
            "name": "consumer:route1",
            "status": "UP"        }
    ]
}
```

NOTE: the path can change depending on the runtime used and the configuration.

When you're running on certain runtimes you will get more information by default. This is also possible in the `camel-main` runtime provider. However, you'll need to specify that as a request parameter:

```
$ curl http://localhost:8080/q/health?data=true
{
    "status": "UP"
,
    "checks": [
        {
            "name": "context",
            "status": "UP",
            "data": {
                 "check.group": "camel",
                 "check.id": "context",
                 "check.kind": "ALL",
                 "context.name": "camel-1",
                 "context.phase": "5",
                 "context.status": "Started",
                 "context.version": "4.12.0-SNAPSHOT",
                 "failure.count": "0",
                 "invocation.count": "2",
                 "invocation.time": "2025-03-20T09:43:01.870896479+01:00[Europe/Madrid]",
                 "success.count": "2",
                 "success.start.time": "2025-03-20T09:42:59.074646004+01:00[Europe/Madrid]",
                 "success.time": "2025-03-20T09:43:01.870896479+01:00[Europe/Madrid]"
            }
        },
...
```

=== Configuring initial state

The initial state of health-checks (readiness). There are the following states: UP, DOWN, UNKNOWN.

By default, the state is DOWN, is regarded as being pessimistic/careful. This means that the overall health
checks may report as DOWN during startup and then only if everything is up and running flip to being UP.

Setting the initial state to UP, is regarded as being optimistic. This means that the overall health checks may
report as UP during startup and then if a consumer or other service is in fact un-healthy, then the health-checks
can flip being DOWN.

Setting the state to UNKNOWN means that some health-check would be reported in unknown state, especially during
early bootstrap where a consumer may not be fully initialized or validated a connection to a remote system.

This option allows to pre-configure the state for different modes.

=== Excluding health-checks

By default, all enabled health-checks are invoked by Camel when check the health status.

It is possible to specify checks that should be excluded, for example a specific route by the route-id.

[source,properties]
----
camel.health.exclude-pattern = myroute
----

You can specify multiple patterns (and use wildcards) such as:

[source,properties]
----
camel.health.exclude-pattern = myroute,foo,bar*
----

==== Routes that are not automatically started

If a route is configured to not to automatically start (`autoStartup=false`),
then the route and its corresponding consumer health checks is always up as it is externally managed.

=== Turning off consumer level health-checks

If routes health check is enabled then they will execute consumer health-checks as well
as part of an aggregated response.

The consumer checks can be turned off, to only use the route level checks (status of the route)

[source,properties]
----
camel.health.consumersEnabled=false
----

You can also turn off individual consumers by prefixing the ID with `consumer:` and the route id:

[source,properties]
----
camel.health.exclude-pattern = consumer:myroute*
----

which will turn off checks for all consumers on routes that starts with `myroute` in the route ID.

Or you can turn off producer based health checks by their component name:

[source,properties]
----
camel.health.exclude-pattern = producer:kafka*
----

Or all AWS producer health-checks

[source,properties]
----
camel.health.exclude-pattern = producer:aws*
----

=== Turning on producer level health-checks

Only consumer based health-checks is enabled by default.

Some components (in particular AWS) provides also health checks for producers.
These health checks can be enabled via:

[source,properties]
----
camel.health.producersEnabled=true
----

=== Turning off health checks from components

Some Camel components comes with health-checks.

For example to turn off both consumer and producer health checks from Kafka:

[source,properties]
----
camel.component.kafka.health-check-consumer-enabled = false
camel.component.kafka.health-check-producer-enabled = false
----

TIP: You can turn of either consumer, producer or both.

== JMX management

The health check is manageable via JMX (requires `camel-management` JAR on the classpath).
You can find the `DefaultHealthCheck` MBean under the `health` node in the Camel JMX tree.

This MBean allows at runtime to manage health-checks where you can enable and disable checks based on their IDs.
As well have the latest status whether the overall health check is healthy or not.
The MBean also allows invoking health checks based on IDs (or all of them).

=== Configuring level of details in the health check responses

The option `exposureLevel` sets the level of details to exposure as result of invoking health checks.

There are the following levels:

- _full_ - The full level will include all details and status from all the invoked health checks.
- _default_ - The default level will report UP if everything is okay, and only include detailed information for health check that was DOWN.
- _oneline_ - The oneline level will only report either UP or DOWN.

You can specify multiple patterns (and use wildcards) such as:

For example to only report either as UP or DOWN then use:

[source,properties]
----
camel.health.exposure-level = oneline
----

=== Enriching and controlling health check responses

Each health check that is invoked will gather details about the result using `HealthCheckResultBuilder`.

To allow enriching and manipulating the result, then you can use `HealthCheckResultStrategy` to
plug in a custom bean that can process the result, and change state, add information, remove unwanted information,
etc. on the result builder.

The custom bean should be registered to the Camel xref:registry.adoc[Registry] to be discovered
by `camel-health`. Only one instance of the bean is allowed.

== Invoking health checks

You can invoke the health checks from Java by using the `org.apache.camel.health.HealthCheckHelper` which has APIs
to easily invoke all the health checks and gather their results, or filter out unwanted checks, or invoke only
the readiness or liveness checks.

The health checks can also be invoked from JMX.

== Writing a custom health check

There are a limited number of health checks provided by Camel out of the box,
so you may need to write your own check which you can do by implementing the _HealthCheck_ interface
or by extending _AbstractHealthCheck_ which provides some useful methods.

To make the health-check discoverable you should annotate the class with `@HealthCheck` and
the _name_-check syntax.

[source,java]
----
import org.apache.camel.spi.annotations.HealthCheck;
import org.apache.camel.impl.health.AbstractHealthCheck;

@HealthCheck("my-check")
public final class MyHealthCheck extends AbstractHealthCheck {

    public MyHealthCheck() {
        super("myapp", "my-check");
    }

    @Override
    protected void doCall(HealthCheckResultBuilder builder, Map<String, Object> options) {
        // Default value
        builder.unknown();

        // Add some details to the check result
        builder.detail("my.detail", camelContext.getName());

        if (unhealtyCondition) {
            builder.down();
        } else {
            builder.up();
        }
    }
}
----

You can now make _MyHealthCheck_ available to Camel by adding an instance to (for example Spring application context)
or directly to the Camel xref:registry.adoc[Registry].

== Loading custom health checks

Camel can discover and load custom health checks from classpath scanning. This requires
to annotate the custom health checks with `@HealthCheck` annotation on the class (see above).

Then the xref:camel-component-maven-plugin.adoc[camel-component-maven-plugin] can be
used to automatic generated service loader file in `META-INF/services/org/apache/camel/health-checks` that Camel uses
to discover the custom health checks.

You must also enable loading custom health check by setting (Camel Main, Camel K, or Camel Quarkus):

[source,properties]
----
camel.main.load-health-checks = true
----

And in Spring Boot:

[source,properties]
----
camel.springboot.load-health-checks = true
----

And if you use the classic Spring XML, you can enable this on `<camelContext>` as shown:

[source,xml]
----
<camelContext loadHealthChecks="true">
    ...
</camelContext>
----

And of course you can also enable loading health checks from Java via `CamelContext`:

[source,java]
----
CamelContext context = ...
context.setLoadHealthChecks(true);
----

TIP: The example `main-health` has a custom health check which is loadable.

=== Loading custom health checks in Camel Quarkus

If you use Camel Quarkus then you can write custom health checks with
xref:components:others:microprofile-health.adoc[MicroProfile Health], which
Camel Quarkus can automatically discover during build time compilation and ensure
are automatically loaded.

Using Camel's own health check APIs does however allow building health checks
that are usable anywhere you use Camel whether its standalone, spring boot, quarkus,
or something else.

== Writing custom Health Check for Camel components

You can implement custom health checks in Camel components (currently only for consumers).

To do this, you implement the interface `HealthCheckAware` on your consumer class, which should
return the custom health check in the getter method.

In the custom health check implementation, you can perform the check as shown in the previous section.
Camel will then use these custom component health checks when it performs *routes* health checks.

== Examples

There are examples for Camel at:

- Camel Standalone: https://github.com/apache/camel-examples/tree/main/main-health[main-health]
- Camel Spring Boot: https://github.com/apache/camel-spring-boot-examples/tree/main/health-checks[health-checks]
- Camel Quarkus: https://github.com/apache/camel-quarkus-examples/tree/main/health[health]
= HTTP Session Handling

Several Camel components can use HTTP as the underlying transport protocol.
In general HTTP calls are stateless in nature, however some servers allow
maintaining state via cookies. Cookies are often used to maintain a server
session (e.g. via a session cookie called "JSESSIONID" with servers implementing
the JEE Servlet specification).

== Session Scope

If a Camel route intends to implement some kind of HTTP session handling
the scope of this session should be considered.

Independently of the session scope the implementation must honor the domain of
the handled cookies.

=== Route/Context Scope

It might be desirable to have a single session for a route or a
CamelContext. This essentially means that all calls to
a server issued from a route or CamelContext share a single HTTP session.

=== Endpoint Scope

It is also possible to have a session on an
Endpoint entity. This would mean that all invocations of
an HTTP call issued by a single Endpoint share a session, whereas different
Endpoints never share sessions, even if the call is sent to the same server.

=== Exchange Scope

The third option to define a session scope is on
Exchange level. This is particularly useful for scenarios
where the server session is really maintaining state.

In this case the route could e.g. first do a login call, then some update calls
and finally a logout call. If the session handling would be defined on route or
CamelContext scopes this would seem to run, however under load parallel invocations
of the route would share a *single* session, which could cause issues. If the session
is defined on exchange scope, each invocation of the route will get a separate session,
and the server can maintain a separate state for the different parallel invocations.

== Usage

If you are a Camel user, you see that several Camel components support the cookieHandler
parameter on endpoint level. All you need to do is to instantiate a cookie handler
appropriate for your use case and reference it in the cookieHandler parameter for
all endpoints that are supposed to participate in the HTTP session.

There are two pre-implemented cookie handlers:

- `org.apache.camel.http.common.cookie.InstanceCookieHandler`
- `org.apache.camel.http.common.cookie.ExchangeCookieHandler`

The `InstanceCookieHandler` stores  cookies in an instance of itself. You can compare that
to a browser instance that is shared between all the endpoints that use it (and will
be used for all invocations of these endpoints). If you want to maintain separate sessions
for different endpoints or groups of endpoints you may have multiple instances of the
`InstanceCookieHandler`.

The `ExchangeCookieHandler` stores the session in the exchange. With the browser analogy
this means that each Exchange will get its own browser instance (so sessions are separated).
As the `ExchangeCookieHandler` does not store any state it is generally not useful to have
multiple `ExchangeCookieHandler` instances (as they would access the same data, anyway).

== Example

The following three routes will each do two invocations of an echo REST service. In the first
route (without a cookie handler) each invocation will get a new session. For the second route
all invocations will share a session. For the third route the first, and the second invocation
within the route share a session, but different (even parallel) invocations of the route will
not share a session.

[source,xml]
-----------------------------------------------------------
  <cxf:rsClient id="rsClientProxy" address="http://127.0.0.1:8080/CxfRsProducerSessionTest/"
    serviceClass="org.apache.camel.component.cxf.jaxrs.testbean.EchoService"
    loggingFeatureEnabled="true" />

  <camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
    <route>
       <from uri="direct://proxy"/>
       <to uri="cxfrs://bean://rsClientProxy"/>
       <convertBodyTo type="java.lang.String"/>
       <to uri="cxfrs://bean://rsClientProxy"/>
    </route>
    <route>
       <from uri="direct://proxyinstance"/>
       <to uri="cxfrs://bean://rsClientProxy?cookieHandler=#instanceCookieHandler"/>
       <convertBodyTo type="java.lang.String"/>
       <to uri="cxfrs://bean://rsClientProxy?cookieHandler=#instanceCookieHandler"/>
    </route>
    <route>
       <from uri="direct://proxyexchange"/>
       <to uri="cxfrs://bean://rsClientProxy?cookieHandler=#exchangeCookieHandler"/>
       <convertBodyTo type="java.lang.String"/>
       <to uri="cxfrs://bean://rsClientProxy?cookieHandler=#exchangeCookieHandler"/>
    </route>
  </camelContext>

  <bean id="instanceCookieHandler" class="org.apache.camel.http.common.cookie.InstanceCookieHandler"/>
  <bean id="exchangeCookieHandler" class="org.apache.camel.http.common.cookie.ExchangeCookieHandler"/>
-----------------------------------------------------------

Both `CookieHandler` implementations support setting a CookiePolicy to control the policy for storing
cookies. Default is `CookiePolicy.ACCEPT_ORIGINAL_SERVER`.

== Cookies and EIPs

Some EIPs like xref:components:eips:multicast-eip.adoc[Multicast] or xref:components:eips:split-eip.adoc[Split]
create multiple exchanges from a single one. If no `org.apache.camel.http.common.cookie.ExchangeCookieHandler`
is used before this, each multicast or splitter branch will have its own cookie store. This will not be the case
if the first invocation of one of the endpoints using the cookie handler is before the multicast, because in
this case the cookie store will be attached to the original exchange, and the exchanges created by the multicast
will copy the reference to this cookie store so there is effectively a shared cookie store across branches.
As a workaround, you can call a `cookieHandler.getCookieStore()` e.g. by setting this to some dummy header.

== Component Developers

If you want to develop a HTTP based component that is supposed to participate in a session
you have to add the following parts to your code:

. Include a build reference to camel-http-common (if it is not already there)
. Add a cookieHandler parameter to the endpoint class (together with getter and setter)
. Before your code does the HTTP call, if a cookie handler is set on the endpoint
perform a `cookieHandler.loadCookies(exchange, uri)` call. It will return a
`Map<String, List<String>>` containing the headers that need to be sent to the server.
The details how you need to send these headers to the server depend on the underlying HTTP
API you are using.
. After your code does receive the HTTP response if a cookie handler is set on the endpoint
perform a `cookieHandler.storeCookies(exchange, uri, m)` call. `m` is a
`Map<String, List<String>>` containing the HTTP headers returned from the server.

NOTE: Some APIs provide more direct support for cookie handling. In this case it might be easier
to get the underlying `java.net.CookieStore` with a `cookeManager.getCookieStore(exchange)` call
and handle the cookies using the cookie interface provided by the underlying library.= Improving the documentation

The Apache Camel project loves your help with improving the documentation, whether its
a tiny typo fix, or adding more details to an existing component, etc.

NOTE: This page only describes working with the 'documentation' portion of the website.
Other portions are written in markdown and built using Hugo.

== Simple changes

If there's an `edit this page` button at the top right of the page and you wish to propose a simple change such as fixing a typo or rewording something, use this xref:faq:how-do-i-edit-the-website.adoc[very simple process].
For more complicated changes, including changing xrefs, adding, removing or renaming pages, and significant organizational changes, please use the process described on this page.

== Where to find the documentation

All of the documentation accessible in the left-hand navigation panel in the documentation portion of the website is managed in the link:https://asciidoc.org/[AsciiDoc format] and built with the https://antora.org[Antora] static site generator.
As of November 2021, by far the most capable Asciidoc editor is the Intellij Asciidoc plugin, which works with  all Intellij editor products including the free IDEA Community Edition.
The plugin preview is more capable than viewing a local Asciidoc file with a browser plugin as it has some understanding of Antora structure.
Note that the only reliable way to preview your changes is with a full build of the Antora portion of the website.

The files have the extension `.adoc` and are managed in the Camel repositories.
General documentation is usually directly editable.
Component specific documentation is partially or entirely generated from other metadata sources which are in turn generated from the code, often from javadoc.
Altering generated documentation requires finding the original source, which varies by project.
Editable pages are found in several different places in the repositories:

Main camel repository::
Camel components::: In the `src/main/docs` folder for the component or camel module.
These are symlinked to under `docs/components`.
EIPs::: In the `core/camel-core-engine/src/main/docs` folder.
Core languages::: In the `core/camel-core-languages/src/main/docs` folder.
Note that many languages are under `components`.
User manual and FAQS::: In the `/docs/user-manual` folder.
Camel Karaf:: In the `docs` folder.
Camel Spring Boot:: Most documentation is generated and appended to the component documentation it applies to.
Editable pages are under `docs/spring-boot` and `core/camel-spring-boot/src/main/docs` and `core/camel-spring-boot-xml/src/main/docs`.

Other subprojects::
camel-k, camel-k-runtime::: Under `docs`.
There is no generated `camel-k` documentation.
camel-kafka-connector::: Editable pages are under `docs`.
Most documentation is generated directly from the generated json files for each connector under `connectors/<connector-name>/src/generated/resources`.
camel-kamelets::: Only `docs/modules/ROOT/pages/index.adoc` is editable.
All other documentation is generated from the kamelet yaml descriptors.
camel-quarkus::: Editable pages are under `docs`.
Pages under `docs/modules/ROOT/pages/reference/components` and `docs/modules/ROOT/pages/reference/extensions` are generated, including optional snippets from e.g. `extensions/activemq/src/main/doc`.
camel-quarkus-examples::: Editable pages are under `docs`.

[#_local_build_instructions]
== How to build the website locally, with your changes

First, make sure you have yarn, version >= 3.1.0, installed globally.

All three builds rely on a 'site-manifest' that lists the contents of the site with enough detail so that Antora knows about all the pages.

NOTE: The following procedure is not available in all subprojects yet.
If there is no `docs/local-build.sh` in the one you are working on, please ping djencks on zulip and I'll try to get it in soon.

=== Directory layout and initial setup

You need a single directory, such as `camel`, that contains all the camel subprojects you are working with, and the `camel-website` project.

[source,console]
----
cd camel
git clone https://github.com/apache/camel-website.git
----

=== Quick partial build

In your project, run
[source,sh]
----
./local-build.sh quick
----

This will build your local subproject substituted into the main Camel website build.
It will check syntax in your local subproject, and xrefs within it and from it to the rest of the site.
It will not check xrefs into your subproject.

Under `camel-website/documentation` you will find only the pages for your subproject.
Looking at this in a browser, links within the subproject will stay in the local pages, and links to the rest of the site will go to the main camel site.
There is no obvious way to get back to your local pages.

=== Full local Antora build

You only have to do this once, and again whenever there are significant changes to the website.

In your project, run
[source,sh]
----
./local-build.sh full
----
This will build the entire site, including your changes in your branch, and generate a 'site-manifest' listing all the contents of the website, that can be used to build only small parts of the site.
This full build will also check that all xrefs into your subproject branch are valid.

=== Subsequent partial continuous builds

After this full build completes, you can work on documentation with live updates in your browser by running
[source,sh]
----
./local-build.sh
----
This will do an initial build of just the current branch in the current subproject, incorporating it into the full site built in the full build, start a web server to serve the site, set up browser-sync on pages you are looking at in your browser, and rebuild the (partial) site as it detects changes.
Depending on the amount of content generation Antora is doing, this may take up to a minute or so.

This partial build will detect broken xrefs within your branch and from your branch to the main site, but will not (yet) detect broken xrefs from the rest of the site into your branch.
If you rename or remove a page please do a full build or check the PR build carefully for broken xrefs.

=== Viewing a full build in httpd

If you do a full build (`yarn build-all` or `yarn build` rather than `yarn build:antora` or use of the `local-build.sh` script in a subproject) and have Docker available locally you can view your build served with httpd by running `local-httpd-in-docker.sh`.
This is especially valuable to check redirects set up with `page-aliases`.

== Creating a documentation pull request.

NOTE: Simple changes such as typo fixes or rewording can usually be done directly at GitHub after pressing the `edit this page` button at the top left of each page.
Note that if the page source starts with a comment that the page is copied or generated this will not work!
Please do not use this method if you are changing any xrefs or making significant changes to format; instead follow the procedure below.

. Fork/clone the appropriate repository from GitHub and switch to the branch you are working with.
. Create a branch for your work with a name starting with the original branch name, e.g. `git switch -c main-doc-fix`
. Edit the `.adoc` sources as needed.
Preview your work in the Intellij Asciidoc plugin preview or in a browser with an Asciidoctor extension installed.
. Do a xref:#_local_build_instructions[local website build with your changes].
//=== The following workflow may be usable after https://gitlab.com/antora/antora/-/issues/831 is implemented, perhaps with the aid of an Antora extension.
//. Commit and push your work and create a PR in the (sub)project repository.
//Note the PR number, e.g. #456
//. Fork/clone the camel-website repository, and create an appropriate branch, e.g. `git switch -c camel-quarkus-main-456`.
//. Locate the project you are working with in the `antora-playbook.yml` under `sources`, and locate the branch you have altered under the appropriate `-url`.
//Leaving the original branch as a comment, alter the branch to e.g. `- pull/456` using the PR number you noted earlier.
//. Commit the change to the playbook, push it to your `camel-website` fork, and open a PR against `camel-website`.
//CI will build your change and, if successful, will deploy a preview on Netlify.
//There will be an email with the preview URL.
//. Check for build problems and examine the preview.
//. Upon approval, your content PR will be merged.
//Unless you have made a considerably more extensive change than described above, the `camel-website` PR will not need to be merged and may be closed.
//
//=== Currently usable workflow
. Commit and push your work and create a PR in the (sub)project repository.
. Fork/clone the camel-website repository, and create an appropriate branch, e.g. `git switch -c camel-quarkus-main-456`.
The following process will work for any number of doc PRs against any number of source repositories: usually you will have one subproject repo and one branch.
. Locate the `- url` of the project(s) you are working with in the `antora-playbook.yml` under `sources`, and locate the branch(es) you have altered under that `- url`.
. Add something like this to the end of the  `antora-playbook.yml`:
+
--
[source,yml]
----
    - require: '@djencks/antora-source-map'
#      log_level: trace #<1>
      source-map: <2>
        - url: 'https://github.com/apache/camel-kamelets.git' # <3>
          mapped-url: 'https://github.com/djencks/camel-kamelets.git' # <4>
          branches: # <5>
            - branch: main # <6>
              mapped-branch: main-collect # <7>
            - branch: 0.6.x
              mapped-branch: 0.6.x-collect
            - branch: 0.5.x
              mapped-branch: 0.5.x-collect
----
<1> Turning on trace logging will show you in great detail what's changed from the regular playbook, which can be useful if the build is not doing what you expect.
<2> List of source urls to substitute, probably only one.
<3> The GitHub URL of the subproject you are working on.
<4> The GitHub URL of your fork of the subproject.
<5> List of modified branches: probably only one.
<6> Name of the branch your PR will merge into.
<7> Name of your PR branch.
--
. At this point you can test your playbook changes locally by running `yarn build:antora` or `yarn build`.
. Commit the playbook changes, push to your fork of the `camel-website` repository, and open a PR.
. If all goes well you will get an email telling you where the Netlify preview is; this is also shown on the PR page.
. Check for build problems and examine the preview.
. Upon approval, your content PR will be merged.
A `camel-website` PR constructed as described here will not need to be merged and may be closed.

== New, renamed, or removed pages

* Add, rename, or remove the xref for your page in the appropriate nav.adoc file.
* Build the entire website and check for broken xrefs: these will appear as errors in the Antora log output.

== Changed xrefs

First, read xref:#_a_guide_to_xrefs[]

* Build the entire website and check for broken xrefs.

== Adding a new component version

See xref:release-guide-website.adoc[].

== A guide to xrefs

For a general explanation of Antora xref syntax see https://docs.antora.org/antora/3.0/page/xref/[the Antora documentation].
Due to the logical structure of the Camel documentation, xrefs will have a very limited choice of structure.

IMPORTANT: A bit of confusion is possible here between Antora components and Camel components.
Generally an Antora component corresponds more or less to a Camel subproject, and never to a camel commponent.
All the camel components are documented in an Antora component named `components`.
In this section the word `component` means an Antora component.

IMPORTANT: Antora components may be `distributed` which means that the content comes from more than one place, possibly from different repositories.
For instance, the `components` component has content from the main camel repository under the start_paths `docs/components` and `core/camel-core-engine/src/main/docs` and from the `camel-spring-boot` repository under `components-starter` and `docs/components`.
Furthermore the content may not appear in the normal Antora structure but may be collected from a more maven-project-friendly arrangement with an Antora extension.

=== xrefs within an (Antora) component

Generally there will never be a reason to refer from one version of a component to another version.
To assure this happens without maintenance issues, leave out the version and component segments from the xref, e.g. in the `components` component

[source,adoc,subs=+attributes]
xref{blank}:eips:enterprise-integration-patterns.adoc[]

NOT

[source,adoc,subs=+attributes]
xref{blank}:next@components:eips:enterprise-integration-patterns.adoc[]

Do this no matter how many locations the component is distributed over.

An xref within the same module can leave out the module segment, although it does no harm.

Do not specify the component name: if you do, the link will be to the `latest` (non-prerelease, i.e., non-`next`) version, not the current version.

=== Links to the user manual

The user-manual component is https://docs.antora.org/antora/3.0/component-with-no-version/[unversioned].
Leave out the version segment.
For example, this will link to this page from anywhere in the documentation:

[source,adoc]
xref:manual::improving-the-documentation.adoc[]

=== Links between subprojects

Each camel subproject relates to other subprojects, and each version of a subproject relates to specific versions of these other subprojects.
These subproject versions are specified in the `antora.yml` component descriptor for the documentation component for that subproject.
Note that for distributed components each start path has a component descriptor but only one has the additional `asciidoc/attributes` key.
For example,

[source,yaml]
----
name: camel-kafka-connector
title: Camel Kafka Connector
version: next
prerelease: true
display-version: Next (Pre-release)

nav:
- modules/ROOT/nav.adoc

asciidoc:
  attributes:
    camel-version: 3.12.x
    camel-k-runtime-version: 1.8.0
    camel-k-version:
    camel-kamelets-version: 0.3.0
----

NOTE: Setting these up is WIP

Use these attributes to refer to documentation for the related subproject, e.g.

[source,adoc]
xref{blank}:{camel-version}@components:eips:enterprise-integration-patterns.adoc[]

If there's a missing attribute, please raise an issue rather than using a concrete version.= Apache Camel user manual

Apache Camel™ is a versatile open-source integration framework based on
known xref:components:eips:enterprise-integration-patterns.adoc[Enterprise Integration
Patterns].

Camel empowers you to define routing and mediation rules in a variety of
domain-specific languages (xref:manual::dsl.adoc[DSL], such as Java, XML, Groovy, and YAML).
This means you get smart completion of
routing rules in your IDE, whether in a Java or XML editor.

For a deeper and better understanding of Apache Camel, an xref:faq:what-is-camel.adoc[Introduction] is provided.


== Summary

* <<Overview>>
* <<Documentation>>
* <<Developers>>

== Overview

* xref:getting-started.adoc[Getting Started]
* xref:book-getting-started.adoc[Longer Getting Started Guide]
* xref:faq:index.adoc[FAQ]
* https://github.com/apache/camel/blob/main/NOTICE.txt[Legal Notice]

== Documentation

* <<User Guide>>
* link:/community/books/[Books]
* xref:examples.adoc[Examples]
* xref:architecture.adoc[Architecture]
* xref:components:eips:enterprise-integration-patterns.adoc[Enterprise Integration Patterns]
* xref:component-dsl.adoc[Component DSL]
* xref:Endpoint-dsl.adoc[Endpoint DSL]
* xref:dataformat-dsl.adoc[DataFormat DSL]
* xref:language-dsl.adoc[Language DSL]
* xref:dsl.adoc[DSL]
* xref:components::index.adoc[Components]
* xref:components:dataformats:index.adoc[Data Formats]
* xref:languages.adoc[Languages]

=== User Guide

* xref:getting-started.adoc[Getting Started]
* xref:book-getting-started.adoc[Longer Getting Started Guide]
* xref:spring.adoc[Working with Camel and Spring]
* xref:faq:how-do-i-configure-endpoints.adoc[How do I configure endpoints?]
* xref:camelcontext-autoconfigure.adoc[Auto Configuration]
* xref:bean-integration.adoc[Bean Integration]
* xref:configuring-route-startup-ordering-and-autostartup.adoc[Configuring route startup ordering and autostartup]
* xref:graceful-shutdown.adoc[Graceful Shutdown]
* xref:error-handler.adoc[Error handler]
* xref:using-propertyplaceholder.adoc[How to use Camel property placeholders]
* xref:variables.adoc[How to use Variables]
* xref:examples.adoc[Examples]
* xref:testing.adoc[Testing]
* xref:camel-maven-plugin.adoc[Camel Maven Plugin] for running Camel from a Maven goal
* xref:camel-component-maven-plugin.adoc[Camel Component Maven Plugin] to generate all the necessary metadata and Java file for your custom component.
* xref:camel-report-maven-plugin.adoc[Camel Maven Report Plugin] to validate your source code and report the code coverage of your camel routes
* xref:camel-maven-archetypes.adoc[Camel Maven Archetypes]
* xref:components::jmx-component.adoc[Camel JMX]
* xref:rest-dsl.adoc[Working with REST and Rest DSL]
** xref:rest-dsl-openapi.adoc[Rest DSL contract first with OpenAPI]
* xref:writing-components.adoc[Writing Custom Camel Components]

=== xref:architecture.adoc[Architecture]

* xref:backlog-debugger.adoc[BacklogDebugger]
* xref:backlog-tracer.adoc[BacklogTracer]
* xref:batch-consumer.adoc[Batch Consumer]
* xref:browsable-endpoint.adoc[BrowsableEndpoint]
* xref:camelcontext.adoc[CamelContext]
* xref:clustering.adoc[Clustering and loadbalancing]
* xref:components::index.adoc[Component]
* xref:data-format.adoc[Data Format]
* xref:debugger.adoc[Debugger]
* xref:delay-interceptor.adoc[Delayer]
* xref:dsl.adoc[DSL]
* xref:endpoint.adoc[Endpoint]
* xref:endpoint-annotations.adoc[Endpoint Annotations]
* xref:error-handler.adoc[Error Handler]
* xref:exchange.adoc[Exchange]
* xref:exchange-pattern.adoc[Exchange Pattern]
* xref:exchange-pooling.adoc[Exchange Pooling]
* xref:expression.adoc[Expression]
* xref:event-notifier.adoc[Event Notifier]
* xref:http-session-handling.adoc[HTTP-Session Handling]
* xref:injector.adoc[Injector]
* xref:components:eips:intercept.adoc[Intercept]
* xref:languages.adoc[Languages]
* xref:lifecycle.adoc[Lifecycle]
* xref:oncompletion.adoc[OnCompletion]
* xref:pluggable-class-resolvers.adoc[Pluggable Class Resolvers]
* xref:predicate.adoc[Predicate]
* xref:processor.adoc[Processor]
* xref:registry.adoc[Registry]
* xref:route-builder.adoc[RouteBuilder]
* xref:lambda-route-builder.adoc[LambdaRouteBuilder]
* xref:route-controller.adoc[RouteController]
* xref:route-policy.adoc[RoutePolicy]
* xref:route-configuration.adoc[RouteConfiguration]
* xref:context-reload.adoc[ContextReload]
* xref:route-reload.adoc[RouteReload]
* xref:route-template.adoc[RouteTemplate]
* xref:routes.adoc[Routes]
* xref:stream-caching.adoc[Stream caching]
* xref:threading-model.adoc[Threading Model]
* xref:tracer.adoc[Tracer]
* xref:type-converter.adoc[Type Converter]
* xref:uris.adoc[URIs]
* xref:uuidgenerator.adoc[UuidGenerator]

=== xref:dsl.adoc[DSL]

* xref:java-dsl.adoc[Java DSL]
* xref:bean-integration.adoc[Java Annotation DSL]
* xref:components::spring-summary.adoc[Spring XML DSL]
* xref:rest-dsl.adoc[Rest DSL]

== Developers

* xref:building.adoc[Building Camel from Source]
= Injector

The
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/spi/Injector.html[Injector]
is a pluggable strategy to any IoC container such as
Spring to be able to create and
dependency-inject objects of a certain type.

= Java DSL

Apache Camel offers a Java-based DSL.

In the Java DSL you create a route by extending the xref:manual::route-builder.adoc[`RouteBuilder` class], and implementing the `configure` method.

== Java DSL example

This is best illustrated by an example.
In the code below we create a new class called `MyRouteBuilder` that extends the
`org.apache.camel.builder.RouteBuilder` from Camel.

In the `configure` method the Java DSL is at our disposal.

[source,java]
-------------------------------------------------------------------------
import org.apache.camel.builder.RouteBuilder;

/**
 * A Camel Java DSL Router
 */
public class MyRouteBuilder extends RouteBuilder {

    /**
     * Let's configure the Camel routing rules using Java code...
     */
    public void configure() {

        // here is a sample which processes the input files
        // (leaving them in place - see the 'noop' flag)
        // then performs content based routing on the message using XPath
        from("file:src/data?noop=true")
            .choice()
                .when(xpath("/person/city = 'London'"))
                    .to("file:target/messages/uk")
                .otherwise()
                    .to("file:target/messages/others");
    }

}
-------------------------------------------------------------------------

In the `configure` method we can define Camel xref:routes.adoc[Routes].

In the example above we have a single route, which pickup files (the `from`).

[source,java]
---------------------------------------
from("file:src/data?noop=true")
---------------------------------------

Then we use the xref:components:eips:choice-eip.adoc[Content-Based Router] EIP
(the `choice`) to route the message whether the person is from London or not.

[source,java]
-------------------------------------------------------
.choice()
    .when(xpath("/person/city = 'London'"))
        .to("file:target/messages/uk")
    .otherwise()
        .to("file:target/messages/others");
-------------------------------------------------------

=== Using Text Blocks for long URIs

If you have very long endpoint xref:uris.adoc[uris], then you can declare those in Java text blocks, instead
of breaking a String into multiple added elements:

[source,java]
----
    from("""
            debezium-postgres:customerEvents
            ?databasePassword={{myPassword}}
            &databaseDbname=myDB
            &databaseHostname=myHost
            &pollIntervalMs=2000
            &queryFetchSize=100
        """)
        .to("kafka:cheese");
----

=== Routes using Java lambda style

Camel now supports to define Camel routes in Java DSL using Lambda style. This can be beneficial for microservices or serverless where
you may want to quickly define a few routes.

For example, using lambda style you can define a Camel route that takes messages from Kafka and send to JMS in a single line of code:

[source,java]
----
rb -> rb.from("kafka:cheese").to("jms:queue:foo");
----

There is a bit more to this as the lambda route must be coded in a Java method that returns an instance of `LambdaRouteBuilder`.
See more at the xref:lambda-route-builder.adoc[LambdaRouteBuilder] documentation.


== More Details

For more details see xref:dsl.adoc[DSL], xref:routes.adoc[Routes], and xref:processor.adoc[Processor].

=== The Java DSL under the hood

As mentioned in the Getting Started guide, you can use Camel's Java DSL in a way that almost looks like a DSL. For instance:

*Note*: comments afterward explain some of the constructs used in the example.

.*Example of Camel's "Java DSL"*
[source,java]
----
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
        from("queue:a").filter(header("foo").isEqualTo("bar")).to("queue:b");

        from("queue:c").choice()
                .when(header("foo").isEqualTo("bar")).to("queue:d")
                .when(header("foo").isEqualTo("cheese")).to("queue:e")
                .otherwise().to("queue:f");
    }
};
CamelContext myCamelContext = new DefaultCamelContext();
myCamelContext.addRoutes(builder);
----

The first line in the above example creates an object which is an instance of an anonymous subclass of `RouteBuilder` with the specified `configure()` method.

The `CamelContext.addRoutes(RouterBuilder builder)` method invokes `builder.setContext(this)` – so the `RouteBuilder` object knows which `CamelContext` object it is associated with – and then invokes `builder.configure()`. The body of `configure()` invokes methods such as `from()`, `filter()`, `choice()`, `when()`, `isEqualTo()`, `otherwise()` and `to()`.

The `RouteBuilder.from(String uri)` method invokes `getEndpoint(uri)` on the `CamelContext` associated with the `RouteBuilder` object to get the specified `Endpoint` and then puts a `FromBuilder` _wrapper_ around this `Endpoint`. The `FromBuilder.filter(Predicate predicate)` method creates a `FilterProcessor` object for the `Predicate` (that is, condition) object built from the `header("foo").isEqualTo("bar")` expression. In this way, these operations incrementally build up a `Route` object (with a `RouteBuilder` wrapper around it) and add it to the `CamelContext` instance associated with the `RouteBuilder`.


== More Information

See xref:lambda-route-builder.adoc[Lambda Route Builder] for creating a routing rule using the DSL, using Java lambda style.
= JMX

Camel has optional support for JMX management, which is
part of the `camel-management` and `camel-management-api` JARs.

== Using JMX to manage Apache Camel

The JMX instrumentation agent is enabled in Camel when the `camel-management`
JAR is included in the classpath. Once enabled, the Camel runtime creates and
registers MBean management objects with a `MBeanServer` instance in the VM.
This allows Camel users to instantly obtain insights into how Camel routes
perform down to the individual processor level.

The high level supported types of management objects are:

- https://www.javadoc.io/doc/org.apache.camel/camel-management/current/org/apache/camel/management/mbean/ManagedCamelContext.html[CamelContext]
- https://www.javadoc.io/doc/org.apache.camel/camel-management/current/org/apache/camel/management/mbean/ManagedComponent.html[Component]
- https://www.javadoc.io/doc/org.apache.camel/camel-management/current/org/apache/camel/management/mbean/ManagedConsumer.html[Consumer]
- https://www.javadoc.io/doc/org.apache.camel/camel-management/current/org/apache/camel/management/mbean/ManagedDataFormat.html[DataFormat]
- https://www.javadoc.io/doc/org.apache.camel/camel-management/current/org/apache/camel/management/mbean/ManagedEndpoint.html[Endpoint]
- https://www.javadoc.io/doc/org.apache.camel/camel-management/current/org/apache/camel/management/mbean/ManagedProcessor.html[Processor]
- https://www.javadoc.io/doc/org.apache.camel/camel-management/current/org/apache/camel/management/mbean/ManagedRoute.html[Route]
- https://www.javadoc.io/doc/org.apache.camel/camel-management/current/org/apache/camel/management/mbean/ManagedService.html[Service]

Most of these management objects also expose lifecycle operations in
addition to performance counter-attributes.


== Disabling or enabling Camel JMX

JMX is only enabled in Camel when the `camel-management` JAR is included on the
classpath. To quickly enable or disable JMX, simply add or remove this JAR
from the classpath.

It is also possible to enable or disable JMX via configuration as documented below.

You can disable the JMX instrumentation agent by setting the Java VM system
property as follows:

[source,bash]
----
-Dorg.apache.camel.jmx.disabled=true
----

The property value is treated as `boolean`.

Alternatively, add a `jmxAgent` element inside the `camelContext` element in
Spring XML configuration:

[source,xml]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
  <jmxAgent id="agent" disabled="true"/>
    ...
</camelContext>
----

In Java, you can disable JMX directly on the `CamelContext` as follows:

[source,java]
----
CamelContext camel = new DefaultCamelContext();
camel.disableJMX();
----

== Camel JMX configuration options

Camel JMX can be configured with the following options.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Option |JVM System Property |Default Value |Description
|`id` |  |  |*required* The JMX agent name

|`usePlatformMBeanServer` |`org.apache.camel.jmx.usePlatformMBeanServer` |`true`
|Whether to use the MBeanServer from JVM.

|`mbeanServerDefaultDomain`
|`org.apache.camel.jmx.mbeanServerDefaultDomain` |`org.apache.camel`
|The default JMX domain of the `MBeanServer`

|`mbeanObjectDomainName` |`org.apache.camel.jmx.mbeanObjectDomainName` |`org.apache.camel`
|The JMX domain that all object names will use

|`mbeansLevel` |  |`Default`
|Configure the level for which MBeans are registered.
See section _Registering MBeans for specific resources only_ for more details.

|`onlyRegisterProcessorWithCustomId`
|`org.apache.camel.jmx.onlyRegisterProcessorWithCustomId` |`false`
|If this option is enabled, then only processors with a
custom id set will be registered. This allows you to filer out unwanted
processors in the JMX console.

|`statisticsLevel` |  |`Default`
|Configure the level for whether performance statistics is enabled for the MBean.
See section _Configuring level of granularity for performance statistics_ for more details.

|`includeHostName` |`org.apache.camel.jmx.includeHostName` | `false`
|Whether to include the hostname in the MBean naming.

|`useHostIPAddress` |`org.apache.camel.jmx.useHostIPAddress` |`false`
|Whether to use hostname or IP Address in the service url
when creating the remote connector. By default, the hostname will be
used.

|`loadStatisticsEnabled` |`org.apache.camel.jmx.loadStatisticsEnabled` |`false`
|Whether load statistics is enabled (gather load statistics using a background thread per CamelContext).

|`endpointRuntimeStatisticsEnabled`
|`org.apache.camel.jmx.endpointRuntimeStatisticsEnabled` |`true`
|Whether endpoint runtime statistics is enabled (gather runtime
usage of each incoming and outgoing endpoint).

|`mask` |`org.apache.camel.jmx.mask` |`true`
|A flag that indicates whether to remove detected sensitive information (such as passwords)
from MBean names and attributes.

|`updateRouteEnabled` |`org.apache.camel.jmx.updateRouteEnabled` |`false`
|Whether to allow updating routes at runtime via JMX using the ManagedRouteMBean. This is disabled by default, but can be enabled for development and troubleshooting purposes, such as updating routes in an existing running Camel via JMX and other tools.

|=======================================================================

=== Registering MBeans for specific resources only

Camel automatically registers MBeans for the context, routes, and processors
when it starts up. However, you can specify a level to control whether
MBeans are registered at startup. The levels are:

* `Default` - Camel will register MBeans for the context, all the routes and the processors.

* `RoutesOnly` - Camel will register MBeans for the context and for all the routes (not for any processor).

* `ContextOnly` -  Camel will register MBeans for the context (neither for any route nor for any processor).

=== Registering new MBeans for new routes, created by route templates, Kamelets

Camel provides the following settings to control when to register mbeans.

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|`registerAlways` |`false` |If enabled then MBeans are always registered.

|`registerNewRoutes` |`true` |If enabled then adding new routes after
CamelContext has been started will also register
MBeans from that given route.

|`registerRoutesCreateByKamelet` |`false` |If enabled then adding routes created by Kamelet will also register MBeans from that given route.

|`registerRoutesCreateByTemplate` |`true` |If enabled then adding routes created by route template (not Kamelet, see option above) will also register MBeans from that given route.

|=======================================================================

By default, Camel automatically registers MBeans for all routes configured at
startup. The `registerNewRoutes` option controls whether MBeans should also be
registered for new routes added later on. This feature can be disabled, for
example, if you are adding and removing temporary routes that do not require
management.

In *Camel 4.5* onwards, there are additional options to configure whether routes created from route templates or Kamelets
should be registered as MBeans or not. By default, Kamelets are now disabled with the intention to regard a Kamelet
as a component, instead of a set of additional routes and processors MBeans that is essentially unnecessary for management
and monitoring. The option `registerRoutesCreateByKamelet` can be set to `true` to enable MBeans, which is how Camel 4.4 or
older behaves. On the other hand, routes created from route templates (not Kamelets) are default enabled.

CAUTION: However, be cautious when using the `registerAlways` option in
conjunction with dynamic EIP patterns, such as the xref:components:eips:recipientList-eip.adoc[Recipient List],
which have unique endpoints. This can potentially lead to system degradation
due to the increasing number of MBeans in the registry from its associated
services/producers. Keep in mind that an MBean is not a lightweight object
and consumes memory.

== Management naming pattern

You can configure a naming pattern for the MBeans names that Camel creates.
The pattern is used as part of the `ObjectName` as the key after the domain name.

By default, Camel will use MBean names for the `ManagedCamelContextMBean`
as follows:

[source,text]
----
org.apache.camel:context=camel-1,type=context,name=camel-1
----

If you configure a name on the `CamelContext` then that name is part of
the `ObjectName` as well. For example, if we have:

[source,xml]
----
<camelContext id="myCamel" ...>
----

Then the MBean names will be as follows:

[source,text]
----
org.apache.camel:context=myCamel,type=context,name=myCamel
----

In the event of a naming clash within the JVM, such as when there is already an
MBean with the same name, Camel will automatically try to resolve the issue by
finding a new, available name in the `JMXMBeanServer` using a counter. For
example, the counter will be appended to the name, resulting in an `ObjectName`
such as `myCamel-1`:

[source,text]
----
org.apache.camel:context=myCamel-1,type=context,name=myCamel
----

=== Naming Patterns

This is possible because Camel uses a naming pattern by default that
supports the following tokens:

* `\#camelId#` = the CamelContext id (eg the name)
* `\#name#` - same as `\#camelId#`
* `\#counter#` - an incrementing counter

If there is a naming clash in the `JMXMBeanServer` then Camel
will automatically fall back and use the `\#counter#` in the pattern to remedy
this. Thus, the following patterns will then be used: `\#name#-\#counter#`

If you set an explicit naming pattern, then that pattern is always used,
and the default patterns above are *not* used.

This allows us to have full control, very easily, of the naming for both
the `CamelContext` id in the Registry and the JMX MBeans in the `JMXMBeanRegistry`.

So if we want to explicitly name both the `CamelContext` and to use fixed
MBean names that do not change (i.e., without counters), then we can use
the `managementNamePattern` attribute:

[source,xml]
----
<camelContext id="myCamel" managementNamePattern="#name#">
----

Then the MBean names will always be as follows:

[source,text]
----
org.apache.camel:context=myCamel,type=context,name=myCamel
----

In Java, you can configure the `managementNamePattern` as follows:

[source,java]
----
context.getManagementNameStrategy().setNamePattern("#name#");
----

== Configuring performance statistics

You can set a level for whether performance statistics are
enabled or not when Camel starts up. The levels are:

* `Default` - Camel will enable statistics for both routes and
processors (fine-grained).

* `Extended` - As default but with additional statistics gathered during
runtime such as fine-grained level of usage of endpoints and more.

* `RoutesOnly` - Camel will only enable statistics for routes (coarse
grained)

* `Off` - Camel will not use any statistics.


[NOTE]
====
*What does statistics enabled mean?*

Statistics enabled means that Camel will do fine-grained performance
statistics for that particular MBean. There are statistics you can see, such as number of exchanges completed/failed,
last/total/min/max/mean processing time, first/last failed time, etc.

====

Using Java DSL, you set the statistics level by:

[source,java]
----
// only enable routes when Camel starts
context.getManagementStrategy().setStatisticsLevel(ManagementStatisticsLevel.RoutesOnly);
----

And from XML DSL you can do:

[source,xml]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
    <jmxAgent id="agent" statisticsLevel="RoutesOnly"/>
 ...
</camelContext>
----

=== Performance load statistics

It is possible to include load statistics for CamelContext and Route MBeans.
These statistics are for average load based on the number of in-flight
exchanges, measured over periods of 1, 5, and 15 minutes. This is similar to
load statistics on Unix systems.

You can enable this by setting `loadStatisticsEnabled=true`.

== Hiding sensitive information

By default, Camel enlists MBeans in JMX such as endpoints configured
using URIs. In this configuration, there may be
sensitive information such as passwords.

This will mask URIs having options such as password and
passphrase, and use `xxxxxx` as the replacement value.

=== Masking JMX attributes in custom components

When implementing custom Camel components, you can mark which
JMX attributes to mask with the `@ManagedAttribute` and `@ManagedOperation` annotations.

The `mask` attribute can be set to `true` to indicate that the result of this JMX
attribute/operation should be masked (if enabled on JMX agent, see
above).

For example, on the default managed endpoints from camel-core
`org.apache.camel.api.management.mbean.ManagedEndpointMBean`, we have
declared that the `EndpointUri` JMX attribute is masked:

[source,java]
----
@ManagedAttribute(description = "Endpoint URI", mask = true)
String getEndpointUri();
----

== Expose JMX metrics remotely

When you're running the application locally, you can use any JMX client (ie, `jconsole`) to access to the process and the the statistics exposed. However, you may want to expose these metrics remotely in order to be accessed by any remote process: https://docs.oracle.com/javase/tutorial/jmx/remote/jconsole.html[expose the JMX metrics remotely].

NOTE: make sure to properly secure the access to JMX services for production workloads.

== How to use a Java Agent

Exposing the JMX metrics with its native protocol may not always be possible (ie, for firewall limitations, security, etc). In this case you may recur to the availability of JSR 160 compatible Java Agents (for instance, https://jolokia.org/reference/html/manual/agents.html#agents-jvm[Jolokia]), which goal is to adapt the JMX interface with HTTP based protocol. With this approach you can run you application attaching a Java Agent whose goal will be to take care of exposing JMX via HTTP. As an example:
```
java -javaagent:jsr160-javaagent.jar -jar my-camel-app.jar
```
will expose certain endpoints (depending on the implementation) which would let you interact with JMX.

Depending on the implementation you will need to provide to a different set of agent configuration. For example, if you're running Jolokia agent, then, you will need to run this configuration to expose a plain HTTP unsecure service:
```
java -javaagent:jolokia-agent-jvm-2.1.1-javaagent.jar=protocol=http,useSslClientAuthentication=false,discoveryEnabled=false,host=*,extendedClientCheck=false -jar my-camel-app.jar
```
From that moment onward you will be able to access the service via:

```

$ curl http://localhost:8778/jolokia/list/org.apache.camel | jq | more
{
  "request": {
    "path": "org.apache.camel",
    "type": "list"
  },
  "value": {
    "context=camel-1,name=\"platform-http\",type=components": {
      "op": {
        "getCamelId": {
          "args": [],
          "ret": "java.lang.String",
          "desc": "CamelId"
        },
        "isHealthCheckSupported": {
          "args": [],
          "ret": "boolean",
          "desc": "HealthCheckSupported"
        },
        "getComponentName": {
          "args": [],
          "ret": "java.lang.String",
          "desc": "ComponentName"
        },
...
```

Each agent implementation may provide a different way to get and execute actions on the various endpoint.

WARNING: make sure to properly secure the access to the HTTP services for production workloads checking the specific agent configuration documentation.
= JSON

JSON is a xref:data-format.adoc[Data Format] to marshal and unmarshal
Java objects to and from http://www.json.org/[JSON].

For JSON to object marshalling, Camel provides integration with many
popular JSON libraries such as:

- Jackson
- Google GSon
- Johnzon

How to use JSON with Camel then see the documentation (for the JSON data library of choice)
in the list of xref:components:dataformats:index.adoc[Data Formats].= LambdaRouteBuilder

The `LambdaRouteBuilder` is a functional interface which is used for creating a routing rule using the xref:dsl.adoc[DSL],
using Java lambda style.

[source,java]
----
rb -> rb.from("timer:foo").log("Hello Lambda");
----

Instances of `LambdaRouteBuilder` are discovered and transformed into `RouteBuilder` instances
which are added to the CamelContext.

== Usage

To use `LambdaRouteBuilder` you need to create a method that returns `LambdaRouteBuilder` which then
allows to use Java lambda style to define a single route.

In the example below the method `myRoute` is used to create a Camel route that consumes from Kafka and sends the messages to JMS.

To make the route discoverable by Camel during startup, then the method must be annotated.
The method should be annotated with `@BindToRegistry` in standalone mode with `camel-main`, `@Bean` in case of Spring Boot or `@Produce` in case of Quarkus.

[source,java]
----
public class MyConfiguration {
    @BindToRegistry
    public LambdaRouteBuilder myRoute() {
        return rb -> rb.from("kafka:cheese").to("jms:queue:foo");
    }
}
----

== LambdaEndpointRouteBuilder

The xref:Endpoint-dsl.adoc[Endpoint DSL] can also be used as a lambda route builder with the
`org.apache.camel.builder.endpoint.LambdaEndpointRouteBuilder` class from the `camel-endpointdsl` JAR.

[source,java]
----
public class MyConfiguration {
    @BindToRegistry
    public LambdaEndpointRouteBuilder myRoute() {
        return rb -> rb.from(rb.kafka("cheese")).to(rb.jms("queue:foo"));
    }
}
----

The `LambdaEndpointRouteBuilder` has _type safe_ endpoint but requires to prefix with the instance name (`rb`)
when choosing an endpoint name. Notice above how to select the kafka endpoint

[source,java]
----
rb.from(rb.kafka("cheese"))
----

With the regular `LambdaRouteBuilder` it's just a `String` type, so the `rb` prefix is not needed anymore:

[source,java]
----
rb.from("kafka:cheese")
----
= Language DSL

The Language DSL is a builder API that allows using type safe construction of
Camel xref:languages.adoc[Languages].

The Language DSL is exclusively available as part of the Java DSL.

The DSL can be accessed directly from the `RouteBuilder` thanks to the method `expression()`.

== Using Language DSL

In the following example, a `TokenizerExpression` is created using the legacy approach where the expression is instantiated explicitly and configured using setters:

[source,java]
----
public class MyRoutes extends RouteBuilder {
    @Override
    public void configure() {
        TokenizerExpression expression = new TokenizerExpression("(\\W+)\\s*"); // <1>
        expression.setRegex(true); // <2>
        from("file:data")
            .split(expression) // <3>
            .process("processEntry");
    }
}
----
<1> Instantiate the expected expression
<2> Configure the expression according to the needs
<3> Affect the expression with the expected configuration

The previous code could be simplified using the utility methods available directly from the `ExpressionClause` corresponding to the type returned by several existing methods such as `split()`, `setBody()`, `setHeader(String)`, `aggregate()`, etc.:

[source,java]
----
public class MyRoutes extends RouteBuilder {
    @Override
    public void configure() {
        from("file:data")
            .split()
            .tokenize("(\\W+)\\s*", true) // <1>
            .process("processEntry");
    }
}
----
<1> Select the `tokenize` language with a specific regular expression

This approach is suitable for very basic configuration, but as there are only limited utility methods for each supported language, for more complex configuration, we can quickly face situations where the utility method for our expected configuration doesn't exist. In this situation, you can either use the legacy approach or the language DSL like in the next code snippet:

[source,java]
----
public class MyRoutes extends RouteBuilder {
    @Override
    public void configure() {
        from("file:data")
            .split(
                expression() // <1>
                    .tokenize() // <2>
                        .token("(\\W+)\\s*") // <3>
                        .regex(true) // <3>
                    .end() // <4>
            )
            .process("processEntry");
    }
}
----
<1> Give access to all the supported languages
<2> Select the `tokenize` language
<3> Configure the expression according to the needs
<4> Build the expression with the expected configuration
= Languages

To support flexible and powerful
xref:components:eips:enterprise-integration-patterns.adoc[Enterprise Integration
Patterns], Camel supports various Languages to create an
xref:expression.adoc[Expression] or xref:predicate.adoc[Predicate]
within the xref:routes.adoc[Routes] and xref:dsl.adoc[DSL]..

== Supported languages

There are about 20 different xref:components:languages:index.adoc[Languages] such
as scripted programming languages like Groovy, and template based languages like Velocity and Freemarker,
and XML/JSon languages, and many others.

Most of these languages are also supported used as
xref:parameter-binding-annotations.adoc[Annotation Based Expression Language] in Java beans.
= Camel Lifecycle

Camel uses a simple _lifecycle_ interface called
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Service.html[Service]
which has `start()` and `stop()` methods.

Many of Camel's classes implement `Service` such as
`CamelContext` along with all `Component` and `Endpoint` classes.

When you use Camel you typically have to start the
`CamelContext` which will start all the various
components and endpoints and activate the routing rules until the
context is stopped again.

== CamelContext Lifecycle

The `CamelContext` provides methods to control its lifecycle:

* `build`
* `init`
* `start`
* `stop`
* `suspend`
* `resume`

The operations are paired: start/stop and suspend/resume.

Stop is performing a xref:graceful-shutdown.adoc[Graceful Shutdown]
which means all its internal state, cache, etc is cleared; and the
routes is being stopped in a graceful manner to ensure messages are given
time to complete.

IMPORTANT: If you start a `CamelContext` after a stop, then its
performing a _cold_ start, recreating all the state, cache etc. again; which is not guaranteed to startup correctly again.
Instead you can use the suspend/resume operations. They will keep the
`CamelContext` _warm_ and only suspend/stop routes using the same
graceful shutdown feature. This ensures messages are given time to complete.

End users is encouraged to use suspend/resume if you are temporary
stopping a Camel application.

All these operations are available in JMX as well,
so you can control Camel from JMX management.

== Service lifecycle

A service (`org.apache.camel.Service`) in Camel adheres to the following
lifecycle states as illustrated in the diagram below:

image::images/service_lifecycle.png[image]

The `org.apache.camel.support.service.ServiceSupport` is a good base class to
extend for custom services as it offers the basic functionally to keep
track of state. You implement your custom logic in the `doStart`,
`doStop`, `doSuspend`, `doResume` methods.

TIP: A service can optimally support suspend/resume by the
`org.apache.camel.SuspendableService`. This means not all services in
Camel supports suspension. It's encouraged that consumers support
suspension which allows suspending/resuming routes.

== Startup Lifecycle

When Camel startup there are various listeners that can be used to plugin custom code, that
can listen and react during startup such as `LifecycleStrategy`, or `MainListener`.

If you need Camel to check for _something_ before it can start up, then look at xref:startup-condition.adoc[Startup Condition]= Mapped Diagnostic Context (MDC)

The Mapped Diagnostic Context is a technology used in Java to provide a set of customized information into each log trace. The major logging frameworks implements it, and, although it may have certain limitations, this technology is used to enhance the logging and monitoring of a Java application (Camel applications included).

The main limitation of this technology is the fact that it stores values on a context that is available at thread level. Since Camel is an application that manages multiple thread, when it deals with asynchronous calls, the context propagation may not work correctly.

NOTE: the framework should generally handle MDC correctly. However, there could be components (eg, tracing components) and other asynchronous parts of the system that still require the implementation of the context propagation: please report if you notice anything wrong.

== How to configure in Camel application

The first thing you need to do is to enable the `camel.main.useMdcLogging=true`. This flag will automatically include in the MDC context the following Exchange information:

* camel.breadcrumbId
* camel.exchangeId
* camel.messageId
* camel.correlationId
* camel.routeId
* camel.stepId
* camel.contextId
* camel.transactionKey

You can use the above variables for MDC depending on the logging framework you're using. For example, if you're using log4j2, then, the variable will be like `%X{camel.exchangeId}`. Other logging frameworks should have a similar approach, just check its specific documentation.

== User values

If you're using Java DSL you can include any customized information by adding that using low level MDC API:

```java
        org.slf4j.MDC.put("myKey", "myValue");
```

Each MDC should be now able to include that information.

== Context propagation

If you're using some asynchronous component, then, you may need to configure the application to enable the MDC context propagation. For that reason you need to add the `camel.main.mdcLoggingKeysPattern` configuration. This configuration will drive the process of copying the MDC context on the thread that will execute your Exchange asynchronously.
= Apache Camel Migration and Upgrade Guides

We do frequent releases, a release almost every month, and even though we strive to maintain backward compatibility, we may on occasion introduce a breaking change in the interest of the long-term evolution of the project.

Listed here are the notes on how to migrate between major versions, and what to watch out when upgrading from minor versions.

- xref:camel-3-migration-guide.adoc[Camel 2.x to 3.0 migration guide]
- xref:camel-3x-upgrade-guide.adoc[Upgrade guide for 3.x releases]
- xref:camel-4-migration-guide.adoc[Camel 3.x to 4.0 migration guide]
- xref:camel-4x-upgrade-guide.adoc[Upgrade guide for 4.x releases]
= Notify Builder

The `NotifyBuilder` is a builder from the `org.apache.camel.builder` package which allows you to build expressions and then test or wait for that condition to occur.
The expressions are based around notifications about xref:exchange.adoc[Exchange] being routed.
So what does that mean?

It means that you can build an expressions which can tell you when Camel is finished with routing 5 messages etc.
You may want to use this when testing a route which you cannot or will not use xref:components::mock-component.adoc[Mocks].

NOTE: The `NotifyBuilder` is only intended for testing purposes and you can only use this with Java coding.

== Basic example using NotifyBuilder

Suppose we have a very simple route:

[source,java]
----
from("jms:queue:quotes")
    .to("bean:quotes");
----

Imagine the route being more complex, and a production ready route.

Now you want to test this route without using mocks or the likes.
We want to test that it could process a message send to that queue.
By using the `NotifyBuilder` we can build an expression which expresses when that condition occurred.

[source,java]
----
NotifyBuilder notify = new NotifyBuilder().whenDone(1).create();

// now use some API to send a message etc. Maybe you cannot use Camel's ProducerTemplate
// now we want to wait until the message has been routed and completed

boolean done = notify.matches(10, TimeUnit.SECONDS);
assertTrue("Should be done", done);

// now maybe use some API to see that the message did as expected
----

This is a very basic example where we configured the `NotifyBuilder`
to match when any `Exchange` is done.

The builder has many more methods to set more complex expressions, which even can be stacked using and, or, not operations.

== NotifyBuilder API

The `NotifyBuilder` has many methods that allow you to build even more complex expressions.
The table below list the most commonly used methods.

[width="100%",cols="1m,4",options="header",]
|=======================================================================
|Method |Description
| from(endpointUri) | Matches only when Exchanges are incoming from that particular endpoint. The endpointUri can be a pattern, which is the same pattern matching used by Intercept.
| fromRoute(routeId) | Matches only when Exchanges are incoming from that particular route. The routeId can be a pattern, which is the same pattern matching used by Intercept.
| filter(predicate) | Filters out unwanted Exchanges (only messages passing (true) the predicate is used).
| wereSentTo(endpointUri) | Matches only when Exchanges has at any point been sent to the given endpoint. The endpointUri can be a pattern, which is the same pattern matching used by Intercept.
| whenDone(number)| Matches when X number or more messages is done.
| whenComplete(number) | Matches when X number or more messages is complete.
| whenFailed(number) | Matches when X number or more messages is failed.
| whenBodiesDone(bodies) | Matches when the message bodies are done in the same order. This method is non strict which means that it will disregard any additional done messages.
| whenAnyDoneMatches(predicate) | Matches if any one of the done messages matched the Predicate.
| create | Creates the notifier. After you have created it you can use the matches methods.
| matches | Tests whether the notifier currently matches. This operation returns immediately. This method is to be used after you have created the expression.
| matches(timeout) | Waits until the notifier matches or times out. Returns `true` if matches, or `false` if time-out occurs. This operation returns immediately. This method is to be used after you have created the expression.
| matchesWaitTime | Wait until the builder matches or timeout. The timeout value used is based on the highest result wait time configured on any of mock endpoints being used. If no mock endpoint was used, then the default timeout value is 10 seconds. This method is convenient to use in unit tests when you use mocks. Then you don't have to specify the timeout value explicit.
|=======================================================================

`NotifyBuilder` has more than 30 methods. For full list of methods then see the https://www.javadoc.io/doc/org.apache.camel/camel-core-model/current/org/apache/camel/builder/NotifyBuilder.html[javadoc for NotifyBuilder].

TIP: You can create multiple instances of `NotifyBuilder` if you want to be notified
of different conditions. `NotifyBuilder` also supports using binary operations
(and, or, not) to stack together multiple conditions.

=== Difference between done, completed and failed

The `NotifyBuilder` identifies three ways a message can complete:

- _Done_ - The message is done, regardless of whether it completes or fails.
- _Completed_ - The message completes with success (no failure).
- _Failed_ - The message fails (for example an exception is thrown and not handled).

The names of these three ways are also incorporated in the names of the builder methods: `whenDone`, `whenCompleted`, and `whenFailed`.

=== Examples

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .from("direct:foo").whenDone(5)
    .create();
----

Here we want to match when the direct:foo endpoint have done 5 messages.

You may also want to be notified when an message is done by the index, for example the very first message. To do that you can simply do:

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .whenDoneByIndex(0)
    .create();
----

This ensures that the notifier only matches exactly when the first message is done.

If you use `whenDone(1)` instead, then the notifier matches when at least one message is done.
There could be use cases where `whenDone(1)` would match even if the first message hasn't been done yet,
as other message in between could be done ahead of the first message.
That is why `whenDoneByIndex` was added to support this scenario.

Here we want to match when the direct:foo endpoint have done 5 messages which contains the word 'test' in the body.
The filter accepts a xref:predicate.adoc[Predicate].

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .from("direct:foo").filter(body().contains("test")).whenDone(5)
    .create();
----

Here we just say that at least one message should be done received from any JMS endpoint (notice the wildcard matching).

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .from("jms:*").whenDone(1)
    .create();
----

Here, we just say that at least three message should be done received from any of myCoolRoutes (notice the wildcard matching).

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
.fromRoute("myCoolRoutes*").whenDone(3)
.create();
----

Here both 5 foo messages and 7 bar messages must be done. Notice the use of the and operator.

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .from("direct:foo").whenDone(5)
    .and().from("direct:bar").whenDone(7)
    .create();
----

Here we expect to receive two messages whose body is Hello World then Bye World.

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .from("direct:foo").whenBodiesReceived("Hello World", "Bye World")
    .create();
----

Here we expect to receive a message which contains Camel in the body.

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .whenAnyReceivedMatches(body().contains("Camel"))
    .create();
----

=== Using mock endpoint for fine-grained expectations

[source,java]
----
// let's use a mock to set the expressions as it got many great assertions for that
// notice we use mock:assert which does NOT exist in the route, it's just a pseudo name
MockEndpoint mock = getMockEndpoint("mock:assert");
mock.expectedBodiesReceivedInAnyOrder("Hello World", "Bye World", "Hi World");

NotifyBuilder notify = new NotifyBuilder(context)
    .from("direct:foo").whenReceivedSatisfied(mock)
    .create();
----

Here we combine a xref:components::mock-component.adoc[Mock] with the `NotifyBuilder`.
We use the mock to set fine-grained expectations such as we should receive 3 messages in any order. Then using the builder we can tell that those messages should be received from the direct:foo endpoint. You can combine multiple expressions as much as you like.
However, we suggest using the mock for fine-grained expectations that you may already know how to use. You can also specify that the Exchanges must have been sent to a given endpoint.

=== Using wereSentTo

For example in the following we expect the message to be sent to mock:bar

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .wereSentTo("mock:bar")
    .create();
----

You can combine this with any of the other expectations, such as, to only match if 3+ messages are done, and were sent to the mock:bar endpoint:

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .whenDone(3).wereSentTo("mock:bar")
    .create();
----

You can add additional `wereSentTo`, such as the following two:

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .wereSentTo("activemq:queue:foo").wereSentTo("activemq:queue:bar")
.create();
----

As well as you can expect a number of messages to be done, and a message to fail, which has to be sent to another endpoint:

[source,java]
----
NotifyBuilder notify = new NotifyBuilder(context)
    .whenDone(3).wereSentTo("activemq:queue:goodOrder")
    .and().whenFailed(1).wereSentTo("activemq:queue:badOrder")
    .create();
----
= OnCompletion

Camel has this concept of a _Unit of Work_ that encompass the
Exchange. The unit of work among others supports
synchronization callbacks that are invoked when the
Exchange is complete. The callback API is defined in
`org.apache.camel.spi.Synchronization` and the extended synchronization
`org.apache.camel.spi.SynchronizationRouteAware` that have callbacks for
route events.

== UnitOfWork API

You can get hold of the `org.apache.camel.spi.UnitOfWork` from
`org.apache.camel.Exchange` with the method `getUnitOfWork()`.

== OnCompletion DSL

The OnCompletion EIP supports the following features:

* level: context or route (route level override global level)
* triggered either always, only if completed with success, or only if failed
* `onWhen` predicate to only trigger if matched
* `mode` to define whether to run either before or after
route consumer writes response back to callee (if it is InOut) (default AfterConsumer)
* `parallelProcessing` whether to run async or sync (use a thread pool or not) (default false)

The onCompletion supports running the completion task in either synchronous or asynchronous mode
(using a thread pool) and also whether to run before or after the route
consumer is done. The reason is to give more flexibility. For example to
specify to run synchronous and before the route consumer is done, which
allows to modify the exchange before the consumer writes back any
response to the callee. You can use this to for example add customer
headers, or send to a log to log the response message, etc.

=== onCompletion with route scope

The OnCompletion EIP allows you to add custom routes/processors when
the original Exchange is complete. Camel spins off a
copy of the Exchange and routes it in a separate
thread, similar to a Wire Tap. This allows the
original thread to continue while the onCompletion route is running
concurrently. We chose this model as we did not want the
onCompletion route to interfere with the original route.

=== Multiple onCompletions

You may define multiple onCompletions at both context and route level.

When you define route level onCompletions then any context levels are disabled for that given route.

[source,java]
-----------------------------------------------------------
from("direct:start")
    .onCompletion()
        // this route is only invoked when the original route is complete as a kind
        // of completion callback
        .to("log:sync")
        .to("mock:sync")
    // must use end to denote the end of the onCompletion route
    .end()
    // here the original route contiunes
    .process(new MyProcessor())
    .to("mock:result");
-----------------------------------------------------------

By default the OnCompletion EIP will be triggered when the
Exchange is complete and regardless if the
Exchange completed with success or with a failure
(such as an Exception was thrown). You can limit the trigger to only
occur `onCompleteOnly` or by `onFailureOnly` as shown below:

[source,java]
-----------------------------------------------------------
from("direct:start")
    // here we qualify onCompletion to only invoke when the exchange failed (exception or FAULT body)
    .onCompletion().onFailureOnly()
        .to("log:sync")
        .to("mock:syncFail")
    // must use end to denote the end of the onCompletion route
    .end()    
    .onCompletion().onCompleteOnly()
        .to("log:sync")
        .to("mock:syncOK")
    .end()
    // here the original route continues
    .process(new MyProcessor())
    .to("mock:result");
-----------------------------------------------------------

You can identify if the Exchange is an
OnCompletion Exchange as Camel will add the
property `Exchange.ON_COMPLETION` with a boolean value of `true`.

=== Using onCompletion from XML DSL

The onCompletion is defined like this with XML DSL:

[source,xml]
----
<route>
    <from uri="direct:start"/>
    <!-- this onCompletion block will only be executed when the exchange is done being routed -->
    <!-- this callback is always triggered even if the exchange failed -->
    <onCompletion>
        <!-- so this is a kinda like an after completion callback -->
        <to uri="log:sync"/>
        <to uri="mock:sync"/>
    </onCompletion>
    <process ref="myProcessor"/>
    <to uri="mock:result"/>
</route>
----

And the `onCompleteOnly` and `onFailureOnly` is defined as a boolean
attribute on the `<onCompletion>` tag, so the failure example would be:

[source,xml]
----
<route>
    <from uri="direct:start"/>
    <!-- this onCompletion block will only be executed when the exchange is done being routed -->
    <!-- this callback is only triggered when the exchange failed, as we have onFailureOnly=true -->
    <onCompletion onFailureOnly="true">
        <to uri="log:sync"/>
        <to uri="mock:sync"/>
    </onCompletion>
    <process ref="myProcessor"/>
    <to uri="mock:result"/>
</route>
----

=== onCompletion with global level

This works just like the route level except from the fact that they are
defined globally. An example below:

[source,java]
----
// define a global on completion that is invoked when the exchange is done being routed
onCompletion().to("log:global").to("mock:sync");
 
from("direct:start")
    .process(new MyProcessor())
    .to("mock:result");
----

And in XML:

[source,xml]
----
<!-- this is a global onCompletion route that is invoked when any exchange is done being routed
     as a kind of after callback -->
<onCompletion>
    <to uri="log:global"/>
    <to uri="mock:sync"/>
</onCompletion>
 
<route>
    <from uri="direct:start"/>
    <process ref="myProcessor"/>
    <to uri="mock:result"/>
</route>
----

IMPORTANT: If an `onCompletion` is defined in a route, it overrides *all* global
scoped, and thus it is only the route scoped that is used. The globally
scoped are not in use.

=== Using onCompletion with onWhen predicate

As other DSL in Camel you can attach a predicate to
the `onCompletion`, so it only triggers in certain conditions, when the
predicate matches. For example to only trigger if the message body contains the word
_Hello_ we can do like:

[source,java]
----
from("direct:start")
    .onCompletion().onWhen(body().contains("Hello"))
        // this route is only invoked when the original route is done being routed
        // and the onWhen predicate is true
        .to("log:sync")
        .to("mock:sync")
    // must use end to denote the end of the onCompletion route
    .end()
    // here the original route continues
    .to("log:original")
    .to("mock:result");
----

== Using onCompletion with or without thread pool

To use a thread pool then either set a `executorService` or set
`parallelProcessing` to true.

For example in Java DSL do

[source,java]
----
onCompletion().parallelProcessing()
    .to("mock:before")
    .delay(1000)
    .setBody(simple("OnComplete:${body}"));
----

And in XML DSL:

[source,xml]
----
<onCompletion parallelProcessing="true">
  <to uri="mock:before"/>
  <delay><constant>1000</constant></delay>
  <setBody><simple>OnComplete:${body}</simple></setBody>
</onCompletion>
----

You can also refer to a specific thread pool
to be used, using the `executorServiceRef` option

[source,xml]
----
<onCompletion executorServiceRef="myThreadPool">
  <to uri="mock:before"/>
  <delay><constant>1000</constant></delay>
  <setBody><simple>OnComplete:${body}</simple></setBody>
</onCompletion>
----

=== OnCompletion consumer modes

OnCompletion supports two modes that affect the route consumer:

* AfterConsumer - Default mode which runs after the consumer is done
* BeforeConsumer - Runs before the consumer is done, and before the
consumer writes back response to the callee

The AfterConsumer mode is the default mode which is the same behavior as
in older Camel releases.

The new BeforeConsumer mode is used to run `onCompletion` before the
consumer writes its response back to the callee (if in InOut mode). This
allows the `onCompletion` to modify the Exchange, such as adding special
headers, or to log the Exchange as a response logger etc.

For example to always add a "created by" header you
use `modeBeforeConsumer()` as shown below:

[source,java]
----------------------------------------------------
.onCompletion().modeBeforeConsumer()
    .setHeader("createdBy", constant("Someone"))
.end()
----------------------------------------------------

And in XML DSL you set the mode attribute to BeforeConsumer:

[source,xml]
----
<onCompletion mode="BeforeConsumer">
  <setHeader name="createdBy">
    <constant>Someone</constant>
  </setHeader>
</onCompletion>
----

= Parameter Binding Annotations

The bean parameter binding annotations from Camel are as follows:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Annotation |Meaning |Parameter
|`org.apache.camel.Body`
|To bind to an inbound message body | 

|`org.apache.camel.Header`
|To bind to a message header |String name of the header

|`org.apache.camel.Headers`
|To bind to the Map of the message headers |

|`org.apache.camel.Variable`
|To bind to a named variable |String name of the
variable

|`org.apache.camel.Variables`
|To bind to the variables map |

|`org.apache.camel.ExchangeProperty`
|To bind to a named property on the exchange |String name of the
property

|`org.apache.camel.ExchangeProperties`
|To bind to the exchange property map on the exchange |

|`org.apache.camel.ExchangeException`
|To bind to an Exception set on the exchange |

|=======================================================================

These annotations can be used with the xref:components::bean-component.adoc[Bean]
component or when invoking beans in the xref:dsl.adoc[DSL]

Annotations can be used to define an xref:expression.adoc[Expression] or
to extract various headers, properties or payloads from a
xref:components:eips:message.adoc[Message] when invoking a bean method (see
xref:bean-integration.adoc[Bean Integration] for more detail of how to
invoke bean methods) together with being useful to help disambiguate
which method to invoke.

If no annotations are used then Camel assumes that a single parameter is
the body of the message. Camel will then use the
xref:type-converter.adoc[Type Converter] mechanism to convert from the
expression value to the actual type of the parameter.

== Using bean parameter binding annotations

In this example below we have a `@Consume` consumer (like message driven)
that consumes JMS messages from the activemq queue. We use the `@Header`
and `@Body` parameter binding annotations to bind from the JMSMessage to
the method parameters.

[source,java]
----
public class MyBean {

    @Consume("activemq:my.queue")
    public void doSomething(@Header("JMSCorrelationID") String correlationID, @Body String body) {
        // process the inbound message here
    }

}
----

In the above Camel will extract the value of
`Message.getJMSCorrelationID()`, then using the
xref:type-converter.adoc[Type Converter] to adapt the value to the type
of the parameter if required - it will inject the parameter value for
the *correlationID* parameter. Then the payload of the message will be
converted to a String and injected into the *body* parameter.

TIP: You don't necessarily need to use the `@Consume` annotation if you don't
want to as you could also make use of the Camel xref:dsl.adoc[DSL] to
route to the bean's method as well.

=== Using the DSL to invoke the bean method

Here is another example which does not use xref:pojo-consuming.adoc[POJO
Consuming] annotations but instead uses the xref:dsl.adoc[DSL] to route
messages to the bean method

[source,java]
----
public class MyBean {

    public void doSomething(@Header("JMSCorrelationID") String correlationID, @Body String body) {
        // process the inbound message here
    }

}
----

The routing DSL then looks like this

[source,java]
----
from("activemq:someQueue").
  to("bean:myBean");
----

Here *myBean* would be looked up in the xref:registry.adoc[Registry]
then the body of the message would be used to try figure out what method to call.

If you want to be explicit you can use:

[source,java]
----
from("activemq:someQueue").
  to("bean:myBean?methodName=doSomething");
----

And here we have a nifty example for you to show some great power in
Camel. You can mix and match the annotations with the normal parameters,
so we can have this example with annotations and the Exchange also:

[source,java]
----
public class MyBean {

    public void doSomething(@Header("user") String user, @Body String body, Exchange exchange) {
        exchange.getIn().setBody(body + "MyBean");
    }

}
----

=== Annotation Based Expression Language

You can also use any of the xref:languages.adoc[Languages] supported in
Camel to bind expressions to method parameters when using
xref:bean-integration.adoc[Bean Integration]. For example, you can use
any of these annotations:

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Annotation |Description
|`@Bean`
|Inject a xref:components:languages:bean-language.adoc[Bean] expression

|`@Constant`
|Inject a xref:components:languages:constant-language.adoc[Constant] expression

|`@Groovy`
|Inject a  xref:components:languages:groovy-language.adoc[Groovy] expression

|`@Header`
|Inject a xref:components:languages:header-language.adoc[Header] expression

|`@Simple`
|Inject an xref:components:languages:simple-language.adoc[Simple] expression

|`@XPath`
|Inject an xref:components:languages:xpath-language.adoc[XPath] expression

|=======================================================================

The table above only list some of the commonly used languages. You can find
a list of all supported xref:components:languages:index.adoc[Languages]
which each have their own annotation that can be used.

It is required to include the JAR of the language, for example `camel-groovy`,
or `camel-jsonpath` to use the `@JSonPath` annotation.

Here is an example how to use `@XPath`:

[source,java]
----
public class Foo {

    @Consume("activemq:my.queue")
    public void doSomething(@XPath("/foo/bar/text()") String correlationID, @Body String body) {
        // process the inbound message here
    }

}
----

==== Advanced example using @Bean

And an example of using the the `@Bean` binding annotation,
where you can call a xref:components::bean-component.adoc[POJO] to supply
the parameter value:

[source,java]
----
public class MyBean {
    
    @Consume("activemq:my.queue")
    public void doSomething(@Bean("myCorrelationIdGenerator") String correlationID, @Body String body) {
        // process the inbound message here
    }
}
----

When a message is consumed from the activemq queue, then Camel will invoke the `doSomething`
method. The parameter with `@Bean` is telling Camel to call yet another bean that
computes the correlation id parameter:

[source,java]
----
public class MyIdGenerator {

    private UserManager userManager;

    public String generate(@Header(name = "user") String user, @Body String payload) throws Exception {
       User user = userManager.lookupUser(user);
       String userId = user.getPrimaryId();
       String id = userId + generateHashCodeForPayload(payload);
       return id;
   }
}
----

The xref:components::bean-component.adoc[POJO] MyIdGenerator has one public method that
accepts two parameters. We have also annotated this one with the
`@Header` and `@Body` annotations to help Camel know what to bind here from
the Exchange being processed.

Of course this could be simplified a lot if you for instance just have a
simple id generator. But we wanted to demonstrate that you can use the
xref:bean-binding.adoc[Bean Binding] annotations anywhere.

[source,java]
----
public class MySimpleIdGenerator {

    public static int generate()  {
       // generate a unique id
       return 123;
   }
}
----

And finally we just need to remember to have our bean registered in the xref:registry.adoc[Registry]:

For example in Spring XML:

[source,xml]
----
<bean id="myCorrelationIdGenerator" class="com.mycompany.MySimpleIdGenerator"/>
----

==== Example using Groovy

In this example we have an Exchange that has a User object stored in the
in header. This User object has methods to get some user information. We
want to use xref:components:languages:groovy-language.adoc[Groovy] to inject an expression that
extracts and concats the fullname of the user into the fullName parameter.

[source,java]
----
public class MyBean {

    public void doSomething(@Groovy("$request.header['user'].firstName $request.header['user'].familyName") String fullName, @Body String body) {
        // process the inbound message here
    }

}
----

Groovy supports _GStrings_ that is like a template where we can insert `$`
placeholders that will be evaluated by Groovy.
= Pluggable Class Resolvers

Camel provides pluggable class resolvers allowing third party platforms
and containers to provide their own resolvers in case the default ones
would not fit.

When running Camel on platforms such as Spring Boot, Quarkus, or Apache Karaf,
then Camel uses platform specific resolvers to support classloading in these runtimes.

== Configuration of a custom class resolver

To instruct Camel to use your own custom class resolver, you set the
resolver on the `CamelContext` using the appropriate setters;
or register a custom resolver in the xref:registry.adoc[Registry] then Camel
will automatically detect this during startup.

=== SPI providers

Platform providers should look in the `org.apache.camel.spi` package for
the pluggable resolvers, such as:

* `ClassResolver`
* `FactoryFinderResolver`
* `PackageScanClassResolver`
* `PackageScanResourceResolver`
* `ResourceResolver`
= POJO Consuming

To consume a message you use the `@Consume`
annotation to mark a particular method of a bean as being a consumer
method. The value of the annotation defines the Camel
xref:endpoint.adoc[Endpoint] to consume from.

IMPORTANT: The `@Consume` POJO annotations are not part of any Camel routes, and you cannot use errorHandler or onException with that.

[NOTE]
====
The following steps use the ActiveMQ component which is not yet supported on Camel 4.
====

For example lets invoke the `onCheese()` method with the String body of the
inbound JMS message from ActiveMQ on the cheese
queue; this will use the xref:type-converter.adoc[Type Converter] to
convert the JMS ObjectMessage or BytesMessage to a String - or just use
a TextMessage from JMS

[source,java]
----
public class Foo {

  @Consume("activemq:cheese")
  public void onCheese(String name) {
    // do something here
  }
}
----

The xref:bean-binding.adoc[Bean Binding] is then used to convert the
inbound xref:components:eips:message.adoc[Message] to the parameter list used to invoke
the method .

This basically creates a route that looks kinda like this:

[source,java]
----
from(uri).bean(theBean, "methodName");
----

== Using a property to define the endpoint

The following annotations `@Consume`, `@Produce`, `@EndpointInject`, now
offers a `property` attribute you can use to define the endpoint as a
property on the bean. Then Camel will use the getter method to access
the property.

For example:

[source,java]
----
public class MyService {
  private String serviceEndpoint;
  
  public void setServiceEndpoint(String uri) {
     this.serviceEndpoint = uri;
  }

  public String getServiceEndpoint() {
     return serviceEndpoint;
  }

  @Consume(property = "serviceEndpoint")
  public void onService(String input) {
     // do something
  }
}
----

The bean `MyService` has a property named `serviceEndpoint` which has
getter/setter for the property. Now we want to use the bean for
xref:pojo-consuming.adoc[POJO Consuming], and hence why we use `@Consume`
in the `onService` method. Notice how we use the
`property = "serviceEndpoint` to configure the property that has the
endpoint url.

If you define the bean in Spring XML, then you can configure the property as follows:

[source,xml]
----
<bean id="myService" class="com.foo.MyService">
  <property name="serviceEndpoint" value="activemq:queue:foo"/>
</bean>
----

This allows you to configure the bean without with any dependency injection style.

=== Advanced use with property naming convention

Camel offers a naming convention which allows you to not have to
explicit name the property. Camel uses this algorithm to find the getter method.
The method must be a `getXXX` method.

. Use the property name if explicit given
. If no property name was configured, then use the method name
. Try to get the property with name**Endpoint** (eg with Endpoint as postfix)
. Try to get the property with the name as is (eg no postfix or postfix)
. If the property name starts with **on** then omit that, and try step 3 and 4 again.

So in the example above, we could have defined the `@Consume` annotation as:

[source,java]
----
  @Consume(property = "service")
  public void onService(String input) {
----

Now the property is named "service" which then would match step 3 from
the algorithm, and have Camel invoke the `getServiceEndpoint` method.

We could also have omitted the property attribute, to make it implicit

[source,java]
----
  @Consume
  public void onService(String input) {
----

Now Camel matches step 5, and loses the prefix *on* in the name, and
looks for 'service' as the property. And because there is a
`getServiceEndpoint` method, Camel will use this method.

= POJO producing

There are two different ways to send messages to any Camel
xref:endpoint.adoc[Endpoint] from a POJO:

- Using `@Produce` or `@EndpointInject`
- Or to hide using an interface

[NOTE]
====
The following steps use the ActiveMQ component which is not yet supported on Camel 4.
====

== Using @Produce

To allow sending of messages from POJOs you can use the `@Produce` annotation.
This will inject a `org.apache.camel.ProducerTemplate` so that the bean can send messages.

IMPORTANT: The `@Produce` POJO annotations are not part of any Camel routes, and you cannot use errorHandler or onException with that.

For example to send a message to the foo queue on ActiveMQ:

[source,java]
----
public class Foo {
  @Produce("activemq:foo")
  ProducerTemplate producer;

  public void doSomething() {
    if (whatever) {
      producer.sendBody("<hello>world!</hello>");
    }
  }
}
----

The downside of this is that your code is now dependent on a Camel API,
the `ProducerTemplate`. The next section describes how to remove this
dependency.

TIP: See xref:pojo-consuming.adoc[POJO Consuming] for how to use a property
on the bean as endpoint configuration, e.g., using the `property`
attribute on `@Produce` or `@EndpointInject`.

== Hiding the Camel APIs From Your Code

You can hide Camel APIs from your application code.
You can add the `@Produce` annotation to an injection
point (a field or property setter) using some interface
you use in your business logic. Example:

[source,java]
----
public interface MyListener {
    // this method is request/reply (InOut) because the method has a return value
    // to use one way (InOnly) then the method should be a void method
    String sayHello(String name);
}

public class MyBean {
    @Produce("activemq:foo")
    protected MyListener producer;

    public void doSomething() {
        // lets send a message and get a response back
        String response = producer.sayHello("James");
    }
}
----

Here Camel will automatically inject a smart client side proxy at
the `@Produce` annotation - an instance of the `MyListener`
interface.

When we invoke methods on this interface the method call is
turned into an object and is sent to the
endpoint; in this case the ActiveMQ endpoint to
queue *`foo`*. Because the `sayHello` method has a return type (`String`) then Camel
will use xref:components:eips:requestReply-eip.adoc[Request Reply] (InOut) messaging.

[source,java]
----
public interface MyListener {
    void sayHello(String name);
}
----

If the method is a `void` method, then Camel will use xref:components:eips:event-message.adoc[Event Message] (InOnly) messaging.
= Predicates

xref:expression.adoc[Expressions] and Predicates can then be used to
create the various xref:components:eips:enterprise-integration-patterns.adoc[Enterprise
Integration Patterns] in the xref:dsl.adoc[DSL] like with the xref:components:eips:choice-eip.adoc[Content Based Router] EIP.

To support dynamic rules Camel supports pluggable
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Predicate.html[Predicate]
strategies using a variety of different xref:components:languages:index.adoc[Languages].

== Predicate API

The API for a Camel Predicate is defined in the
`org.apache.camel.Predicate` interface as shown:

[source,java]
-------------------------------------------------------------------------------
public interface Predicate {

    /**
     * Evaluates the predicate on the message exchange and returns true if this
     * exchange matches the predicate
     *
     * @param exchange the message exchange
     * @return true if the predicate matches
     */
    boolean matches(Exchange exchange);

}
-------------------------------------------------------------------------------

A `Predicate` is being evaluated to a boolean value so the result is
either `true` or `false`. This makes predicates so
powerful as it is often used to control the routing of message in which
path they should be routed.

A simple example is to route an xref:exchange.adoc[Exchange] based on a
header value with the xref:components:eips:choice-eip.adoc[Content Based Router] EIP:

[source,java]
----
from("jms:queue:order")
   .choice()
      .when(header("type").isEqualTo("widget")).to("bean:widgetOrder")
      .when(header("type").isEqualTo("wombat")).to("bean:wombatOrder")
   .otherwise()
      .to("bean:miscOrder")
   .end();
----

In the route above the xref:predicate.adoc[Predicate] is the
`header("type").isEqualTo("widget")` as it is constructed as an
xref:expression.adoc[Expression] that is evaluated as a
xref:predicate.adoc[Predicate]. To do this the various _Builder classes_
help us here to create a nice and fluent syntax. `isEqualTo` is a
builder method that returns a xref:predicate.adoc[Predicate] based on
the input.

Sometimes the fluent builders can get long, and a bit complex to read,
then you can just define your predicate outside the route and then just
refer to the predicate in the route:

[source,java]
----
Predicate isWidget = header("type").isEqualTo("widget");
----

And then you can refer to it in the route as:

[source,java]
----
from("jms:queue:order")
   .choice()
      .when(isWidget).to("bean:widgetOrder")
      .when(isWombat).to("bean:wombatOrder")
   .otherwise()
      .to("bean:miscOrder")
   .end();
----

== Negating a Predicate

You can use the *not* method on the `PredicateBuilder` to negate a
predicate.

First, we import the static method `not`, so it makes our route nice and easy to
read:

[source,java]
----
import static org.apache.camel.builder.PredicateBuilder.not;
----

And then we can use it to enclose an existing predicate and negate it as
the example shows:

[source,java]
----
from("direct:start")
    .choice()
        .when(not(header("username").regex("goofy|pluto"))).to("mock:people")
        .otherwise().to("mock:animals")
    .end();
----

== Compound Predicates

You can also create compound predicates using boolean operators such as
`and, or, not` and many others.

Currently, this feature is only available in the Java-based DSLs, and not
in other DSLs such as XML.

Using the
https://www.javadoc.io/doc/org.apache.camel/camel-support/current/org/apache/camel/support/builder/PredicateBuilder.html[`PredicateBuilder`] class,
you can combine predicates *from different Expression Languages* based on logical operators and comparison operators:

* `not`, `and`, `or`
* `isNull`, `isNotNull`
* `isEqualTo`, `isGreaterThan`, `isLessThan`
* `startsWith`, `endsWith`
* `in` ("any of X predicates stands true")

Additionally, with `PredicateBuilder` you can create regular expressions
and use them as predicates, applying them to the result of an
expression, e.g.

[source,java]
----
PredicateBuilder.regex(header("foo"), "\d\{4}");
----
applies the regular expression to the foo header.

Combining different Expression Languages is also possible, e.g.:

[source,java]
----
PredicateBuilder.and(XPathBuilder.xpath("/bookings/flights"), simple("${exchangeProperty.country = 'Spain'}"))
----

The sample below demonstrates further use cases:

[source,java]
----
// We define 3 predicates based on some user roles
// we have static imported and/or from org.apache.camel.builder.PredicateBuilder

// First we have a regular user that is just identified having a username header
Predicate user = header("username").isNotNull();

// The admin user must be a user AND have a admin header as true
Predicate admin = and(user, header("admin").isEqualTo("true"));

// And God must be an admin and (either have type god or a special message containing Camel Rider)
Predicate god = and(admin, or(body().contains("Camel Rider"), header("type").isEqualTo("god")));

// As you can see with the predicates above we can stack them to build compound predicates

// In our route below we can create a nice content based router based on the predicates we
// have defined. Then the route is easy to read and understand.
// We encourage you to define complex predicates outside the fluent router builder as
// it will just get a bit complex for humans to read
from("direct:start").choice()
    .when(god).to("mock:god")
    .when(admin).to("mock:admin")
    .when(user).to("mock:user")
    .otherwise().to("mock:guest")
.end();
----

= Processor

The
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/Processor.html[Processor]
interface is used to implement consumers of message exchanges or to
implement a xref:components:eips:message-translator.adoc[Message Translator],
and other use-cases.

== Using a processor in a route

Once you have written a class which implements processor like this:

[source,java]
----
public class MyProcessor implements Processor {

    public void process(Exchange exchange) throws Exception {
        // do something...
    }

}
----

Then you can easily call this processor from a Java such as:

[source,java]
----
from("activemq:myQueue").process(new MyProcessor());
----

Notice that the processor is referred to by the class type `MyProcessor.class` in the route.
Camel will during startup automatic create one new instance of the processor using xref:injector.adoc[Injector]
to be used during routing messages.

In XML DSL however the `<process`> tag requires, referring to an existing processor instance
which can be done:

You can then easily use this inside a route by declaring the bean in
Spring, say via the XML:

[source,xml]
----
<bean id="myProcessor" class="com.acme.MyProcessor"/>
----

And then use the bean id in the Camel route:

[source,xml]
----
<route>
  <from uri="activemq:myQueue"/>
  <process ref="myProcessor"/>
</route>
----

And in Java DSL:

[source,java]
----
from("activemq:myQueue").process("myProcessor");
----

=== Referring to beans using #class syntax

In XML DSL you can also refer to the processor by its class name using `#class:` as prefix as shown:

[source,xml]
----
<route>
  <from uri="activemq:myQueue"/>
  <process ref="#class:com.acme.MyProcessor"/>
</route>
----

This also works in Java DSL:

[source,java]
----
from("activemq:myQueue").process("#class:com.acme.MyProcessor");
----

NOTE: For more details about the `#class:` prefix (and others) then see xref:property-binding.adoc[Property Binding].

However in Java DSL you would often use the type safe way and instantiate the Processor directly as previously shown:

[source,java]
----
from("activemq:myQueue").process(new MyProcessor());
----


== Why use process when you can use to instead?

The process can be used in routes as an anonymous inner class such:

[source,java]
----
    from("activemq:myQueue").process(new Processor() {
        public void process(Exchange exchange) throws Exception {
            String payload = exchange.getIn().getBody(String.class);
            // do something with the payload and/or exchange here
           exchange.getIn().setBody("Changed body");
       }
    }).to("activemq:myOtherQueue");
----

This is usable for quickly whirling up some code. If the code in the
inner class gets a bit more complicated it is of course advised to
refactor it into a separate class. This approach is better if you do not want to use this processor again.
From reusability perspective, it is not recommended to use this approach with anonymous inner classes.

== See Also

** xref:manual::consumertemplate.adoc[Consumer Template]: to learn how to consume data (including within processors)
** xref:manual::producertemplate.adoc[Producer Template]: to learn how to produce data (including within processors)
= ProducerTemplate

The `ProducerTemplate` interface allows you to send message exchanges to
endpoints in a variety of different ways to make it easy to work with
Camel xref:endpoint.adoc[Endpoint] instances from Java code.

It can be configured with a default endpoint if you just want to send
lots of messages to the same endpoint; or you can specify an
xref:endpoint.adoc[Endpoint] or uri as the first parameter.

The `sendBody()` method allows you to send any object to an endpoint
easily as shown:

[source,java]
----
ProducerTemplate template = exchange.getContext().createProducerTemplate();

// send to default endpoint
template.sendBody("<hello>world!</hello>");

// send to a specific queue
template.sendBody("activemq:MyQueue", "<hello>world!</hello>");

// send with a body and header
template.sendBodyAndHeader("activemq:MyQueue",
   "<hello>world!</hello>",
   "CustomerRating", "Gold");
----

You can also supply an `Exchange` or a `Processor` to customize the exchange.

== Send vs Request methods

The `ProducerTemplate` supports xref:exchange-pattern.adoc[Message Exchange Patterns] (MEP)
that are used to control the messaging style to use:

* _send methods_ - xref:components:eips:event-message.adoc[Event Message] (InOnly)
* _request methods_ - xref:components:eips:requestReply-eip.adoc[Request Reply] (InOut)

In other words, all the methods on the `ProducerTemplate` that starts with `sendXXX` are for InOnly messaging,
and all the methods starting with `requestXXX` are for InOut messaging.

Lets see an example where we invoke an endpoint to get the response (InOut):

[source,java]
----
Object response = template.requestBody("<hello/>");

// you can type convert the response to what you want such as String
String ret = template.requestBody("<hello/>", String.class);

// or specify the endpoint uri in the method
String ret = template.requestBody("cxf:bean:HelloWorldService", "<hello/>", String.class);
----

== Fluent interface

The `FluentProducerTemplate` provides a fluent syntax over the regular `ProducerTemplate`.

Here are some examples:

=== Set headers and body

This is the most common style with fluent builders to set headers, and message body as show:

[source,java]
----
Integer result = FluentProducerTemplate.on(context)
    .withHeader("key-1", "value-1")
    .withHeader("key-2", "value-2")
    .withBody("Hello")
    .to("direct:inout")
    .request(Integer.class);
----

=== Using a processor

Here we use xref:processor.adoc[Processor] to prepare the message to be sent.

[source,java]
----
Integer result = FluentProducerTemplate.on(context)
    .withProcessor(exchange -> exchange.getIn().setBody("Hello World"))
    .to("direct:exception")
    .request(Integer.class);
----

=== Advanced with a template customizer

This is rarely in use, but a `TemplateCustomizer` can be used for advanced use-cases
to control various aspects of the `FluentProducerTemplate` such as configuring to use a custom thread pool:

[source,java]
----
Object result = FluentProducerTemplate.on(context)
    .withTemplateCustomizer(
        template -> {
            template.setExecutorService(myExecutor);
            template.setMaximumCacheSize(10);
        }
    )
    .withBody("the body")
    .to("direct:start")
    .request();
----

== See Also

See xref:consumertemplate.adoc[ConsumerTemplate]= Property binding in Camel

Camel supports binding property values (key=value) in many places such as configuration of Camel
components, endpoints, EIPs, routes, and Camel bootstrap configuration.

Together with property placeholders, property placeholder functions, then there is plenty of power, but also
something that takes a little learning to master.

== Property binding features

The core of Camels property binding is implemented in `PropertyBindingSupport.java` which is used internally in Camel,
and as well can be used by Camel component developers.

The `PropertyBindingSupport` class supports binding String valued properties to an instance which uses a set of conventions:

- _property placeholders_ - Keys and values using Camels property placeholder will be resolved.
- _nested_ - Properties can be nested using the dot syntax (OGNL and builder pattern using with as prefix), eg `foo.bar=123`.
- _map_ - Properties can lookup in Map's using map syntax, eg `foo[bar]` where foo is the name of the property that is a Map instance, and bar is the name of the key.
- _list_ - Properties can refer or add to in List's using list syntax, eg `foo[0]` where foo is the name of the property that is a List instance, and 0 is the index. To refer to the last element, then use `last` as key.
- _reference by property placeholder id_ - Values can refer to a property placeholder key with `#property:myKey`
- _reference by bean id_ - Values can refer to other beans in the registry by prefixing with `#` or `#bean:` eg `#myBean` or `#bean:myBean`. It is recommended to favour using `#bean:` syntax to make it obvious it's a bean reference.
- _reference by type_ - Values can refer to singleton beans by their type in the registry by prefixing with `#type:` syntax, eg `#type:com.foo.MyClassType`.
- _autowire by type_ - Values can refer to singleton beans by auto wiring by setting the value to `#autowired`.
- _reference new class_ - Values can refer to creating new beans by their class name by prefixing with `#class`, eg `#class:com.foo.MyClassType`.
       The class is created using a default no-arg constructor, however if you need to create the instance via a factory method
       then you specify the method as shown: `#class:com.foo.MyClassType#myFactoryMethod`.
       And if the factory method requires parameters they can be specified as follows:
       `#class:com.foo.MyClassType#myFactoryMethod('Hello World', 5, true)`.
       Or if you need to create the instance via constructor parameters then you can specify the parameters as shown:
       `#class:com.foo.MyClass('Hello World', 5, true)`.
       If the factory method is on another bean or class, then you must specify this as shown:
       `#class:com.foo.MyClassType#com.foo.MyFactory:myFactoryMethod`. Where `com.foo.MyFactory` either refers to a FQN classname,
       or can refer to an existing bean by id, such as: `#class:com.foo.MyClassType#myFactoryBean:myFactoryMethod`.
- _valueAs(type):value_ - To declare that the value should be converted to the given type, such as `#valueAs(int):123`
       which indicates that the value 123 should be converted to an integer.
- _ignore case_ - Whether to ignore case for property keys (will ignore by default)

== Property binding basics

Do not get overwhelmed by the set of features and what they really do.

At the basics the property binding are used for setting values on Java objects from string values (key=value).

For example to set brokers on the Kafka component you can do:

[source,properties]
----
camel.component.kafka.brokers = mykafka1,mykafka2
----

This will essentially be equivalent to configuring Kafka component in regular Java code via setters:

[source,java]
----
KafkaComponent kafka = ...
kafka.setBrokers("mykafka1,mykafka2");
----

NOTE: For configuring Camel components in Java code, there is also xref:component-dsl.adoc[Component DSL].

The configuration of Camel components, endpoints, routes etc can often require more flexibility and therefore
the property binding has many features to bind by looking up existing objects by id, or anonymously by their type,
and as well to walk down an object graph to bind nested parameters.

== Using PropertyBindingSupport in Java

Although `PropertyBindingSupport` is not primary intended for end users to use, but nevertheless its possible to use,
and also you may get a better understanding of this feature by seeing how this class is used with pure Java.

Suppose we have the following two POJOs `Foo.java` and `Bar.java`:

[source,java]
----
public class Foo {
    private String name;
    private Bar bar = new Bar();

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Bar getBar() {
        return bar;
    }

    public void setBar(Bar bar) {
        this.bar = bar;
    }
}

public class Bar {
    private int age;
    private boolean rider;

    public int getAge() {
        return age;
    }

    public boolean isRider() {
        return rider;
    }

    // this has no setter but only builders and mix the builders with both styles

    public Bar withAge(int age) {
        this.age = age;
        return this;
    }

    public Bar withRider(boolean rider) {
        this.rider = rider;
        return this;
    }
}
----

Then we can use `PropertyBindingSupport` to bind properties to these POJOs:

[source,java]
----
Foo foo = new Foo();

Map<String, Object> prop = new HashMap<>();
prop.put("name", "James");
prop.put("bar.age", "33");
prop.put("bar.rider", "true");

PropertyBindingSupport.bindProperties(context, foo, prop);
----

This will then set the POJOs to have the following values:

----
Foo.name = James
Foo.Bar.age = 33
Foo.Bar.rider = true
----

Instead of providing a map with all the parameters then a single parameter can also be set using builder style as shown:

[source,java]
----
Foo foo = new Foo();

PropertyBindingSupport.build().bind(context, foo, "name", "James");
PropertyBindingSupport.build().bind(context, foo, "bar.age", "33");
PropertyBindingSupport.build().bind(context, foo, "bar.rider", "true");
----

Which is more common to do as follows:

[source,java]
----
Foo foo = new Foo();

PropertyBindingSupport.build().withCamelContext(context).withTarget(foo)
    .withProperty("name", "James");
    .withProperty("bar.age", "33");
    .withProperty("bar.rider", "true")
    .bind();
----

In the example above then we are setting nested values on foo via `bar.age` and `bar.rider`. This is possible because
Foo class has a `getBar` method that returns the `Bar` instance to use:

[source,java]
----
    private Bar bar = new Bar();

    public Bar getBar() {
        return bar;
    }
----

It's a common practice for POJO classes to not create nested instances, but instead on demand. So suppose
`private Bar bar = new Bar();` was not present in the Foo class. In this situation then Camel will automatic
create a new instance of `Bar` using its default no-arg constructor. For more advanced use-cases then you
can specify how the Bar instance should be created, such as via a factory method, or pass in constructor parameters.

For example suppose Bar has a constructor parameter that accepts a boolean, we can pass that information via `#class:` as shown:

[source,java]
----
PropertyBindingSupport.build().withCamelContext(context).withTarget(foo)
    .withProperty("name", "James");
    .withProperty("bar", "#class:com.mycompany.Bar(true)")
    .withProperty("bar.age", "33");
    .withProperty("bar.rider", "true")
    .bind();
----

=== Using fluent builder class

When you are in need to configure a bean via _fluent builder class_, such as the following example:

[source,java]
----
public class MyDriverBuilder {

 private String url;
 private String username;
 private String password;

 public MyDriverBuilder url(String url) {
     this.url = url;
     return this;
 }

 public MyDriverBuilder username(String username) {
     this.username = username;
     return this;
 }

 public MyDriverBuilder password(String password) {
     this.password = password;
     return this;
 }

 public MyDriver build() {
     return new MyDriver(url, username, password);
 }
}
----

And you want to create an instance of `MyDriver` via the `MyDriverBuilder` class, then this can be done as follows:

[source,java]
----
MyDriver driver = PropertyBindingSupport.build()
  .withCamelContext(context)
  .withTarget(new MyDriverBuilder())
  .withFluentBuilder(true)
  .withProperty("url", "localhost:1234")
  .withProperty("username", "scott")
  .withProperty("password", "tiger")
  .build(MyDriver.class);
----

Notice how we use the `build(MyDriver.class)` to build the bean via the target class `.withTarget(new MyDriverBuilder())`.
The build method will by default invoke `build` as the builder method, but you can specify the name, such as `.build(MyDriver.class, "myBuilderMethod");`


== More details

Property binding is notably used when running Camel in standalone mode with Camel Main, or using Camel Spring Boot, Camel K,
Camel Kafka Connector, or Camel Quarkus. All these runtimes have a similar way of configuring via property bindings such
as from `application.properties` files.

See more at xref:components:others:main.adoc[Camel Main]
= Registry

The `org.apache.camel.spi.Registry` API is a common API to lookup beans in any kind of runtime platform,
whether you run Camel on Spring Boot, Quarkus, Standalone, Kafka or something else.

Camel uses the `DefaultRegistry` that based on which runtime used (Spring Boot, Quarkus, etc.) will
first look up beans from the runtime platform, and fallback to Camel's own `SimpleRegistry`.

== Registry API

The registry has two sets of APIs:

- binding
- lookup

The binding API is used to add new beans into the registry.
The lookup is used for looking up existing beans from the registry.

=== Binding API

The binding API is as follows:

[source,java]
----
public interface Registry extends BeanRepository {

    /**
     * Binds the bean to the repository (if possible).
     * If the bean is CamelContextAware then the registry will automatic inject the context if possible.
     *
     * @param  id    the id of the bean
     * @param  bean  the bean
     */
    void bind(String id, Object bean);

    /**
     * Binds the bean to the repository (if possible).
     * Binding by id and type allows to bind multiple entries with the same id but with different type.
     * If the bean is CamelContextAware then the registry will automatic inject the context if possible.
     *
     * @param  id    the id of the bean
     * @param  type  the type of the bean to associate the binding
     * @param  bean  the bean
     */
    void bind(String id, Class<?> type, Object bean);

}
----

If you, for example, need to add a bean to the `Registry` then you can easily do this from Java as follows:

[source,java]
----
Object myFoo = ...
camelContext.getRegistry().bind("foo", myFoo);
----

Then you can access the bean by the id, such as from a Camel route:

[source,java]
----
from("jms:cheese").bean("foo");
----

==== Binding in Spring XML

If you use the Spring XML file, then any `<bean>` is automatic handled by Spring itself, and
registered into Spring bean container; which means there is no need to bind the bean from Camel also.

[source,xml]
----
<bean id="foo" class="com.foo.MyFoo"/>
----

==== Binding in Spring Boot

When using Spring Boot, then you can also use annotations to declare beans
such as with the `@Bean` annotation on the method that creates the bean:

[source,java]
----
@Bean
public MyFoo foo() {
    return new MyFoo();
}
----

This is a common functionality of Spring Boot, and you can find information about this in
the Spring Boot project documentation.

==== Binding in Quarkus

Quarkus has similar functionality like Spring Boot to declare beans, which can be done
with the `javax.inject.enterprise.Produces` and `javax.inject.Named` annotations:

[source,java]
----
@Produces @Named("foo")
public MyFoo foo() {
    return new MyFoo();
}
----

== Lookup API

Registry is mostly used for looking up beans by their IDs, or by type. This is heavily used
during startup of Camel where Camel is wiring up all components, endpoints, routes, processors, beans and so forth.

The lookup API is the following methods:

[source,java]
----
public interface BeanRepository {

    /**
     * Looks up a bean in the registry based purely on name, returning the bean or null if it could not be found.
     *
     * Important: Multiple beans of different types may be bound with the same name, and its encouraged to use the
     * lookupByNameAndType(String, Class) to lookup the bean with a specific type, or to use any of the
     * find methods.
     *
     * @param  name the name of the bean
     * @return      the bean from the registry or null if it could not be found
     */
    Object lookupByName(String name);

    /**
     * Looks up a bean in the registry, returning the bean or null if it could not be found.
     *
     * @param  name the name of the bean
     * @param  type the type of the required bean
     * @return      the bean from the registry or null if it could not be found
     */
    <T> T lookupByNameAndType(String name, Class<T> type);

    /**
     * Finds beans in the registry by their type.
     *
     * @param  type the type of the beans
     * @return      the types found, with their bean ids as the key. Returns an empty Map if none found.
     */
    <T> Map<String, T> findByTypeWithName(Class<T> type);

    /**
     * Finds beans in the registry by their type.
     *
     * @param  type the type of the beans
     * @return      the types found. Returns an empty Set if none found.
     */
    <T> Set<T> findByType(Class<T> type);

}
----

You can lookup beans from Java code as shown:

[source,java]
----
// lookup by id only
Object foo = camelContext.getRegistry().lookupByName("foo");

// lookup by type so there is no need for type casting
MyFoo foo2 = camelContext.getRegistry().lookupByNameAndType("foo", MyFoo.class);
----

=== Looking up beans

You can also use dependency injection that will look up the bean via the Camel registry.
If you use a runtime platform such as Spring Boot or Quarkus, then they come with their own
functionality for this. Camel also has its own bean injection annotation `@BeanInject` which can
be used when running Camel standalone.

NOTE: You can also use `@BeanInject` from Camel in Spring Boot or Quarkus;
but this requires the class with the bean injection is _managed_ by Camel (such as a `RouteBuilder` class);
which may not always be the case. Therefore, it is best to only use the Spring Boot or Quarkus annotations.

==== Lookup in Spring Boot

When using Spring Boot, you can use Spring annotations such as `@Autowired` or `@Inject`
for dependency injection.

==== Lookup in Quarkus

When using Quarkus, you can use CDI annotations such as `@Inject` and `@Named`
for dependency injection.

== More Information

See xref:bean-injection.adoc[Bean Injection] and xref:bean-integration.adoc[Bean Integration]
for more details on working with Beans in Camel.

= Updating the website after a release

Most steps are the same for all releases, although some details may vary.
There are several cases:

* A single repository release, such as `camel-kafka-connector`.
* A set of separately versioned repositories, such as `camel-k`, `camel-k-runtime`, and `camel-kamelets`.
* The set of main `camel` and `camel-spring-boot` which are versioned together.

Changes in the content repositories may be done as part of release preparation, or later. Changes in the `camel-website` `antora-playbook.yml` can be supplied in a PR at any time but should be merged only after the release is voted on and approved.

We'll use the notation `<repo short name>:<path>` to indicate the file to be changed.
For instance, `camel:docs/components/antora.yml` for the `docs/components/antora.yml` component descriptor in the main camel repository, in whatever branch is under discussion.

//== Notes on versions
//
//Within an Antora component, xrefs to content in the same component, whether they are in the same source tree or repository, should never include the `version` or `component` segment of the page id.
//Including the version will make the page non-relocatable to another version: for instance specifying `next` in the main branch will break the link when main is branched for a release.
//Including the `component` segment will redirect to the (Antora) latest version, which will typically be the last released version.
//
//Antora calculates the latest version as the last non-prerelease version.
//Since we are marking the main branch as prerelease, this will never be the main branch.

== After the new release, branches are created in all affected content repositories

These will always be branches from `main`.
Changes to all the new branches, e.g. `camel-3.13.x`, will be necessary.
The changes are almost the same whether the new branch is LTS or not.

=== Changes to the new branches (e.g. `camel-3.13.x`) in affected content repositories

. Examine the `content:sources` key of the `camel-website:antora-playbook.yml` and locate the URLs of the repositories.
. For each URL, locate the `start_path` or `start_paths` key.
. For each start path entry, locate the `antora.yml` component descriptor at that path in the new branch in the repository.
For each Antora component, exactly one of the associated component descriptors will have additional information beyond the name and version.
The version will need to be updated in all associated component descriptors, and the additional information only in the one containing it.
The primary component descriptor, having been duplicated from `main`, will specify version `next` and related properties, and will look something like this:
+
[source,yaml]
----
name: camel-kafka-connector
title: Camel Kafka Connector
version: next
prerelease: true
display-version: Next (Pre-release)

nav:
- modules/ROOT/nav.adoc

asciidoc:
  attributes:
    camel-version: 3.12.x
    camel-k-runtime-version: 1.8.0
    camel-kamelets-version: 0.3.0
    prerelease: true
----
. Set the version to the documentation version for the new release, e.g. `0.11.0`.
. Remove the top level `prerelease` key.
. If the new release is LTS, set the `display-version` appropriately, e.g. `0.11.0 (LTS)`: otherwise remove the `display-version` key.
. Consider the versions listed in `asciidoc/attributes`.
These represent the other camel subprojects this one depends on.
** For subprojects outside the current release set, these will not change on release.
** For subprojects in the same release set, such as `camel` and `camel-spring-boot`, these versions will need to be updated to refer to the new version of the other subproject.
. Remove `prerelease` from `asciidoc/attributes`.
. If the release is LTS, add an `lts` attribute specifying the date out of service.
. Find the `source-map.yml` file next to the `antora.yml` component descriptor.
It will look something like this:
+
--
[source,yml]
----
    - require: '@djencks/antora-source-map'
#      log_level: trace
      source-map:
        - url: 'https://github.com/apache/camel-kamelets.git'
          mapped-url: './../camel-kamelets'
          branches:
            - branch: main
              mapped-branch: HEAD
----
--
Change the `- branch: main` to specify the branch being released, e.g. `- branch: 0.6.x`.
. Build each project (e.g. `mvn clean install -Pfastinstall`) and check for generated changes that need to be committed (or undone if there are tooling problems).
. There will also be `local-build.sh`, `source-map.yml`, and `source-watch.yml` files in the docs directory of the subproject.
These files support xref:improving-the-documentation.adoc#_local_build_instructions[local partial builds of the subproject].
In `source-map.yml`, change the `branch` value from `main` to the new git branch name for the release.

Since the branches with these changes have not yet been added to the Antora playbook, they may be kept on a PR fork/branch or merged into the release branch locally or in the repository.

=== Playbook changes

These changes must go through a PR before being merged, and it is highly advisable to build the website locally to check for problems.

. As in the previous section, examine the `content:sources` key of the `camel-website:antora-playbook.yml` and locate the URLs of the repositories.
. Under `branches` add the new branch directly under `main`, so the branches appear in reverse chronological order, newest first.
Note that this is the git branch name, which is related to but usually not identical to the Antora component version.
. Consult these xref:improving-the-documentation.adoc#_local_build_instructions[local build instructions].
. Consult these xref:improving-the-documentation.adoc#_creating_a_documentation_pull_request[instructions for creating a documentation PR].
Note that your `camel-website` PR will definitely need to be merged after removing the `source-map` extension configuration used to preview the website changes.

=== Notes for specific projects

==== camel-quarkus

Many of the versions in the `antora.yml` component descriptor are set by the maven build from `pom.xml` properties.
Check that these have appropriate values after running the build.
If the build sets inappropriate values, consider fixing or disabling the groovy script.

== Removing obsolete component versions

After each release, it may be possible to remove old versions of the documentation from subprojects.
This depends on whether any current versions of other subprojects depend on the old subproject versions.

The experimental approach is to remove the old branches from the playbook and build the site.
If there are errors from broken xrefs pointing to the removed version, put them back.

You can also examine the component descriptors of older versions of subprojects that depend on the current subproject,
but it is not obvious how to determine which these are without looking at all of them.
= Release Guide

This guide covers how to create and announce a Camel release.
Instructions on updating the website to include the new documentation version are xref:release-guide-website.adoc[here].

[[ReleaseGuide-Prequisites]]
== Prequisites

To prepare or perform a release, you *must be* at least an Apache Camel committer.

* The artifacts for each and every release must be *signed*.
* Your public key must be added to the KEYS file.
* Your public key should also be cross-signed by other Apache committers (this can be done at key signing parties at
ApacheCon, for instance).
* Make sure you have the correct maven configuration in `~/.m2/settings.xml`.
* https://github.com/takari/maven-wrapper[Maven Wrapper] is used and bundled with Camel 2.21 onwards and should be used
for building the release.
* You may want to get familiar with the release settings in the parent Apache POM.
* Make sure you are using Java 11 for Apache Camel 3 and Java 21 for Apache Camel 4.

[[ReleaseGuide-MavenSetup]]
== Maven Setup
Before you deploy anything to the https://repository.apache.org[Apache Nexus repository] using Maven, you should
configure your `~/.m2/settings.xml` file so that the file permissions of the deployed artifacts are group-writable.
If you do not do this, other developers will not be able to overwrite your SNAPSHOT releases with newer versions.

The settings follow the guidelines used by the Maven project. Please pay particular attention to the
http://maven.apache.org/guides/mini/guide-encryption.html[password encryption recommendations].

[source,xml]
----
<settings>
  ...
  <servers>
    <!-- Per http://maven.apache.org/developers/committer-settings.html -->

    <!-- To publish a snapshot of some part of Maven -->
    <server>
      <id>apache.snapshots.https</id>
      <username> <!-- YOUR APACHE LDAP USERNAME --> </username>
      <password> <!-- YOUR APACHE LDAP PASSWORD --> </password>
    </server>
    <!-- To publish a website of some part of Maven -->
    <server>
      <id>apache.website</id>
      <username> <!-- YOUR APACHE LDAP USERNAME --> </username>
      <filePermissions>664</filePermissions>
      <directoryPermissions>775</directoryPermissions>
    </server>
    <!-- To stage a release of some part of Maven -->
    <server>
      <id>apache.releases.https</id>
      <username> <!-- YOUR APACHE LDAP USERNAME --> </username>
      <password> <!-- YOUR APACHE LDAP PASSWORD --> </password>
    </server>
    <!-- To stage a website of some part of Maven -->
    <server>
      <id>stagingSite</id> <!-- must match hard-coded repository identifier in site:stage-deploy -->
      <username> <!-- YOUR APACHE LDAP USERNAME --> </username>
      <filePermissions>664</filePermissions>
      <directoryPermissions>775</directoryPermissions>
    </server>

  </servers>
  ...
  <profiles>
    <profile>
      <id>release</id>
      <properties>
        <gpg.useagent>false</gpg.useagent>
        <gpg.passphrase><!-- YOUR GPG PASSPHRASE --></gpg.passphrase>
        <test>false</test>
      </properties>
    </profile>

  </profiles>
...
</settings>
----

[[ReleaseGuide-CreatingTheRelease-Camel]]
== Creating the Release

Complete the following steps to create a new Camel release:

. Grab the latest source from Git, checkout the target branch (`BRANCH_NAME`) to build from, and create a release branch off of that branch:

  
  $ git clone https://git-wip-us.apache.org/repos/asf/camel.git
  $ cd camel
  $ git checkout BRANCH_NAME
  $ git checkout -b release/NEW-VERSION

. Perform a license check with http://creadur.apache.org/rat/apache-rat-plugin[Apache Rat]:

  
  ./mvnw -e org.apache.rat:apache-rat-plugin:check
  grep -e ' !?????' target/rat.txt
  

*  The latter command will provide a list of all files without valid license headers.
  Ideally this list is empty, otherwise fix the issues by adding valid license headers and rerun the above commands before
  proceeding with the next step.

. Do a release dry run to check for problems:

  
  ./mvnw release:prepare -DdryRun -Prelease
  

* The release plugin will prompt for a release version, an SCM tag and the next release version.

*  Use a three digit release version of the form: `MAJOR.MINOR.PATCH`, e.g. `3.0.0`.

*  For the tag use a string of the form: `camel-MAJOR.MINOR.PATCH`, e.g. `camel-3.0.0`.

*  For the next version increase the patch version and append `-SNAPSHOT`, e.g. `3.0.1-SNAPSHOT`.

* Make sure to check the generated signature files:

  
  $ gpg camel-core/target/camel-core-3.0.0-SNAPSHOT.jar.asc
  gpg: assuming signed data in `camel-core/target/camel-core-3.0.0.jar'
  gpg: Signature made Sat 06 Apr 2019 03:58:01 AM PDT using RSA key ID 5942C049
  gpg: Good signature from "Gregor Zurowski <gzurowski@apache.org>"
 

. Prepare the release:

* First clean up the dry run results:


  $ ./mvnw release:clean -Prelease


* Next prepare the release:


  $ ./mvnw release:prepare -Prelease


*  This command will create the tag and update all pom files with the given version number.

. Perform the release and publish to the Apache staging repository:


  $ ./mvnw release:perform -Prelease


. Close the Apache staging repository:

* Login to https://repository.apache.org using your Apache LDAP credentials.
Click on "Staging Repositories". Then select "org.apache.camel-xxx" in the list of repositories, where xxx represents
your username and ip.
Click "Close" on the toolbar above.
This will close the repository from future deployments and make it available for others to view.
If you are staging multiple releases together, skip this step until you have staged everything.
Enter the name and version of the artifact being released in the "Description" field and then click "Close".
This will make it easier to identify it later.

. Verify staged artifacts:

* If you click on your repository, a tree view will appear below.
You can then browse the contents to ensure the artifacts are as you expect them.
Pay particular attention to the existence of *.asc (signature) files.
If you don't like the content of the repository, right-click your repository and choose "Drop".
You can then roll back your release and repeat the process.
Note the repository URL, you will need this in your vote email.

[[ReleaseGuide-CreatingTheRelease-Camel-spring-boot]]
== Creating the Release for camel-spring-boot

Complete the following steps to create a new Camel-spring-boot release:

. Grab the latest source from Git and checkout the target branch (`BRANCH_NAME`) to build from:

  $ git clone https://git-wip-us.apache.org/repos/asf/camel-spring-boot.git
  $ cd camel
  $ git checkout BRANCH_NAME

. From Camel 3.3.0 ahead, the camel-spring-boot project uses camel-dependencies as parent.
You'll need to set the version here https://github.com/apache/camel-spring-boot/blob/master/pom.xml#L26
To the version released from the main Camel repository as the first step.
  
. Perform a license check with http://creadur.apache.org/rat/apache-rat-plugin[Apache Rat]:

  ./mvnw -e org.apache.rat:apache-rat-plugin:check
  grep -e ' !?????' target/rat.txt
  
*  The latter command will provide a list of all files without valid license headers.
  Ideally this list is empty, otherwise fix the issues by adding valid license headers and rerun the above commands before
  proceeding with the next step.

. You already have built the main camel repo for releasing, so you already have a final version in your local repository.
Change the camel-version property in https://github.com/apache/camel-spring-boot/blob/master/pom.xml accordingly and commit.

. Do a release dry run to check for problems:

  ./mvnw release:prepare -DdryRun -Prelease
  
 * The release plugin will prompt for a release version, an SCM tag and the next release version.

*  Use a three digit release version of the form: `MAJOR.MINOR.PATCH`, e.g. `3.0.0`.

*  For the tag use a string of the form: `camel-MAJOR.MINOR.PATCH`, e.g. `camel-3.0.0`.

*  For the next version increase the patch version and append `-SNAPSHOT`, e.g. `3.0.1-SNAPSHOT`.

* Make sure to check the generated signature files:

  $ gpg core/camel-spring-boot/target/camel-spring-boot-3.0.0-SNAPSHOT.jar.asc
  gpg: assuming signed data in `core/camel-spring-boot/target/camel-spring-boot-3.0.0-SNAPSHOT.jar'
  gpg: Signature made Sat 06 Apr 2019 03:58:01 AM PDT using RSA key ID 5942C049
  gpg: Good signature from "Gregor Zurowski <gzurowski@apache.org>"
 
. Prepare the release:

* First clean up the dry run results:

  $ ./mvnw release:clean -Prelease

* Next prepare the release:

  $ ./mvnw release:prepare -Prelease

*  This command will create the tag and update all pom files with the given version number.

. Perform the release and publish to the Apache staging repository:

  $ ./mvnw release:perform -Prelease

. Close the Apache staging repository:

* Login to https://repository.apache.org using your Apache LDAP credentials.
Click on "Staging Repositories". Then select "org.apache.camel-xxx" in the list of repositories, where xxx represents
your username and ip.
Click "Close" on the tool bar above.
This will close the repository from future deployments and make it available for others to view.
If you are staging multiple releases together, skip this step until you have staged everything.
Enter the name and version of the artifact being released in the "Description" field and then click "Close".
This will make it easier to identify it later.

. Verify staged artifacts:

* If you click on your repository, a tree view will appear below.
You can then browse the contents to ensure the artifacts are as you expect them.
Pay particular attention to the existence of *.asc (signature) files.
If you don't like the content of the repository, right-click your repository and choose "Drop".
You can then roll back your release and repeat the process.
Note the repository URL, you will need this in your vote email.

. Once the release has been voted

* Login to https://repository.apache.org using your Apache LDAP credentials.
Click on "Staging Repositories". Then select "org.apache.camel-xxx" in the list of repositories, where xxx represents
your username and ip.
Click "Release" on the tool bar above.
This will release the artifacts.

[[ReleaseGuide-PublishingTheRelease-Camel]]
== Publishing the Release

. Once the release has been voted:

* Login to https://repository.apache.org using your Apache LDAP credentials.
Click on "Staging Repositories". Then select "org.apache.camel-xxx" in the list of repositories, where xxx represents
your username and IP.
Click "Release" on the tool bar above.
This will release the artifacts.

. Perform a release in JIRA:

* Release the version in JIRA: https://issues.apache.org/jira/plugins/servlet/project-config/CAMEL/versions

. Copy distribution to Apache website:

  cd ${CAMEL_ROOT_DIR}/etc/scripts
  ./release-distro.sh <Camel version>
  
. Copy SBOMs to Apache website:

  cd ${CAMEL_ROOT_DIR}/etc/scripts
  ./release-sbom.sh <Camel version>

. Remove the old distribution version from the Apache website:

  svn rm https://dist.apache.org/repos/dist/release/camel/apache-camel/OLD_CAMEL_VERSION -m "Removed the old release"

. Upload the new schema files (and the manual):

  cd ${CAMEL_ROOT_DIR}/etc/scripts
  ./release-website.sh <Camel version>

. Merge the release branch back into the corresponding base branch (e.g., merge `release/3.2.0` into `camel-3.2.x`)

  git checkout BASE_BRANCH
  git pull
  git merge --no-ff release/VERSION
  git push

. Delete the local and remote release branch:

  git branch -D release/VERSION
  git push origin --delete release/VERSION

[[Publish-xsd-schemas]]
== Publish xsd schemas

* On https://github.com/apache/camel-website/tree/main/static/schema the xsd related to cxf,spring-security and spring
must be pushed to make them available to end users.

[[Tagging-examples]]
== Tagging examples

These steps are optional, and they could be done later too.

Once the release train (camel and camel-spring-boot) has been voted and published, there are some additional steps needed for the camel examples.

. Camel-examples

* On https://github.com/apache/camel-examples in the examples/pom.xml file, the following steps are necessary:

* Update the camel-dependencies version to the version coming from the release-train

* Update the `camel.version` properties to the version coming from the release-train

* To be sure everything is fine, run:

  $ ./mvnw clean install

* Commit

  $ git commit -a
  $ git push origin master (or the branch related to the release, eg. camel-3.4.x)
  $ git tag -a camel-examples-$version -m "$version"
  $ git push origin camel-examples-$version

* Now we pushed the tag, and we need to advance the version of the examples

* Update the camel-dependencies version to the next version

* Update the `camel.version` properties to the next version

* Run the following command to advance the version in the examples
  
  $ find . -type f -exec sed -i 's/$oldVersion/$newVersion/g' {} +

* To be sure everything is fine, run:

  $ ./mvnw clean install

. Camel-spring-boot-examples

* On https://github.com/apache/camel-spring-boot-examples in the examples/pom.xml file the following steps are necessary:

* Update the camel-dependencies version to the version coming from the release-train
    
* Update the `camel.version` properties to the version coming from the release-train
    
* To be sure everything is fine, run:
      
  $ ./mvnw clean install
    
* Commit
  
  $ git commit -a
  $ git push origin master (or the branch related to the release, eg. camel-3.4.x)
  $ git tag -a camel-spring-boot-examples-$version -m "$version"
  $ git push origin camel-spring-boot-examples-$version

* Now we pushed the tag, and we need to advance the version of the examples

* Update the camel-dependencies version to the next version

* Update the `camel.version` properties to the next version

* Run the following command to advance the version in the examples

  $ find . -type f -exec sed -i 's/$oldVersion/$newVersion/g' {} +
   
* To be sure everything is fine, run:

  $ ./mvnw clean install= REST DSL with contract-first OpenAPI

From *Camel 4.6* onwards, the xref:rest-dsl.adoc[Rest DSL] has been improved with a _contract-first_
approach using vanilla OpenAPI specification.

== How it works

The Rest DSL OpenAPI is a facade that builds xref:components::rest-openapi-component.adoc[Rest OpenAPI] endpoint as
consumer for Camel routes. The actual HTTP transport is leveraged by using the xref:components::platform-http-component.adoc[Platform HTTP],
which makes it plugin to Camel Spring Boot, Camel Quarkus or can run standalone with Camel Main.

=== Limitations

Camel does not support websockets from the OpenAPI 3.1 specification.
Neither is (at this time of writing) any security aspects from the OpenAPI specification in use.

== Contract first

The _contract-first_ approach requires you to have an existing OpenAPI v3 specification file.
This contract is a standard OpenAPI contract, and you can use any existing API design tool to build such contracts.

TIP: Camel support OpenAPI v3.0 and v3.1.

In Camel, you then use the Rest DSL in _contract-first_ mode.
For example, having a contract in a file named `my-contract.json`,
you can then copy this file to `src/main/resources` so it's loaded from classpath.

In Camel Rest DSL you can then very easily define _contract-first_ as shown below:


[tabs]
====
Java::
+
[source,java]
----
@Override
public void configure() throws Exception {
    rest().openApi("petstore-v3.json");
}
----
XML::
+
[source,xml]
----
<rest>
  <openApi specification="petstore-v3.json"/>
</rest>
----
YAML::
+
[source,yaml]
----
- rest:
    openApi:
      specification: petstore-v3.json
----
====

When Camel startup the OpenAPI specification file is loaded and parsed. For every API
Camel builds HTTP REST endpoint, which are routed 1:1 to Camel routes using the `direct:operationId` naming convention.

The _pestore_ has 18 APIs here we look at the 5 user APIs:

[source,text]
----
 http://0.0.0.0:8080/api/v3/user                       (POST)   (accept:application/json,application/x-www-form-urlencoded,application/xml produce:application/json,application/xml)
 http://0.0.0.0:8080/api/v3/user/createWithList        (POST)   (accept:application/json produce:application/json,application/xml)
 http://0.0.0.0:8080/api/v3/user/login                 (GET)    (produce:application/json,application/xml)
 http://0.0.0.0:8080/api/v3/user/logout                (GET)
 http://0.0.0.0:8080/api/v3/user/{username}            (DELETE,GET,PUT)
----

These APIs are outputted using the URI that clients can use to call the service.
Each of these APIs has a unique _operation id_ which is what Camel uses for calling the route. This gives:

[source,text]
----
 http://0.0.0.0:8080/api/v3/user                       direct:createUser
 http://0.0.0.0:8080/api/v3/user/createWithList        direct:createUsersWithListInput
 http://0.0.0.0:8080/api/v3/user/login                 direct:loginUser
 http://0.0.0.0:8080/api/v3/user/logout                direct:logoutUser
 http://0.0.0.0:8080/api/v3/user/{username}            direct:getUserByName
----

You should then implement a route for each API that starts from those direct endpoints listed above, such as:

[tabs]
====
Java::
+
[source,java]
----
@Override
public void configure() throws Exception {
    rest().openApi("petstore-v3.json");

    from("direct:getUserByName")
       ... // do something here
}
----
XML::
+
[source,xml]
----
<rest>
  <openApi specification="petstore-v3.json"/>
</rest>
<route>
  <from uri="direct:getUserByName"/>
  // do something here
</route>
----
YAML::
+
[source,yaml]
----
- rest:
    openApi:
      specification: petstore-v3.json
- route:
    from:
      uri: direct:getUserByName
      steps:
        - log:
            message: "do something here"
----
====

=== Ignoring missing API operations

When using OpenAPI with _contract-first_, then Camel will on startup check if there is a corresponding `direct:operationId` route
for every API service. If some operations are missing, then Camel will fail on startup with an error.

During development, you can use `missingOperation` to ignore this as shown:

[source,java]
----
    rest().openApi("petstore-v3.json").missingOperation("ignore");
----

This allows you to implement the APIs one by one over time.

=== Mocking API operations

This is similar to ignoring missing API operations, as you can tell Camel to mock instead, as shown:

[source,java]
----
    rest().openApi("petstore-v3.json").missingOperation("mock");
----

When using _mock_, then Camel will (for missing operations) simulate a successful response:

1. attempting to load canned responses from the file system.
2. for GET verbs then attempt to use example inlined in the OpenAPI `response` section.
3. for other verbs (DELETE, PUT, POST, PATCH) then return the input body as response.
4. if none of the above, then return empty body.

This allows you to have a set of files that you can use for development and testing purposes.

The files should be stored in `camel-mock` when using Camel JBang, and `src/main/resources/camel-mock` for Maven/Gradle based projects.

For example, the following https://github.com/apache/camel-kamelets-examples/tree/main/jbang/open-api-contract-first[Camel JBang example] is structured as:

[source,text]
----
README.md
camel-mock/pet/123.json
petstore-v3.json
petstore.camel.yaml
----

And the Camel route:

[source,yaml]
----
- restConfiguration:
    clientRequestValidation: true
- rest:
    openApi:
      missingOperation: mock
      specification: petstore-v3.json
----

When running this example, you can call the APIs and have an empty successful response. However, for the url `pet/123` the
file `camel-mock/pet/123.json` will be loaded as the response as shown below:

[source,bash]
----
$ curl http://0.0.0.0:8080/api/v3/pet/123
{
  "pet": "donald the dock"
}
----

If no file is found, then Camel will attempt to find an example from the _response_ section in the OpenAPI specification.

In the response section below, then for success GET response (200) then for the `application/json` content-type, we have
an inlined example. Note if there are multiple examples for the same content-type, then Camel will pick the first example,
so make sure it's the best example you want to let Camel use as mocked response body.

[source,json]
----
"responses": {
    "200": {
        "description": "successful operation",
        "content": {
            "application/xml": {
                "schema": {
                    "$ref": "#/components/schemas/Pet"
                }
            },
            "application/json": {
                "schema": {
                    "$ref": "#/components/schemas/Pet"
                },
                "examples": {
                    "success": {
                        "summary": "A cat",
                        "value": "{\"pet\": \"Jack the cat\"}"
                    }
                }
            }
        }
    },
    "400": {
        "description": "Invalid ID supplied"
    },
    "404": {
        "description": "Pet not found"
    }
----

=== Binding to POJO classes

_contract-first_ Rest DSL with OpenAPI also supports binding mode to JSON and XML.
This works the same as _code first_ xref:rest-dsl.adoc[Rest DSL].

However, we have added the `bindingPackageScan` configuration to make it possible for Camel to automatically discover POJO classes from classpath.

When using Spring Boot or Quarkus, then you must configure the package names (base) such as follows:

[source,java]
----
// turn on json binding and scan for POJO classes in the model package
restConfiguration().bindingMode(RestBindingMode.json)
        .bindingPackageScan("sample.petstore.model");
----

You can also configure this in `application.properties`:

[source,properties]
----
camel.rest.bindingMode = json
camel.rest.bindingPackageScan = sample.petstore.model
----

Then Camel will automatically for every OpenAPI operation detect the specified schemas for incoming and outgoing responses,
and map that to Java POJO classes by class name.

For example, the `getPetById` operation in the OpenAPI contract:

[source,json]
----
"responses": {
    "200": {
        "description": "successful operation",
        "content": {
            "application/xml": {
                "schema": {
                    "$ref": "#/components/schemas/Pet"
                }
            },
            "application/json": {
                "schema": {
                    "$ref": "#/components/schemas/Pet"
                }
            }
        }
    },
----

Here Camel will detect the `schema` part:

[source,json]
----
"schema": {
    "$ref": "#/components/schemas/Pet"
}
----

And compute the class name as `Pet` and attempt to discover this class from classpath scanning specified via the `bindingPackageScan` option.

You can also use `title` attribute of the Schema to provide the name of the POJO class. This is helpful when you need to use one name for the Schema in the OpenAPI contract and use another name for the actual POJO class in the implementation.

[source,json]
----
"components": {
        "schemas": {
            "Pet": {
                "type": "object",
                "title": "PetResponseDto",
                "properties": {
                    ...
                }
            }
        }
    },
----

Here Camel will detect the class name as `PetResponseDto` and try to discover it from the classpath. This can be used for both Responses and RequestBodies.

You can source code generate Java POJO classes from an OpenAPI specification via tooling such as the `swagger-codegen-maven-plugin` Maven plugin.
For more details, see this https://github.com/apache/camel-spring-boot-examples/tree/main/openapi-contract-first[Spring Boot example].

=== Expose API specification

The OpenAPI specification is by default not exposed on the HTTP endpoint. You can make this happen by setting the rest-configuration as follows:

[source,yaml]
----
- restConfiguration:
    apiContextPath: /api-doc
----

Then the specification is accessible on `/api-doc` on the embedded HTTP server, so typically that would be `http://localhost:8080/api-doc`.

In the returned API specification the `server` section has been modified to return the IP of the current server. This can be controlled via:


[source,yaml]
----
- restConfiguration:
    apiContextPath: /api-doc
    hostNameResolver: localIp
----

And you can turn this off by setting the value to `none` so the server part is taken verbatim from the specification file.

[source,yaml]
----
- restConfiguration:
    apiContextPath: /api-doc
    hostNameResolver: none
----

== Examples

You can find a few examples such as:

- https://github.com/apache/camel-kamelets-examples/tree/main/jbang/open-api-contract-first
- https://github.com/apache/camel-spring-boot-examples/tree/main/openapi-contract-first
= REST DSL

Apache Camel offers a REST styled DSL.

The intention is to allow end users to define REST services (hosted by Camel) using a
REST style with verbs such as get, post, delete, etc.

NOTE: From *Camel 4.6* onwards, the Rest DSL has been improved with a _contract-first_ approach using vanilla OpenAPI specification
files. This is documented in the xref:rest-dsl-openapi.adoc[Rest DSL with OpenAPI contract first] page. This current page documents the
_code-first_ Rest DSL that Camel provides for a long time.

== How it works

The Rest DSL is a facade that builds xref:components::rest-component.adoc[Rest] endpoints as
consumers for Camel routes. The actual REST transport is leveraged by
using Camel REST components such
as xref:components::netty-http-component.adoc[Netty HTTP], xref:components::servlet-component.adoc[Servlet], and
others that have native REST integration.

== Components supporting Rest DSL

The following Camel components support the Rest DSL:

* xref:components::rest-component.adoc[camel-rest] *required* contains the base rest component needed by Rest DSL
* xref:components::netty-http-component.adoc[camel-netty-http]
* xref:components::jetty-component.adoc[camel-jetty]
* xref:components::platform-http-component.adoc[camel-platform-http]
* xref:components::servlet-component.adoc[camel-servlet]
* xref:components::undertow-component.adoc[camel-undertow]

== Rest DSL with Java DSL

To use the Rest DSL in Java DSL, then just do as with regular Camel routes by
extending the `RouteBuilder` and define the routes in the `configure`
method.

A simple REST service can be defined as follows, where we use `rest()` to
define the services as shown below:

[source,java]
----
@Override
public void configure() throws Exception {
    rest("/say")
        .get("/hello").to("direct:hello")
        .get("/bye").consumes("application/json").to("direct:bye")
        .post("/bye").to("mock:update");

    from("direct:hello")
        .transform().constant("Hello World");

    from("direct:bye")
        .transform().constant("Bye World");
}
----

This defines a REST service with the following url mappings:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Base Path |Uri template |Verb |Consumes
|`_/say_` |`_/hello_` |`get` |_all_
|`_/say_` |`_/bye_` |`get` |`application/json`
|`_/say_` |`_/bye_` |`post` |_all_
|===

Notice that in the REST service we route directly to a Camel endpoint
using `to()`. This is because the Rest DSL has a shorthand for
routing directly to an endpoint using `to()`.

== Rest DSL with XML DSL

The example above can be defined in XML as shown below:

[source,xml]
----
<camelContext xmlns="http://camel.apache.org/schema/spring">
  <rest path="/say">
    <get path="/hello">
      <to uri="direct:hello"/>
    </get>
    <get path="/bye" consumes="application/json">
      <to uri="direct:bye"/>
    </get>
    <post path="/bye">
      <to uri="mock:update"/>
    </post>
  </rest>
  <route>
    <from uri="direct:hello"/>
    <transform>
      <constant>Hello World</constant>
    </transform>
  </route>
  <route>
    <from uri="direct:bye"/>
    <transform>
      <constant>Bye World</constant>
    </transform>
  </route>
</camelContext>
----

== Using a base path

The REST DSL allows defining a base path to help applying the _"don't repeat yourself"_ (DRY) practice.
For example, to define a customer path, we can set the base path in
`rest("/customer")` and then provide the uri templates in the verbs, as
shown below:

[source,java]
----
rest("/customers/")
    .get("/{id}").to("direct:customerDetail")
    .get("/{id}/orders").to("direct:customerOrders")
    .post("/neworder").to("direct:customerNewOrder");
----

And using XML DSL, it becomes:

[source,xml]
----
<rest path="/customers/">
  <get path="/{id}">
    <to uri="direct:customerDetail"/>
  </get>
  <get path="/{id}/orders">
    <to uri="direct:customerOrders"/>
  </get>
  <post path="/neworder">
    <to uri="direct:customerNewOrder"/>
  </post>
</rest>
----

TIP: The REST DSL will take care of duplicate path separators when using base
path and uri templates. In the example above the rest base path ends
with a slash `/` and the verb starts with a slash `/`.
Camel will take care of this and remove the duplicated slash.

It is not required to use both base path and uri templates. You can omit
the base path and define the base path and uri template in the verbs
only. The example above can be defined as:

[source,xml]
----
<rest>
  <get path="/customers/{id}">
    <to uri="direct:customerDetail"/>
  </get>
  <get path="/customers/{id}/orders">
    <to uri="direct:customerOrders"/>
  </get>
  <post path="/customers/neworder">
    <to uri="direct:customerNewOrder"/>
  </post>
</rest>
----

You can combine path parameters to build complex expressions.
For example:

[source,java]
----
 rest("items/")
     .get("{id}/{filename}.{content-type}")
     .to("direct:item")
----


== Managing Rest services

Each of the rest services becomes a Camel route, so in the first example,
we have 2 x get and 1 x post REST service, which each becomes a Camel
route.
This makes it _the same_ from Apache Camel to manage and run these
services, as they are just Camel routes.
This means any tooling and API
today that deals with Camel routes, also work with the REST services.

NOTE: To use JMX with Camel then `camel-management` JAR must be included in the classpath.

This means you can use JMX to stop/start routes, and also get the JMX
metrics about the routes, such as the number of messages processed, and their
performance statistics.

There is also a Rest Registry JMX MBean that contains a registry of all
REST services that has been defined.

== Inline Rest DSL as a single route

IMPORTANT: Camel 4.4 or older has inline-routes disabled by default. Camel 4.5 or newer has inline-routes enabled by default.

Each of the rest services becomes a Camel route, and this means, that if the rest
service is calling another Camel route via `direct`, which is a widespread practice.
This means that each rest service then becomes two routes. This can become harder to manage
if you have many rest services.

When you use `direct` endpoints then you can enable Rest DSL to automatically _inline_ the direct
route in the rest route, meaning that there is only one route per rest service.

To do this you *MUST* use `direct` endpoints, and each endpoint must be unique name per service.
And the option `inlineRoutes` must be enabled.

For example, in the Java DSL below we have enabled inline routes and each rest service
uses `direct` endpoints with unique names.

[source,java]
----
restConfiguration().inlineRoutes(true);

rest("/customers/")
    .get("/{id}").to("direct:customerDetail")
    .get("/{id}/orders").to("direct:customerOrders")
    .post("/neworder").to("direct:customerNewOrder");
----

And in XML:

[source,xml]
----
<restConfiguration inlineRoutes="true"/>

<rest>
  <get path="/customers/{id}">
    <to uri="direct:customerDetail"/>
  </get>
  <get path="/customers/{id}/orders">
    <to uri="direct:customerOrders"/>
  </get>
  <post path="/customers/neworder">
    <to uri="direct:customerNewOrder"/>
  </post>
</rest>
----

If you use Camel Main, Camel Spring Boot, Camel Quarkus or Camel JBang, you can also enable this in `application.properties` such as:

[source,properties]
----
camel.rest.inline-routes = true
----

== Disabling REST services

While developing REST services using Rest DSL, you may want to temporary disabled some REST endpoints,
which you can do using `disabled` as shown in the following.

[source,java]
----
rest("/customers/")
    .get("/{id}").to("direct:customerDetail")
    .get("/{id}/orders").to("direct:customerOrders").disabled("{{ordersEnabled}}")
    .post("/neworder").to("direct:customerNewOrder").disabled();
----

And in XML:

[source,xml]
----
<rest>
  <get path="/customers/{id}">
    <to uri="direct:customerDetail"/>
  </get>
  <get path="/customers/{id}/orders" disabled="{{ordersEnabled}}">
    <to uri="direct:customerOrders"/>
  </get>
  <post path="/customers/neworder" disabled="true">
    <to uri="direct:customerNewOrder"/>
  </post>
</rest>
----

In this example the last two REST endpoints are configured with `disabled`.
You can use xref:manual:ROOT:using-propertyplaceholder.adoc[Property Placeholder] to
let an external configuration determine if the REST endpoint is disabled or not.
In this example the `/customers/\{id}/orders` endpoint is disabled via a placeholder.
The last REST endpoint is hardcoded to be disabled.

== Binding to POJOs using

The Rest DSL supports automatic binding json/xml contents to/from POJOs
using data formats.
By default, the binding
mode is off, meaning there is no automatic binding happening for
incoming and outgoing messages.

You may want to use binding if you develop POJOs that maps to your REST
services request and response types. This allows you as a developer to
work with the POJOs in Java code.

The binding modes are:

[width="100%",cols="10%,90%",options="header",]
|===
|Binding Mode |Description

|`off` |Binding is turned off. This is the default option.

|`auto` |Binding is enabled, and Camel is relaxed and supports JSON, XML or both if
the necessary data formats are included in the classpath. Notice that if
for example `camel-jaxb` is not on the classpath, then XML binding is
not enabled.

|`json` |Binding to/from JSON is enabled, and requires a JSON capable data
format on the classpath. By default, Camel will use `jackson` as the
data format.

|`xm` |Binding to/from XML is enabled, and requires `camel-jaxb` on the
classpath.

|`json_xml` |Binding to/from JSON and XML is enabled and requires both data formats to
be on the classpath.
|===

When using camel-jaxb for XML bindings, then
you can use the option `mustBeJAXBElement` to relax the output message
body must be a class with JAXB annotations. You can use this in
situations where the message body is already in XML format, and you want
to use the message body as-is as the output type. If that is the case,
then set the dataFormatProperty option `mustBeJAXBElement` to `false`
value.

The binding from POJO to JSon/JAXB will only happen if the `content-type`
header includes the word `json` or `xml` representatively. This allows you
to specify a custom content-type if the message body should not attempt to be
marshalled using the binding. For example, if the message body is a
custom binary payload, etc.

When automatic binding from POJO to JSON/JAXB takes place the existing `content-type` header will by default be replaced with either `application/json` or `application/xml`.
To disable the default behavior and be able to produce JSON/JAXB responses with custom `content-type` headers (e.g. `application/user.v2+json`) you configure this in Java DSL as shown below:

[source,java]
----
restConfiguration().dataFormatProperty("contentTypeHeader", "false");
----

To use binding you must include the necessary data formats on the
classpath, such as `camel-jaxb` and/or `camel-jackson`. And then enable
the binding mode. You can configure the binding mode globally on the
rest configuration, and then override per rest service as well.

To enable binding, you configure this in Java DSL as shown below:

[source,java]
----
restConfiguration().component("netty-http").host("localhost").port(portNum).bindingMode(RestBindingMode.auto);
----

And in XML DSL:

[source,xml]
----
<restConfiguration bindingMode="auto" component="netty-http" port="8080"/>
----

When binding is enabled, Camel will bind the incoming and outgoing
messages automatic, accordingly to the content type of the message. If
the message is JSON, then JSON binding happens; and so if the message is
 XML, then XML binding happens. The binding happens for incoming and reply
messages. The table below summaries what binding occurs for incoming and
reply messages. 

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Message Body |Direction |Binding Mode |Message Body

|XML |Incoming |auto,xml,json_xml |POJO

|POJO |Outgoing |auto,xml, json_xml |XML

|JSON |Incoming |auto,json,json_xml |POJO

|POJO |Outgoing |auto,json,json_xml |JSON
|===
 
When using binding, you must also configure what POJO type to map to.
This is mandatory for incoming messages, and optional for outgoing.

NOTE: When using binding mode `json`, `xml` or `json_xml` then Camel will automatically set `consumers` and `produces`
on the rest endpoint (according to the mode), if not already explicit configured. For example, with binding mode `json`
and setting the outType as `UserPojo` then Camel will define this rest endpoint as producing `application/json`.

For example, to map from xml/json to a pojo class `UserPojo` you do this
in Java DSL as shown below:

[source,java]
----
// configure to use netty-http on localhost with the given port
// and enable auto binding mode
restConfiguration().component("netty-http").host("localhost").port(portNum).bindingMode(RestBindingMode.auto);

// use the rest DSL to define the rest services
rest("/users/")
    .post().type(UserPojo.class)
        .to("direct:newUser");
----

Notice we use `type` to define the incoming type. We can optionally
define an outgoing type (which can be a good idea, to make it known from
the DSL and also for tooling and JMX APIs to know both the incoming and
outgoing types of the REST services). To define the outgoing type, we
use `outType` as shown below:

[source,java]
----
// configure to use netty-http on localhost with the given port
// and enable auto binding mode
restConfiguration().component("netty-http").host("localhost").port(portNum).bindingMode(RestBindingMode.auto);

// use the rest DSL to define the rest services
rest("/users/")
    .post().type(UserPojo.class).outType(CountryPojo.class)
        .to("direct:newUser");
----

And in XML DSL:

[source,xml]
----
<rest path="/users/">
  <post type="UserPojo" outType="CountryPojo">
    <to uri="direct:newUser"/>
  </post>
</rest>
----

To specify input and/or output using an array, append `[]` to the end
of the canonical class name as shown in the following Java DSL:

[source,java]
----
// configure to use netty-http on localhost with the given port
// and enable auto binding mode
restConfiguration().component("netty-http").host("localhost").port(portNum).bindingMode(RestBindingMode.auto);

// use the rest DSL to define the rest services
rest("/users/")
    .post().type(UserPojo[].class).outType(CountryPojo[].class)
        .to("direct:newUser");
----

The `UserPojo` is just a plain pojo with getter/setter as shown:

[source,java]
----
public class UserPojo {
    private int id;
    private String name;
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
----

The `UserPojo` only supports JSON, as XML requires using JAXB
annotations, so we can add those annotations if we want to support XML
also

[source,java]
----
@XmlRootElement(name = "user")
@XmlAccessorType(XmlAccessType.FIELD)
public class UserPojo {
    @XmlAttribute
    private int id;
    @XmlAttribute
    private String name;
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
----

By having the JAXB annotations, the POJO supports both JSON and XML
bindings.

=== Camel Rest-DSL configurations

The Rest DSL supports the following options:

[width="100%",cols="2,5,^1,2",options="header"]
|===
| Name | Description | Default | Type
| *apiComponent* | Sets the name of the Camel component to use as the REST API (such as swagger or openapi) |  | String
| *apiContextPath* | Sets a leading API context-path the REST API services will be using. This can be used when using components such as camel-servlet where the deployed web application is deployed using a context-path. |  | String
| *apiHost* | To use a specific hostname for the API documentation (such as swagger or openapi) This can be used to override the generated host with this configured hostname |  | String
| *apiProperties* | Sets additional options on api level |  | Map
| *apiVendorExtension* | Whether a vendor extension is enabled in the Rest APIs. If enabled, then Camel will include additional information as a vendor extension (e.g., keys starting with `_x-_`) such as route ids, class names etc. Not all third party API gateways and tools support vendor-extensions when importing your API docs. | false | boolean
| *bindingMode* | Sets the binding mode to be used by the REST consumer | RestBindingMode.off | RestBindingMode
| *clientRequestValidation* | Whether to enable validation of the client request to check: 1) Content-Type header matches what the Rest DSL consumes; returns HTTP Status 415 if validation error. 2) Accept header matches what the Rest DSL produces; returns HTTP Status 406 if validation error. 3) Missing required data (query parameters, HTTP headers, body); returns HTTP Status 400 if validation error. 4) Parsing error of the message body (JSON, XML or Auto binding mode must be enabled); returns HTTP Status 400 if validation error. | false | boolean
| *component* | Sets the name of the Camel component to use as the REST consumer |  | String
| *componentProperties* | Sets additional options on component level |  | Map
| *consumerProperties* | Sets additional options on consumer level |  | Map
| *contextPath* | Sets a leading context-path the REST services will be using. This can be used when using components such as camel-servlet where the deployed web application is deployed using a context-path. Or for components such as camel-jetty or camel-netty-http that includes a HTTP server. |  | String
| *corsHeaders* | Sets the CORS headers to use if CORS has been enabled. |  | Map
| *dataFormatProperties* | Sets additional options on data format level |  | Map
| *enableCORS* | To specify whether to enable CORS, which means Camel will automatically include CORS in the HTTP headers in the response. This option is default false | false | boolean
| *enableNoContentResponse* | To specify whether to return HTTP 204 with an empty body when a response contains an empty JSON object or XML root object. | false | boolean
| *endpointProperties* | Sets additional options on endpoint level |  | Map
| *host* | Sets the hostname to use by the REST consumer |  | String
| *hostNameResolver* | Sets the resolver to use for resolving hostname | RestHostNameResolver.allLocalIp | RestHostNameResolver
| *inlineRoutes* | Inline routes in rest-dsl which are linked using direct endpoints. By default, each service in Rest DSL is an individual route, meaning that you would have at least two routes per service (rest-dsl, and the route linked from rest-dsl). Enabling this allows Camel to optimize and inline this as a single route. However, this requires using direct endpoints, which must be unique per service. This option is default false. | false | boolean
| *jsonDataFormat* | Sets a custom JSON data format to be used Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance. |  | String
| *port* | Sets the port to use by the REST consumer |  | int
| *producerApiDoc* | Sets the location of the api document (swagger api) the REST producer will use to validate the REST uri and query parameters are valid accordingly to the api document. This requires adding camel-openapi-java to the classpath, and any miss configuration will let Camel fail on startup and report the error(s). The location of the api document is loaded from classpath by default, but you can use file: or http: to refer to resources to load from file or http url. |  | String
| *producerComponent* | Sets the name of the Camel component to use as the REST producer |  | String
| *scheme* | Sets the scheme to use by the REST consumer |  | String
| *skipBindingOnErrorCode* | Whether to skip binding output if there is a custom HTTP error code, and instead use the response body as-is. This option is default true. | true | boolean
| *useXForwardHeaders* | Whether to use X-Forward headers to set host etc. for Swagger. This option is default true. | true | boolean
| *xmlDataFormat* | Sets a custom XML data format to be used. Important: This option is only for setting a custom name of the data format, not to refer to an existing data format instance. |  | String
|===


For example, to configure to use the jetty component on port 9091, then we can do as follows:
[source,java]
----
restConfiguration().component("jetty").port(9091).componentProperty("foo", "123");
----

And with XML DSL:

[source,xml]
----
<restConfiguration component="jetty" port="9091">
  <componentProperty key="foo" value="123"/>
</restConfiguration>
----

If no component has been explicitly configured,
then Camel will look up if there is a Camel component that integrates with the Rest DSL,
or if a `org.apache.camel.spi.RestConsumerFactory` is registered in the registry.
If either one is found, then that is being used.

You can configure properties on these levels.

* component - Is used to set any options on the Component class. You can
also configure these directly on the component.
* endpoint - Is used set any option on the endpoint level. Many of the
Camel components has many options you can set on endpoint level.
* consumer - Is used to set any option on the consumer level.
* data format - Is used to set any option on the data formats. For
example, to enable pretty print in the JSON data format.
* cors headers - If cors is enabled, then custom CORS headers can be
set. See below for the default values which are in used. If a custom
header is set then that value takes precedence over the default value.

You can set multiple options of the same level, so you can, for
example, configure two component options, and three endpoint options, etc.


== Enabling or disabling Jackson JSON features

When using JSON binding, you may want to turn specific Jackson features
on or off.
For example, to disable failing on unknown properties (e.g., JSON
input has a property which cannot be mapped to a POJO) then configure
this using the `dataFormatProperty` as shown below:

[source,java]
----
restConfiguration().component("jetty").host("localhost").port(getPort()).bindingMode(RestBindingMode.json)
   .dataFormatProperty("json.in.disableFeatures", "FAIL_ON_UNKNOWN_PROPERTIES");
----

You can disable more features by separating the values using comma, such
as:

[source,java]
----
.dataFormatProperty("json.in.disableFeatures", "FAIL_ON_UNKNOWN_PROPERTIES,ADJUST_DATES_TO_CONTEXT_TIME_ZONE");
----

Likewise, you can enable features using the enableFeatures such as:

[source,java]
----
restConfiguration().component("jetty").host("localhost").port(getPort()).bindingMode(RestBindingMode.json)
   .dataFormatProperty("json.in.disableFeatures", "FAIL_ON_UNKNOWN_PROPERTIES,ADJUST_DATES_TO_CONTEXT_TIME_ZONE")
   .dataFormatProperty("json.in.enableFeatures", "FAIL_ON_NUMBERS_FOR_ENUMS,USE_BIG_DECIMAL_FOR_FLOATS");
----

The values that can be used for enabling and disabling features on
Jackson are the names of the enums from the following three Jackson
classes

* `com.fasterxml.jackson.databind.SerializationFeature`
* `com.fasterxml.jackson.databind.DeserializationFeature`
* `com.fasterxml.jackson.databind.MapperFeature`

The rest configuration is, of course, also possible using XML DSL:

[source,xml]
----
<restConfiguration component="jetty" host="localhost" port="9090" bindingMode="json">
  <dataFormatProperty key="json.in.disableFeatures" value="FAIL_ON_UNKNOWN_PROPERTIES,ADJUST_DATES_TO_CONTEXT_TIME_ZONE"/>
  <dataFormatProperty key="json.in.enableFeatures" value="FAIL_ON_NUMBERS_FOR_ENUMS,USE_BIG_DECIMAL_FOR_FLOATS"/>
</restConfiguration>
----

== Default CORS headers

If CORS is enabled, then the _"follow headers"_ is in use by default.
You can configure custom CORS headers that take precedence over the default
value.

[width="100%",cols="50%,50%",options="header",]
|===
|Key |Value
|`Access-Control-Allow-Origin` |*
|`Access-Control-Allow-Methods` |GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, CONNECT, PATCH
|`Access-Control-Allow-Headers` |Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers
|`Access-Control-Max-Age` |3600
|===
 
== Defining a custom error message as-is

If you want to define custom error messages to be sent back to the
client with a HTTP error code (e.g., such as 400, 404 etc.)
then you set a header with the key `Exchange.HTTP_RESPONSE_CODE`
to the error code (must be 300+) such as 404.
And then the message body with any reply message, and optionally
set the content-type header as well. There is a little example shown
below:

[source,java]
----
restConfiguration().component("netty-http").host("localhost").port(portNum).bindingMode(RestBindingMode.json);
// use the rest DSL to define the rest services
rest("/users/")
    .post("lives").type(UserPojo.class).outType(CountryPojo.class)
    .to("direct:users-lives");

from("direct:users-lives")
    .choice()
        .when().simple("${body.id} < 100")
            .bean(new UserErrorService(), "idToLowError")
        .otherwise()
            .bean(new UserService(), "livesWhere");
----

In this example, if the input id is a number that is below 100, we want
to send back a custom error message, using the UserErrorService bean,
which is implemented as shown:

[source,java]
----
public class UserErrorService {
    public void idToLowError(Exchange exchange) {
        exchange.getIn().setBody("id value is too low");
        exchange.getIn().setHeader(Exchange.CONTENT_TYPE, "text/plain");
        exchange.getIn().setHeader(Exchange.HTTP_RESPONSE_CODE, 400);
    }
}
----

In the `_UserErrorService_` bean, we build our custom error message, and set
the HTTP error code to 400. This is important, as that tells rest-dsl
that this is a custom error message, and the message should not use the
output pojo binding (e.g., would otherwise bind to `_CountryPojo_`).

=== Catching JsonParserException and returning a custom error message

You can return a custom message as-is (see previous section).
So we can leverage this with Camel error handler to
catch `JsonParserException`, handle that exception and build our custom
response message.
For example, to return a HTTP error code 400 with a
hardcoded message, we can do as shown below:

[source,java]
----
onException(JsonParseException.class)
    .handled(true)
    .setHeader(Exchange.HTTP_RESPONSE_CODE, constant(400))
    .setHeader(Exchange.CONTENT_TYPE, constant("text/plain"))
    .setBody().constant("Invalid json data");
----

== Query/Header Parameter default Values

You can specify default values for parameters in the rest-dsl, such as
the verbose parameter below:

[source,java]
----
  rest("/customers/")
      .get("/{id}").to("direct:customerDetail")
      .get("/{id}/orders")
        .param().name("verbose").type(RestParamType.query).defaultValue("false").description("Verbose order details").endParam()
          .to("direct:customerOrders")
      .post("/neworder").to("direct:customerNewOrder");
----

The default value is automatic set as
header on the incoming Camel `Message`. So if the call
to `/customers/id/orders` do not include a query parameter with
key `verbose` then Camel will now include a header with key `verbose`
and the value `false` because it was declared as the default value. This
functionality is only applicable for query parameters.
Request headers may also be defaulted in the same way.

[source,java]
----
  rest("/customers/")
      .get("/{id}").to("direct:customerDetail")
      .get("/{id}/orders")
        .param().name("indicator").type(RestParamType.header).defaultValue("disabled").description("Feature Enabled Indicator").endParam()
          .to("direct:customerOrders")
      .post("/neworder").to("direct:customerNewOrder");
----

== Client Request Validation

It is possible to enable validation of the incoming client request.
The validation checks for the following:

- Content-Type header matches what the Rest DSL consumes. (Returns HTTP Status 415)
- Accept header matches what the Rest DSL produces. (Returns HTTP Status 406)
- Missing required data (query parameters, HTTP headers, body). (Returns HTTP Status 400)
- Checking if query parameters or HTTP headers has not-allowed values. (Returns HTTP Status 400)
- Parsing error of the message body (JSON, XML or Auto binding mode must be enabled). (Returns HTTP Status 400)

If the validation fails, then Rest DSL will return a response
with an HTTP error code.

The validation is by default turned off (to be backwards compatible).
It can be turned on via `clientRequestValidation` as shown below:

[source,java]
----
restConfiguration().component("jetty").host("localhost")
    .clientRequestValidation(true);
----

== OpenAPI / Swagger API

The Rest DSL supports OpenAPI and Swagger by
the `camel-openapi-java` modules.

You can define each parameter fine-grained
with details such as name, description, data type, parameter type and so
on, using the `param`.
For example, to define the id path parameter, you
can do as shown below:

[source,xml]
----
<!-- this is a rest GET to view an user by the given id -->
<get path="/{id}" outType="org.apache.camel.example.rest.User">
  <description>Find user by id</description>
  <param name="id" type="path" description="The id of the user to get" dataType="int"/>
  <to uri="bean:userService?method=getUser(${header.id})"/>
</get>
----

And in Java DSL

[source,java]
----
.get("/{id}").description("Find user by id").outType(User.class)
    .param().name("id").type(path).description("The id of the user to get").dataType("int").endParam()
    .to("bean:userService?method=getUser(${header.id})")
----

The body parameter type requires to use body as well for the name. For
example, a REST PUT operation to create/update an user could be done as:

[source,xml]
----
<!-- this is a rest PUT to create/update an user -->
<put type="org.apache.camel.example.rest.User">
  <description>Updates or create a user</description>
  <param name="body" type="body" description="The user to update or create"/>
  <to uri="bean:userService?method=updateUser"/>
</put>
----

And in Java DSL:

[source,java]
----
.put().description("Updates or create a user").type(User.class)
    .param().name("body").type(body).description("The user to update or create").endParam()
    .to("bean:userService?method=updateUser")
----

=== Vendor Extensions

The generated API documentation can be configured to include vendor extensions (https://swagger.io/specification/#specificationExtensions)
which document the operations and definitions with additional information, such as class name of model classes, camel context id and route id's.
This information can be very helpful for developers, especially during troubleshooting. However, at production usage you may wish to not have this turned
on to avoid leaking implementation details into your API docs.

The vendor extension information is stored in the API documentation with keys starting with `x-`.

NOTE: Not all third party API gateways and tools support vendor-extensions when importing your API docs.

The vendor extensions can be turned on `RestConfiguration` via the `apiVendorExtension` option:

[source,java]
----
restConfiguration()
    .component("servlet")
    .bindingMode(RestBindingMode.json)
    .dataFormatProperty("prettyPrint", "true")
    .apiContextPath("api-doc")
    .apiVendorExtension(true)
        .apiProperty("api.title", "User API").apiProperty("api.version", "1.0.0")
        .apiProperty("cors", "true");
----

And in XML DSL:

[source,xml]
----
 <restConfiguration component="servlet" bindingMode="json"
                       apiContextPath="api-docs"
                       apiVendorExtension="true">

      <!-- we want json output in pretty mode -->
      <dataFormatProperty key="prettyPrint" value="true"/>

      <!-- setup swagger api descriptions -->
      <apiProperty key="api.version" value="1.0.0"/>
      <apiProperty key="api.title" value="User API"/>

</restConfiguration>
----

=== Supported API properties

The following table lists supported API properties and explains their effect. To set them use `apiProperty(String, String)` in the Java DSL
or `<apiProperty>` when defining the REST API via XML configuration. Properties in **bold** are required by the OpenAPI 2.0 specification. 
Most of the properties affect the OpenAPI https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#infoObject[Info object], https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#licenseObject[License object] or https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#contact-object[Contact object].

|===
|Property | Description
| **api.version** | Version of the API 
| **api.title** | Title of the API
| api.description | Description of the API
| api.termsOfService | API Terms of Service of the API
| api.license.name | License information of the API
| api.license.url | URL for the License of the API
| api.contact.name | The identifying name of the contact person/organization
| api.contact.url | The URL pointing to the contact information
| api.contact.email | The email address of the contact person/organization
| api.specification.contentType.json | The Content-Type of the served OpenAPI JSON specification, `application/json` by default
| api.specification.contentType.yaml | The Content-Type of the served OpenAPI YAML specification, `text/yaml` by default
| externalDocs.url |  The URI for the target documentation. This must be in the form of a URI
| externalDocs.description | A description of the target documentation
|===
= RouteBuilder

The `RouteBuilder` is a base class which is derived from to create routing rules using the DSL.
Instances of `RouteBuilder` are then added to the `CamelContext`.

== RouteBuilder example

The following shows an example of a `RouteBuilder`:

[source,java]
-------------------------------------------------------------------------
import org.apache.camel.builder.RouteBuilder;

/**
 * A Camel Java DSL Router
 */
public class MyRouteBuilder extends RouteBuilder {

    /**
     * Let's configure the Camel routing rules using Java code...
     */
    public void configure() {

        // here is a sample which processes the input files
        // (leaving them in place - see the 'noop' flag)
        // then performs content based routing on the message using XPath
        from("file:src/data?noop=true")
            .choice()
                .when(xpath("/person/city = 'London'"))
                    .to("file:target/messages/uk")
                .otherwise()
                    .to("file:target/messages/others");
    }

}
-------------------------------------------------------------------------

In the `configure` method we can define Camel xref:routes.adoc[Routes].

== More Information

See more in xref:dsl.adoc[DSL], xref:java-dsl.adoc[Java DSL] and xref:routes.adoc[Routes].
= Route Configuration

Camel 3.12 introduces route configuration which is used for separating configurations
from the routes. This can be used in situations such as configuring different error handling across a set of routes.
In previous versions of Camel, this was more cumbersome to do, as you would either have
to copy the same configuration to a set of routes or rely on global error handling configuration.

Now you can configure a number of route configurations, and then specify on each route
which configuration to use (you can use match by ids, wildcards, and regular expression).

The route configuration is supported by all DSLs, so usable by: Java, XML, Groovy and so forth.

In the route configuration, you can set up common strategies for:

- xref:error-handler.adoc[Error Handler]
- xref:exception-clause.adoc[OnException]
- xref:oncompletion.adoc[OnCompletion]
- xref:components:eips:intercept.adoc[Intercept]


== Route Configuration Builder in Java DSL

With Java DSL you can use `RouteConfigurationBuilder` to specify the configuration as shown below.
The builder is similar to `RouteBuilder` so its use is familiar.

[source,java]
----
public class MyJavaErrorHandler extends RouteConfigurationBuilder {

    @Override
    public void configuration() throws Exception {
        routeConfiguration("javaError")
            .onException(Exception.class).handled(true)
            .log("Java WARN: ${exception.message}");
    }
}
----

NOTE: The `RouteConfigurationBuilder` uses `configuration` as the method where the configuration is coded.
This is on purpose, so as not to use the `configure` method which the regular Java DSL `RouteBuilder`
uses for coding Camel routes.

In the example above, then there is only one route configuration that has been assigned the ID `_javaError_`.
This ID allows us to refer to this configuration later when you want to assign which routes are using the configuration.

This configuration is a basic configuration that just catches and handles all exceptions and logs a WARN message.

=== Assigning route configurations to routes

To use this configuration in your routes, then you can assign it with `routeConfigurationId` as shown:

[source,java]
----
public class MyJavaRouteBuilder extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        from("timer:java?period=2s")
            // refer to the route configuration by the id to use for this route
            .routeConfigurationId("javaError")
            .setBody(method(MyJavaRouteBuilder.class, "randomNumber"))
            .log("Random number ${body}")
            .filter(simple("${body} < 30"))
                .throwException(new IllegalArgumentException("The number is too low"));
    }

    public static int randomNumber() {
        return new Random().nextInt(100);
    }
}
----

In the `routeConfigurationId` the configuration to use is specified by the ID, eg `_javaError_`.

Multiple configurations can be assigned (separated by comma), such as:

[source,java]
----
.routeConfigurationId("javaError,myAudit")
----

The route configuration supports matching by:

- exact ID name. This is the sample we have seen above.
- wildcard
- regular expression.

Wildcards are text ending with a `*`.
They are matched when the configuration ID starts with the specified text followed by any characters.
For instance, you can do:

[source,java]
----
.routeConfigurationId("java*,myAudit")
----

Here we use wildcard in `_java*_` which means any configuration whose ID starts with java is a match.

Match by regular expression is just like match by wildcard but using regex instead.

[source,java]
----
.routeConfigurationId(".*error.*")
----

Here we want to match any configuration whose ID contains `_error_`.

=== Adding route configurations to CamelContext

Because a `RouteConfigurationBuilder` is also a `RouteBuilder` then you add route configurations
the same way for `RouteBuilder` such as using the API on `CamelContext`

[source,java]
----
CamelContext context = ...
// add the route configuration
context.addRoutes(new MyJavaErrorHandler());
// add the regular route
context.addRoutes(new MyJavaRouteBuilder());
----

If you use Spring Boot, then your Camel routes and route configurations can be auto-discovered
by the spring boot component scanning. This requires adding the `@Component` annotation to the class.

See the example https://github.com/apache/camel-spring-boot-examples/tree/main/routes-configuration[camel-spring-boot-examples/routes-configuration].


=== Route configuration with Endpoint DSL

The xref:Endpoint-dsl.adoc[Endpoint DSL] can also be used for route configurations.
This requires adding `camel-endpointdsl` to the classpath, and then using
`org.apache.camel.builder.endpoint.EndpointRouteConfigurationBuilder`,
which offers the _type safe_ DSL for Camel endpoints.


== Default route configurations

Route configurations are either given an explicit unique ID, or the configuration is _nameless_.
A _nameless_ configuration is used as default/fallback configuration, for routes which have *NOT*
been explicitly assigned route configurations.

Suppose you have one _nameless_ configuration and another named `_retryError_`:

[source,java]
----
public class MyJavaErrorHandler extends RouteConfigurationBuilder {

    @Override
    public void configuration() throws Exception {
        routeConfiguration()
            .onException(Exception.class).handled(true)
            .log("WARN: ${exception.message}");

        routeConfiguration("retryError")
            .onException(Exception.class).maximumRedeliveries(5);
    }
}
----

And the following two routes:

[source,java]
----
   from("file:cheese").routeId("cheese")
        .to("kafka:cheese");

   from("file:beer").routeId("beer")
        .routeConfigurationId("retryError")
        .to("jms:beer");
----

In the example above, the `_cheese_` route has no route configurations assigned, so the route
will use the default configuration, which in case of an exception will log a warning.

The `_beer_` route on the other hand has the route configuration `_retryError_` assigned, and this
configuration will in case of an exception retry up to five times and then if still an error
then fail and rollback.

If you add more routes, then those routes can also be assigned the `_retryError_` configuration
if they should also retry in case of error.

=== Route Configuration with Error Handler

Each route configuration can also have a specific error handler configured, as shown below:

[source,java]
----
public class MyJavaErrorHandler extends RouteConfigurationBuilder {

    @Override
    public void configuration() throws Exception {
        routeConfiguration()
            .errorHandler(deadLetterChannel("mock:dead"));

        routeConfiguration("retryError")
            .onException(Exception.class).maximumRedeliveries(5);
    }
}
----

In the example above, the `_nameless_` configuration has an error handler with a dead letter queue.
And the route configuration with id `_retryError_` does not, and instead it will attempt
to retry the failing message up till five times before giving up (exhausted).
Because this route configuration does not have any error handler assigned, then Camel will use the default error handler.

IMPORTANT: Routes that have a local error handler defined, will always use this error handler,
instead of the error handler from route configurations. A route can only have one error handler.

== Route Configuration in XML

When using XML DSL, then you can code your route configurations in XML files as shown below:

[source,xml]
----
<routeConfiguration id="xmlError">
    <onException>
        <exception>java.lang.Exception</exception>
        <handled><constant>true</constant></handled>
        <log message="XML WARN: ${exception.message}"/>
    </onException>
</routeConfiguration>
----

And in the XML routes you can assign which configurations to use:

[source,xml]
----
<route routeConfigurationId="xmlError">
    <from uri="timer:xml?period=5s"/>
    <log message="I am XML"/>
    <throwException exceptionType="java.lang.Exception" message="Some kind of XML error"/>
</route>
----

In this example, the route is assigned the `_xmlError_` route configuration by the exact ID.


== Route Configuration in YAML

When using YAML DSL, then you can code your route configurations in YAML files as shown below:

[source,yaml]
----
- route-configuration:
    id: "yamlError"
    on-exception:
    - on-exception:
        handled:
          constant: "true"
        exception:
          - "java.lang.Exception"
        steps:
          - log:
              message: "YAML WARN ${exception.message}"
----

And in the YAML routes you can assign which configurations to use:

[source,yaml]
----
- route:
    # refer to the route configuration by the id to use for this route
    route-configuration-id: "yamlError"
    from:
      uri: "timer:yaml?period=3s"
      steps:
        - set-body:
            simple: "Timer fired ${header.CamelTimerCounter} times"
        - to:
            uri: "log:yaml"
            parameters:
              show-body-type: false
              show-exchange-pattern: false
        - throw-exception:
            exception-type: "java.lang.IllegalArgumentException"
            message: "Error from yaml"
----

In this example, the route is assigned the `_yamlError_` route configuration by the exact ID.

== Mixing DSLs

Routes and route configuration are not required to use the same language. For example, you can code
route configurations in Java, and then use XML DSL for the routes, and they would work together.

== Route Configuration in classic Spring XML

When using XML DSL with `camel-spring-xml` then you can code your route configurations in `<routeConfigurationContext>` snippets
in separate XML files as shown below:

[source,xml]
----
<routeConfigurationContext id="myConf" xmlns="http://camel.apache.org/schema/spring">
    <routeConfiguration id="xmlError">
        <onException>
            <exception>java.lang.Exception</exception>
            <handled><constant>true</constant></handled>
            <log message="XML WARN: ${exception.message}"/>
        </onException>
    </routeConfiguration>
</routeConfigurationContext>
----

Then from `<camelContext>` you can refer to these XML snippets by their ids:

[source,xml]
----
<camelContext id="myCamel" xmlns="http://camel.apache.org/schema/spring">

    <!-- refer to the ID on the context that has the route configurations (see above) -->
    <routeConfigurationContextRef ref="myConf"/>

    <!-- routes can then assign which configuration to use -->
    <route routeConfigurationId="xmlError">
        <from uri="timer:xml?period=5s"/>
        <log message="I am XML"/>
        <throwException exceptionType="java.lang.Exception" message="Some kind of XML error"/>
    </route>
</camelContext>
----

In this example, the route is assigned the `_xmlError_` route configuration by the exact ID.

== Packaging route configurations in reusable JARs

You can package common route configurations into JARs which you can then use together with
your Camel applications, by adding the JARs as dependencies to the classpath (such as in Maven pom.xml file).

This allows, for example, to use a _common practice_ among your Camel applications.

== Logging Summary

If you set `startup-summary-level=verbose` then Camel will log for each route which route configurations they have been assigned.

This option can be configured via Java API and also in `application.properties` for Camel on Spring Boot, Quarkus, and Camel standalone via `camel-main`

[source,java]
----
camelContext.setStartupSummaryLevel(StartupSummaryLevel.Verbose);
----

And with Spring Boot:

[source,properties]
----
camel.spring-boot.startup-summary-level = verbose
----

And in Camel Main / Quarkus:

[source,properties]
----
camel.main.startup-summary-level = verbose
----

== Route Precondition

The route configurations can be included or not according to the result of a test expressed in simple language that is evaluated only once during the initialization phase.

In the next example, the route configuration is only included if the parameter `activate` has been set to `true`.

[source,java]
----
routeConfiguration().precondition("{{activate}}")
    .onException(IllegalArgumentException.class)
    .handled(true)
    .log("WARN: ${exception.message}");
----

And the same example using XML DSL:

[source,xml]
----
<routeConfiguration precondition="{{activate}}">
    <onException>
        <exception>java.lang.IllegalArgumentException</exception>
        <handled>
            <constant>true</constant>
        </handled>
        <log message="XML WARN: ${exception.message}"/>
    </onException>
</routeConfiguration>
----

And in YAML DSL:

[source,yaml]
----
- route-configuration:
    precondition: "{{activate}}"
    on-exception:
    - on-exception:
        exception:
          - "java.lang.IllegalArgumentException"
        handled:
          constant: "true"
        steps:
          - log:
              message: "YAML WARN ${exception.message}"
----

== More Information

See these examples:

- https://github.com/apache/camel-examples/tree/main/routes-configuration[camel-examples/examples/routes-configuration]
- https://github.com/apache/camel-spring-boot-examples/tree/main/routes-configuration[camel-spring-boot-examples/routes-configuration/]

= Route Controller

Camel uses a `RouteController` for managing the lifecycle of all the routes.
The controller is mainly in use during starting up the routes when Camel startup.

The controller is handling which routes, and in which order they should be started.

Camel offers two kinds of controllers. The classic default controller, and a supervising
controller that can attempt to restart routes that failed during startup.

== DefaultRouteController

This is the default controller and strategy that has always been in use by Camel.
The controller works with the _fail fast_ principle, that if any routes fail to
start, then it gives up and Camel itself fails to start up.

The controller also starts the routes sequentially and uses a single thread.
This means there is no concurrent startup, meaning the routes are started
more reliably without concurrency issues.

If a route fails on startup then it is often its `Consumer` that triggers an error
in its startup. Some components offer a way to handle this internally and
attempt to recover from this. However, most components do not offer such a feature
and therefore in most situations, the route would fail to startup and therefore
also Camel itself. The JMS component is an example of a component that can
recover from startup issues in the `Consumer` such as failing to connect to the JMS broker.

The `SupervisingRouteController` is capable of handling this, and manages routes
that have failed to startup, by taking over and attempting to restart these routes.

Given the routes below:

[source,java]
----
from("file:foo/cake")
  to("log:cake");

from("salesforce:cheese")
  to("log:cheese");
----

Then the two routes may fail on startup. However, the first route with the file component
would very likely always start up as it is just using the file system that is reliable.

The second route, however, is using Salesforce, which can fail to start up if there is no network
connecting to Salesforce.

== SupervisingRouteController

A supervising capable `RouteController` that delays the startup of the routes
after the camel context startup and takes control of starting the routes in a safe manner.
This controller is able to retry starting failing routes, and has various options to configure
settings for backoff between restarting routes.

If we take the same example again:

[source,java]
----
from("file:foo/cake")
  to("log:cake");

from("salesforce:cheese")
  to("log:cheese");
----

Then we can tell Camel to use the supervising route controller to let Camel attempt to
recover starting the salesforce route.

=== Configuring Supervising Route Controller

Enabling and configuring supervising route controller from Java:

[source,java]
-----
CamelContext camel = ...
SupervisingRouteController src = camel.getRouteController().supervise();
src.setBackOffDelay(5000);
src.setBackOffMaxAttempts(3);
src.setInitialDelay(1000);
src.setThreadPoolSize(2);
-----

If you use Camel with Spring Boot or Camel Main, you can also enable supervising
from `application.properties`:

[source,properties]
----
camel.routecontroller.enabled = true

# and you can configure more options
camel.routecontroller.backoffDelay = 5000
camel.routecontroller.backoffMaxAttempts = 3
camel.routecontroller.initialDelay = 1000
camel.routecontroller.threadPoolSize = 2
----

And for users with Spring <beans> you can do as follows:

[source,xml]
----
<camelContext>
    <routeController id="myController"
                     supervising="true" initialDelay="1000" threadPoolSize="2"
                     backOffDelay="5000" backOffMaxAttempts="3"/>
    <route>
      <from uri="file:foo/cake"/>
      <to uri="log:cake"/>
    </route>
    <route>
      <from uri="salesforce:cheese"/>
      <to uri="log:cheese"/>
    </route>
</camelContext>
----

=== Supervising Route Controller Options

You can configure the `SupervisingRouteController` using the following options:

[width="100%",cols="10%,20%,70%",options="header",]
|=======================================================================
| Option | Default | Description
| Enabled | `false` | To enable using supervising route controller which allows Camel to start up, and then, the controller takes care of starting the routes in a safe manner. This can be used when you want to startup Camel despite a route may otherwise fail fast during startup and cause Camel to fail to startup as well. By delegating the route startup to the supervising route controller then its manages the startup using a background thread. The controller allows to be configured with various settings to attempt to restart failing routes.
| InitialDelay | | Initial delay in milliseconds before the route controller starts, after CamelContext has been started.
| BackOffDelay | `2000` | Backoff delay in milliseconds when restarting a route that failed to startup.
| BackOffMaxAttempts | | Backoff maximum number of attempts to restart a route that failed to startup. When this threshold has been exceeded then the controller will give up attempting to restart the route, and the route will remain as stopped. Will by default attempt forever.
| BackOffMaxDelay | | Backoff maximum delay in milliseconds when restarting a route that failed to startup.
| BackOffMaxElapsedTime | | Backoff maximum elapsed time in milliseconds, after which the backoff should be considered exhausted and no more attempts should be made.
| BackOffMultiplier | 1.0 | Backoff multiplier to use for exponential backoff. This is used to extend the delay between restart attempts.
| IncludeRoutes | | Pattern for filtering routes to be included as supervised. The pattern is matched on route id, and endpoint uri for the route. Multiple patterns can be separated by comma. For example, to include all kafka routes, you can say `kafka:`. And to include routes with specific route ids `_myRoute,myOtherRoute_`. The pattern supports wildcards and uses the matcher from `org.apache.camel.support.PatternHelper#matchPattern`.
| ExcludeRoutes | | Pattern for filtering routes to be excluded as supervised. The pattern is matched on route id, and endpoint uri for the route. Multiple patterns can be separated by comma. For example, to exclude all JMS routes, you can say `jms:`. And to exclude routes with specific route ids `_mySpecialRoute,myOtherSpecialRoute_`. The pattern supports wildcards and uses the matcher from `org.apache.camel.support.PatternHelper#matchPattern`.
| ThreadPoolSize | `1` | The number of threads used by the route controller scheduled thread pool that are used for restarting routes. The pool uses 1 thread by default, but you can increase this to allow the controller to concurrently attempt to restart multiple routes in case more than one route has problems starting.
| UnhealthyOnExhausted | `true` | Whether to mark the route as unhealthy (down) when all restarting attempts (backoff) have failed and the route is not successfully started and the route manager is giving up. If setting this to `false` will make health checks ignore this problem and allow to report the Camel application as UP.
| UnhealthyOnRestarting | `true` | Whether to mark the route as unhealthy (down) when the route failed to initially start, and is being controlled for restarting (backoff). If setting this to false will make health checks ignore this problem and allow reporting the Camel application as UP.
|=======================================================================

IMPORTANT: The `UnhealthyOnExhausted` and `UnhealthyOnRestarting` options are default `false` in Camel 4.6 or older.

=== Filtering routes to fail fast

When using supervising route controller, then all routes would by default be supervised
and allow Camel to start up successfully; even if one or more routes failed to start up.
This is because the supervising will handle those failed routes and attempt to restart
them in the background (with backoff).

You may have a critical route which must always start up, and if not, cause Camel itself to fail starting.
This can be done by filtering the route from the supervising with the include/exclude options.

Given the routes below:

[source,java]
----
from("file:foo/cake")
  to("log:cake");

from("salesforce:cheese")
  to("log:cheese");

from("aws-s3:foo")
  .to("log:foo")

----

Then suppose we should fail fast if any AWS route fails to startup. This can be done
by excluding by pattern `aws*` (uri or route id)

[source,java]
-----
camel.routecontroller.excludeRoutes = aws*
-----

== JMX management

The route controllers are manageable in JMX, where you can find their MBean under the `services` node.

NOTE: To use JMX with Camel then `camel-management` JAR must be included in the classpath.

== More Information

When Apache Camel is shutting down, then its xref:graceful-shutdown.adoc[Graceful Shutdown]
that handles this to ensure all the routes are shutdown graceful and safely.
= RoutePolicy

A route policy `org.apache.camel.spi.RoutePolicy` is used to control
route(s) at runtime. For example, you can use it to determine whether a
route should be running or not. However, the policies can support any
kind of use cases.

== How it works

You associate a route with a given `RoutePolicy` and then during
runtime Camel will invoke callbacks on this policy where you can
implement your custom logic. Camel provides a support class that is a
good base class to extend `org.apache.camel.support.RoutePolicySupport`.

There are these callbacks invoked:

* `onInit`
* `onRemove`
* `onStart`
* `onStop`
* `onSuspend`
* `onResume`
* `onExchangeBegin`
* `onExchangeDone`

See the Javadoc of the `org.apache.camel.spi.RoutePolicy` for more
details; and also the implementation of the
`org.apache.camel.throttling.ThrottlingInflightRoutePolicy` for a concrete
example.

Camel provides the following policies out of the box:

* `org.apache.camel.throttling.ThrottlingInflightRoutePolicy` - a throttling
based policy that automatically suspends/resumes route(s) based on metrics
from the current in flight exchanges. You can use this to dynamically
 throttle, e.g. a xref:components::jms-component.adoc[JMS] consumer, to avoid it consuming too
fast.

* `org.apache.camel.throttling.ThrottlingExceptionRoutePolicy` - a throttling
based policy modeled after the circuit breaker. This policy will stop consuming
from an endpoint based on the type of exceptions that are thrown and the threshold setting.

Camel also provides an ability to schedule routes to
be activated, deactivated, suspended and/or resumed at certain times
during the day using a
xref:scheduledroutepolicy.adoc[ScheduledRoutePolicy] (offered via the
xref:components::quartz-component.adoc[Quartz] component).

== SuspendableService

If you want to dynamic suspend/resume routes, then it is advised to
use `SuspendableService` as it allows for fine-grained
suspend and resume operations.

== `ThrottlingInflightRoutePolicy`

The *`ThrottlingInflightRoutePolicy`* is triggered when an
xref:exchange.adoc[Exchange] is complete, which means that it requires
at least one xref:exchange.adoc[Exchange] to be complete before it
_works_.

The throttling in flight route policy has the following options:

[width="100%",cols="10%,10%,80%",options="header",]
|===

|Option |Default |Description

|`scope` |`Route` |A scope for either `Route` or `Context` which defines if the current
number of in flight exchanges is context based or for that particular
route.

|`maxInflightExchanges` |`1000` |The maximum threshold when the throttling will start to suspend the
route if the current number of in flight exchanges is higher than this
value.

|`resumePercentOfMax` |`70` |A percentage `0..100` which defines when the throttling should resume
again in case it has been suspended.

|`loggingLevel` |`INFO` |The logging level used for logging the throttling activity.

|`logger` |`ThrottlingInflightRoutePolicy` |The logger category.
|===

=== ThrottlingInflightRoutePolicy compared to the Throttler EIP

The `ThrottlingInflightRoutePolicy` compared to
xref:components:eips:throttle-eip.adoc[Throttler] EIP is that it does *not* block during
throttling. Its throttling is approximate-based, meaning that
its coarser grained and not explicitly precise as the
xref:components:eips:throttle-eip.adoc[Throttler] EIP.

The xref:components:eips:throttle-eip.adoc[Throttler] EIP can
be much more accurate and only allow a specific number of messages being
passed per a given time unit. Also, the `ThrottlingInflightRoutePolicy`
is based its metrics on number of in flight exchanges whereas
xref:components:eips:throttle-eip.adoc[Throttler] EIP is based on number o
messages per time unit.

== ScheduledRoutePolicy

See xref:scheduledroutepolicy.adoc[Scheduled Route Policy] for scheduling based route policy.

== Using route policies in Camel routes

You configure the route policy as follows from Java DSL, using the
`routePolicy` method:

[source,java]
-----------------------------------------------------------
RoutePolicy myPolicy = new MyRoutePolicy();

from("seda:foo").routePolicy(myPolicy).to("mock:result");
-----------------------------------------------------------

In Spring XML you configure using the `routePolictRef` attribute on `<route>` as shown:

[source,xml]
---------------------------------------------------------
<bean id="myPolicy" class="com.mycompany.MyRoutePolicy"/>
   
<route routePolicyRef="myPolicy">
    <from uri="seda:foo"/>
    <to uri="mock:result"/>
</route>
---------------------------------------------------------

You can configure one or more route policies (separated by comma), such as:

[source,java]
----
from("seda:foo").routePolicy(myPolicy, myOtherPolicy).to("mock:result");
----

And in XML:

[source,xml]
---------------------------------------------------------
<route routePolicyRef="myPolicy,myOtherPolicy">
    <from uri="seda:foo"/>
    <to uri="mock:result"/>
</route>
---------------------------------------------------------

== Using RoutePolicyFactory

If you want to use a route policy for every route, you can use
a `org.apache.camel.spi.RoutePolicyFactory` as a factory for creating
a `RoutePolicy` instance for each route. This can be used when you
want to use the same kind of route policy for all or some routes.

With the factory, you only need to configure this once, and every route created will
have the policy assigned.

There is API on `CamelContext` to add a factory, as shown below

[source,java]
----------------------------------------------------------
context.addRoutePolicyFactory(new MyRoutePolicyFactory());
----------------------------------------------------------

And from XML DSL you just define a `<bean>` with the factory, and Camel will automatically detect this factory:

[source,xml]
----------------------------------------------------------------------
<bean id="myRoutePolicyFactory" class="com.foo.MyRoutePolicyFactory"/>
----------------------------------------------------------------------

You can have as many route policy factories as you want, so if you have two factories,
you can add them both as shown:

[source,java]
----------------------------------------------------------
context.addRoutePolicyFactory(new MyRoutePolicyFactory());
context.addRoutePolicyFactory(new MyOtherRoutePolicyFactory());
----------------------------------------------------------

And in XML:

[source,xml]
----------------------------------------------------------------------
<bean id="myRoutePolicyFactory" class="com.foo.MyRoutePolicyFactory"/>
<bean id="myOtherRoutePolicyFactory" class="com.foo.MyOtherRoutePolicyFactory"/>
----------------------------------------------------------------------
= Route Reload

The route reload functionality in Camel is capable of watching a directory folder
for file changes, and then automatic trigger reload of the running routes in the Camel application.

This functionality is intended for development purposes and not for production use.

NOTE: This feature is not supported when using Camel Quarkus, as you should be using
the hot-reloading functionality that comes with Quarkus instead. This functionality
can also reload Java source code changes and much more.

== Using route reloading

You cannot watch for file changes in the Java classpath. It is only possible to watch
for file changes in the file system (i.e., using `file` and not `classpath`).

The route reloading can be configured in Java or with Spring Boot, Quarkus in the following way:

[source,java]
----
CamelContext context = ...

RouteWatcherReloadStrategy reload = new RouteWatcherReloadStrategy();
reload.setFolder("myfolder/routes");
reload.setPattern("*.xml");

context.addService(reload);
----

And with Camel Quarkus / Camel Main you can configure this in `application.properties:`

[source,properties]
----
# turn on route reloading on file changes
camel.main.routes-reload-enabled = true
# the base directory to watch
camel.main.routes-reload-directory = myfolder/routes
# pattern(s) for files to watch
camel.main.routes-reload-pattern = *.xml
----

And in Spring Boot:

[source,properties]
----
# turn on route reloading on file changes
camel.springboot.routes-reload-enabled = true
# the base directory to watch
camel.springboot.routes-reload-directory = myfolder/routes
# pattern(s) for files to watch
camel.springboot.routes-reload-pattern = *.xml
----

=== Route Reload Options

You can configure the `RouteWatcherReloadStrategy` using the following options:

[width="100%",cols="2,5,^1,2",options="header"]
|=======================================================================
| Name | Description | Default | Type
| `routesReloadDirectory` | Directory to scan for route changes. Camel cannot scan the classpath, so this must be configured to a file directory. Development with Maven as build tool, you can configure the directory to be `src/main/resources` to scan for Camel routes in XML or YAML files. | `src/main/resources/camel` | String
| `routesReloadDirectoryRecursive` | Whether the directory to scan should include subdirectories. Depending on the number of sub-directories, then this can cause the JVM to start up slower as Camel uses the JDK file-watch service to scan for file changes. | `false` | boolean
| `routesReloadEnabled` | Used for enabling automatic routes reloading. If enabled, then Camel will watch for file changes in the given reload directory, and trigger reloading routes if files are changed. | `false` | boolean
| `routesReloadPattern` | Used for inclusive filtering of routes from directories. Typical used for specifying to accept routes in XML or YAML files. The default pattern is \*.yaml,*.xml Multiple patterns can be specified separated by comma. | `\*.yaml,*.xml`  | String
| `routesReloadRemoveAllRoutes` | When reloading routes should all existing routes be stopped and removed. By default, Camel will stop and remove all existing routes before reloading routes. This ensures that only the reloaded routes will be active. If disabled, then only routes with the same route id are updated, and any existing routes are continued to run. | `true` | boolean
|=======================================================================


=== Must use route id's

When using route reload, then it is recommended to assign id's to your routes, so Camel
knows exactly which routes have been updated.
This is necessary because Apache Camel must stop the existing routes from running before they can be updated.

And adding new routes is therefore possible as they would have a new unique route id specified.

== See Also

See related xref:context-reload.adoc[].

See the following examples that come with live reloading enabled:

- https://github.com/apache/camel-examples/tree/main/main-xml[camel-examples/examples/main-xml]
- https://github.com/apache/camel-examples/tree/main/main-yaml[camel-examples/examples/main-yaml]
= Route Template

A Route template is as its name implies a template for a route, which is used
to create routes from a set of input parameters. In other words,
route templates are parameterized routes.

_Route template_ + _input parameters_ => _route_

From a route template, you can create one or more routes.

== Defining route templates in the DSL

Route templates are to be defined in the DSL (just like routes) as shown in the following:

[source,java]
----
public class MyRouteTemplates extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        // create a route template with the given name
        routeTemplate("myTemplate")
            // here we define the required input parameters (can have default values)
            .templateParameter("name")
            .templateParameter("greeting")
            .templateParameter("myPeriod", "3s")
            // here comes the route in the template
            // notice how we use {{name}} to refer to the template parameters
            // we can also use {{propertyName}} to refer to property placeholders
            .from("timer:{{name}}?period={{myPeriod}}")
                .setBody(simple("{{greeting}} ${body}"))
                .log("${body}");
    }
}
----

And in Spring XML DSL

[source,xml]
----
<camelContext>
  <routeTemplate id="myTemplate">
    <templateParameter name="name"/>
    <templateParameter name="greeting"/>
    <templateParameter name="myPeriod" defaultValue="3s"/>
    <route>
      <from uri="timer:{{name}}?period={{myPeriod}}"/>
      <setBody><simple>{{greeting}} ${body}</simple></setBody>
      <log message="${body}"/>
    </route>
  </routeTemplate>
</camelContext>
----

And in XML DSL

[source,xml]
----
<routeTemplates xmlns="http://camel.apache.org/schema/spring">
    <routeTemplate id="myTemplate">
        <templateParameter name="name"/>
        <templateParameter name="greeting"/>
        <templateParameter name="myPeriod" defaultValue="3s"/>
        <route>
            <from uri="timer:{{name}}?period={{myPeriod}}"/>
            <setBody><simple>{{greeting}} ${body}</simple></setBody>
            <log message="${body}"/>
        </route>
    </routeTemplate>
</routeTemplates>
----

In the examples above, there was one route template, but you can define as many as you want.
Each template must have a unique id. The template parameters are used for defining the parameters
the template accepts. As you can see, there are three parameters: `_name_`, `_greeting_`, and `_myPeriod_`. The first two
parameters are mandatory, whereas `_myPeriod_` is optional as it has a default value of 3s.

The template parameters are then used in the route as regular property placeholders with the `{{ }}` syntax.
Notice how we use `{\{name}}` and `{\{greeting}}` in the timer endpoint and the simple language.

The route can, of course, use regular property placeholders as well.
Now imagine there was a property placeholder with the name greeting:

[source,properties]
----
greeting = Davs
----

Then Camel would normally have used this value `Davs` when creating the route. However, as the route template
has defined a template parameter with the same name `greeting` then a value must be provided when
creating routes from the template.

Template parameters take precedence over regular property placeholders.

== Creating a route from a route template

To create routes from route templates, then you should use `org.apache.camel.builder.TemplatedRouteBuilder`.

In the following code snippet, you can see how this is done with the builder:

[source,java]
----
// create two routes from the template
TemplatedRouteBuilder.builder(context, "myTemplate")
    .parameter("name", "one")
    .parameter("greeting", "Hello")
    .add();

TemplatedRouteBuilder.builder(context, "myTemplate")
    .parameter("name", "two")
    .parameter("greeting", "Bonjour")
    .parameter("myPeriod", "5s")
    .add();
----

And in Java DSL:

[source,java]
----
templatedRoute("myTemplate")
        .parameter("name", "one")
        .parameter("greeting", "Hello");
templatedRoute("myTemplate")
        .parameter("name", "two")
        .parameter("greeting", "Bonjour")
        .parameter("myPeriod", "5s");
----

And in Spring XML DSL:

[source,xml]
----
<camelContext>
  <templatedRoute routeTemplateRef="myTemplate">
    <parameter name="name" value="one"/>
    <parameter name="greeting" value="Hello"/>
  </templatedRoute>
  <templatedRoute routeTemplateRef="myTemplate">
    <parameter name="name" value="two"/>
    <parameter name="greeting" value="Bonjour"/>
    <parameter name="myPeriod" value="5s"/>
  </templatedRoute>
</camelContext>
----

And in XML DSL:

[source,xml]
----
<templatedRoutes xmlns="http://camel.apache.org/schema/spring">
  <templatedRoute routeTemplateRef="myTemplate">
    <parameter name="name" value="one"/>
    <parameter name="greeting" value="Hello"/>
  </templatedRoute>
  <templatedRoute routeTemplateRef="myTemplate">
    <parameter name="name" value="two"/>
    <parameter name="greeting" value="Bonjour"/>
    <parameter name="myPeriod" value="5s"/>
  </templatedRoute>
</templatedRoutes>
----

And in YAML DSL:

[source,yaml]
----
- templated-route:
    route-template-ref: "myTemplate"
    parameters:
      - name: "name"
        value: "one"
      - name: "greeting"
        value: "Hello"
- templated-route:
    route-template-ref: "myTemplate"
    parameters:
      - name: "name"
        value: "two"
      - name: "greeting"
        value: "Bonjour"
      - name: "myPeriod"
        value: "5s"
----

The returned value from `add` is the route id of the new route that was added.
However `null` is returned if the route is not yet created and added, which can happen if `CamelContext` is
not started yet.

If no route id is provided, then Camel will auto assign a route id. In the example above then Camel would
assign route ids such as `route1`, `route2` to these routes.

If you want to specify a route id, then use `routeId` as follows, where the id is set to myCoolRoute:

[source,java]
----
TemplatedRouteBuilder.builder(context, "myTemplate")
    .routeId("myCoolRoute")
    .parameter("name", "one")
    .parameter("greeting", "hello")
    .parameter("myPeriod", "5s")
    .add();
----

And in Java DSL:

[source,java]
----
templatedRoute("myTemplate")
        .routeId("myCoolRoute")
        .parameter("name", "one")
        .parameter("greeting", "hello")
        .parameter("myPeriod", "5s");
----

And in Spring XML DSL:

[source,xml]
----
<camelContext>
  <templatedRoute routeTemplateRef="myTemplate" routeId="myCoolRoute">
    <parameter name="name" value="one"/>
    <parameter name="greeting" value="hello"/>
    <parameter name="myPeriod" value="5s"/>
  </templatedRoute>
</camelContext>
----

And in XML DSL:

[source,xml]
----
<templatedRoutes xmlns="http://camel.apache.org/schema/spring">
  <templatedRoute routeTemplateRef="myTemplate" routeId="myCoolRoute">
    <parameter name="name" value="one"/>
    <parameter name="greeting" value="hello"/>
    <parameter name="myPeriod" value="5s"/>
  </templatedRoute>
</templatedRoutes>
----

And in YAML DSL:

[source,yaml]
----
- templated-route:
    route-template-ref: "myTemplate"
    route-id: "myCoolRoute"
    parameters:
      - name: "name"
        value: "one"
      - name: "greeting"
        value: "hello"
      - name: "myPeriod"
        value: "5s"
----

=== Using template parameters with Java DSL simple builder

When using Java DSL and simple language, then beware that you should
not use the _simple fluent builder_ when defining the simple expressions/predicates.

For example, given the following route template in Java DSL:

[source,java]
----
public class MyRouteTemplates extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        routeTemplate("myTemplate")
            .templateParameter("name")
            .templateParameter("color")
            .from("direct:{{name}}")
                .choice()
                    .when(simple("{{color}}").isEqualTo("red"))
                        .to("direct:red")
                    .otherwise()
                        .to("color:other")
                .end();
    }
}
----

Then notice how the simple predicate is using _simple fluent builder_ `simple("{\{color}}").isEqualTo("red")`.
This is **not supported** with route templates and would not work when creating multiple routes from the template.

Instead, the simple expression should be a literal String value _only_ as follows:
----
    .when(simple("'{{color}}' == 'red'")
----

=== Using hardcoded node IDs in route templates

If route templates contain hardcoded node IDs, then routes created from templates will use the same IDs.
Therefore, if two or more routes are created from the same template, you will have _duplicate id detected_ error.

Given the route template below, then it has hardcoded ID (`_new-order_`) in node calling the http services.

[source,java]
----
public class MyRouteTemplates extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        routeTemplate("orderTemplate")
            .templateParameter("queue")
            .from("jms:{{queue}}")
                .to("http:orderserver.acme.com/neworder").id("new-order")
                .log("Processing order");
    }
}
----

When creating routes from templates, you can then provide a _prefix_ which is used for all node IDs.
This allows to create 2 or more routes without _duplicate id_ errors.

For example in the following, we create a new route `_myCoolRoute_` from the `_myTemplate_` template, and
use a prefix of `_web_`.

And in Java DSL

[source,java]
----
templatedRoute("orderTemplate")
        .routeId("webOrder")
        .prefixId("web")
        .parameter("queue", "order.web");
----

Then we can create a 2nd route:

[source,java]
----
templatedRoute("orderTemplate")
        .routeId("ftpOrder")
        .prefixId("ftp")
        .parameter("queue", "order.ftp");
----

And in Spring XML DSL:

[source,xml]
----
<camelContext>
  <templatedRoute routeTemplateRef="orderTemplate" routeId="webOrder" prefixId="web">
    <parameter name="queue" value="web"/>
  </templatedRoute>
</camelContext>
----

And in XML DSL:

[source,xml]
----
<templatedRoutes xmlns="http://camel.apache.org/schema/spring">
  <templatedRoute routeTemplateRef="orderTemplate" routeId="webOrder" prefixId="web">
    <parameter name="queue" value="web"/>
  </templatedRoute>
</templatedRoutes>
----

And in YAML DSL:

[source,yaml]
----
- templated-route:
    route-template-ref: "orderTemplate"
    route-id: "webOrder"
    prefix-id: "web"
    parameters:
      - name: "queue"
        value: "web"
----

== Binding beans to route template

The route template allows binding beans that are locally scoped and only used as part of creating routes from the template.
This allows using the same template to create multiple routes, where beans are local (private) for each created route.

For example, given the following route template where we use `templateBean` to set up the local bean as shown:

[source,java]
----
routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .templateBean("myClient", S3Client.class, rtc ->
            S3Client.builder().region(rtc.getProperty("region", Region.class)).build();
    )
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")
----

The template has two parameters to specify the AWS region and the S3 bucket. To connect to S3
then a `software.amazon.awssdk.services.s3.S3Client` bean is necessary.

To create this bean, we specify this with the `templateBean` DSL where we specify the bean id as `myClient`.
The type of the bean can be specified (`S3Client.class`), however, it is optional
(can be used if you need to let beans be discovered by type and not by name).

This ensures that the code creating the bean is executed later (when Camel is creating a route from the template),
then the code must be specified as a _supplier_. Because we want during creation of the bean access to template parameters,
we use a Camel `BeanSupplier` which gives access to `RouteTemplateContext` that is the `_rtc_` variable in the code above.

IMPORTANT: The local bean with id `myClient` *must* be referred to using Camel's property placeholder syntax, eg `{\{myClient}}`
in the route template, as shown above with the _to_ endpoint. This is because the local
bean must be made unique and Camel will internally re-assign the bean id to use a unique id instead of `myClient`. And this is done with the help
of the property placeholder functionality.

If multiple routes are created from this template, then each of the created routes have their own
`S3Client` bean created.

=== Binding beans to route templates from template builder

The `TemplatedRouteBuilder` also allows to bind local beans (which allows specifying those beans) when
creating routes from existing templates.

Suppose the route template below is defined in XML:
[source,xml]
----
<camelContext>
  <routeTemplate id="s3template">
    <templateParameter name="region"/>
    <templateParameter name="bucket"/>
    <route>
      <from uri="direct:s3-store"/>
      <to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/>
    </route>
  </routeTemplate>
</camelContext>
----

The template has no bean bindings for `#{\{myClient}}` which would be required for creating the template.

When creating routes form the template via `TemplatedRouteBuilder` then you can provide the bean binding
if you desire the bean to be locally scoped (not shared with others):

[source,java]
----
TemplatedRouteBuilder.builder(context, "s3template")
    .parameter("region", "US-EAST-1")
    .parameter("bucket", "myBucket")
    .bean("myClient", S3Client.class,
                S3Client.builder()
                    .region(rtc.getProperty("region", Region.class))
                    .build())
    .routeId("mys3route")
    .add();
----

As you can see the binding is similar to when using `templateBean` directly in the route template.

And in Java DSL:

[source,java]
----
templatedRoute("s3template")
        .parameter("region", "US-EAST-1")
        .parameter("bucket", "myBucket")
        .bean("myClient", S3Client.class,
                rtc -> S3Client.builder() // <1>
                    .region(rtc.getProperty("region", Region.class))
                    .build())
        .routeId("mys3route");
----
<1> Note that the third parameter of the `bean` method is not directly the bean but rather a factory method that will be used to create the bean, here we use a lambda expression as factory method.

And in XML DSL:

[source,xml]
----
  <templatedRoute routeTemplateRef="s3template" routeId="mys3route">
    <parameter name="region" value="US-EAST-1"/>
    <parameter name="bucket" value="myBucket"/>
    <bean name="myClient" type="software.amazon.awssdk.services.s3.S3Client"
          scriptLanguage="groovy"> <!--1-->
        <script>
            import software.amazon.awssdk.services.s3.S3Client
            S3Client.builder()
                .region(rtc.getProperty("region", Region.class))
                .build()
        </script>
    </bean>
  </templatedRoute>
----
<1> For non-Java DSL, in case of a complex bean factory, you can still rely on a language like `groovy` to define your bean factory inside a `script` element.

And in YAML DSL:

[source,yaml]
----
- templated-route:
    route-template-ref: "s3template"
    route-id: "mys3route"
    parameters:
      - name: "region"
        value: "US-EAST-1"
      - name: "bucket"
        value: "myBucket"
    beans:
      - name: "myClient"
        type: "software.amazon.awssdk.services.s3.S3Client"
        scriptLanguage: "groovy"
        script: | # <1>
            import software.amazon.awssdk.services.s3.S3Client
            S3Client.builder()
                .region(rtc.getProperty("region", Region.class))
                .build()
----
<1> For non-Java DSL, in case of a complex bean factory, you can still rely on a language like `groovy` to define your bean factory as value of the `script` key.

Instead of binding the beans from the template builder, you could also create the bean outside the template,
and bind it by reference.

[source,java]
----

final S3Client myClient = S3Client.builder().region(Region.US_EAST_1).build();

TemplatedRouteBuilder.builder(context, "s3template")
    .parameter("region", Region.US_EAST_1)
    .parameter("bucket", "myBucket")
    .bean("myClient", myClient)
    .routeId("mys3route")
    .add();
----

And in Java DSL:

[source,java]
----
templatedRoute("s3template")
        .parameter("region", "US-EAST-1")
        .parameter("bucket", "myBucket")
        .bean("myClient", S3Client.class, rtc -> myClient)
        .routeId("mys3route");
----

You should prefer to create the local beans directly from within the template (if possible) because this
ensures the route template has this out of the box. Otherwise, the bean must be created or provided every time
a new route is created from the route template. However, the latter gives freedom to create the bean in any other custom way.

=== Binding beans to route templates using bean types

You can create a local bean by referring to a fully qualified class name which Camel will use to create
a new local bean instance. When using this, the created bean is created via default constructor of the class.

The bean instance can be configured with properties via getter/setter style.
The previous example with creating the AWS S3Client would not support this kind as this uses _fluent builder_ pattern (not getter/setter).

TIP: In *Camel 4.6* onwards, you can also use constructor arguments for beans

So suppose we have a class as follows:

[source,java]
----
public class MyBar {
    private String name;
    private String address;

    // getter/setter omitted

    public String location() {
        return "The bar " + name + " is located at " + address;
    }
}
----

Then we can use the `MyBar` class as a local bean in a route template as follows:

[source,java]
----
routeTemplate("barTemplate")
    .templateParameter("bar")
    .templateParameter("street")
    .templateBean("myBar")
        .typeClass("com.foo.MyBar")
        .property("name", "{{bar}}")
        .property("address", "{{street}}")
    .end()
    .from("direct:going-out")
    .to("bean:{{myBar}}")
----

With Java DSL, you can also refer to the bean class using type safe way:

[source,java]
----
.templateBean("myBar")
    .typeClass(MyBar.class)
    .property("name", "{{bar}}")
    .property("address", "{{street}}")
.end()
----

In XML DSL you would do:

[source,xml]
----
<camelContext xmlns="http://camel.apache.org/schema/spring">
    <routeTemplate id="myBar">
        <templateParameter name="bar"/>
        <templateParameter name="street"/>
        <templateBean name="myBean" type="#class:com.foo.MyBar">
            <properties>
                <property key="name" value="{{bar}}"/>
                <property key="address" value="{{street}}"/>
            </properties>
        </templateBean>
        <route>
            <from uri="direct:going-out"/>
            <to uri="bean:{{myBar}}"/>
        </route>
    </routeTemplate>
</camelContext>
----

=== Binding beans to route templates using scripting languages

You can use scripting languages like groovy, java, mvel to create the bean.
This allows defining route templates with the scripting language built-in (such as groovy).

For example, creating the AWS S3 client can be done as shown in Java (with inlined groovy code):

[source,java]
----
routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .templateBean("myClient", "groovy",
            "software.amazon.awssdk.services.s3.S3Client.S3Client.builder()
            .region(rtc.getProperty("region", Region.class))
            .build()"
    )
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")
----

The groovy code can be externalized into a file on the classpath or file system, by using `resource:` as prefix, such as:

[source,java]
----
routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .templateBean("myClient", "groovy", "resource:classpath:s3bean.groovy")
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")
----

Then create the file `s3bean.groovy` in the classpath root:

[source,groovy]
----
import software.amazon.awssdk.services.s3.S3Client
S3Client.builder()
    .region(rtc.getProperty("region", Region.class))
    .build()
----

The route template in XML DSL can then also use groovy language to create the bean as follows:

[source,xml]
----
<camelContext>
  <routeTemplate id="s3template">
    <templateParameter name="region"/>
    <templateParameter name="bucket"/>
    <templateBean name="myClient" type="groovy">
        <script>
            import software.amazon.awssdk.services.s3.S3Client
            S3Client.builder()
                .region(rtc.getProperty("region", Region.class))
                .build()
        </script>
    </templateBean>
    <route>
      <from uri="direct:s3-store"/>
      <to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/>
    </route>
  </routeTemplate>
</camelContext>
----

Notice how the groovy code can be inlined directly in the route template in XML also. Of course, you can also externalize
the bean creation code to an external file, by using `resource:` as prefix:

[source,xml]
----
<camelContext>
  <routeTemplate id="s3template">
    <templateParameter name="region"/>
    <templateParameter name="bucket"/>
    <templateBean name="myClient" type="groovy">
        <script>resource:classpath:s3bean.groovy</script>
    </templateBean>
    <route>
      <from uri="direct:s3-store"/>
      <to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/>
    </route>
  </routeTemplate>
</camelContext>
----

The languages supported are:

[width="100%",cols="2s,8",options="header"]
|===
| Type | Description
| bean | Calling a method on a Java class to create the bean.
| groovy | Using a groovy script to create the bean.
| java | Java code which is runtime compiled (using jOOR library) to create the bean.
| mvel | To use a Mvel template script to create the bean.
| ognl | To use OGNL template script to create the bean.
| _name_ | To use a third-party language by the given `_name_` to create the bean.
|===

Camel will bind `RouteTemplateContext` as the root object with name `rtc` when evaluating the script.
This means you can get access to all the information from `RouteTemplateContext` and `CamelContext` via `rtc`.

This is what we have done in the scripts in the previous examples where we get hold of a template parameter with:

[source,groovy]
----
    rtc.getProperty('region', String.class)
----

To get access to `CamelContext` you can do:

[source,groovy]
----
    var cn = rtc.getCamelContext().getName()
----

The most powerful languages to use are groovy and java. The other languages are limited in flexibility
as they are not complete programming languages, but are more suited for templating needs.

It is recommended to either use groovy or java, if creating the local bean requires coding,
and the route templates are not defined using Java code.

The bean language can be used when creating the local bean from an existing Java method (static or not-static method),
and the route templates are not defined using Java code.

For example suppose there is a class named `com.foo.MyAwsHelper` that has a method called `createS3Client`
then you can call this method from the route template in XML DSL:

[source,xml]
----
<camelContext>
  <routeTemplate id="s3template">
    <templateParameter name="region"/>
    <templateParameter name="bucket"/>
    <templateBean name="myClient" type="bean">
        <script>com.foo.MyAwsHelper?method=createS3Client</script>
    </templateBean>
    <route>
      <from uri="direct:s3-store"/>
      <to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/>
    </route>
  </routeTemplate>
</camelContext>
----

The method signature of createS3Client must then have one parameter for the `RouteTemplateContext` as shown:

[source,java]
----
public static S3Client createS3Client(RouteTemplateContext rtc) {
    return S3Client.builder()
        .region(rtc.getProperty("region", Region.class))
        .build();
}
----

If you are using pure Java code (both template and creating local bean),
then you can create the local bean using Java lambda style as previously documented.

==== Configuring the type of the created bean

The `type` must be set to define what FQN class the created bean.

[source,xml]
----
<camelContext>
  <routeTemplate id="s3template">
    <templateParameter name="region"/>
    <templateParameter name="bucket"/>
    <templateBean name="myClient" scriptLanguage="bean" type="software.amazon.awssdk.services.s3.S3Client">
        <script>com.foo.MyAwsHelper?method=createS3Client</script>
    </templateBean>
    <route>
      <from uri="direct:s3-store"/>
      <to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/>
    </route>
  </routeTemplate>
</camelContext>
----

And in Java DSL you can do:

[source,java]
----
routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .templateBean("myClient", S3Client.class, "bean", "com.foo.MyAwsHelper?method=createS3Client")
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")
----

== Configuring route templates when creating route

There may be some special situations where you want to be able to do some custom configuration/code when
a route is about to be created from a route template. To support this you can use the `configure` in the route template DSL
where you can specify the code to execute as show:

[source,java]
----
routeTemplate("myTemplate")
    .templateParameter("myTopic")
    .configure((RouteTemplateContext rtc) ->
        // do some custom code here
    )
    .from("direct:to-topic")
    .to("kafka:{{myTopic}}");
----

== JMX management

The route templates can be dumped as XML from the `ManagedCamelContextMBean` MBean via the `dumpRouteTemplatesAsXml` operation.

== Creating routes from a properties file

When using `camel-main` you can specify the parameters for route templates in `application.properties` file.

For example, given the route template below (from a `RouteBuilder` class):

[source,java]
----
routeTemplate("mytemplate")
    .templateParameter("input")
    .templateParameter("result")
    .from("direct:{{input}}")
        .to("mock:{{result}}");
----

Then we can create two routes from this template by configuring the values in the `application.properties` file:

[source,properties]
----
camel.route-template[0].template-id=mytemplate
camel.route-template[0].input=foo
camel.route-template[0].result=cheese

camel.route-template[1].template-id=mytemplate
camel.route-template[1].input=bar
camel.route-template[1].result=cheese
----

== Creating routes from custom sources of template parameters

The SPI interface `org.apache.camel.spi.RouteTemplateParameterSource` can be used to implement custom sources that
are used during startup of Camel to create routes via the templates with parameters from the custom source(s).

For example, a custom source can be implemented to read parameters from a shared database that Camel uses during startup
to create routes.
This allows externalizing these parameters and as well to easily add more routes with varying parameters.

To let Camel discover custom sources, then register the source into the Camel registry.

== See Also

See the example https://github.com/apache/camel-examples/tree/main/routetemplate[camel-examples/examples/routetemplate/].
= Routes

In Apache Camel, a _route_ is a set of processing steps that are applied to a message as it travels from a source to a destination. A route typically consists of a series of processing steps that are connected in a linear sequence.

A Camel _route_ is where the integration flow is defined. For example, you can write a Camel route to specify how two systems can be integrated. You can also specify how the data can be manipulated, routed, or mediated between the systems.

The routes are typically defined using a simple, declarative syntax that is easy to read and understand.

For instance, you could write a _route_ to consume files from an FTP server and send them to an http://activemq.apache.org[ActiveMQ] messaging system. A _route_ to do so, using xref:java-dsl.adoc[Java DSL], would look like this:

[source,java]
----
from("ftp:myserver/folder")
  .to("activemq:queue:cheese");
----

Camel _routes_ can be defined using a variety of xref:dsl.adoc[domain-specific languages (DSLs)], such as Java, Spring XML, or YAML. For example, you could write the _route_ described above using XML:

[source,xml]
----
<route>
  <from uri="ftp:myserver/folder"/>
  <to uri="activemq:queue:cheese"/>
</route>
----


== Writing Routes in Java using the Java DSL

You can create a route using the Java language by extending the xref:manual::route-builder.adoc[`RouteBuilder` class], and implementing the `configure` method.

Here's an example:

[source,java]
------------------------------------------------------
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
        from("direct:a").to("direct:b");
    }
};
------------------------------------------------------

As you can see from the code snippet above, Camel uses xref:manual::uris.adoc[URIs] to wire endpoints together.

We refer to this way of writing route as using the xref:manual::java-dsl.adoc[Java DSL].

== Route Precondition

The routes can be included or not according to the result of a test. You can express the condition for the tests using the simple language. Camel evaluates this condition only once during the initialization phase.

Here's an example that includes the route only if the parameter `format` has been set to `xml`:

[source,java]
----
from("direct:in").precondition("'{{format}}' == 'xml'")
   .unmarshal().jaxb()
   .to("direct:out");
----

You can write the same route described above using the xref:components:others:java-xml-io-dsl.adoc[XML DSL]:

[source,xml]
----
<route precondition="'{{format}}' == 'xml'">
  <from uri="direct:in"/>
  <unmarshal><jaxb/></unmarshal>
  <to uri="direct:out"/>
</route>
----

You can also write the same route described above using the xref:components:others:yaml-dsl.adoc[YAML DSL]:

[source,yaml]
----
- route:
    precondition: "'{{format}}' == 'xml'"
    from:
      uri: "direct:in"
      steps:
        - unmarshal:
            jaxb: {}
        - to: "direct:out"
----

== More Information

Check the xref:dsl.adoc[list of supported languages] that you can use for writing Camel routes.
= ScheduledRoutePolicy

A scheduled xref:route-policy.adoc[Route Policy]
`org.apache.camel.routepolicy.quartz.ScheduledRoutePolicy` is an
extensible abstract policy that is used to provide Camel routes
scheduling capabilities at runtime.

Scheduling of routes typically involves the following capabilities:

* _Route activation_ - Starting a route a given start time if the route is
in a stopped state awaiting activation.
* _Route de-activation_ - Shutting down an otherwise active and started
route at a given time.
* _Route suspension_ - Simply de-activating the route consumer endpoint
URI declared on the `from(...)` section of the route from listening on a
given port. The route is still considered as started, however, clients
will not be able to send requests along the route.
* _Route resumption_ - Resuming the listener on a formerly suspended route
consumer endpoint URI. This route is ready to accept requests following
route resumption and client requests will be accepted by the route
consumer to be forwarded along the route.

Camel offers two such concrete policies that offer scheduled route policy
support:

* xref:simplescheduledroutepolicy.adoc[SimpleScheduledRoutePolicy] - An
ability to offer route scheduling services using a Simple xref:components::quartz-component.adoc[Quartz] trigger.
* xref:cronscheduledroutepolicy.adoc[CronScheduledRoutePolicy] - An
ability to offer route scheduling services using a Cron based xref:components::quartz-component.adoc[Quartz]
trigger.

== More Information

See xref:route-policy.adoc[Route Policy]= Security

Camel offers several forms and levels of security capabilities that can be
used on Camel routes. These various forms of security may be used in
conjunction with each other or separately.

The broad categories offered are:

* _Route Security_ - Authentication and Authorization services to proceed
on a route or route segment
* _Payload Security_ - Data Formats that offer encryption/decryption
services at the payload level
* _Endpoint Security_ - Security offered by components that can be
utilized by endpointUri associated with the component
* _Configuration Security_ - Security offered by encrypting sensitive
information from configuration files or external Secured Vault systems.

Camel offers the xref:camel-configuration-utilities.adoc[JSSE Utility]
for configuring SSL/TLS related aspects of a number of Camel components.

== Route Security

Authentication and Authorization Services

Camel offers xref:route-policy.adoc[Route Policy] driven security capabilities that may be wired into
routes or route segments. A route policy in Camel utilizes a strategy pattern
for applying interceptors on Camel Processors. It's offering the ability
to apply cross-cutting concerns (for example. security, transactions etc) of a Camel route.

The components offering authentication and authorization services
utilizing xref:route-policy.adoc[Route Policy] are:

* xref:components:others:shiro.adoc[Shiro Security]
* xref:components:others:spring-security.adoc[Spring Security]

== Payload Security

Camel offers encryption/decryption services to secure payloads or
selectively apply encryption/decryption capabilities on
portions/sections of a payload.

The dataformats offering encryption/decryption of payloads
utilizing xref:components:eips:marshal-eip.adoc[Marshal] are:

* xref:components:dataformats:crypto-dataformat.adoc[Crypto]
* xref:components:dataformats:pgp-dataformat.adoc[PGP]
* xref:components:dataformats:xmlSecurity-dataformat.adoc[XML security]

== Endpoint Security

Some components in Camel offer an ability to secure their endpoints
(using interceptors etc) and therefore ensure that they offer the
ability to secure payloads as well as provide
authentication/authorization capabilities at endpoints created using the
components.

== Configuration Security

Camel offers the xref:components::properties-component.adoc[Properties] component to
externalize configuration values to properties files. Those values could
contain sensitive information such as usernames and passwords.

Those values can be encrypted and automatically decrypted by Camel using:

* xref:components:others:jasypt.adoc[Jasypt]

Camel also supports accessing the secured configuration from an external vault systems.

=== Configuration Security using Vaults

The following _Vaults_ are supported by Camel:

* xref:components::aws-secrets-manager-component.adoc[AWS Secrets Manager]
* xref:components::google-secret-manager-component.adoc[Google Secret Manager]
* xref:components::azure-key-vault-component.adoc[Azure Key Vault]
* xref:components::hashicorp-vault-component.adoc[Hashicorp Vault]

==== Using AWS Vault

To use AWS Secrets Manager, you need to provide _accessKey_, _secretKey_ and the _region_.
This can be done using environmental variables before starting the application:

[source,bash]
----
export $CAMEL_VAULT_AWS_ACCESS_KEY=accessKey
export $CAMEL_VAULT_AWS_SECRET_KEY=secretKey
export $CAMEL_VAULT_AWS_REGION=region
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.aws.accessKey = accessKey
camel.vault.aws.secretKey = secretKey
camel.vault.aws.region = region
----

If you want instead to use the https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/credentials.html[AWS default credentials provider], you'll need to provide the following env variables:

[source,bash]
----
export $CAMEL_VAULT_AWS_USE_DEFAULT_CREDENTIALS_PROVIDER=true
export $CAMEL_VAULT_AWS_REGION=region
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.aws.defaultCredentialsProvider = true
camel.vault.aws.region = region
----

It is also possible to specify a particular profile name for accessing AWS Secrets Manager

[source,bash]
----
export $CAMEL_VAULT_AWS_USE_PROFILE_CREDENTIALS_PROVIDER=true
export $CAMEL_VAULT_AWS_PROFILE_NAME=test-account
export $CAMEL_VAULT_AWS_REGION=region
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.aws.profileCredentialsProvider = true
camel.vault.aws.profileName = test-account
camel.vault.aws.region = region
----

At this point you'll be able to reference a property in the following way by using `aws:` as prefix in the `{{ }}` syntax:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{aws:route}}"/>
    </route>
</camelContext>
----

Where `route` will be the name of the secret stored in the AWS Secrets Manager Service.

You could specify a default value in case the secret is not present on AWS Secret Manager:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{aws:route:default}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist, the property will fallback to "default" as value.

Also, you are able to get a particular field of the secret, if you have, for example, a secret named database of this form:

[source,json]
----
{
  "username": "admin",
  "password": "password123",
  "engine": "postgres",
  "host": "127.0.0.1",
  "port": "3128",
  "dbname": "db"
}
----

You're able to do get single secret value in your route, like for example:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{aws:database#username}}"/>
    </route>
</camelContext>
----

Or re-use the property as part of an endpoint.

You could specify a default value in case the particular field of secret is not present on AWS Secret Manager:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{aws:database#username:admin}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist or the secret exists, but the username field is not part of the secret, the property will fall back to "admin" as value.

NOTE: For the moment we are not considering the rotation function if any are applied, but it is in the work to be done.

The only requirement is adding `camel-aws-secrets-manager` JAR to your Camel application.

==== Using GCP Vault

To use GCP Secret Manager, you need to provide _serviceAccountKey_ file and GCP _projectId_.
This can be done using environmental variables before starting the application:

[source,bash]
----
export $CAMEL_VAULT_GCP_SERVICE_ACCOUNT_KEY=file:////path/to/service.accountkey
export $CAMEL_VAULT_GCP_PROJECT_ID=projectId
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.gcp.serviceAccountKey = accessKey
camel.vault.gcp.projectId = secretKey
----

If you want instead to use the https://cloud.google.com/docs/authentication/production[GCP default client instance], you'll need to provide the following env variables:

[source,bash]
----
export $CAMEL_VAULT_GCP_USE_DEFAULT_INSTANCE=true
export $CAMEL_VAULT_GCP_PROJECT_ID=projectId
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.gcp.useDefaultInstance = true
camel.vault.aws.projectId = region
----

At this point you'll be able to reference a property in the following way by using `gcp:` as prefix in the `{{ }}` syntax:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{gcp:route}}"/>
    </route>
</camelContext>
----

Where `route` will be the name of the secret stored in the GCP Secret Manager Service.

You could specify a default value in case the secret is not present on GCP Secret Manager:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{gcp:route:default}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist, the property will fallback to "default" as value.

Also, you are able to get a particular field of the secret, if you have, for example, a secret named database of this form:

[source,json]
----
{
  "username": "admin",
  "password": "password123",
  "engine": "postgres",
  "host": "127.0.0.1",
  "port": "3128",
  "dbname": "db"
}
----

You're able to do get single secret value in your route, like for example:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{gcp:database#username}}"/>
    </route>
</camelContext>
----

Or re-use the property as part of an endpoint.

You could specify a default value in case the particular field of secret is not present on GCP Secret Manager:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{gcp:database#username:admin}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist or the secret exists, but the username field is not part of the secret, the property will fallback to "admin" as value.

NOTE: For the moment we are not considering the rotation function if any are applied, but it is in the work to be done.

There are only two requirements: 
- Adding `camel-google-secret-manager` JAR to your Camel application.
- Give the service account used permissions to do operation at secret management level (for example accessing the secret payload, or being admin of secret manager service)

==== Using Azure Key Vault

To use this function, you'll need to provide credentials to Azure Key Vault Service as environment variables:

[source,bash]
----
export $CAMEL_VAULT_AZURE_TENANT_ID=tenantId
export $CAMEL_VAULT_AZURE_CLIENT_ID=clientId
export $CAMEL_VAULT_AZURE_CLIENT_SECRET=clientSecret
export $CAMEL_VAULT_AZURE_VAULT_NAME=vaultName
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.azure.tenantId = accessKey
camel.vault.azure.clientId = clientId
camel.vault.azure.clientSecret = clientSecret
camel.vault.azure.vaultName = vaultName
----

Or you can enable the usage of Azure Identity in the following way:

[source,bash]
----
export $CAMEL_VAULT_AZURE_IDENTITY_ENABLED=true
export $CAMEL_VAULT_AZURE_VAULT_NAME=vaultName
----

You can also enable the usage of Azure Identity in the `application.properties` file such as:

[source,properties]
----
camel.vault.azure.azureIdentityEnabled = true
camel.vault.azure.vaultName = vaultName
----

At this point, you'll be able to reference a property in the following way:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{azure:route}}"/>
    </route>
</camelContext>
----

Where route will be the name of the secret stored in the Azure Key Vault Service.

You could specify a default value in case the secret is not present on Azure Key Vault Service:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{azure:route:default}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist, the property will fallback to "default" as value.

Also you are able to get a particular field of the secret if you have, for example, a secret named database of this form:

[source,bash]
----
{
  "username": "admin",
  "password": "password123",
  "engine": "postgres",
  "host": "127.0.0.1",
  "port": "3128",
  "dbname": "db"
}
----

You're able to do get single secret value in your route, like for example:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{azure:database#username}}"/>
    </route>
</camelContext>
----

Or re-use the property as part of an endpoint.

You could specify a default value in case the particular field of secret is not present on Azure Key Vault:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{azure:database#username:admin}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist or the secret exists, but the username field is not part of the secret, the property will fallback to "admin" as value.

For the moment we are not considering the rotation function if any are applied, but it is in the work to be done.

The only requirement is adding the camel-azure-key-vault jar to your Camel application.

==== Using Hashicorp Vault

To use this function, you'll need to provide credentials for Hashicorp vault as environment variables:

[source,bash]
----
export $CAMEL_VAULT_HASHICORP_TOKEN=token
export $CAMEL_VAULT_HASHICORP_HOST=host
export $CAMEL_VAULT_HASHICORP_PORT=port
export $CAMEL_VAULT_HASHICORP_SCHEME=http/https
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.hashicorp.token = token
camel.vault.hashicorp.host = host
camel.vault.hashicorp.port = port
camel.vault.hashicorp.scheme = scheme
----

In case the running Hashicorp Vault instance you're pointing is running on Hashicorp Cloud, the configuration will require two additional parameters:

[source,bash]
----
export CAMEL_VAULT_HASHICORP_TOKEN=token
export CAMEL_VAULT_HASHICORP_HOST=host
export CAMEL_VAULT_HASHICORP_PORT=port
export CAMEL_VAULT_HASHICORP_SCHEME=http/https
export CAMEL_HASHICORP_VAULT_CLOUD=true
export CAMEL_HASHICORP_VAULT_NAMESPACE=namespace
----

You can also set the same in the `application.properties` file such as:

[source,properties]
----
camel.vault.hashicorp.token = token
camel.vault.hashicorp.host = host
camel.vault.hashicorp.port = port
camel.vault.hashicorp.scheme = scheme
camel.vault.hashicorp.cloud = true
camel.vault.hashicorp.namespace = namespace
----

At this point, you'll be able to reference a property in the following way:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{hashicorp:secret:route}}"/>
    </route>
</camelContext>
----

Where route will be the name of the secret stored in the Hashicorp Vault instance, in the 'secret' engine.

You could specify a default value in case the secret is not present on Hashicorp Vault instance:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{hashicorp:secret:route:default}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist in the 'secret' engine, the property will fall back to "default" as value.

Also, you are able to get a particular field of the secret, if you have, for example, a secret named database of this form:

[source,bash]
----
{
  "username": "admin",
  "password": "password123",
  "engine": "postgres",
  "host": "127.0.0.1",
  "port": "3128",
  "dbname": "db"
}
----

You're able to do get single secret value in your route, in the 'secret' engine, like, for example:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{hashicorp:secret:database#username}}"/>
    </route>
</camelContext>
----

Or re-use the property as part of an endpoint.

You could specify a default value in case the particular field of secret is not present on Hashicorp Vault instance, in the 'secret' engine:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{hashicorp:secret:database#username:admin}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist or the secret exists (in the 'secret' engine) but the username field is not part of the secret, the property will fall back to "admin" as value.

There is also the syntax to get a particular version of the secret for both the approach, with field/default value specified or only with secret:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{hashicorp:secret:route@2}}"/>
    </route>
</camelContext>
----

This approach will return the RAW route secret with version '2', in the 'secret' engine.

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{hashicorp:route:default@2}}"/>
    </route>
</camelContext>
----

This approach will return the route secret value with version '2' or default value in case the secret doesn't exist or the version doesn't exist (in the 'secret' engine).

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{hashicorp:secret:database#username:admin@2}}"/>
    </route>
</camelContext>
----

This approach will return the username field of the database secret with version '2' or admin in case the secret doesn't exist or the version doesn't exist (in the 'secret' engine).

==== Using IBM Secrets Manager Vault

To use this function, you'll need to provide credentials for IBM Secrets Manager vault as environment variables:

[source,bash]
----
export CAMEL_VAULT_IBM_TOKEN=token
export CAMEL_VAULT_IBM_SERVICE_URL=serviceUrl
----

You can also configure the credentials in the `application.properties` file such as:

[source,properties]
----
camel.vault.ibm.token = token
camel.vault.ibm.serviceUrl = serviceUrl
----

NOTE: if you're running the application on a Kubernetes based cloud platform, you can initialize the environment variables from a Secret or Configmap to enhance security. You can also enhance security by xref:manual::using-propertyplaceholder.adoc#_resolving_property_placeholders_on_cloud[setting a Secret property placeholder] which will be initialized at application runtime only.

NOTE: `camel.vault.ibm` configuration only applies to the IBM Secrets Manager Vault properties function (E.g when resolving properties).
When using the `operation` option to create, get, list secrets etc., you should provide the `token` and `serviceUrl` options.

At this point, you'll be able to reference a property in the following way:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{ibm:default:route}}"/>
    </route>
</camelContext>
----

Where route will be the name of the secret stored in the IBM Secrets Manager Vault instance, in the 'default' secret group.

You could specify a default value in case the secret is not present on IBM Secrets Manager Vault instance:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{ibm:default:route:default}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist in the 'default' secret group, the property will fall back to "default" as value.

Also, you are able to get a particular field of the secret, if you have, for example, a secret named database of this form:

[source,bash]
----
{
  "username": "admin",
  "password": "password123",
  "engine": "postgres",
  "host": "127.0.0.1",
  "port": "3128",
  "dbname": "db"
}
----

You're able to do get single secret value in your route, in the 'default' secret group, like for example:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{ibm:default:database#username}}"/>
    </route>
</camelContext>
----

Or re-use the property as part of an endpoint.

You could specify a default value in case the particular field of secret is not present on IBM Secrets Manager Vault instance, in the 'secret' engine:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{ibm:default:database#username:admin}}"/>
    </route>
</camelContext>
----

In this case, if the secret doesn't exist or the secret exists (in the 'default' secret group) but the username field is not part of the secret, the property will fall back to "admin" as value.

There is also the syntax to get a particular version of the secret for both the approaches, with field/default value specified or only with secret:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{ibm:default:route@2}}"/>
    </route>
</camelContext>
----

This approach will return the RAW route secret with version '2', in the 'default' secret group.

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{ibm:default:route:default@2}}"/>
    </route>
</camelContext>
----

This approach will return the route secret value with version '2' or default value in case the secret doesn't exist or the version doesn't exist (in the 'default' secret group).

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <log message="Username is {{ibm:default:database#username:admin@2}}"/>
    </route>
</camelContext>
----

This approach will return the username field of the database secret with version '2' or admin in case the secret doesn't exist or the version doesn't exist (in the 'default' secret group).

The only requirement is adding the camel-ibm-secrets-manager jar to your Camel application.

==== Automatic Camel context reloading on Secret Refresh while using AWS Secrets Manager

Being able to reload Camel context on a Secret Refresh, could be done by specifying the usual credentials (the same used for AWS Secret Manager Property Function).

With Environment variables:

[source,bash]
----
export $CAMEL_VAULT_AWS_USE_DEFAULT_CREDENTIALS_PROVIDER=accessKey
export $CAMEL_VAULT_AWS_REGION=region
----

or as plain Camel main properties:

[source,properties]
----
camel.vault.aws.useDefaultCredentialProvider = true
camel.vault.aws.region = region
----

Or by specifying accessKey/SecretKey and region, instead of using the default credentials provider chain.

To enable the automatic refresh, you'll need additional properties to set:

[source,properties]
----
camel.vault.aws.refreshEnabled=true
camel.vault.aws.refreshPeriod=60000
camel.vault.aws.secrets=Secret
camel.main.context-reload-enabled = true
----

where `camel.vault.aws.refreshEnabled` will enable the automatic context reload, `camel.vault.aws.refreshPeriod` is the interval of time between two different checks for update events and `camel.vault.aws.secrets` is a regex representing the secrets we want to track for updates.

Note that `camel.vault.aws.secrets` is not mandatory: if not specified the task responsible for checking updates events will take into accounts or the properties with an `aws:` prefix.

The only requirement is adding the camel-aws-secrets-manager jar to your Camel application.

==== Automatic Camel context reloading on Secret Refresh while using AWS Secrets Manager with Eventbridge and AWS SQS Services

Another option is to use AWS EventBridge in conjunction with the AWS SQS service.

On the AWS side, the following resources need to be created:

- an AWS CloudTrail trail
- an AWS SQS Queue
- an EventBridge rule of the following kind

[source,json]
----
{
  "source": ["aws.secretsmanager"],
  "detail-type": ["AWS API Call via CloudTrail"],
  "detail": {
    "eventSource": ["secretsmanager.amazonaws.com"]
  }
}
----

This rule will make the event related to AWS Secrets Manager filtered

- You need to set the a Rule target to the AWS SQS Queue for Eventbridge rule

- You need to give permission to the Eventbrige rule, to write on the above SQS Queue. For doing this you'll need to define a json file like this:

[source,json]
----
{
    "Policy": "{\"Version\":\"2012-10-17\",\"Id\":\"<queue_arn>/SQSDefaultPolicy\",\"Statement\":[{\"Sid\": \"EventsToMyQueue\", \"Effect\": \"Allow\", \"Principal\": {\"Service\": \"events.amazonaws.com\"}, \"Action\": \"sqs:SendMessage\", \"Resource\": \"<queue_arn>\", \"Condition\": {\"ArnEquals\": {\"aws:SourceArn\": \"<eventbridge_rule_arn>\"}}}]}"
}
----

Change the values for queue_arn and eventbridge_rule_arn, save the file with policy.json name and run the following command with AWS CLI

[source,bash]
----
aws sqs set-queue-attributes --queue-url <queue_url> --attributes file://policy.json
----

where queue_url is the AWS SQS Queue URL of the just created Queue.

Now you should be able to set up the configuration on the Camel side. To enable the SQS notification, add the following properties:

[source,properties]
----
camel.vault.aws.refreshEnabled=true
camel.vault.aws.refreshPeriod=60000
camel.vault.aws.secrets=Secret
camel.main.context-reload-enabled = true
camel.vault.aws.useSqsNotification=true
camel.vault.aws.sqsQueueUrl=<queue_url>
----

where queue_url is the AWS SQS Queue URL of the just created Queue.

Whenever an event of PutSecretValue for the Secret named 'Secret' will happen, a message will be enqueued in the AWS SQS Queue and consumed on the Camel side and a context reload will be triggered.

==== Automatic Camel context reloading on Secret Refresh while using Google Secret Manager

Being able to reload Camel context on a Secret Refresh, could be done by specifying the usual credentials (the same used for Google Secret Manager Property Function).

With Environment variables:

[source,bash]
----
export $CAMEL_VAULT_GCP_USE_DEFAULT_INSTANCE=true
export $CAMEL_VAULT_GCP_PROJECT_ID=projectId
----

or as plain Camel main properties:

[source,properties]
----
camel.vault.gcp.useDefaultInstance = true
camel.vault.aws.projectId = projectId
----

Or by specifying a path to a service account key file, instead of using the default instance.

To enable the automatic refresh you'll need additional properties to set:

[source,properties]
----
camel.vault.gcp.projectId= projectId
camel.vault.gcp.refreshEnabled=true
camel.vault.gcp.refreshPeriod=60000
camel.vault.gcp.secrets=hello*
camel.vault.gcp.subscriptionName=subscriptionName
camel.main.context-reload-enabled = true
----

where `camel.vault.gcp.refreshEnabled` will enable the automatic context reload, `camel.vault.gcp.refreshPeriod` is the interval of time between two different checks for update events and `camel.vault.gcp.secrets` is a regex representing the secrets we want to track for updates.

Note that `camel.vault.gcp.secrets` is not mandatory: if not specified the task responsible for checking updates events will take into accounts or the properties with an `gcp:` prefix.

The `camel.vault.gcp.subscriptionName` is the subscription name created in relation to the Google PubSub topic associated with the tracked secrets.

This mechanism makes use of the notification system related to Google Secret Manager: through this feature, every secret could be associated with one up to ten Google Pubsub Topics. These topics will receive
events related to the life cycle of the secret.

There are only two requirements: 
- Adding `camel-google-secret-manager` JAR to your Camel application.
- Give the service account used permissions to do operation at secret management level (for example, accessing the secret payload, or being admin of secret manager service and also have permission over the Pubsub service)

==== Automatic Camel context reloading on Secret Refresh while using Azure Key Vault

Being able to reload Camel context on a Secret Refresh, could be done by specifying the usual credentials (the same used for Azure Key Vault Property Function).

With Environment variables:

[source,bash]
----
export $CAMEL_VAULT_AZURE_TENANT_ID=tenantId
export $CAMEL_VAULT_AZURE_CLIENT_ID=clientId
export $CAMEL_VAULT_AZURE_CLIENT_SECRET=clientSecret
export $CAMEL_VAULT_AZURE_VAULT_NAME=vaultName
----

or as plain Camel main properties:

[source,properties]
----
camel.vault.azure.tenantId = accessKey
camel.vault.azure.clientId = clientId
camel.vault.azure.clientSecret = clientSecret
camel.vault.azure.vaultName = vaultName
----

If you want to use Azure Identity with environment variables, you can do in the following way:

[source,bash]
----
export $CAMEL_VAULT_AZURE_IDENTITY_ENABLED=true
export $CAMEL_VAULT_AZURE_VAULT_NAME=vaultName
----

You can also enable the usage of Azure Identity in the `application.properties` file such as:

[source,properties]
----
camel.vault.azure.azureIdentityEnabled = true
camel.vault.azure.vaultName = vaultName
----

To enable the automatic refresh, you'll need additional properties to set:

[source,properties]
----
camel.vault.azure.refreshEnabled=true
camel.vault.azure.refreshPeriod=60000
camel.vault.azure.secrets=Secret
camel.vault.azure.eventhubConnectionString=eventhub_conn_string
camel.vault.azure.blobAccountName=blob_account_name
camel.vault.azure.blobContainerName=blob_container_name
camel.vault.azure.blobAccessKey=blob_access_key
camel.main.context-reload-enabled = true
----

where `camel.vault.azure.refreshEnabled` will enable the automatic context reload, `camel.vault.azure.refreshPeriod` is the interval of time between two different checks for update events and `camel.vault.azure.secrets` is a regex representing the secrets we want to track for updates.

where `camel.vault.azure.eventhubConnectionString` is the eventhub connection string to get notification from, `camel.vault.azure.blobAccountName`, `camel.vault.azure.blobContainerName` and `camel.vault.azure.blobAccessKey` are the Azure Storage Blob parameters for the checkpoint store needed by Azure Eventhub.

Note that `camel.vault.azure.secrets` is not mandatory: if not specified the task responsible for checking updates events will take into accounts or the properties with an `azure:` prefix.

The only requirement is adding the camel-azure-key-vault jar to your Camel application.

==== Automatic Camel context reloading on Secret Refresh while using IBM Secrets Manager

Being able to reload Camel context on a Secret Refresh could be done by specifying the IBM Event Streams credentials combined with the IBM Secrets Manager one (the same used for IBM Secrets Manager Property Function).

With Environment variables:

[source,bash]
----
export CAMEL_VAULT_IBM_TOKEN=token
export CAMEL_VAULT_IBM_SERVICE_URL=serviceUrl
export CAMEL_VAULT_IBM_EVENTSTREAM_BOOTSTRAP_SERVERS=bootstrapServers
export CAMEL_VAULT_IBM_EVENTSTREAM_TOPIC=topic
export CAMEL_VAULT_IBM_EVENTSTREAM_USERNAME=token
export CAMEL_VAULT_IBM_EVENTSTREAM_PASSWORD=password
export CAMEL_VAULT_IBM_EVENTSTREAM_CONSUMER_GROUP_ID=groupId
export CAMEL_VAULT_IBM_EVENTSTREAM_CONSUMER_POLL_TIMEOUT=3000
----

or as plain Camel main properties:

[source,properties]
----
camel.vault.ibm.token = token
camel.vault.ibm.serviceUrl = serviceUrl
camel.vault.ibm.eventStreamBootstrapServers = bootstrapServers
camel.vault.ibm.eventStreamTopic = topic
camel.vault.ibm.eventStreamUsername = token
camel.vault.ibm.eventStreamPassword = password
camel.vault.ibm.eventStreamGroupId = groupId
camel.vault.ibm.eventStreamConsumerPollTimeout=3000
----

To enable the automatic refresh, you'll need additional properties to set:

[source,properties]
----
camel.vault.ibm.refreshEnabled=true
camel.vault.ibm.secrets=Secret
camel.main.context-reload-enabled = true
----

where `camel.vault.ibm.refreshEnabled` will enable the automatic context reload and `camel.vault.ibm.secrets` is a regex representing the secrets we want to track for updates.

where `camel.vault.ibm.eventStreamBootstrapServers` is the comma-separated list of Bootstrap Servers for IBM Event Stream, `camel.vault.ibm.eventStreamTopic`, `camel.vault.ibm.eventStreamUsername`, `camel.vault.ibm.eventStreamPassword`, `camel.vault.ibm.eventStreamGroupId` and `camel.vault.ibm.eventStreamConsumerPollTimeout` are the IBM Event Stream parameters for connecting and consuming events related to Secrets.

Note that `camel.vault.ibm.secrets` is not mandatory: if not specified the task responsible for checking updates events will take into accounts or the properties with an `ibm:` prefix.

The only requirement is adding the camel-ibm-secrets-manager jar to your Camel application.
= Service Registry

Service registration is a key part of service discovery which Camel leverages through
the _Service Call EIP_ and support to ease the process to expose routes in a
cloud environment and consume them with minimal configuration.

== Service Registry Set-Up

A `ServiceRegistry` is just like any other camel service so set it up you only need
to register your implementations to the `CamelContext`:

[source,java]
----
ServiceRegistry service = new MyServiceRegistry();

context.addService(service);
----

The configuration of the _Service Registry_ depends on the implementation you have chosen.
Out of the box camel provides the following implementations:

[cols="1,1,2", options="header"]
|====
|Type         |Module             | Class
|consul       |camel-consul       | org.apache.camel.component.consul.cloud.ConsulServiceRegistry
|spring-cloud |camel-spring-cloud | org.apache.camel.component.spring.cloud.CamelSpringCloudServiceRegistry
|zookeeper    |camel-zookeeper    | org.apache.camel.component.zookeeper.cloud.ZooKeeperServiceRegistry
|====

== Service Registry Usage

The _Service Registry SPI_ is leveraged by the following new implementations:

=== ServiceRegistryRoutePolicy

This is an implementation of a xref:route-policy.adoc[Route Policy] that register/deregister routes
to a given `ServiceRegistry` according to route's life-cycle:

[source,java]
----
RoutePolicy policy = new ServiceRegistrationRoutePolicy()

// bind the policy to one or more routes
from("undertow:http://0.0.0.0:8080")
    .routePolicy(policy)
    .log("Route ${routeId} has been invoked");
----

To apply the same policy to all the routes a dedicated `RoutePolicyFactory` can be used:

[source,java]
----
// add the service registry route policy factory to context
context.addRoutePolicyFactory(new ServiceRegistrationRoutePolicyFactory()));
----

To configure how the service is exposed you can add route specific properties like:

[source,java]
----
// bind the policy to one or more routes
from("undertow:http://0.0.0.0:8080")
    .routePolicy(policy)
    .routeProperty(ServiceDefinition.SERVICE_META_NAME, "my-service")
    .routeProperty(ServiceDefinition.SERVICE_META_ID, "my-id")
    .routeProperty(ServiceDefinition.SERVICE_META_PORT, "8080")
    .log("Route ${routeId} has been invoked");
----

Service name and service id can also be provided by _routeId_ and _routeGroup_:

[source,java]
----
// bind the policy to one or more routes
from("undertow:http://0.0.0.0:8080")
    .routePolicy(policy)
    .routeGroup("my-service")
    .routeId("my-id")
    .routeProperty(ServiceDefinition.SERVICE_META_PORT, "8080")
    .log("Route ${routeId} has been invoked");
----

Any property prefixed with _service._ is automatically added to the service's metadata.

TIP: Some component such has camel-undertow and those based on camel-http-common implement _DiscoverableService_ and they can automatically provide the metadata needed for service registration.

=== Service Component

The xref:components::service-component.adoc[Service] component is similar to a `ServiceRegistrationRoutePolicyFactory`
but is capable of tagging routes that need to be registered to the `ServiceRegistry`
by prefixing the related endpoints with `service:name` according to the following syntax:

[source,text]
----
service:serviceName:delegateUri[?options]
----

Let's explain this with an example:

[source,java]
----
from("service:my-service:undertow:http://0.0.0.0:8080")
    .log("Route ${routeId} has been invoked");
----

To configure how the service is exposed you can add service specific endpoint options such as:

[source,java]
----
from("service:my-service:undertow:http://0.0.0.0:8080?service.id=my-service-id")
    .log("Route ${routeId} has been invoked");
----

Any option prefixed with _service._ is automatically added to the service's metadata.

= SimpleScheduledRoutePolicy

`SimpleScheduledRoutePolicy` is a xref:scheduledroutepolicy.adoc[ScheduledRoutePolicy]
that facilitates route activation, de-activation, suspension and resumption of routes
based on the xref:components::quartz-component.adoc[Quartz] simple trigger.


== How it works

In order to use a `SimpleScheduledRoutePolicy` it is necessary to
instantiate an object of the type
`org.apache.camel.routepolicy.quartz.SimpleScheduledRoutePolicy`.

NOTE: All Scheduled route policies share the scheduler created by the Quartz
component. In this way, scheduler, jobs and triggers can be managed in a
common and consistent way.

=== Configuration options

In order to perform a route operation at a given time the following
information must be provided.

* Starting a route

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter Name |Type |Default |Description
|routeStartDate |java.util.Date |  |the initial scheduled Date and time
for route start

|routeStartRepeatCount |int |  |no of times to repeat the job

|routeStartRepeatInterval |long |  |the time interval in milliseconds to
trigger the next attempt to start the route
|=======================================================================

* Stopping a route

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter Name |Type |Default |Description
|routeStopDate |java.util.Date |  |the initial scheduled Date and time
for route stop

|routeStopRepeatCount |int |  |no of times to repeat the job

|routeStopRepeatInterval |long |  |the time interval in milliseconds to
trigger the next attempt to stop the route

|routeStopGracePeriod |int |10 seconds |the time period to wait before
initiating graceful route stop

|routeStopTimeUnit |long |TimeUnit.MILLISECONDS |the time unit for the
grace period expressed as java.util.concurrent.TimeUnit
|=======================================================================

* Suspending a route

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter Name |Type |Default |Description
|routeSuspendDate |java.util.Date |  |the initial scheduled Date and
time for route suspension

|routeSuspendRepeatCount |int |  |no of times to repeat the job

|routeSuspendRepeatInterval |long |  |the time interval in milliseconds
to trigger the next attempt to suspend the route
|=======================================================================

* Resuming a route

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter Name |Type |Default |Description
|routeResumeDate |java.util.Date |  |the initial scheduled Date and time
for route start

|routeResumeRepeatCount |int |  |no of times to repeat the job

|routeResumeRepeatInterval |long |  |the time interval in milliseconds
to trigger the next attempt to resume the route
|=======================================================================

Once the
`org.apache.camel.routepolicy.quartz.SimpleScheduledRoutePolicy` is
created it can be wired into the camel route as follows.

== Using the SimpleScheduledRoutePolicy

The `SimpleScheduledRoutePolicy` can be used in Java DSL as show:

[source,java]
----
SimpleScheduledRoutePolicy policy = new SimpleScheduledRoutePolicy();
long startTime = System.currentTimeMillis() + 3000L;
policy.setRouteStartDate(new Date(startTime));
policy.setRouteStartRepeatCount(1);
policy.setRouteStartRepeatInterval(3000);
                
from("direct:start")
   .routeId("test")
   .routePolicy(policy)
   .to("mock:success");
----

And in Spring XML:

[source,xml]
----
<bean id="date" class="org.apache.camel.routepolicy.quartz.SimpleDate"/>

<bean id="startPolicy" class="org.apache.camel.routepolicy.quartz.SimpleScheduledRoutePolicy">
    <property name="routeStartDate" ref="date"/>
    <property name="routeStartRepeatCount" value="1"/>
    <property name="routeStartRepeatInterval" value="3000"/>      
</bean> 
    
<camelContext xmlns="http://camel.apache.org/schema/spring">
    <route id="myroute" routePolicyRef="startPolicy">
        <from uri="direct:start"/>
        <to uri="mock:success"/>
    </route>
</camelContext>
----

== Dependency

Maven users will need to add a `camel-quartz` dependency to their
`pom.xml` to avail this capability.

[source,xml]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-quartz</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----
= Spring XML

Using Camel with Spring XML files, is a classic way, of using XML DSL with Camel.
Camel has historically been using Spring XML for a long time.
The Spring framework started with XML files as a popular and common configuration for building Spring applications.

The following is an example of what it looks like:

[source,xml]
----
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
    ">

    <camelContext xmlns="http://camel.apache.org/schema/spring">
        <route>
            <from uri="direct:a"/>
            <choice>
                <when>
                    <xpath>$foo = 'bar'</xpath>
                    <to uri="direct:b"/>
                </when>
                <when>
                    <xpath>$foo = 'cheese'</xpath>
                    <to uri="direct:c"/>
                </when>
                <otherwise>
                    <to uri="direct:d"/>
                </otherwise>
            </choice>
        </route>
    </camelContext>

</beans>
----

== Using Spring XML

The following dependency needs to be added to your pom.xml so that Spring XML files can be scanned by Camel:

[source,xml]
--------------------------------------------------------------------------------------------------------------
 <dependency>
     <groupId>org.apache.camel.springboot</groupId>
     <artifactId>camel-spring-boot-xml-starter</artifactId>
 </dependency>
--------------------------------------------------------------------------------------------------------------

You can use Spring XML files to specify Camel routes using XML DSL as shown:

[source,xml]
--------------------------------------------------------------------------------------------------------------
<camelContext id="camel-A" xmlns="http://camel.apache.org/schema/spring">
  <route>
    <from uri="seda:start"/>
    <to uri="mock:result"/>
  </route>
</camelContext>
--------------------------------------------------------------------------------------------------------------

=== Configuring Components and Endpoints

You can configure your Component or xref:endpoint.adoc[Endpoint] instances in your Spring XML as follows in this example.

[source,xml]
--------------------------------------------------------------------------------------------------------------
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
</camelContext>

<bean id="activemq" class="org.apache.camel.component.activemq.ActiveMQComponent">
  <property name="connectionFactory">
    <bean class="org.apache.activemq.ActiveMQConnectionFactory">
      <property name="brokerURL" value="tcp:someserver:61616"/>
    </bean>
  </property>
</bean>
--------------------------------------------------------------------------------------------------------------

Which allows you to configure a component using any name, but its common to use the same name
eg (`activemq`). Then you can refer to the component using `activemq:destinationName`.

This works by the Camel lazily fetching components from the Spring context for the scheme name you use for Endpoint xref:uris.adoc[URI]s.

== Using Java DSL with Spring XML files

You can use Java Code to define your xref:route-builder.adoc[RouteBuilder] implementations. These can be defined as beans in spring and then referenced in your camel context e.g.

[source,xml]
--------------------------------------------------------------------------------------------------------------
<camelContext xmlns="http://camel.apache.org/schema/spring">
  <routeBuilder ref="myBuilder"/>
</camelContext>

<bean id="myBuilder" class="org.apache.camel.spring.example.test1.MyRouteBuilder"/>
--------------------------------------------------------------------------------------------------------------

=== Using package scanning

Camel also provides a powerful feature that allows for the automatic discovery and initialization of routes in given packages. This is configured by adding tags to the camel context in your spring context definition, specifying the packages to be recursively searched for RouteBuilder implementations. To use this feature in 1.X, requires a <package></package> tag specifying a comma separated list of packages that should be searched e.g.

[source,xml]
--------------------------------------------------------------------------------------------------------------
<camelContext>
  <packageScan>
    <package>com.foo</package>
    <excludes>**.*Excluded*</excludes>
    <includes>**.*</includes>
  </packageScan>
</camelContext>
--------------------------------------------------------------------------------------------------------------

This will scan for `RouteBuilder` classes in the _com.foo_ and sub-packages.

You can also filter the classes with includes or excludes such as:

[source,xml]
--------------------------------------------------------------------------------------------------------------
<camelContext>
  <packageScan>
    <package>com.foo</package>
    <excludes>**.*Special*</excludes>
  </packageScan>
</camelContext>
--------------------------------------------------------------------------------------------------------------

Which will skip classes that has _Special_ in the name.

Exclude patterns are applied before the include patterns. If no include or exclude patterns are defined then all the Route classes discovered in the packages will be returned.

`?` matches one character `\*` matches zero or more characters `**` matches zero or more segments of a fully qualified name

=== Using context scanning

You can allow Camel to scan the container context, e.g. the Spring ApplicationContext for route builder instances. This allow you to use the Spring *<component-scan>* feature and have Camel pickup any *`RouteBuilder`* instances which was created by Spring in its scan process.

[source,xml]
--------------------------------------------------------------------------------------------------------------
<!-- enable Spring @Component scan -->
<context:component-scan base-package="org.apache.camel.spring.issues.contextscan"/>

<camelContext xmlns="http://camel.apache.org/schema/spring">
    <!-- and then let Camel use those @Component scanned route builders -->
    <contextScan/>
</camelContext>
--------------------------------------------------------------------------------------------------------------

This allows you to just annotate your routes using the Spring *`@Component`*  and have those routes included by Camel:

[source,java]
--------------------------------------------------------------------------------------------------------------
@Component
public class MyRoute extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        from("direct:start")
            .to("mock:result");
    }
}
--------------------------------------------------------------------------------------------------------------

You can also use the ANT style for inclusion and exclusion, as mentioned above in the package scan section.

== Additional configuration of Spring XML

See more details at xref:advanced-configuration-of-camelcontext-using-spring.adoc[Camel Spring XML Auto Configuration].
= Spring

Apache Camel is designed to work first class with Spring in a number of ways, such as:

* Camel runs on Spring Boot with the Camel Spring Boot project
* Camel works with Spring XML files (classic Spring XML)
* Camel works with Spring dependency injection
* Camel works with Spring configuration and property placeholders
* Camel works with Spring transactions
* Camel works with Spring testing

== Using Camel on Spring Boot

See the Camel Spring Boot documentation.

== Using Camel with Spring XML files

Using Camel with Spring XML files, is a classic way, of using XML DSL with Camel.
Camel has historically been using Spring XML for a long time. The Spring framework
started with XML files as a popular and common configuration for building Spring applications.

To use Camel with Spring XML files see the xref:spring-xml-extensions.adoc[Spring XML] documentation.

== Using Spring dependency injection

Spring dependency injection is integrated first-class when using Spring and Spring together.

For example when using Camel on Spring Boot, then you can use any kind of Spring dependency and
be able to inject Camel resources such as 'CamelContext', xref:endpoint.adoc[Endpoint] and many more.

== Using Camel with Spring configuration and property placeholders

See xref:using-propertyplaceholder.adoc[Using Property Placeholder] documentation.

== Using Camel with Spring transactions

See xref:components:eips:transactional-client.adoc[Transactional Client] EIP.

== Using Camel with Spring testing

See xref:components:others:test-spring-junit5.adoc[camel-test-spring-junit5] documentation.

= Startup Condition

*Available as of Camel 4.9*

You can use `StartupCondition` to let Camel perform some checks on startup,
before continuing. For example to check if a specific ENV exists, or wait
for a specific file to be created etc.

Camel provides a few out of the box

- `EnvStartupCondition` - To check for a specific OS environment exists
- `FileStartupCondition` - To check for a specific file exists

You can implement custom conditions by implementing `org.apache.camel.spi.StartupCondition`,
and add these to the `StartupConditionStrategy` or `Registry` such as:

[source,java]
----
StartupConditionStrategy scs = context.getCamelContextExtension().getContextPlugin(StartupConditionStrategy.class);
scs.addStartupCondition(new MyCondition());
----

If you use Camel Main, Spring Boot, or Quarkus, you can configure startup conditions with configuration in `application.properties`.

For example to check for a specific OS environment variable exists:

[source,properties]
----
camel.startupcondition.enabled = true
camel.startupcondition.environmentVariableExists = FOO_BAR
----

Or to use a custom condition by its class name:

[source,properties]
----
camel.startupcondition.enabled = true
camel.startupcondition.customClassNames = com.foo.MyStartupCondition
----

= Stream caching

While stream types (like `StreamSource`, `InputStream` and `Reader`) are commonly used in messaging for performance reasons, they also have an important drawback: they can only be read once. In order to be able to work with message content multiple times, the stream needs to be cached.

Streams are cached in memory. However, for large stream messages, you can set `spoolEnabled=true`
and then large message (over 128 KB) will be cached in a temporary file instead.
Camel itself will handle deleting the temporary file once the cached stream is no longer necessary.

[IMPORTANT]
====
*StreamCache - Affecting the message payload*

The `StreamCache` will affect your payload object as it will replace the `Stream` payload with a `org.apache.camel.StreamCache` object.
This `StreamCache` is capable of being re-readable and thus possible to better be routed within Camel using redelivery
or xref:components:eips:choice-eip.adoc[Content Based Router] or the likes.
====

In order to determine if a message payload requires caching, then Camel uses
the xref:type-converter.adoc[Type Converter] functionality, to determine if
the message payload type can be converted into an `org.apache.camel.StreamCache` instance.

[IMPORTANT]
====
All the classes from the Camel release that implements `org.apache.camel.StreamCache` is NOT intended for end users
to create as instances, but they are part of Camels stream-caching functionality.
====

== Configuring Stream Caching

Stream caching is configured using `org.apache.camel.spi.StreamCachingStrategy`.

The strategy has the following options:

[width="100%",cols="20%,20%,60%",options="header"]
|=======================================================================
| Option | Default | Description

| enabled | true
| Whether stream caching is enabled

| allowClasses | | To filter stream caching of a given set of allowed/denied classes. By default, all classes that are `java.io.InputStream` is allowed. Multiple class names can be separated by comma.

| denyClasses | | To filter stream caching of a given set of allowed/denied classes. By default, all classes that are `java.io.InputStream` is allowed. Multiple class names can be separated by comma.

| spoolEnabled | false
| Whether spool to disk is enabled

| spoolDirectory | ${java.io.tmpdir}/camel/camel-tmp-\#uuid#
| Base directory where temporary files for spooled streams should be stored. This option supports naming patterns as documented below.

| spoolCipher | null
| If set, the temporary files are encrypted using the specified cipher transformation (i.e., a valid stream or 8-bit cipher name such as "RC4", "AES/CTR/NoPadding". An empty name "" is treated as null).

| spoolThreshold | 128 KB
| Size in bytes when the stream should be spooled to disk instead of keeping in memory. Use a value of 0 or negative to disable it all together so streams is always kept in memory regardless of their size.

| spoolUsedHeapMemoryThreshold | 0
| A percentage (1 to 99) of current used heap memory to use as threshold for spooling streams to disk. The upper bounds is based on heap committed (guaranteed memory the JVM can claim). This can be used to spool to disk when running low on memory.

| spoolUsedHeapMemoryLimit | Max
| If `spoolUsedHeapMemoryThreshold` is in use, then whether the used heap memory upper limit is either Max or Committed.

| anySpoolRules | false
| Whether any or all ``SpoolRule``s must return `true` to determine if the stream should be spooled or not. This can be used as applying AND/OR binary logic to all the rules. By default it's AND based.

| bufferSize | 4096
| Sets the buffer size to use when allocating in-memory buffers used for in-memory stream caches.

| removeSpoolDirectoryWhenStopping | true
| Whether to remove the spool directory when stopping xref:camelcontext.adoc[CamelContext].

| statisticsEnabled | false
| Whether utilization statistics is enabled. By enabling this you can see these statics for example with JMX.
|=======================================================================

=== SpoolDirectory naming pattern

The following patterns is supported:

* `\#uuid#` = a random UUID
* `\#camelId#` = the CamelContext id (e.g. the name)
* `\#name#` = same as `\#camelId#`
* `\#counter#` = an incrementing counter
* `\#bundleId#` = the OSGi bundle id (only for OSGi environments)
* `\#symbolicName#` = the OSGi symbolic name (only for OSGi environments)
* `\#version#` = the OSGi bundle version (only for OSGi environments)
* `${env:key}` = the environment variable with the key
* `$\{key}` = the JVM system property with the key

A couple of examples:

To store in the java temp directory with a sub directory using the `CamelContext` name:

[source,java]
----
context.getStreamCachingStrategy().setSpoolDirectory"${java.io.tmpdir}#name#/");
----

To store in `KARAF_HOME/tmp/bundleId` directory:

[source,java]
----
context.getStreamCachingStrategy().setSpoolDirectory"${env:KARAF_HOME}/tmp/bundle#bundleId#");
----

== Configuring StreamCachingStrategy in Java

You can configure the `StreamCachingStrategy` in Java as shown below:

[source,java]
----
context.getStreamCachingStrategy().setSpoolEnabled(true);
context.getStreamCachingStrategy().setSpoolDirectory("/tmp/cachedir");
context.getStreamCachingStrategy().setSpoolThreshold(64 * 1024);
context.getStreamCachingStrategy().setBufferSize(16 * 1024);
// to enable encryption using RC4
// context.getStreamCachingStrategy().setSpoolCipher("RC4");
----

And remember to enable Stream caching on the `CamelContext`:

[source,java]
----
context.setStreamCaching(true);
----

or on routes:

[source,java]
----
from("file:inbox")
  .streamCaching()
  .to("bean:foo");
----

== Configuring StreamCachingStrategy in XML

In XML you can enable stream caching on the `<camelContext>` and then do the configuration in the `streamCaching` element:

[source,xml]
----
<camelContext streamCache="true">

  <streamCaching id="myCacheConfig" bufferSize="16384" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolThreshold="65536"/>

  <route>
    <from uri="direct:c"/>
    <to uri="mock:c"/>
  </route>

</camelContext>
----

=== Using spoolUsedHeapMemoryThreshold

By default, stream caching will spool only big payloads (128 KB or bigger) to disk. However you can also set the `spoolUsedHeapMemoryThreshold` option which is a percentage of used heap memory. This can be used to also spool to disk when running low on memory.

For example with:

[source,xml]
----
<streamCaching id="myCacheConfig" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolUsedHeapMemoryThreshold="70"/>
----

Then notice that as `spoolThreshold` is default enabled with 128 KB, then we have both thresholds in use (`spoolThreshold` and `spoolUsedHeapMemoryThreshold`). And in this example then we only spool to disk if payload is > 128 KB and that used heap memory is > 70%. The reason is that we have the option `anySpoolRules` as default `false`. That means both rules must be `true` (e.g. AND).

If we want to spool to disk if either of the rules (e.g. OR), then we can do:

[source,xml]
----
<streamCaching id="myCacheConfig" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolUsedHeapMemoryThreshold="70" anySpoolRules="true"/>
----

If we only want to spool to disk if we run low on memory then we can set:

[source,xml]
----
<streamCaching id="myCacheConfig" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolThreshold="-1" spoolUsedHeapMemoryThreshold="70"/>
----

then we do not use the `spoolThreshold` rule, and only the heap memory based is in use.

By default, the upper limit of the used heap memory is based on the maximum heap size. Though you can also configure to use the committed heap size as the upper limit, this is done using the `spoolUsedHeapMemoryLimit` option as shown below:

[source,xml]
----
<streamCaching id="myCacheConfig" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolUsedHeapMemoryThreshold="70" spoolUsedHeapMemoryLimit="Committed"/>
----

== Using custom SpoolRule implementations

You can implement your custom rules to determine if the stream should be spooled to disk. This can be done by implementing the interface `org.apache.camel.spi.StreamCachingStrategy.SpoolRule` which has a single method:

[source,java]
----
boolean shouldSpoolCache(long length);
----

The `length` is the length of the stream.
To use the rule then add it to the `StreamCachingStrategy` as shown below:

[source,java]
----
SpoolRule mySpoolRule = ...
context.getStreamCachingStrategy().addSpoolRule(mySpoolRule);
----

And from XML you need to define a `<bean>` with your custom rule:

[source,xml]
----
<bean id="mySpoolRule" class="com.foo.MySpoolRule"/>

<streamCaching id="myCacheConfig" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolRules="mySpoolRule"/>
----

Using the spoolRules attribute on `<streamCaching>`. if you have more rules, then separate them by comma.

[source,xml]
----
<streamCaching id="myCacheConfig" spoolEnabled="true" spoolDirectory="/tmp/cachedir" spoolRules="mySpoolRule,myOtherSpoolRule"/>
----

== Using StreamCachingProcessor

Since Camel 4.11 this processor can be used to convert the current message body to a `StreamCache`. This allows the body to be re-read multiple times and can be placed at any point in a Camel route.

[source, java]
----
from("direct:start")
    .process(new StreamCachingProcessor())
    .to("log:cached");
----
= Test Infrastructure

The components in the Camel Test Infra provide utilities to simplify testing with Camel and other systems may interact with it.

The test infra is divided in two parts:

* One that offers container provisioning features for all scopes
* Another that provides container provisioning features for tests.

== Simulating the Test Infrastructure

One of the first steps when implementing a new test is to identify how to simulate infrastructure required for it to
run. The test-infra module provides a reusable library of infrastructure that can be used for that purpose. 

In general, the integration test leverages the features provided by the project https://www.testcontainers.org/[TestContainers]
and uses container images to simulate the environments. Additionally, it may also support running the tests against remote 
environments as well as, when available, embeddable components. This varies by each component, and it is recommended to 
check the code for additional details.

=== Writing A New Test Infrastructure Module


[NOTE]
====
This section is aimed at Camel maintainers that need to write new test infra components. End users can skip this section.
====

The test code abstracts the provisioning of test environments behind service classes (i.e.: JMSService, JDBCService,
etc). The purpose of the service class is to abstract both the type service (i.e.: Kafka, Strimzi, etc.) and
the location of the service (i.e.: remote, local, embedded, etc). This provides flexibility to test the code under 
different circumstances (i.e.: using a remote JMS broker or using a local JMS broker running in a container managed by
TestContainers). It makes it easier to hit edge cases as well as try different operating scenarios (i.e.: higher
latency, slow backends, etc).

When a container image is not available via TestContainers, tests can provide their own implementation using officially
available images. The license must be compatible with Apache 2.0. If an official image is not available, a Dockerfile
to build the service can be provided. The Dockerfile should try to minimize the container size and resource usage
whenever possible.

The container information must reside in a file named `container.properties` which should contain the container fully qualified
name:

[source,properties]
----
opensearch.container=mirror.gcr.io/opensearchproject/opensearch:2.18.0
opensearch.container.ppc64le=icr.io/ppc64le-oss/opensearch-ppc64le:2.12.0
----

The keys must follow the pattern `<name>.properties`. Specific architectures can be added to the key to denote which container
to be used for each architecture. Currently accepted values are:

* `aarch64`: for Arm
* `s390x`: for s390x (Linux On Mainframe)
* `ppc64le`: for 64-bit little ending power

It is also possible to use embeddable components when required, although this usually leads to more code and higher
maintenance.

NOTE: support for embeddable components may be removed in future versions.

==== Recommended Structure for Test Infrastructure Modules

The actual Service interface and implementation should be added under `src/main`, while the actual integration with JUnit 
can be added to `src/test`, in this way the classes needed to run the service (most of them, with testcontainers) are decoupled
by JUnit and can be run separately.

===== Main Sources

The service should provide an interface, named after the infrastructure being implemented, and this interface should extend the 
https://github.com/apache/camel/blob/main/test-infra/camel-test-infra-common/src/main/java/org/apache/camel/test/infra/common/services/InfrastructureService.java[`InfrastructureService`]
interface.

Ideally, there should be two concrete implementations of the services: one of the remote service (if applicable) and
another for the container service: 

```
              MyService
                 / \
                /   \
               /     \
 MyRemoteService    MyContainerService
```
                     

In most cases, a specialized service factory class is responsible for creating the service according to runtime
parameters and/or other test scenarios constraints. When a service allows different service types or locations to be
selected, this should be done via command line properties (`-D<property.name>=<value>`). For example, when allowing a
service to choose between running as a local container or as remote instance, a property in the format
`<name>.instance.type` should be handled. Additional runtime parameters used in different scenarios, should be handled
as `<name>.<parameter>`. More complex services may use the builder available through the factory classes to compose 
the service accordingly.

===== Test Sources

Once the main sources are implemented, https://github.com/apache/camel/blob/main/test-infra/camel-test-infra-common/src/test/java/org/apache/camel/test/infra/common/services/TestService.java[TestService]
interface can be used to integrate the actual Service implementation with JUnit and its lifecycle.
The services should try to minimize the test execution time and resource usage when running. As such,
the https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/BeforeAllCallback.html[BeforeAllCallback]
and https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/AfterAllCallback.html[AfterAllCallback]
should be the preferred extensions whenever possible because they allow the instance of the infrastructure to be static
throughout the test execution.

[NOTE]
====
Bear in mind that, according to the https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/RegisterExtension.html[JUnit 5 extension]
model, the time of service initialization may differ depending on whether the service instance is declared as
static or not in the test class. As such, the code should make no assumptions as to its time of initialization.
====

==== Registering Properties

All services should register the properties, via `System.setProperty` that allow access to the services. This is required
 to resolve those properties when running tests using the Spring framework. This registration allows the properties
to be resolved in Spring's XML files. 

This registration is done in the `registerProperties` methods during the service initialization. 

==== Registering Properties Example:

Registering the properties in the concrete service implementation:

[source,java]
----
    public void registerProperties() {
        // MyServiceProperties.MY_SERVICE_HOST is a string with value "my.service.host"
        System.setProperty(MyServiceProperties.MY_SERVICE_HOST, container.getHost());
        
        // MyServiceProperties.MY_SERVICE_PORT is a string with value "my.service.port"
        System.setProperty(MyServiceProperties.MY_SERVICE_PORT, String.valueOf(container.getServicePort()));
        
        // MyServiceProperties.MY_SERVICE_ADDRESS is a string with value "my.service.address"
        System.setProperty(MyServiceProperties.MY_SERVICE_ADDRESS, getServiceAddress());
    }
    
    public void initialize() {
        LOG.info("Trying to start the MyService container");
        container.start();

        registerProperties();
        LOG.info("MyService instance running at {}", getServiceAddress());
    }
----

Then, when referring these properties in Camel routes or Spring XML properties, you may use `{{my.service.host}}`,
`{{my.service.port}}` and `{{my.service.address}}`.


==== Packaging Recommendations

This is infrastructure code for testing, therefore, it should be package as test type artifacts. The
https://github.com/apache/camel/blob/main/test-infra/camel-test-infra-parent[parent pom] should provide all the necessary bits for packaging the test infrastructure.

=== Using The Test Infrastructure in Tests

Using the test infra in a new component test is rather straightforward, similar to using any other reusable component.
You start by declaring the test infra dependencies in your pom file. 

This should be similar to:

[source,xml]
----
<!-- test infra -->
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-test-infra-myservice</artifactId>
    <version>${project.version}</version>
    <type>test-jar</type>
    <scope>test</scope>
</dependency>
----

[NOTE]
====
On the dependencies above, the dependency version is set to `${project.version}`. This should be adjusted to the
Camel version when used outside the Camel Core project.
====

On the test class, add a member variable for the service and annotate it with the https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/RegisterExtension.html[@RegisterExtension],
 to let JUnit 5 manage its lifecycle.

[source,java]
----
@RegisterExtension
static MyService service = MyServiceServiceFactory.createService();
----

More complex test services can be created using something similar to:

[source,java]
----
@RegisterExtension
static MyService service = MyServiceServiceFactory
    .builder()
        .addRemoveMapping(MyTestClass::myCustomRemoteService) // this is rarely necessary
        .addLocalMapping(MyTestClass::staticMethodReturningAService) // sets the handler for -Dmy-service.instance.type=local-myservice-local-container
        .addMapping("local-alternative-service", MyTestClass::anotherMethodReturningAService) // sets the handler for -Dmy-service.instance.type=local-alternative-service
    .createService();
----

You can use the methods as well as the registered properties to access the test infrastructure services available. 
When using these properties in Spring XML files, you may use those properties.

[source,xml]
----
<someSpringXmlElement httpHost="{{my.service.host}}" port="{{my.service.port}}" />
----

It's also possible to use these properties in the test code itself. For example, when setting up the test url for the
Camel component:

[source,java]
----
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() {
                from("direct:put")
                    .to("mycomponent:someoption?host={{my.service.host}}&port={{my.service.port}}");
            }
        };
    }
----

==== Execution Ordering

When combining the different modules of the test infra, you may need to ensure that they execute in the proper order. You can do so by using JUnit's `@Order` annotation.

For instance:

[source,java]
----
    @Order(1)
    @RegisterExtension
    protected static KafkaService service = KafkaServiceFactory.createSingletonService();

    @Order(2)
    @RegisterExtension
    protected static CamelContextExtension contextExtension = new DefaultCamelContextExtension();
----

== Container Runtime Support

Most of the test infrastructure in this module is based on containers.
Therefore, they will require a container runtime to run.
The tests have been written and tested using:

* Docker
* https://podman.io/[Podman]

=== Podman Support

Assuming Podman is properly installed and configured to behave like docker (i.e.: short name resolution, resolving docker.io registry, etc.), the only requirement for using Podman is to export the `DOCKER_HOST` variable before running the tests.

==== Linux

On most systems that should be similar to the following command: 

```
export DOCKER_HOST=unix:///run/user/$UID/podman/podman.sock
```

==== OS X and Windows

Running the test-infra with Podman on OS X and Windows should work on many cases. However, it requires additional steps and has a few issues. Therefore, it is not recommended at this time.

== Known Issues and/or Tips

=== Multi-architecture support

Some containers don't have images available for all architectures. In this case, it is recommended to:

1. use an alternative image from a reputable source if they provide an image for that architecture.
2. create a `Dockerfile` and build your own if the system is available on that arch.
3. disable the tests on that architecture.= Testing

Testing is a crucial activity in any piece of software development or
integration. Typically, Camel users would use various different
technologies wired together in a variety of EIPs with different
endpoints, languages, bean integration, and
dependency injection, so it's easy for things to go wrong!
Testing is the crucial weapon to ensure that things work as you would expect.

Camel is a Java library, so you can easily wire up tests in JUnit.
However, the Camel project has tried to make the testing of Camel as easy
and powerful as possible, so we have introduced the following features.

== Testing modules

The following modules are supported:

[width="100%",cols="1m,4",options="header",]
|=======================================================================
|Component |Description

|xref:components:others:test-junit5.adoc[camel-test-junit5] |*JUnit 5*: Is an older standalone Java
library letting you easily create Camel test cases using a single Java
class for all your configuration and routing without.
|xref:components:others:test-main-junit5.adoc[camel-test-main-junit5] | *JUnit 5*: Used for testing Camel in Camel Main mode

|xref:components:others:test-spring-junit5.adoc[camel-test-spring-junit5] | *JUnit 5*: Used for testing Camel with Spring / Spring Boot

|xref:test-infra.adoc[camel-test-infra] | *Camel Test Infra*: Camel Test Infra is a set of modules that leverage modern JUnit 5 features to abstract the provisioning and execution of test infrastructure. Among other things, it provides abstraction of the infrastructure (based on Test Containers - being the de-facto successor of the camel-testcontainers components) as well as JUnit 5 extensions for the Camel Context itself.

|=======================================================================

NOTE: If you are using Camel Quarkus, then you can find information in
its documentation how to do testing with Quarkus and Camel.

In all approaches, the test classes look pretty much the same in that
they all reuse the xref:bean-integration.adoc[Camel binding and
injection annotations].

TIP: For more details on the different testing modules, then see their respective documentation
from the links in the table above.

== Testing functionality

Camel provides a set of features that are common to use when writing unit or integration tests with Camel.

=== Testing endpoints

Camel provides a number of xref:endpoint.adoc[endpoints] which can make testing easier.

[width="100%",cols="1,3",options="header",]
|=======================================================================
|Name |Description
|xref:components::mock-component.adoc[Mock] |For testing routes and mediation rules using
mocks and allowing assertions to be added to an endpoint.

|xref:components::dataset-component.adoc[DataSet] |For load & soak testing, this endpoint
provides a way to create huge numbers of messages for sending to
components and asserting that they are consumed correctly.

|xref:components::dataset-test-component.adoc[DataSet Test] |Used to automatically load
a set of expected messages from another endpoint which is then compared to the messages
that arrive at this endpoint.

|=======================================================================

The main endpoint is the xref:components::mock-component.adoc[Mock] endpoint, which allows
expectations to be added to different endpoints; you can then run your
tests and assert that your expectations are met at the end.

=== Stubbing out physical transport technologies

If you wish to test out a route but want to avoid actually using real physical transport, then the following
endpoints can be useful:

NOTE: For example, to unit test a transformation route rather than performing a full integration test

[width="100%",cols="1,3",options="header",]
|=======================================================================
|Name |Description
|xref:components::direct-component.adoc[Direct] |Direct invocation of the consumer from the
producer so that single threaded (non-SEDA) in VM invocation is
performed which can be useful to mock out physical transports

|xref:components::seda-component.adoc[SEDA] |Deliver messages asynchronously to consumers via
a `BlockingQueue` which is good for testing asynchronous transports

|xref:components::stub-component.adoc[Stub] |Works like xref:components::stub-component.adoc[SEDA] but does not
validate the endpoint URI, which makes stubbing straightforward.
|=======================================================================

=== Testing existing routes

Camel provides some features to aid during testing of existing routes
where you cannot or will not use xref:components::mock-component.adoc[Mock] etc.
For example, you may have a production ready route which you want to test with some
third party API that sends messages into this route.

[width="100%",cols="1,3",options="header",]
|=======================================================================
|Name |Description
|xref:notify-builder.adoc[NotifyBuilder] |Allows you to be notified when
a certain condition has occurred. For example, when the route has
completed five messages. You can build complex expressions to match your
criteria when to be notified.

|xref:advice-with.adoc[AdviceWith] |Allows you to _advice_ (enhance)
an existing route using a xref:route-builder.adoc[RouteBuilder] style.
For example, you can send (or send and skip) a message to a xref:components::mock-component.adoc[Mock]
endpoint for validating the message send by Camel is as expected.
|=======================================================================

=== Third Party Testing libraries

There are a number of third party testing libraries that Camel users have found useful.

[width="100%",cols="1,3",options="header",]
|=======================================================================
|Name |Description
| https://citrusframework.org/[Citrus Integration Framework] | Framework for automated integration tests supporting a wide range of message protocols and data formats
| https://citrusframework.org/yaks/[Citrus Yaks] | YAKS is a framework to enable Cloud Native BDD testing on Kubernetes
|=======================================================================
= Threading Model

The threading model in Camel is based on a pluggable reactive routing engine,
and thread pools from the JDK concurrency API.

This page focuses on thread pools.
Camel leverages thread pools in several places such as:

* Several xref:components:eips:enterprise-integration-patterns.adoc[EIP] patterns support using thread pools for
concurrency
* xref:components::seda-component.adoc[SEDA] component for asynchronous connectivity
* xref:components:eips:threads-eip.adoc[Threads] EIP in Camel routes
* Some components use thread pools out of the box, such as
xref:components::jms-component.adoc[JMS] or xref:components::jetty-component.adoc[Jetty]

== Thread pool profiles

By default, when a thread pool is to be created by Camel, then the pool configuration
is based upon a profile, the _default thread pool profile_

The default profile is pre-configured out of the box with the following settings:

[width="100%",cols="25%,25%,50%",options="header",]
|===
| Option | Default | Description
| *poolSize* | `10` | Sets the default core pool size (threads to keep minimum in pool)
| *keepAliveTime* | `60` | Sets the default keep alive time (in seconds) for inactive threads
| *maxPoolSize* | `20` | Sets the default maximum pool size
| *maxQueueSize* | `1000` | Sets the default maximum number of tasks in the work queue. Use -1 for an unbounded queue.
| *allowCoreThreadTimeOut* | `true` | Sets default whether to allow core threads to timeout
| *rejectedPolicy* | `CallerRuns` | Sets the default handler for tasks which cannot be executed by the thread pool. Has four options:
`Abort, CallerRuns, Discard, DiscardOldest` which corresponds to the same four options provided out of the box in the JDK.
|===

What that means is that for example when you use
xref:components:eips:multicast-eip.adoc[Multicast] with `parallelProcessing=true` enabled,
then it would create a thread pool based on the profile above.

You can define as many thread pool profiles as you like. But there must
be only *one* default profile. A custom thread pool profile will inherit
from the default profile. Which means that any option you do not
explicit define will fallback and use the option from the default
profile.

=== Configuring default thread pool profile

In Spring XML you can configure thread pool profile with `threadPoolProfile` as shown:

[source,xml]
----
<threadPoolProfile id="defaultThreadPoolProfile"
    defaultProfile="true"
    poolSize="5"
    maxPoolSize="10"/>
----

And in Java DSL

[source,java]
----
ThreadPoolProfile profile = camelContext.getExecutorServiceManager().getDefaultThreadPoolProfile();
profile.setPoolSize(5);
profile.setMaxPoolSize(10);
----

And with camel-main, Spring Boot or Quarkus you can configure this in the `application.properties|yaml` file:

[source,properties]
----
## configure default thread pool profile
camel.threadpool.pool-size = 5
camel.threadpool.max-pool-size = 5
----


=== Using thread pool profiles

Suppose you want to use a custom thread pool profile for a Multicast EIP
pattern in a Camel route you can do it using the `executorServiceRef`
attribute as shown in Spring XML:

[source,xml]
---------------------------------------------------------------------------
<camelContext>

    <threadPoolProfile id="fooProfile"
                       poolSize="20" maxPoolSize="50" maxQueueSize="-1"/>

    <route>
       <multicast aggregationStrategy="myStrategy" executorServiceRef="fooProfile">
          ...
       </multicast>
    </route>
</camelContext>
---------------------------------------------------------------------------

What Camel will do at runtime is to lookup in the
xref:registry.adoc[Registry] for a `ExecutorService` with the id `fooProfile`.
If none found it will fallback and see if there is a
`ThreadPoolProfile` defined with that id. In this example there is a profile,
so the profile is used as base settings for creating a new `ExecutorService` which is
handed back to the xref:components:eips:multicast-eip.adoc[Multicast] EIP to use in the
Camel route.

In Java DSL you can use `ThreadPoolProfileBuilder` to create a profile and then register the profile:

[source,java]
----
ThreadPoolProfileBuilder builder = new ThreadPoolProfileBuilder("fooProfile");
builder.poolSize(20).maxPoolSize(50).maxQueueSize(-1);

camelContext.getExecutorServiceManager().registerThreadPoolProfile(builder.build());
----

== Creating custom thread pools

You can also use the `<threadPool>` tag in Spring XML to create a
specific thread pool (`ExecutorService`). Notice that any options you
do not explicit define, will have Camel to use the default thread pool
profile as fallback. For example if you omit setting the `maxQueueSize`
then Camel will fallback and use the value from the default thread pool
profiles, which by default is `1000`.

== Customizing thread names

On the `ExecutorServiceManager` you can
configure the thread name pattern using the `setThreadNamePattern`
method, which defines the thread names used when a thread pool creates a
thread.

The default pattern is:

[source,text]
----
Camel (#camelId#) thread ##counter# - #name#
----

In the pattern you can use the following placeholders

* `\#camelId#` - The xref:camelcontext.adoc[CamelContext] name
* `\#counter#` An unique incrementing counter
* `\#name#` - The thread name
* `\#longName#` - The long thread name which can include endpoint parameters etc.

In Spring XML the pattern can be set with `threadNamePattern` attribute as shown:

[source,xml]
----
<camelContext threadNamePattern="Riding the thread #counter#">
  <route>
    <from uri="seda:start"/>
    <to uri="log:result"/>
    <to uri="mock:result"/>
  </route>
</camelContext>
----

In Java DSL you can set the pattern as follows:

[source,java]
----
CamelContext camel = ...
camel.getExecutorServiceManager().setThreadNamePattern("Riding the thread #counter#")
----

And with camel-main, Spring Boot or Quarkus you can configure this in the `application.properties|yaml` file:

[source,properties]
----
## camel-main or quarkus
camel.main.thread-name-pattern = Riding the thread #counter#

## spring boot
camel.springboot.thread-name-pattern = Riding the thread #counter#
----

== Shutting down thread pools

All thread pools created by Camel will be properly shutdown when
`CamelContext` shutdowns which ensures no leaks in the pools in case you
run in a server environment with hot deployments and the likes.

The `ExecutorServiceManager` has APIs for shutting down thread pools
gracefully and aggressively. It is encouraged to use this API for creating
and shutting down thread pools.

The method `shutdownGraceful(executorService)` from `ExecutorServiceManager`
will shutdown graceful at first, until a timeout value is hit. After
that it shuts down aggressively, again using the timeout value to wait for
the operation to complete. This means you can wait at most 2 x timeout
for shutting down the thread pool.

The timeout value is by default `10000` millis. You can configure a
custom value on the `ExecutorServiceManager` if needed. During shutdown
Camel will log every 2 seconds at INFO level progress of shutting down
the thread pool. For example in case a shutdown takes a while, then
there is activity in the logs.

The APIs on `ExecutorServiceManager` that is related to shutting down a
thread pool is as follows:

[width="100%",cols="25%,75%",options="header"]
|===
|Method |Description
|shutdown |Marks the thread pool as shutdown
(like calling the `ExecutorService.shutdown()` method).
|shutdownNow |Forces the thread pool to shut down now
(like calling the `ExecutorService.shutdownNow()` method).
|shutdownGraceful |Marks the thread pool as shutdown, and graceful shutdown
the pool, by waiting for tasks to complete. A default timeout value of
10 sec is used, before shutdown becomes aggressive using `shutdownNow`,
forcing threads to shut down quicker.
|shutdownGraceful(timeout) |As shutdownGraceful but with custom timeout value
|awaitTermination |To wait graceful for the termination of a thread pool (eg
to wait for its tasks to complete). Will wait until all tasks are completed or timed out.
|===

== JMX Management

All the thread pools that Camel creates are managed and thus you can see
them in JMX under the `threadpools` tree.

NOTE: This requires to enabled JMX by including `camel-management` JAR in the classpath.

== Component developers

If you develop your own Camel component and are in need of a thread
pool, then it is advised to use the
`ExecutorServiceStrategy`/`ExecutorServiceManager` to create the thread
pool you need.

=== ExecutorServiceStrategy

Camel provides a pluggable strategy to hook in your own thread pool
provider, for example from a WorkManager in a J2EE server etc. +
See the `org.apache.camel.spi.ExecutorServiceStrategy` interface which
you should implement and hook into the WorkManager.

=== ExecutorServiceManager

To hook in custom thread pool providers (e.g. for J2EE servers) a
`ThreadPoolFactory` interface can be implemented. The implementation can
be set in the `ExecutorServiceManager`.

== Virtual Threads

Starting from Java 21, the default `ThreadPoolFactory` can build `ExecutorService` and `ScheduledExecutorService` that
use https://openjdk.org/jeps/425[virtual threads] instead of platform threads.
But as it is an experimental feature, it is not enabled by default, you need to set the System property `camel.threads.virtual.enabled`
to `true` and run Camel using Java 21 or above to enable it.

Be aware that even if it is enabled, there are some use cases where platform threads are still used, for example, if the
thread factory is configured to create non-daemon threads since virtual threads can only be daemons, or when the
`ExecutorService` or `ScheduledExecutorService` to build cannot have more than one thread or finally when `corePoolSize`
is set to zero and `maxQueueSize` is set to a value less or equal to `0`.
= Tracer

Camel's tracer is used for logging message details during routing, where
you can see the route path of each message as they happen. Details of the message is also logged such as the message body, and headers.

TIP: There is an alternative tracer that captures the messages in a xref:backlog-tracer.adoc[Backlog Tracer].

== Enabling Tracing

In Java you set tracing on `CamelContext`:

[source,java]
----
context.setTracing(true);
----

And in XML DSL:

[source,xml]
----
<camelContext trace="true" xmlns="http://activemq.apache.org/camel/schema/spring">
...
</camelContext>
----

And in Spring Boot

[source,text]
----
camel.springboot.tracing = true
----

=== Setting Tracing in Standby mode

By default Camel optimizes and opt-out tracing. Therefore, you would either have to enable tracing from the startup,
or turn on standby mode, to allow tracing to be enabled later during runtime.

To set tracing in standby mode you can do:

[source,java]
----
context.setTracingStandby(true);
----

And in XML DSL:

[source,xml]
----
<camelContext trace="standby" xmlns="http://activemq.apache.org/camel/schema/spring">
...
</camelContext>
----

And in Spring Boot

[source,text]
----
camel.springboot.tracing-standby = true
----

If tracer is in standby mode, then tracing is made available, and can be enabled during runtime.
This requires to either use JMX or enable via Java code:

[source,java]
----
Tracer tracer = context.getTracer();
tracer.setEnabled(true);
----

=== Trace Logging Formatting

The tracer formats the execution of exchanges to log lines. They are
logged at `INFO` level in the log category: `org.apache.camel.Tracing`.

The message information from the Exchange is formatted using `ExchangeFormatter` and the default implementation
has many options you can configure accordingly to the https://www.javadoc.io/doc/org.apache.camel/camel-support/latest/org/apache/camel/support/processor/DefaultExchangeFormatter.html[javadoc].

The tracer outputs the logging with a prefix with the following information:

- arrow - (direction whether input or output)
- routeId - the current route
- label - the current EIP node

This output is assembled using the following default format:

- %-4.4s [%-12.12s] [%-33.33s]

The default format can be customized using, for exameple to use wider columns:

[source,java]
----
context.setTracingLoggingFormat("%-4.4s [%-30.30s] [%-50.50s]");
----

And in XML DSL:

[source,xml]
----
<camelContext trace="true" traceLoggingFormat="%-4.4s [%-30.30s] [%-50.50s]">
...
</camelContext>
----

And in Spring Boot

[source,properties]
----
camel.springboot.tracing-logging-format = %-4.4s [%-30.30s] [%-50.50s]
----

And in Camel Main / Quarkus

[source,properties]
----
camel.main.tracing-logging-format = %-4.4s [%-30.30s] [%-50.50s]
----
= Transformer

Transformer (`org.apache.camel.spi.Transformer`) performs declarative transformation of the message according
to the declared _Input Type_ and/or _Output Type_ on a route definition which declares
the expected message type. The default Camel Message implements `DataTypeAware`, which allows to hold the message type
represented by `DataType`.

If the input type and/or output type is declared by _Input Type_ and/or _Output Type_ in the route
definition, and in case it is different from actual message type at runtime, Camel internal processor
looks for a `Transformer` which transforms from the current message type to the expected message
type and apply. Once transform succeed or message is already in expected type, then the message
data type is updated.

== Data type format

[source,text]
----
scheme:name
----

where *scheme* is the type of data model like `java`, `xml` or `json`, and *name* is the individual data type name.
The scheme could also represent a Camel component scheme such as `http` or `aws2-s3` in order to reference component specific data types.
When using the `java` scheme the data type name may be the qualified class name (e.g. `java:org.apache.camel.Foo`)
If you only specify *scheme* then it hits all the data types which has that scheme like a wildcard.

== Supported Transformers

[width="100%",cols="25%,75%",options="header",]
|===
| Transformer | Description
| Data Format Transformer | Transform with using Data Format
| Endpoint Transformer | Transform with using Endpoint
| Custom Transformer | Transform with using custom transformer class. Transformer must be a subclass of `org.apache.camel.spi.Transformer`
| Loading Transformer | Loads multiple transformer implementations (e.g. via annotation classpath scan). Also preloads known default Camel transformer implementations.
|===

=== Common Options

All transformers have following common options to specify which data type is supported by the transformer. `name` or both of `fromType` and `toType` must be specified.

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| scheme | The supported data type scheme. It is possible to just reference a scheme like `xml` or `json`. For example if `xml` is specified, the transformer is applied for all java -&gt; xml and xml -&gt; java transformation.
| name | The name of the transformer. If name is specified users may use a combination of a scheme and name (e.g. `xml:Order`) to reference the transformer in a route.
| fromType | xref:transformer.adoc[Data type] to transform from.
| toType | xref:transformer.adoc[Data type] to transform to.
|===

Transformer implementations may use `scheme:name` or the combination of `fromType/toType` as an identifier.

When using the `scheme:name` identifier users may reference the transformer by its full name in a route.

[tabs]
====
Java::
+
[source,java]
----
from("direct:abc")
    .inputType("myScheme:myTransformer")
    .to("...");
----

XML::
+
[source,xml]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
    <route>
        <from uri="direct:abc"/>
        <inputType urn="myScheme:myTransformer"/>
        <to uri="..."/>
    </route>
</camelContext>
----
====

As mentioned earlier the transformer may also skip the name and just use a `scheme` (e.g. `xml`) in order to apply to
all data type transformations of a given scheme (e.g. `xml:Order`, `xml:OrderResponse`, `xml:anything`)

When using the combination of `fromType/toType` as an identifier the transformer gets matched automatically by the given
data types used on the Camel route (e.g. inputType) and the given Exchange data type (specified by the Exchange message using `DataTypeAware` interface).

In general, the transformer resolving mechanism tries to find the best match when searching for a proper transformation
from a given data type to a given data type. The mechanism tries to find exact matches for `fromType` and `toType` first,
then wildcard matches (using transformers for the given data type scheme only), then named transformers using `scheme:name` identifiers,
then named transformers matching `scheme` only.

If not already preloaded by the configuration the Transformer resolving mechanism also performs lazy loading of transformer implementations using the factory finder resource path lookup.

=== DataFormat Transformer Options

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| type | Data Format type
| ref | reference to the Data Format ID
|===

Here is an example to specify xref:components:dataformats:bindy-dataformat.adoc[Bindy] DataFormat type:

[tabs]
====
Java::
+
[source,java]
----
BindyDataFormat bindy = new BindyDataFormat();
bindy.setType(BindyType.Csv);
bindy.setClassType(com.example.Order.class);
transformer()
    .fromType(com.example.Order.class)
    .toType("csv:CSVOrder")
    .withDataFormat(bindy);
----

XML::
+
[source,xml]
----
<dataFormatTransformer fromType="java:com.example.Order" toType="csv:CSVOrder">
    <bindy id="csvdf" type="Csv" classType="com.example.Order"/>
</dataFormatTransformer>
----
====

== Endpoint Transformer Options

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| ref | Reference to the Endpoint ID
| uri | Endpoint URI
|===

Here is an example to specify endpoint URI in Java DSL:

[source,java]
----
transformer()
    .fromType("xml")
    .toType("json")
    .withUri("component:componentPathOptions?mappingFile=myMapping.xml...");
----

And here is an example to specify endpoint ref in XML DSL:

[source,xml]
----
<endpointTransformer ref="myEndpoint" fromType="xml" toType="json"/>
----

== Custom Transformer Options

Note that Transformer must be a subclass of `org.apache.camel.spi.Transformer`

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| ref | Reference to the custom Transformer bean ID
| className | Fully qualified class name of the custom Transformer class
|===

Here is an example to specify custom Transformer class:

[tabs]
====
Java::
+
[source,java]
----
transformer()
    .fromType("xml")
    .toType("json")
    .withJava(com.example.MyCustomTransformer.class);
----

XML::
+
[source,xml]
----
<customTransformer className="com.example.MyCustomTransformer" fromType="xml" toType="json"/>
----
====

== Load Transformer Options

Users are able to preload known default transformers. Also users may load transformers via classpath scan.

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| defaults | Loads known default transformer implementations (e.g. plain-text, application-octet-stream)
| location | Classpath location to scan for transformer implementations. Transformer implementations must use the `org.apache.camel.spi.DataTypeTransformer` annotation to get recognized by the scanner.
|===

Here is an example to load default Transformer classes:

[tabs]
====
Java::
+
[source,java]
----
transformer()
    .withDefaults()
----

XML::
+
[source,xml]
----
<loadTransformer defaults="true"/>
----
====

Here is an example to load Transformer classes via classpath scan:

[tabs]
====
Java::
+
[source,java]
----
transformer()
    .scan("org.apache.camel.transformer.standard")
----

XML::
+
[source,xml]
----
<loadTransformer packageScan="org.apache.camel.transformer.standard"/>
----
====

The classpath scan looks for classes that use the `org.apache.camel.spi.DataTypeTransformer` annotation.
The annotation defines the transformer name and/or the supported from/to data types.

[source,java]
----
@DataTypeTransformer(name = "uppercase")
public class UppercaseDataTypeTransformer extends Transformer {

    @Override
    public void transform(Message message, DataType fromType, DataType toType) {
        message.setBody(message.getBody(String.class).toUpperCase());
    }
}
----

== Example

For example to declare the Endpoint Transformer which uses
xslt component to transform from `xml:ABCOrder` to `xml:XYZOrder`, we can do as follows:

[tabs]
====
Java::
+
[source,java]
----
transformer()
    .fromType("xml:ABCOrder")
    .toType("xml:XYZOrder")
    .withUri("xslt:transform.xsl");
----

XML::
+
[source,xml]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
    <transformers>
        <endpointTransformer uri="xslt:transform.xsl" fromType="xml:ABCOrder" toType="xml:XYZOrder"/>
    </transformers>
    ....
</camelContext>
----
====

If you have following route definition, above transformer will be applied when `direct:abc` endpoint sends the message to `direct:xyz`:

[tabs]
====
Java::
+
[source,java]
----
from("direct:abc")
    .inputType("xml:ABCOrder")
    .to("direct:xyz");

from("direct:xyz")
    .inputType("xml:XYZOrder")
    .to("somewhere:else");
----

XML::
+
[source,xml]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
    <route>
        <from uri="direct:abc"/>
        <inputType urn="xml:ABCOrder"/>
        <to uri="direct:xyz"/>
    </route>
    <route>
        <from uri="direct:xyz"/>
        <inputType urn="xml:XYZOrder"/>
        <to uri="somewhere:else"/>
    </route>
</camelContext>
----
====

== See Also

The xref:validator.adoc[Validator] is a related functionality.
= Try, Catch and Finally

Camel supports the Java equivalent of try ... catch ... finally directly in the DSL.
It aims to work like its Java sisters but with more power.

In Camel, we prefix the keywords with `do` to avoid having same keyword as Java.
So we have:

- `doTry`
- `doCatch`
- `doFinally`
- `end` to end the block in Java DSL

When using `doTry ... doCatch ... doFinally` then the regular Camel
xref:error-handler.adoc[Error Handler] is not in use; meaning any
`onException` or the likes does not trigger.
The reason is that
`doTry ... doCatch ... doFinally` is in fact its own error handler and mimics how try/catch/finally works in Java.

== Using doTry ... doCatch ... doFinally

In the route below we have all of them in action:

[source,java]
----
from("direct:start")
    .doTry()
        .process(new ProcessorFail())
        .to("mock:result")
    .doCatch(IOException.class, IllegalStateException.class)
        .to("mock:catch")
    .doFinally()
        .to("mock:finally")
    .end();
----

And in XML DSL

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <doTry>
    <process ref="processorFail"/>
    <to uri="mock:result"/>
    <doCatch>
      <exception>java.io.IOException</exception>
      <exception>java.lang.IllegalStateException</exception>
      <to uri="mock:catch"/>
    </doCatch>
    <doFinally>
       <to uri="mock:finally"/>
    </doFinally>
  </doTry>
</route>
----

=== Using onWhen with doCatch

You can use xref:predicate.adoc[Predicate]s with `doCatch` to make it runtime determine if the block should be triggered or not.
In our case, we only want to trigger if the caused exception message contains the *damn* word.

[source,java]
----
from("direct:start")
    .doTry()
        .process(new ProcessorFail())
        .to("mock:result")
    .doCatch(IOException.class, IllegalStateException.class).onWhen(exceptionMessage().contains("Damn"))
        .to("mock:catch")
    .doCatch(CamelExchangeException.class)
        .to("mock:catchCamel")
    .doFinally()
        .to("mock:finally")
    .end();
----

And in XML DSL

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <doTry>
    <process ref="processorFail"/>
    <to uri="mock:result"/>
    <doCatch>
      <exception>java.io.IOException</exception>
      <exception>java.lang.IllegalStateException</exception>
      <onWhen>
        <simple>${exception.message} contains 'Damn'</simple>
      </onWhen>
      <to uri="mock:catch"/>
    </doCatch>
    <doCatch>
      <exception>org.apache.camel.CamelExchangeException</exception>
      <to uri="mock:catchCamel"/>
    </doCatch>
    <doFinally>
       <to uri="mock:finally"/>
    </doFinally>
  </doTry>
</route>
----

=== Use end() to end the block

Notice when using Java DSL we must use `end()` to indicate where the try ... catch ... finally block ends.
As the example above has a finally, then the `end()` should be at the end of the finally block.
If we are not using a finally, then the `end()` should be at the end of the `doCatch`
to indicate the end there.

TIP: Instead of `end()` you can use `endDoTry()` to end and _return back_ to the try ... catch scope.

=== Using nested doTry ... doCatch EIPs

When nesting `doTry ... doCatch` from an outer `doTry ... doCatch` EIP,
then pay extra attention when using Java DSL as the Java programming language is not _indent aware_
so you may write Java code
that is indented in a way where you think that a catch block is associated with the other doTry, but it is not.

Given the following Java DSL:

[source,java]
----
from("direct:test").routeId("myroute")
    .doTry().
        doTry().
            throwException(new IllegalArgumentException("Forced by me"))
        .doCatch(Exception.class)
            .log("docatch 1")
            .throwException(new IllegalArgumentException("Second forced by me"))
    .doCatch(Exception.class)
        .log("docatch 2")
    .end();
----

Then you may think that `_docatch2_` is associated on the outer doTry because of how the code is formatted.
But it is **not**, both `_docatch1_` and `_docatch2_` are in the inner `doTry`, and the outer `doTry` has no catch blocks.

So in this example, the route will throw the first exception which is then handled in `_docatch1_`
which then throws a second exception, that is not caught.

So what you must do is to end the doCatch block correct (notice how we use `endDoTry()` two times) as shown below:

[source,java]
----
from("direct:test").routeId("myroute")
    .doTry().
        doTry().
            throwException(new IllegalArgumentException("Forced by me"))
        .doCatch(Exception.class)
            .log("docatch 1")
            .throwException(new IllegalArgumentException("Second forced by me"))
         .endDoTry() // end this doCatch block
     .endDoTry() // end the inner doTry
    .doCatch(Exception.class)
        .log("docatch 2")
    .end();
----

And by using the `endDoTry()` we can end the block correctly, and an XML representation of the route would be as follows:

[source,xml]
----
<route>
    <from uri="direct:test"/>
    <doTry>
        <doTry>
            <throwException id="throwException1"/>
            <doCatch id="doCatch1">
                <log id="log1" message="docatch 1"/>
                <throwException id="throwException2"/>
            </doCatch>
        </doTry>
        <doCatch id="doCatch2">
            <log id="log2" message="docatch 2"/>
        </doCatch>
    </doTry>
</route>
----
= Type Converter

Converting body payloads from one type to another is common when routing messages between endpoints.
Conversions regularly occur between the following types:

* `File`
* `String`
* `byte[]` and `ByteBuffer`
* `InputStream` and `OutputStream`
* `Reader` and `Writer`
* XML payloads such as `Document` and `Source`

For example to convert the message body to XML `Document` type
then this can be done as follows in Java:

[source,java]
----
Message message = exchange.getMessage();
Document document = message.getBody(Document.class);
----

Notice that the code only tells Camel what you *want* as the result type (`Document`)
and not what the input type is, or how Camel should do this.

== How Type Conversion works

The type conversion strategy is defined by the
https://www.javadoc.io/doc/org.apache.camel/camel-api/current/org/apache/camel/TypeConverter.html[TypeConverter]
interface. The interface has several methods, however the most important and common API is:

[source,java]
----
<T> T convertTo(Class<T> type, Exchange exchange, Object value) throws TypeConversionException;
----

This API is used by Camel when it converts an object from one type to another. However if
you pay attention then this API only has the result type in the contract. The input type
is inferred from the _value_ parameter.

There are many type converters in Camel, some comes out of the box from camel-core, and others
are additional converters that are shipped in various Camel components.

=== Type converter registry

To keep track of all those converters, then Camel has a registry for type converters
(`org.apache.camel.spi.TypeConverterRegistry`).

This registry keeps track of all possible type converter combinations, such as which converters
that can convert to an `InputStream` and so forth.

So the example from before, what Camel would do is to lookup in the `TypeConverterRegistry`
to find a suitable converter that can convert the given input value to the `Document` type.

The `TypeConverterRegistry` can be accessed via Java:

[source,java]
----
TypeConverterRegistry tcr = camelContext.getTypeConverterRegistry();
TypeConverter tc = tcr.lookup(Document.class, InputStream.class);
----

However often you would not work directly with the `TypeConverterRegistry` or `TypeConverter` APIs in Camel;
as type conversion are often implicit in use where you would just declare the result type; and Camel takes care of this.

[NOTE]
====
In Camel, all the official Camel components, come with source code generated `TypeConverter`
(via `camel-component-maven-plugin`) that allows Camel to load these converters very quickly,
and invoke these type converters at runtime via quick Java method invocations (no reflection overhead).
====

=== Type converter registry utilization statistics

NOTE: as of Camel 4.7.0, the statistics collector in the registry has been made immutable.
As such, enabling collection of statistics has to be done prior to creating the type converter
registry.

Camel can gather utilization statistics of the runtime usage of type
converters. These statistics are available in xref:jmx.adoc[JMX] as well as
from https://www.javadoc.io/doc/org.apache.camel/camel-api/latest/org/apache/camel/spi/TypeConverterRegistry.html#getStatistics--[`TypeConverterRegistry#getStatistics()`].

These statistics are turned off by
default as there is some performance overhead under very high concurrent load.

Enabling statistics in Java:

[source,java]
----
CamelContext context = ...;
context.setTypeConverterStatisticsEnabled(true);
----

Enabling statistics in XML DSL:

[source,xml]
----
<camelContext typeConverterStatisticsEnabled="true">
    ...
</camelContext>
----

== TypeConverter using @Converter annotation

All the type converters that come out of the box are coded as Java methods on _converter_ classes.

This means a class has been annotated with `@Converter` and the methods in the class
annotated with `@Converter` become a type converter _pair_ like in the following example:

[source,java]
----
@Converter(generateLoader = true)
public class IOConverter {
    @Converter
    public static InputStream toInputStream(File file) throws FileNotFoundException {
        return new BufferedInputStream(new FileInputStream(file));
    }
}
----

This is from camel-core where the `IOConverter` class has a number of converters (only 1 shown).
The method `toInputStream` is annotated with `@Converter` which then becomes a type converter
that can convert from `File` to `InputStream`.

All these _converter_ classes are discovered and loaded by Camel.

== Discovering Type Converters

Camel automatically discovers and loads the type converters from all JARs on the classpath at startup.

Camel searches the classpath for a file called
`META-INF/services/org/apache/camel/TypeConverterLoader` which lists
all type converter loader classes. These are automatically generated by the Camel Component Package Plugin.
These _loader_ classes will load the type converters into the Camel type converter registry
and invoke them in a _fast way_ using standard Java method calls.

=== Discovering Type Converters (fast way)

To enable the fast type converter way, you should enable `generateLoader = true`
on the class level annotation as shown:

[source,java]
----
@Converter(generateLoader = true)
public class IOConverter {
    @Converter
    public static InputStream toInputStream(File file) throws FileNotFoundException {
        return new BufferedInputStream(new FileInputStream(file));
    }
}
----

And then you should have the xref:camel-component-maven-plugin.adoc[Camel Component Package Plugin] in as build plugin when compiling the project.

=== Discovering Type Converters in the fastest way

In Camel 3.7 we optimized the type converter system for optimal performance when using the built-in converters.
This was done by bulking together all the converters in the same Maven module into a single class. The class has a single
`convert` method where all the supported converters are available and discovered in a fast way using Java primitives.

To enable this then set `generateBulkLoader=true` in the class `@Converter` annotation. You should do this for all the converter
classes within the same Maven artifact. Then they will be bulked together into a single class.

[source,java]
----
@Converter(generateBulkLoader = true)
public class IOConverter {
    @Converter
    public static InputStream toInputStream(File file) throws FileNotFoundException {
        return new BufferedInputStream(new FileInputStream(file));
    }
}
----

There are few limitations:

- fallback converters are not supported
- the order of the `@Converter` methods matters. If you have multiple `@Converter` methods that accept as _from_ type
types which are from the same class hierarchy then put the methods first that are the most concrete.

For example in `camel-xml-jaxp` we have in the `XmlConverter` multiple `@Converter` methods which can convert to `DomSource`.
We had to put the method that takes `org.w3c.dom.Document` before the method that takes `org.w3c.dom.Node` as `Document` extends `Node`.

The following code shows snippet of the source code generated bulk class. As you can see we have the `Document` method before the `Node` method below:

[source,java]
----
        } else if (to == javax.xml.transform.dom.DOMSource.class) {
            if (value instanceof org.w3c.dom.Document) {
                return getXmlConverter().toDOMSource((org.w3c.dom.Document) value);
            }
            if (value instanceof org.w3c.dom.Node) {
                return getXmlConverter().toDOMSource((org.w3c.dom.Node) value);
            }
----

=== Returning null values

By default, when using a method in a POJO annotation with `@Converter`
returning `null` is not a valid response. If null is returned, then Camel
will regard that type converter as a _miss_, and prevent from using it
in the future. If `null` should be allowed as a valid response, then
you must specify this in the annotation (via `allowNull`) as shown:

[source,java]
----
@Converter(allowNull = true)
public static InputStream toInputStream(File file) throws IOException {
    if (file.exist()) {
        return new BufferedInputStream(new FileInputStream(file));
    } else {
        return null;
    }
}
----

== Fallback Type Converters

The
https://www.javadoc.io/doc/org.apache.camel/camel-base/current/org/apache/camel/impl/converter/AnnotationTypeConverterLoader.html[AnnotationTypeConverterLoader]
has been enhanced to also look for methods defined with a
`@FallbackConverter` annotation, and register it as a fallback type
converter.

Fallback type converters are used as a last resort for converting a
given value to another type. It is used when the regular type converters
give up.
The fallback converters are also meant for a broader scope, so its method
signature is a bit different:

[source,java]
----
@FallbackConverter
public static <T> T convertTo(Class<T> type, Exchange exchange, Object value, TypeConverterRegistry registry)
----

Or you can use the non-generic signature.

[source,java]
----
@FallbackConverter
public static Object convertTo(Class type, Exchange exchange, Object value, TypeConverterRegistry registry)
----

And the method name can be anything (`convertTo` is not required as a
name), so it can be named `convertMySpecialTypes` if you like. +
The `Exchange` parameter is optional, just like the regular
`@Converter` methods.

The purpose with this broad scope method signature is allowing you to
control if you can convert the given type or not. The `type` parameter
holds the type we want the `value` converted to. It is used internally in
Camel for wrapper objects, so we can delegate the type conversion to the
body that is wrapped.

For instance in the method below we will handle all type conversions
that are based on the wrapper class `GenericFile` and we let Camel do the
type conversions on its body instead.

[source,java]
----
@FallbackConverter
public static <T> T convertTo(Class<T> type, Exchange exchange, Object value, TypeConverterRegistry registry) {
    // use a fallback type converter so we can convert the embedded body
    // if the value is GenericFile
    if (GenericFile.class.isAssignableFrom(value.getClass())) {
        GenericFile file = (GenericFile) value;
        Class from = file.getBody().getClass();
        TypeConverter tc = registry.lookup(type, from);
        if (tc != null) {
            Object body = file.getBody();
            return tc.convertTo(type, exchange, body);
        }
    }
    return null;
}
----

== Writing your own Type Converters

You are welcome to write your own converters. Remember to use the
`@Converter` annotations on the classes and methods you wish to use.
And on the top-level class add `Converter(generateLoader = true)` to support the _fast way_
of using type converters.

* static methods are encouraged to reduce caching, but instance methods
are fine, particularly if you want to allow optional dependency
injection to customize the converter
* converter methods should be thread safe and reentrant

=== Exchange parameter

The type converter accepts the `Exchange` as an optional 2nd parameter.
This is usable if the type converter for instance needs information from
the current exchange. For instance combined with the encoding support
it is possible for type converters to convert with the configured
encoding. An example from camel-core for the `byte[]` -> `String`
converter:

[source,java]
----
@Converter
public static String toString(byte[] data, Exchange exchange) {
    String charsetName = exchange.getProperty(Exchange.CHARSET_NAME, String.class);
    if (charsetName != null) {
        try {
            return new String(data, charsetName);
        } catch (UnsupportedEncodingException e) {
            // ignore
        }
    }
    return new String(data);
}
----
= URIs

Camel makes extensive use of URIs to allow you to refer to xref:endpoint.adoc[Endpoints].

For example, consider the following URI:

[source,text]
----
kafka:cheese?brokers=mykafka:1234&clientId=foo
----

This endpoint is created by the xref:components::kafka-component.adoc[Kafka] component.
The URI contains endpoint configurations as context-path and query parameters.
In this example, the context-path is `cheese` which is the kafka topic to use.

The query parameters have two parameters:

1. `brokers=mykafka:1234`: the remote Kafka broker to connect to.
2. `clientId=foo`: the client id, which is a configuration of the Kafka component

== More Information

You can read the guide xref:faq:how-do-i-configure-endpoints.adoc[How do I configure endpoints] to learn more about configuring _endpoints_. Among other things, this guide explains how to refer to beans in the xref:registry.adoc[registry], how to use raw values for password options, how to use xref:using-propertyplaceholder.adoc[property placeholders], or how to use the type safe xref:Endpoint-dsl.adoc[Endpoint DSL] and xref:dataformat-dsl.adoc[DataFormat DSL].
= Using Exchange Pattern Annotations

Invoking InOut methods for ref:components:eips:requestReply-eip.adoc[request/reply] when working with xref:pojo-producing.adoc[POJO Producing] is typically synchronous. As such, the caller will block until the server returns a result.

[NOTE]
====
InOut means that there is an In message for  the input and an Out for the output/result.
====

[NOTE]
====
Other books, posts and reference guides may use the terms In/Out and In/Only for the patterns. In this guide we use InOut and InOnly respectively, as these are the names used within Camel.
====

You can also implement support for xref:components:eips:event-message.adoc[Event Messages] with Apache Camel, using the InOnly xref:exchange-pattern.adoc[pattern]. These are often called "fire and forget" (i.e., like sending a JMS message but not waiting for any response).

Since version 1.5 Camel supports annotations for specifying the message
exchange pattern on Java methods, classes or interfaces.

[[UsingExchangePatternAnnotations-SpecifyingInOnlymethods]]
== Specifying InOnly methods

Typically the InOut pattern is what most users want, but you can
customize to use InOnly using an annotation. For instance:

[source,syntaxhighlighter-pre]
----
public interface Foo {
  Object someInOutMethod(String input);
  String anotherInOutMethod(Cheese input);
  
  @InOnly
  void someInOnlyMethod(Document input);
}
----

The above code shows three methods on an interface:
* the first two use the default InOut mechanism
* the third one, `someInOnlyMethod` uses the InOnly annotation to specify it as being a one-way method call.

[[UsingExchangePatternAnnotations-Classlevelannotations]]
== Class level annotations

You can also use class level annotations to default all methods in an
interface to a pattern:

[source,syntaxhighlighter-pre]
----
@InOnly
public interface Foo {
  void someInOnlyMethod(Document input);
  void anotherInOnlyMethod(String input);
}
----

Apache Camel will detect annotations on base classes or interfaces. For instance, suppose you created a client side proxy for the following code:

[source,syntaxhighlighter-pre]
----
public class MyFoo implements Foo {
  ...
}
----

In this case, the methods inherited from Foo would be InOnly.

[[UsingExchangePatternAnnotations-Overloadingaclasslevelannotation]]
== Overloading a class level annotation


You can overload a class level annotation on specific methods. Suppose you have a class or interface with many InOnly methods, but you want to annote just one or two methods as InOut. You can do it like this:

[source,syntaxhighlighter-pre]
----
@InOnly
public interface Foo {
  void someInOnlyMethod(Document input);
  void anotherInOnlyMethod(String input);
  
  @InOut
  String someInOutMethod(String input); 
}
----

In the above `Foo` interface the only the `someInOutMethod` will be InOut.

[[UsingExchangePatternAnnotations-Usingyourownannotations]]
== Using your own annotations

You might want to create your own annotations to represent a group of
different bits of metadata; such as combining synchrony, concurrency and
transaction behaviour.

In this case you can annotate your annotation with the `@Pattern` annotation to the default exchange pattern you wish to use.

For example, lets say we want to create our own annotation called
`@MyAsyncService`:

[source,syntaxhighlighter-pre]
----
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})

// lets add the message exchange pattern to it
@Pattern(ExchangePattern.InOnly)

// lets add some other annotations - maybe transaction behaviour?

public @interface MyAsyncService {
}
----

Now we can use this annotation, and Camel will figure out the correct
exchange pattern.

[source,syntaxhighlighter-pre]
----
public interface Foo {
  void someInOnlyMethod(Document input);
  void anotherInOnlyMethod(String input);
  
  @MyAsyncService
  String someInOutMethod(String input); 
}
----
= Property placeholders

Camel has extensive support for property placeholders, which
can be used _almost anywhere_ in your Camel xref:routes.adoc[routes],
xref:endpoint.adoc[endpoints], xref:dsl.adoc[DSL], and xref:route-configuration.adoc[route configuration],
xref:bean-integration.adoc[bean integration] and elsewhere.

Property placeholders are used to define a _placeholder_ instead of the actual value.
This is important as you would want to be able to make your applications external
configurable, such as values for network addresses, port numbers, authentication credentials,
login tokens, and configuration in general.

== Properties component

Camel provides the xref:components::properties-component.adoc[Properties] out of the box
from the core, which is responsible for handling and resolving the property placeholders.

See the xref:components::properties-component.adoc[Properties] documentation for how
to configure Camel to known from which location(a) to load properties.


== Property placeholder syntax

The value of a Camel property can be obtained by specifying its key name
within a property placeholder, using the following syntax: `{\{key}}`

For example:

[source,text]
----
{{file.uri}}
----

where `file.uri` is the property key.

Property placeholders can be used to specify parts, or all, of an
endpoint's URI by embedding one or more placeholders in the URI's string
definition.

=== Using property placeholder with default value

You can specify a default value to use if a
property with the key does not exist, where the default value is the text after the colon:

[source,text]
----
{{file.url:/some/path}}
----

In this case the default value is `/some/path`.

=== Using optional property placeholders

Camel's elaborate property placeholder feature supports optional placeholders,
which is defined with the `?` (question mark) as prefix in the key name, as shown:

[source,text]
----
{{?myBufferSize}}
----

If a value for the key exists then the value is used, however if the key does not exist,
then Camel understands this, such as when used in xref:endpoint.adoc[Endpoints]:

[source,text]
----
file:foo?bufferSize={{?myBufferSize}}
----

Then the `bufferSize` option will only be configured in the endpoint, if a placeholder exists.
Otherwise the option will not be set on the endpoint, meaning the endpoint would be _restructued_ as:

[source,text]
----
file:foo
----

Then the option `bufferSize` is not in specified at all, and this would allow Camel to
use the standard default value for `bufferSize` if any exists.

=== Reverse a boolean value

If a property placeholder is a boolean value, then it is possible to negate (reverse) the value by using `!` as prefix in the key.

[source,properties]
----
integration.ftpEnabled=true
----

[source,java]
----
from("ftp:....").autoStartup("{{integration.ftpEnabled}}")
    .to("kafka:cheese")

from("jms:....").autoStartup("{{!integration.ftpEnabled}}")
    .to("kafka:cheese")
----

In the example above then the FTP route or the JMS route should only be started. So if the FTP is enabled then JMS should be disable, and vise-versa.
We can do this be negating the `autoStartup` in the JMS route, by using `!integration.ftpEnabled` as the key.


== Using property placeholders

When using property placeholders in the endpoint xref:uris.adoc[URIs] you should use this with the syntax `{\{key}}` as shown in this example:

[source,properties]
----
cool.end = mock:result
where = cheese
----

And in Java DSL:

[source,java]
----
from("direct:start")
    .to("{{cool.end}}");
----

And in XML DSL:

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <to uri="{{cool.end}}"/>
</route>
----

A property placeholder may also just be a one part in the endpoint URI.
A common use-case is to use a placeholder for an endpoint option such
as the size of the write buffer in the file endpoint:

[source,properties]
----
buf = 8192
----

[source,java]
----
from("direct:start")
    .to("file:outbox?bufferSize={{buf}}");
----

And in XML DSL:

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <to uri="file:outbox?bufferSize={{buf}}"/>
</route>
----

However the placeholder can be anywhere, so it could also be the name of a mock endpoint

[source,java]
----
from("direct:start")
    .to("mock:{{where}}");
----

In the example above the mock endpoint, is already hardcoded to start with `mock:`,
and the `where` placeholder has the value `cheese` so the resolved uri becomes `mock:cheese`.

=== Property placeholders referring to other properties (nested placeholders)

You can also have properties with refer to each other such as:

[source,properties]
----
cool.foo=result
cool.concat=mock:{{cool.foo}}
----

Notice how `cool.concat` refer to another property.

And the route in XML:

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <to uri="{{cool.concat}}"/>
</route>
----

==== Turning off nested placeholders

If the placeholder value contains data that interfere with the property placeholder syntax `{{` and `}}` (such as JSon data),
you can be then explicit turn off nested placeholder by `?nested=false` in the key name, such as shown:

[source,xml]
----
<route>
  <from uri="direct:start"/>
  <to uri="elasticsearch:foo?query={{myQuery?nested=false}}"/>
</route>
----

In the example above the placeholder _myQuery_ placeholder value is as follows

[source,json]
----
{"query":{"match_all":{}}}
----

Notice how the json query ends with `}}` which interfere with the Camel property placeholder syntax.

Nested placeholders can also be turned off globally on the xref:components::properties-component.adoc[Properties] component, such as:

[source,java]
----
CamelContext context = ...
context.getPropertiesComponent().setNestedPlaceholder(false);
----

=== Escape a property placeholder

The property placeholder can be problematic if the double curly brackets are used by a third party library like for example a query in ElasticSearch of type `{"query":{"match_all":{}}}`.

To work around that it is possible to escape the double curly brackets with a backslash character like for example `\{{ property-name \}}`. This way, it won't be interpreted as a property placeholder to resolve and will be resolved as `{{ property-name }}`.

If for some reason, the backslash character before the double curly brackets must not be interpreted as an escape character, it is possible to add another backslash in front of it to escape it, it will then be seen as a backslash.

=== Using property placeholders multiple times

You can of course also use placeholders several times:

[source,properties]
----
cool.start=direct:start
cool.showid=true
cool.result=result
----

And in this route we use `cool.start` two times:

[source,java]
----
from("{{cool.start}}")
    .to("log:{{cool.start}}?showBodyType=false&showExchangeId={{cool.showid}}")
    .to("mock:{{cool.result}}");
----

=== Using property placeholders with producer template

You can also your property placeholders when using
xref:producertemplate.adoc[ProducerTemplate] for example:

[source,java]
----
template.sendBody("{{cool.start}}", "Hello World");
----

=== Using property placeholders with consumer template

This can also be done when using xref:consumertemplate.adoc[ConsumerTemplate], such as:

[source,java]
----
Object body = template.receiveBody("{{cool.start}}");
----

== Resolving property placeholders on cloud

When you are running your Camel application on the cloud you may want to automatically scan any Configmap or Secret as it was an application properties. Given the following Secret:

----
apiVersion: v1
data:
  my-property: Q2FtZWwgNC44
kind: Secret
metadata:
  name: my-secret
type: Opaque
----

You can mount it in your Pod container, for instance, under `/etc/camel/conf.d/_secrets/my-secret`. Now, just make your Camel application be aware where to scan your configuration via `camel.main.cloud-properties-location = /etc/camel/conf.d/_secrets/my-secret` application properties. It's a comma separated value, so, you can add as many Secrets/Configmaps you need.

At runtime, you will be able to read the configuration transparently as ```{{ my-property }}``` as you're doing with the rest of properties.

NOTE: the same configuration works with Configmap.

== Resolving property placeholders from Java code

If you need to resolve property placeholder(s) from some Java code, then Camel has two APIs for this:

- You can use the method `resolveProperty` on the `PropertiesComponent` to resolve a single property from Java code.
- Use the method `resolvePropertyPlaceholders` on the `CamelContext` to resolve (one or more) property placeholder(s) in a String.

For example to resolve a placeholder with key foo, you can do:

[source,java]
----
Optional<String> prop = camelContext.getPropertiesComponent().resolveProperty("foo");
if (prop.isPresent()) {
    String value = prop.get();
    ....
}
----

This API is to lookup a single property and returns a `java.util.Optional` type.

The `CamelContext` have another API which is capable of resolving multiple placeholders, and interpolate placeholders from an input String.
Lets try with an example to explain this:

[source,java]
----
String msg = camelContext.resolvePropertyPlaceholders("{{greeting}} Camel user, Camel is {{cool}} dont you think?");
----

The input string is a text statement which have two placeholders that will be resolved, for example:

[source,properties]
----
greeting = Hi
cool = awesome
----

Will be resolved to:

[source,text]
----
Hi Camel user, Camel is awesome dont you think?
----

== Using property placeholders for any kind of attribute in Spring XML files

Previously it was only the `xs:string` type attributes in the XML DSL
that support placeholders. For example often a timeout attribute would
be a `xs:int` type and thus you cannot set a string value as the
placeholder key. This is now possible using a special
placeholder namespace.

In the example below we use the `prop` prefix for the namespace
`\http://camel.apache.org/schema/placeholder`. Now we can use `prop:` as prefix
to configure any kind of XML attributes in Spring XML files.

In the example below we want to use a placeholder for the `stopOnException` option in
the xref:components:eips:multicast-eip.adoc[Multicast] EIP. The `stopOnException` is a `xs:boolean` type,
so we cannot configure this as:

[source,xml]
----
<multicast stopOnException="{{stop}}">
   ...
</multicast>
----

Instead, we must use the `prop:` namespace, so we must add this namespace
in the top of the XML file in the `<beans>` tag.

To configure the option we must then use the `prop:optionName` as shown below:

[source,xml]
----
<multicast prop:stopOnException="stop">
  ...
</multicast>
----

The complete example is below:

[source,xml]
----
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:prop="http://camel.apache.org/schema/placeholder"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
           http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd">

    <bean id="damn" class="java.lang.IllegalArgumentException">
        <constructor-arg index="0" value="Damn"/>
    </bean>

    <camelContext xmlns="http://camel.apache.org/schema/spring">
        <propertyPlaceholder id="properties" location="classpath:myprop.properties"/>
        <route>
            <from uri="direct:start"/>
            <!-- use prop namespace, to define a property placeholder, which maps to option stopOnException={{stop}} -->
            <multicast prop:stopOnException="stop">
                <to uri="mock:a"/>
                <throwException ref="damn"/>
                <to uri="mock:b"/>
            </multicast>
        </route>
    </camelContext>
</beans>
----

In our properties file we have the value defined as:

[source,properties]
----
stop = true
----


== Bridging Camel property placeholders with Spring XML files

NOTE: If you are using Spring Boot then this does not apply.
This is only for legacy Camel and Spring applications which are using Spring XML files.

The Spring Framework does not allow third-party frameworks such as
Apache Camel to seamless hook into the Spring property placeholder
mechanism. However, you can bridge Spring and Camel by declaring a
Spring bean with the type
`org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer`,
which is a Spring
`org.springframework.beans.factory.config.PropertyPlaceholderConfigurer`
type.

To bridge Spring and Camel you must define a single bean as shown below:

[source,xml]
----
<!-- bridge spring property placeholder with Camel -->
<!-- you must NOT use the <context:property-placeholder at the same time, only this bridge bean -->
<bean id="bridgePropertyPlaceholder" class="org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer">
  <property name="location" value="classpath:org/apache/camel/component/properties/cheese.properties"/>
</bean>
----

You *must not* use the spring `<context:property-placeholder>` namespace
at the same time; this is not possible.

After declaring this bean, you can define property placeholders using
both the Spring style, and the Camel style within the `<camelContext>`
tag as shown below:

[source,xml]
----
<!-- a bean that uses Spring property placeholder -->
<!-- the ${hi} is a spring property placeholder -->
<bean id="hello" class="org.apache.camel.component.properties.HelloBean">
  <property name="greeting" value="${hi}"/>
</bean>

<camelContext xmlns="http://camel.apache.org/schema/spring">
  <!-- in this route we use Camels property placeholder {{ }} style -->
  <route>
    <from uri="direct:{{cool.bar}}"/>
    <bean ref="hello"/>
    <to uri="{{cool.end}}"/>
  </route>
</camelContext>
----

Notice how the hello bean is using pure Spring property placeholders using
the `${}` notation. And in the Camel routes we use the Camel
placeholder notation with `{\{key}}`.

== Using property placeholder functions

The xref:components::properties-component.adoc[Properties] component includes the following functions out of the box:

* `env` - A function to lookup the property from OS environment variables
* `sys` - A function to lookup the property from Java JVM system properties
* `bean` - A function to lookup the property from the return value of bean's method (requires `camel-bean` JAR)
* `service` - A function to lookup the property from OS environment variables using the service naming idiom
* `service.name` - A function to lookup the property from OS environment variables using the service naming idiom returning the hostname part only
* `service.port` - A function to lookup the property from OS environment variables using the service naming idiom returning the port part only

These functions are intended to make it easy to lookup values from the environment, as shown in the example below:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{env:SOMENAME}}"/>
        <to uri="{{sys:MyJvmPropertyName}}"/>
    </route>
</camelContext>
----

You can use default values as well, so if the property does not exist, you can define a default value as shown below, where the default value is a `log:foo` and `log:bar` value.

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="{{env:SOMENAME:log:foo}}"/>
        <to uri="{{sys:MyJvmPropertyName:log:bar}}"/>
    </route>
</camelContext>
----

The service function is for looking up a service which is defined using OS environment variables using the service naming idiom, to refer to a service location using `hostname : port`

* __NAME__**_SERVICE_HOST**
* __NAME__**_SERVICE_PORT**

in other words the service uses `_SERVICE_HOST` and `_SERVICE_PORT` as prefix.
So if the service is named FOO, then the OS environment variables should be set as

[source,bash]
----
export $FOO_SERVICE_HOST=myserver
export $FOO_SERVICE_PORT=8888
----

For example if the FOO service a remote HTTP service, then we can refer to the service in the Camel endpoint uri, and use the HTTP component to make the HTTP call:

[source,xml]
----
<camelContext>
    <route>
        <from uri="direct:start"/>
        <to uri="http://{{service:FOO}}/myapp"/>
    </route>
</camelContext>
----

And we can use default values if the service has not been defined, for example to call a service on localhost, maybe for unit testing.

[source,xml]
----
<camelContext>
<route>
    <from uri="direct:start"/>
    <to uri="http://{{service:FOO:localhost:8080}}/myapp"/>
</route>
</camelContext>
----

The bean function (you need to have `camel-bean` JAR on classpath) is for looking up the property from the return value of bean's method.

Assuming we have registered a bean named 'foo' that has a method called 'bar' that returns a directory name, then we can refer to the bean's method in the camel endpoint url, and use the file component to poll a directory:

[source,xml]
----
<camelContext>
<route>
    <from uri="file:{{bean:foo.bar}}"/>
    <to uri="direct:result"/>
</route>
</camelContext>
----

IMPORTANT: The method must be a public no-arg method (i.e. no parameters) and return a value such as a String, boolean, int.

=== Using Kubernetes property placeholder functions

The `camel-kubernetes` component include the following functions:

* `configmap` - A function to lookup the string property from Kubernetes ConfigMaps.
* `configmap-binary` - A function to lookup the binary property from Kubernetes ConfigMaps.
* `secret` - A function to lookup the string property from Kubernetes Secrets.
* `secret-binary` - A function to lookup the binary property from Kubernetes Secrets.

The syntax for both functions are:

[source]
----
configmap:name/key[:defaultValue]
----

Where the default value is optional, for example the following will lookup `myKey`,
and fail if there is no such configmap.

[source]
----
configmap:mymap/mykey
----

In this example then it would not fail as a default value is provided:

[source]
----
configmap:mymap/mykey:123
----

If the value stored in the configmap is in binary format, so it is stored as `Binary Data`, it will be downloaded in a file, and it returns the absolute path of the file

[source]
----
configmap-binary:mymap/mybinkey
----

it returns a path like `/tmp/camel11787545916150467474/mybinkey`

Before the Kubernetes property placeholder functions can be used they need to be configured with either (or both)

- path - A _mount path_ that must be mounted to the running pod, to load the configmaps or secrets from local disk.
- kubernetes client - *Autowired* An `io.fabric8.kubernetes.client.KubernetesClient` instance to use for connecting to the Kubernetes API server.

Camel will first use _mount paths_ (if configured) to lookup, and then fallback to use the `KubernetesClient`.

==== Configuring mount paths for ConfigMaps and Secrets

The configuration of the _mount path_ are used by the given order:

1. Reading configuration property with keys `camel.kubernetes-config.mount-path-configmaps`
and `camel.kubernetes-config.mount-path-secrets`.
2. Use JVM system property with key `camel.k.mount-path.configmaps` and `camel.k.mount-path.secrets` (Camel K compatible).
3. Use OS ENV variable with key `CAMEL_K_MOUNT_PATH_CONFIGMAPS` and `CAMEL_K_MOUNT_PATH_SECRETS` (Camel K compatible).

For example to use `/etc/camel/resources/` as mount path, you can configure this in the `application.properties`:

[source,properties]
----
camel.kubernetes-config.mount-path-configmaps = /etc/camel/myconfig/
camel.kubernetes-config.mount-path-secrets = /etc/camel/mysecrets/
----

==== Configuring Kubernetes Client

Camel will autowire the `KubernetesClient` if a single instance of the client exists in the running application (lookup via the xref:registry.adoc[Registry]).
Otherwise, a new `KubernetesClient` is created. The client can be configured from either

- Using `camel.kubernetes-config.client.` properties (see below for example)
- Attempt to auto-configure itself by a combination of OS Environment variables, reading from `~./kube/config` configuration,
and service account token file. For more details see the https://github.com/fabric8io/kubernetes-client documentation.

You most likely only need to explicit configure the `KubernetesClient` when you want to connect
from a local computer to a remote Kubernetes cluster, where you can specify various options,
such as the masterUrl and oauthToken as shown:

[source,properties]
----
camel.kubernetes-config.client.masterUrl = https://127.0.0.1:50179/
camel.kubernetes-config.client.oauthToken = eyJhbGciOiJSUzI1NiIsImtpZCI...
----

The `KubernetesClient` has many options, see the https://github.com/fabric8io/kubernetes-client documentation.

If you only use _mount paths_, then it is good practice to disable `KubernetesClient` which can be done by setting enabled to false as show:

[source,properties]
----
camel.kubernetes-config.client-enabled = false
----

When running your Camel applications inside an existing Kubernetes cluster, then you often
would not need to explicit configure the `KubernetesClient` and can rely on default settings.

TIP: If you use Camel Quarkus, then it is recommended to use their https://quarkus.io/guides/kubernetes-config
which automatic pre-configure the `KubernetesClient` which Camel then will reuse.

==== Using configmap with Kubernetes

Given a configmap named `myconfig` in Kubernetes that has two entries:

[source,properties]
----
drink = beer
first = Carlsberg
----

Then these values can be used in your Camel routes such as:

[source,xml]
----
<camelContext>
  <route>
    <from uri="direct:start"/>
    <log message="What {{configmap:myconfig/drink}} do you want?"/>
    <log message="I want {{configmap:myconfig/first}}"/>
  </route>
</camelContext>
----

You can also provide a default value in case a key does not exist:

[source,xml]
----
    <log message="I want {{configmap:myconfig/second:Heineken}}"/>
----

==== Using secrets with Kubernetes

Camel reads ConfigMaps from the Kubernetes API Server. And when RBAC is enabled on the cluster,
the ServiceAccount that is used to run the application needs to have the proper permissions for such access.

A secret named `mydb` could contain username and passwords to connect to a database such as:

[source,properties]
----
myhost = killroy
myport = 5555
myuser = scott
mypass = tiger
----

This can be used in Camel with for example the Postrgres Sink Kamelet:

[source,xml]
----
<camelContext>
  <route>
    <from uri="direct:rome"/>
    <setBody>
      <constant>{ "username":"oscerd", "city":"Rome"}</constant>
    </setBody>
    <to uri="kamelet:postgresql-sink?serverName={{secret:mydb/myhost}}
             &amp;serverPort={{secret:mydb/myport}}
             &amp;username={{secret:mydb/myuser}}
             &amp;password={{secret:mydb/mypass}}
             &amp;databaseName=cities
             &amp;query=INSERT INTO accounts (username,city) VALUES (:#username,:#city)"/>
  </route>
</camelContext>
----

The postgres-sink Kamelet can also be configured in `application.properties` which reduces the configuration
in the route above:

[source,properties]
----
camel.component.kamelet.postgresql-sink.databaseName={{secret:mydb/myhost}}
camel.component.kamelet.postgresql-sink.serverPort={{secret:mydb/myport}}
camel.component.kamelet.postgresql-sink.username={{secret:mydb/myuser}}
camel.component.kamelet.postgresql-sink.password={{secret:mydb/mypass}}
----

Which reduces the route to:

[source,xml]
----
<camelContext>
  <route>
    <from uri="direct:rome"/>
    <setBody>
      <constant>{ "username":"oscerd", "city":"Rome"}</constant>
    </setBody>
    <to uri="kamelet:postgresql-sink?databaseName=cities
             &amp;query=INSERT INTO accounts (username,city) VALUES (:#username,:#city)"/>
  </route>
</camelContext>
----

==== Using configmap or secrets in local-mode

During development you may want to run in _local mode_ where you do not need acces to a Kubernetes cluster, to lookup the configmap.
In the local mode, then Camel will lookup the configmap _keys_ from local properties, eg:

For example the example above with the postgresql kamelet, that was configured using a secret:

[source,properties]
----
camel.component.kamelet.postgresql-sink.databaseName={{secret:mydb/myhost}}
camel.component.kamelet.postgresql-sink.serverPort={{secret:mydb/myport}}
camel.component.kamelet.postgresql-sink.username={{secret:mydb/myuser}}
camel.component.kamelet.postgresql-sink.password={{secret:mydb/mypass}}
----

Now suppose we have a local Postrgres database we want to use, then we can turn on _local mode_
and specify the credentials in the same properties file:

[source,properties]
----
camel.kubernetes-config.local-mode = true
mydb/myhost=localhost
mydb/myport=1234
mydb/myuser=scott
mydb/mypass=tiger
----

NOTE: Notice how the key is prefixed with the name of the secret and a slash, eg `name/key`. This makes it easy to copy/paste
from the actual use of the configmap/secret and into the `application.properties` file.

=== Using custom property placeholder functions

The xref:components::properties-component.adoc[Properties] component allow to plugin 3rd party functions which can be used during parsing of the property placeholders.
These functions are then able to do custom logic to resolve the placeholders, such as looking up in databases, do custom computations, or whatnot.
The name of the function becomes the prefix used in the placeholder.

This is best illustrated in the example route below, where we use `beer` as the prefix:

[source,xml]
----
<route>
    <from uri="direct:start"/>
    <to uri="{{beer:FOO}}"/>
    <to uri="{{beer:BAR}}"/>
</route>
----

The implementation of the function is only two methods as shown below:

[source,java]
----
@org.apache.camel.spi.annotations.PropertiesFunction("beer")
public class MyBeerFunction implements PropertiesFunction {

    @Override
    public String getName() {
        return "beer";
    }

    @Override
    public String apply(String remainder) {
        return "mock:" + remainder.toLowerCase();
    }
}
----

The function must implement the `org.apache.camel.spi.PropertiesFunction` interface.
The method `getName` is the name of the function (beer).
And the `apply` method is where we implement the custom logic to do.
As the sample code is from a unit test, it just returns a value to refer to a mock endpoint.

You also need to have `camel-component-maven-plugin` as part of building the component will
then ensure that this custom properties function has necessary source code generated that makes Camel
able to automatically discover the function.

NOTE: If the custom properties function need logic to startup and shutdown, then the function can extend `ServiceSupport`
and have this logic in `doStart` and `doStop` methods.

TIP: For an example see the `camel-base64` component.

== Using third party property sources

The properties component allows to plugin 3rd party sources to load and lookup properties via the `PropertySource`
API from camel-api.

The regular `PropertySource` will lookup the property on-demand,
for example to lookup values from a backend source such as a database or HashiCorp Vault etc.

A `PropertySource` can define that it supports loading all its properties
(by implementing `LoadablePropertiesSource`) from the source at once, for example from file system.
This allows Camel properties component to load these properties at once during startup.

For example the `camel-microprofile-config` component is implemented using this.
The 3rd-party `PropertySource` can automatically be discovered from classpath when Camel is starting up.
This is done by including the file `META-INF/services/org/apache/camel/property-source-factory` which refers to the fully qualified class name of the `PropertySource` implementation.

See xref:components:others:microprofile-config.adoc[MicroProfile Config] component as an example.

You can also register 3rd-party property sources via Java API:

[source,java]
----
PropertiesComponent pc = context.getPropertiesComponent();
pc.addPropertiesSource(myPropertySource);
----

= UUID Generator

Camel supports third-party UUID generator(s).

A useful scenario is to use a simple counter for testing purpose. With this, it is
easier to correlate the exchanges in the log/debugger.

Camel uses UUIDs in the exchange and message ids, and other unique ids
it uses.

You only have to implement `org.apache.camel.spi.UuidGenerator` and tell
Camel, that it should use your custom implementation:

== Configuring UuidGenerator

[source,java]
----
getContext().setUuidGenerator(new MyCustomUuidGenerator());
----

Camel will configure this UUID generator by doing a lookup in the Spring
bean registry to find the bean of the type `org.apache.camel.spi.UuidGenerator`.

[source,xml]
----
<bean id="simpleUuid" class="org.apache.camel.support.SimpleUuidGenerator" />

<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
  <route>
    <from uri="direct:start" />
    <to uri="mock:result" />
  </route>
</camelContext>
----

== Standard UUID Generators

Camel comes with the following implementations out of the box:

* `org.apache.camel.support.ClassicUuidGenerator`: this is the classic Camel 2.x generator
* `org.apache.camel.support.DefaultUuidGenerator`: default generator (32 chars) optimized for Camel usage
* `org.apache.camel.support.ShortUuidGenerator`: Is 50% the size of the default (16 chars) optimized for Camel usage
* `org.apache.camel.support.SimpleUuidGenerator`: This implementation uses
internally a `java.util.concurrent.atomic.AtomicLong` and increases the
ID for every call by one. Starting with 1 as the first id.
= Validator

Validator performs declarative validation of the message according to the declared
_Input Type_ and/or _Output Type_ on a route definition which declares the expected
message type.


== Data type format

[source,text]
----
scheme:name
----

where *scheme* is the type of data model like `java`, `xml` or `json`, and *name* is the individual
data type name.

== Supported Validators

[width="100%",cols="25%,75%",options="header",]
|===
| Validator | Description
| Predicate Validator | Validate with using Expression or Predicate
| Endpoint Validator | Validate by forwarding to the Endpoint to be used with validation component such as Validation Component or Bean Validation Component.
| Custom Validator | Validate with using custom validator class. Validator must be a subclass of `org.apache.camel.spi.Validator`
|===


== Common Options
All validators have following common options to specify which data type is supported by the validator.
`type` must be specified.

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| type | Data type to validate
|===


== Predicate Validator Options

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| expression | Expression or Predicate to be used for validation
|===

Here is an example to specify a validation predicate:

Java DSL:

[source,java]
----
validator()
    .type("csv:CSVOrder")
    .withExpression(bodyAs(String.class).contains("{name:XOrder}"));
----

XML DSL:

[source,xml]
----
<predicateValidator Type="csv:CSVOrder">
    <simple>${body} contains '{name:XOrder}'</simple>
</predicateValidator>
----

== Endpoint Validator Options

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| ref | Reference to the Endpoint ID
| uri | Endpoint URI
|===

Here is an example to specify endpoint URI in Java DSL:

[source,java]
----
validator()
    .type("xml")
    .withUri("validator:xsd/schema.xsd");
----

And here is an example to specify endpoint ref in XML DSL:

[source,xml]
----
<endpointValidator uri="validator:xsd/schema.xsd" type="xml"/>
----

Note that the Endpoint Validator just forwards the message to the specified endpoint. In above example,
camel forwards the message to the `validator:` endpoint, which actually is a
xref:components::validator-component.adoc[Validation Component]. You can also use any other validation component like
Bean Validation Component.

== Custom Validator Options

The validator must be an implementation of `org.apache.camel.spi.Validator`

[width="100%",cols="25%,75%",options="header",]
|===
| Name | Description
| ref | Reference to the custom Validator bean ID
| className | Fully qualified class name of the custom Validator class
|===

Here is an example to specify custom Validator class:

Java DSL:

[source,java]
----
validator()
    .type("json")
    .withJava(com.example.MyCustomValidator.class);
----

XML DSL:

[source,xml]
----
<customTransformer className="com.example.MyCustomValidator" type="json"/>
----

== Examples

For example to declare the Endpoint Validator which uses
validator component to validate `xml:ABCOrder`, we can do as follows:

Java DSL:

[source,java]
----
validator()
    .type("xml:ABCOrder")
    .withUri("validator:xsd/schema.xsd");
----

And in XML DSL:

[source,xml]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
    <validators>
        <endpointValidator uri="validator:xsd/schema.xsd" type="xml:ABCOrder"/>
    </validators>
</camelContext>
----

If you have following route definition, above validator will be applied when `direct:abc` endpoint
receives the message. Note that `inputTypeWithValidate` is used instead of `inputType` in Java DSL,
and the `validate` attribute on the inputType declaration is set to `true` in XML DSL:

Java DSL:

[source,java]
----
from("direct:abc")
    .inputTypeWithValidate("xml:ABCOrder")
    .log("${body}");
----

XML DSL:

[source,xml]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
    <route>
        <from uri="direct:abc"/>
        <inputType urn="xml:ABCOrder" validate="true"/>
        <log message="${body}"/>
    </route>
</camelContext>
----

== See Also

The xref:transformer.adoc[Transformer] is a related functionality.= Variables

*Available from Camel 4.4*

In Camel 4.4, we have introduced the concept of _variables_.

A variable is a key/value that can hold a value that can either be private per `Exchange`,
or shared per route, or per `CamelContext`.

NOTE: You can also use _exchange properties_ as variables, but the exchange properties are also used internally by Camel,
and some EIPs and components. With the newly introduced _variables_ then these are exclusively for end users.

== Variable Repository

The variables are stored in one or more `org.apache.camel.spi.VariableRepository`. By default, there are the following repositories

- `ExchangeVariableRepository` - A private repository per `Exchange` that holds variables that are private for the lifecycle of each `Exchange`.
- `RouteVariableRepository` - Uses `route` as id. A single repository, that holds variables per `Route`.
- `GlobalVariableRepository` - Uses `global` as id. A single global repository for the entire `CamelContext`.

The `ExchangeVariableRepository` is special as its private per exchange and is the default repository when used during routing.
The `RouteVariableRepository` is a single repository that holds variables that are route scoped.

TIP: There is also `org.apache.camel.spi.BrowsableVariableRepository` which is an extension to `VariableRepository` that
has APIs to browse the current variables. Camel uses this with Camel JBang, and JMX to be able to see the current variables
from management tooling, CLI, and the developer console.

=== Custom variable repositories

You can implement custom `org.apache.camel.spi.VariableRepository` and plugin to be used out of the box with Apache Camel.
For example, you can build a custom repository that stores the variables in a database, so they are persisted.

Each repository must have its own unique id. However, it's also possible to replace the default `global`, or `route` repositories with another.

IMPORTANT: The id `exchange` and `header` is reserved by Camel internally and should not be used as id for custom repositories.

== Getting and setting variables from Java API

To get a local variable from the current exchange, you can do this via Java API:

[source,java]
----
String myValue = "...";
exchange.setVariable("myKey", myValue);

// and later to get the variable
Object val = exchange.getVariable("myKey");

// you can get the value as a specific type
String str = exchange.getVariable("myKey", String.class);
----

The API on `Exchange` will by default get the variables from its local private repository.
However, you can also get variables from other repositories, such as the `global` as show:

[source,java]
----
Object val = exchange.getVariable("global:myGlobalKey");
----

And you can also assign a global variable by prefixing with `global:` as follows:

[source,java]
----
exchange.setVariable("global:myGlobalKey", someObjectHere);
----

There is also API on `CamelContext` to get variables. However, this API will by default get from the `global` repository,
as it's not possible to get variables from any inflight `Exchange` currently being routed.

[source,java]
----
Object val = context.getVariable("myGlobalKey");

// you can get the value as a specific type
String str = context.getVariable("myGlobalKey", String.class);
----

You can also assign a variable to a specific route with `route:` as follows:

[source,java]
----
exchange.setVariable("route:myRouteId:myRouteKey", someObjectHere);
----

And you can get route variables as well:

[source,java]
----
Object val = context.getVariable("route:myRouteId:myRouteKey");

// you can get the value as a specific type
String str = context.getVariable("route:myRouteId:myRouteKey", String.class);
----

== Setting and getting variables from DSL

It is also possible to use variables in Camel xref:routes.adoc[routes] using the
setVariable, removeVariable, and convertVariableTo EIPs.

These EIPs make it possible to set and remove variables from routes. And you can also access variables from the xref:components:languages:simple-language.adoc[Simple] language.

In the following route, we set a variable on the exchange which we use later to build a human-readable event message:

[tabs]
====
Java::
+
[source,java]
----
from("kafka:order.in")
  .setVariable("customerId", jq(".customer.custId"))
  .setVariable("country", jq(".customer.address.co"))
  .transform().simple("Order received from customer ${variable.customerId} in ${variable.country}")
  .to("kafka:order.event");
----

XML::
+
[source,xml]
----
<route>
    <from uri="kafka:order.in"/>
    <setVariable name="customerId">
        <jq>.customer.custId</jq>
    </setVariable>
    <setVariable name="country">
        <jq>.customer.address.co</jq>
    </setVariable>
    <transform>
        <simple>Order received from customer ${variable.customerId} in ${variable.country}</simple>
    </transform>
    <to uri="kafka:order.event"/>
</route>
----

YAML::
+
[source,yaml]
----
- route:
    from:
      uri: kafka:order.in
      steps:
        - setVariable:
            name: customerId
            jq:
              expression: .customer.custId
        - setVariable:
            name: country
            jq:
              expression: .customer.address.co
        - transform:
            simple:
              expression: "Order received from customer ${variable.customerId} in ${variable.country}"
        - to:
            uri: kafka:order.event
----
====

When `route` variables in Camel routes, then the `routeId` is implied as the current route, if not explicit declared.
For example, the following example the first route will set a variable (`route:second:foo`) in the second route.
Then the second route can get hold of the variable without having to specify its route id `route:foo`:

[tabs]
====
Java::
+
[source,java]
----
from("direct:start").routeId("first")
    // sets variable in another route
    .setVariable("route:second:foo").constant("Hello World")
    .to("mock:end");

from("direct:second").routeId("second")
    // use variable from this route
    .setBody().variable("route:foo");
----
====


== Configuring initial variables on startup

When Camel is starting then it's possible to configure initial variables for `global` and `route` repositories only.

This can be done in `application.properties` as shown below:

[source,properties]
----
camel.variable.greeting = Random number
camel.variable.random = 999
----

The variables are default set on the `global` repository, but you can set route scoped variables,
using `route.` as prefix. As we cannot use colon (`:`) in property keys, then dot is used to separate
the route id from the variable name, eg `myRoute.gold`.

[source,properties]
----
camel.variable.route.myRoute.gold = true
camel.variable.greeting = Random number
camel.variable.random = 999
----

Here the gold variable is set on the `route` repository, and the other variables are set on the `global` repository.

The value of a variable can also be loaded from the file system, such as a JSon file. To do this, you should
prefix the value with `resource:file:` or `resource:classpath:` to load from the file system or classpath,
as shown below:

[source,properties]
----
camel.variable.user-template = resource:file:/etc/user.json
----

Camel (*Camel 4.8*) will automatically convert the value to appropriate type:

- all digits are converted to an int or long
- true/false are converted to a boolean
- otherwise string value

There is also support for referring to other existing beans, using the `#bean:` syntax:

[source,properties]
----
camel.variable.cheese = #bean:myCheeseBean
----

Or create a new bean via the `#class:` or `#type:` syntax:

[source,properties]
----
camel.variable.cheese = #class:com.foo.MyClassName
----

Or if the value must be of a special type, you can specify this via `#valueAs` as follows:

[source,properties]
----
camel.variable.amount = #valueAs(float):1.23
----

== Using Variables with EIPs

The following commonly used EIPs for sending and receiving, and transforming messages, have
special support for choosing to use variables over the current `Exchange`:

- from
- to
- toD
- enrich
- poll
- pollEnrich
- wireTap
- unmarshal
- marshal

The intention is to make it more convenient and easy to _gather data_ from other systems without any ceremony to keep
existing data by using techniques such as storing the data temporary using headers, exchange properties,
or with the xref:components:eips:claimCheck-eip.adoc[Claim Check] EIP.

=== Important concept when using variables and EIPs

It is **important** to understand that the variables focus the use of the message **body** only.
This is on purpose to keep it simpler and primary work with the message body as the user data.

The following table summarizes what the EIP supports with variables:

|===
|*EIP* | *VariableSend* | *VariableReceive*
| From | | yes
| To | yes | yes
| ToD | yes | yes
| Enrich | yes | yes
| Poll | | yes
| PollEnrich | | yes
| WireTap | yes |
| Unmarshal | yes | yes
| Marshal | yes | yes
|===

The EIPs listed above have support for using variables when sending and receiving data. This is done by using the `variableSend` and `variableReceive` options
to specify the name of the variable.

The EIPs works in two modes where *variableSend* and *variableReceive* are a little bit different, so pay attention to the following table:

|===
| *VariableSend*       | *VariableReceive*
| *Sending Headers:* Message   | *Received Headers:* Variable
| *Sending Body:* Variable     | *Received Body:* Variable
|===

The *VariableSend* is intended for sending as regular Camel where the sending headers are from the current `Message` and the body is
from the variable. In other words it's only the message body taken from the variable instead of the current `Message` body.

The *VariableReceive* works in a different mode. The idea is that all the received data is stored as variables. This means the current `Message`
is not changed at all. The received body is stored in the variable, and the received headers (transport headers etc.) are stored as read-only
headers as variables as well. The names of the variable is `header:variableName.headerName`. For example, if the variable is `myVar` and the header is `Content-Type`
then the header is stored as a variable with the full name `header:myVar.Content-Type`.

=== Example using Variable Receive

When the EIP is using *VariableReceive*, then the `Message` on the `Exchange` is not in use, but the body and headers will be from the variable.
For example, given the following `Message` containing:

[source,properties]
----
header.foo=123
header.bar=456
body=Hello World
----

And a remote service is called via the route below, and this service returns a new header (`level`) and body: 'Bye World'

[tabs]
====
Java::
+
[source,java]
----
from("direct:service")
  .to("http:myservice")
  .to("log:after");
----
XML::
+
[source,xml]
----
<route>
  <from uri="direct:service"/>
  <to uri="http:myservice"/>
  <to uri="log:after"/>
</route>
----
YAML::
+
[source,yaml]
----
from:
  uri: "direct:service"
  steps:
    - to: "http:myservice"
    - to: "log:after"
----
====

Calling this route, the `Message` is updated to following:

[source,properties]
----
header.foo=123
header.bar=456
header.level=gold
body=Bye World
----

However, if you use *VariableReceive=myVar* to store the returned data from calling the remote service into a variable, then
the result changes as follows:

[tabs]
====
Java::
+
[source,java]
----
from("direct:service")
  .toV("http:myservice", null, "myVar")
  .to("log:after");
----
XML::
+
[source,xml]
----
<route>
  <from uri="direct:service"/>
  <to uri="http:myservice" variableReceive="myVar"/>
  <to uri="log:after"/>
</route>
----
YAML::
+
[source,yaml]
----
from:
  uri: "direct:service"
  steps:
    - to:
        uri: http:myservice
        variableReceive: myVar
    - to: "log:after"
----
====

The `Message` on the current `Exchange` is not changed:

[source,properties]
----
header.foo=123
header.bar=456
body=Hello World
----

And the variable contains all the data received from the remote HTTP service separated into two variables:

[source,properties]
----
myVar=Bye World
header:myVar.level=gold
----

IMPORTANT: Notice the headers are stored with the syntax `header:variable.key`. In the example above the variable name is `myVar`,
and the header key is `level`, which gives: `header:myVar.level`.


=== Using variable to store incoming message body

You can configure the `from` to store the message body into a variable, instead of the `Message`. This makes it easy to have quick access
to the original incoming message body via the variable. Notice that the body on the `Message` will be `null`.

The following example from a unit test shows how to do this. Notice how Java DSL uses `fromV` to make it possible to specify
the name of the variable. In XML and YAML DSL you specify this using the `variableReceive` parameter.

[tabs]
====
Java::
+
[source,java]
----
fromV("direct:start", "myKey")
    .transform().simple("Bye ${body}")
    .to("mock:foo")
    .setBody(variable("myKey"))
    .to("mock:result");
----
XML::
+
[source,xml]
----
<route>
  <from uri="direct:start" variableReceive="myKey"/>
  <transform>
    <simple>Bye ${body}</simple>
  </transform>
  <to uri="mock:foo"/>
  <setBody>
    <variable>myKey</variable>
  </setBody>
  <to uri="mock:result"/>
</route>
----
YAML::
+
[source,yaml]
----
from:
  uri: "direct:start"
  variableReceive: "myKey"
  steps:
    - transform:
        simple: "Bye ${body}"
    - to: "mock:foo"
    - setBody:
        variable: "myKey"
    - to: "mock:result"
----
====

NOTE: In the examples above the transform `Bye $\{body}` will result as `Bye&#160;` because the `Message` has no message body, as the incoming
message body is stored in the variable `myKey` instead.
= What are the dependencies?

== Java support

- Camel 2 requires JDK 8
- Camel 3 requires JDK 8 and supports JDK 11
- Camel 3.15.0+ requires JDK 11
- Camel 3.17.0+ requires JDK 11 and supports JDK 17
- Camel 4.0.0+ requires JDK 17

== Camel JAR Dependencies

Camel core itself is lightweight, and only requires the `slf4j-api` logging API jar.

== Components

All the xref:components::index.adoc[Components] have a range of 3rd party
jars they depend on. They are listed in the maven pom files which files
they require.

= Writing Components

Apache Camel is designed to make it very easy to drop in new components
whether they be routing components, transformers, transports etc. The
idea of a component is to be a factory and manager of
xref:endpoint.adoc[Endpoints].

Here are the main steps to add a new component:

* Write a POJO which implements the `Component` interface. The simplest approach is just to derive from `DefaultComponent`.
* To support auto-discovery of your component, add a file of
`META-INF/services/org/apache/camel/component/FOO` where FOO is the URI
scheme for your component and any related endpoints created on the fly.
This file should contain the information of the component class full name.
For example if your component is implemented by the
`com.example.CustomComponent` class, the file should contain the
following line -- `class=com.example.CustomComponent`.

Users can then either explicitly create your component, configure it and
register it with a `CamelContext` or they can use a URI which auto-creates your component.

[NOTE]
====
It is recommended to bootstrap your initial component using xref:camel-maven-archetypes.adoc[Camel Maven Archetypes], as it will give you all the necessary bits to start developing your component with ease.
You will need as well to make sure to have xref:camel-component-maven-plugin.adoc[Camel Component Maven Plugin] included in your component's `pom.xml` file, order to generate all the necessary metadata and Java files for your component.
====

== Writing Endpoints

When implementing an xref:endpoint.adoc[Endpoint] you typically may
implement one or more of the following methods:

* `createProducer` will create a producer for sending message exchanges to the endpoint
* `createConsumer` implements the xref:components:eips:eventDrivenConsumer-eip.adoc[Event Driven Consumer]
pattern for consuming message exchanges from the endpoint.

Typically, you just derive from `DefaultEndpoint`

== Annotating your Endpoint

If you want to benefit from the automatic generation
of HTML documentation for all the parameters on your endpoint as part of
the maven site reports, you need to
xref:endpoint-annotations.adoc[annotate your Endpoint's parameters].

So this means you add a `@UriEndpoint` annotation to your Endpoint class
and then annotate each parameter you wish to be configured via the URI
configuration mechanism with `@UriParam` (or `@UriParams` for nested
configuration objects).

Refer to the xref:endpoint-annotations.adoc[Endpoint Annotations guide
for details].


== Options

If your component has options you can let it have public getters/setters
and Camel will automatically set the properties when the endpoint is
created.

If you however want to take the matter in your own hands, then
you must remove the option from the given parameter list as Camel will
validate that all options are used. If not Camel will throw a
`ResolveEndpointFailedException` stating which options are unknown.

The parameters are provided by Camel in the `createEndpoint` method from
`DefaultComponent` class:

[source,java]
----
protected abstract Endpoint<E> createEndpoint(String uri, String remaining, Map parameters)
----

The code is an example from the xref:components::seda-component.adoc[SEDA] component that removes the size
parameter:

[source,java]
----
    public BlockingQueue<Exchange> createQueue(String uri, Map parameters) {
        int size = 1000;
        Object value = parameters.remove("size");
        if (value != null) {
            Integer i = convertTo(Integer.class, value);
            if (i != null) {
                size = i;
            }
        }
        return new LinkedBlockingQueue<Exchange>(size);
    }
----

